<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2022-05-12T16:14:08.283Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Proxy 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/</id>
    <published>2022-05-12T16:00:00.000Z</published>
    <updated>2022-05-12T16:14:08.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理（proxy）</strong> 可以理解为一种对象，其能够控制客户端对另一个对象（<strong>subject</strong>）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。<br>proxy 会拦截所有或者部分本应该直接交给 subject 执行的操作，通过额外的预处理或后处理增强其行为，再转发给 subject。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-361cc860946b4838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Proxy pattern schematic"></p><p>Proxy 的主要应用场景：</p><ul><li>Data validation：proxy 对输入数据进行验证，再转发给 subject</li><li>Security：proxy 检查客户端是否有权限执行请求的操作，若检查通过则将请求转发给 subject</li><li>Caching：proxy 负责维护一份内部缓存，只有当请求的数据不在缓存中时，才将该请求转发给 subject 处理</li><li>Lazy initialization：若创建某个对象代价很高，proxy 可以延迟该创建操作直到必要的时候</li><li>Logging：proxy 拦截函数和对应的参数，在函数执行的同时记录日志信息</li><li>Remote objects：proxy 可以接收一个远程对象并令其表现为本地对象</li></ul><h4 id="示例代码：StackCalculator"><a href="#示例代码：StackCalculator" class="headerlink" title="示例代码：StackCalculator"></a>示例代码：StackCalculator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> dividend = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = dividend / divisor</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">const</span> multiplicand = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> multiplier = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = multiplier * multiplicand</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br></pre></td></tr></table></figure><p>现代的计算器基本上都遵循类似的逻辑，即上一个式子的计算结果可以作为下一次计算的输入。<br>在 JavaScript 中，当用户尝试除以 0 时，并不会报错而是返回 <code>Infinity</code>。现在我们尝试借助 Proxy 模式来增强 StackCalculator 除以 0 时的行为。</p><h4 id="Object-composition"><a href="#Object-composition" class="headerlink" title="Object composition"></a>Object composition</h4><p><strong>组合（Composition）</strong>表示一个对象通过引用另一个对象，来扩展或者使用后者的功能。<br>借助组合可以实现 Proxy 模式。创建一个新的对象，令其有着和 subject 完全一致的接口，同时内部还保存着一个对 subject 的引用。参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.divide()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.putValue(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.multiply()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> SafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// 12 / 0 = Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在这次的实现中，proxy 拦截了感兴趣的方法（<code>divide()</code>），为其实现了新的行为（除以 0），而其他的操作（如 <code>putValue()</code>、<code>getValue()</code>、<code>peekValue()</code>、<code>clear()</code> 和 <code>multiply()</code>）则是简单地分派给 subject 去做。<br>计算器的状态（栈中存放的值）仍由 <code>calculator</code> 实例在维护，<code>SafeCalculator</code> 只是调用 <code>calculator</code> 的方法来读取或者修改这些状态。</p><p>上面的实现方式，需要我们显式地将很多方法指派给 subject。即需要写出很多如下形式的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getValue() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这在很大程度上增加了代码的冗余度。</p><h4 id="Object-augmentation"><a href="#Object-augmentation" class="headerlink" title="Object augmentation"></a>Object augmentation</h4><p><strong>对象增强（Object augmentation）</strong>又叫做<strong>猴子补丁（monkey patching）</strong>，能够只代理某个对象的部分方法，并且可能是所有方案中最简单、最常见的一种。<br>它可以将 subject 的某个方法直接替换为 proxy 版本的实现，即直接修改 subject 对象本身。</p><p>参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchToSafeCalculator</span>(<span class="params">calculator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> divideOrig = calculator.divide</span><br><span class="line">  calculator.divide = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// additional validation logic</span></span><br><span class="line">    <span class="keyword">const</span> divisor = calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">    <span class="keyword">return</span> divideOrig.apply(calculator)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> patchToSafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// console.log(calculator.divide())  // Error, not Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>当只需要代理某一个或几个方法的时候，上述方案会非常方便。用户不需要再手动重新实现一遍 <code>putValue()</code> 等方法。<br>不幸的是，简单化也带来了一定的代价，像上面那样直接修改 subject 对象是一种危险的行为。当该 subject 对象被其他部分的代码共享时，修改行为必须尽一切可能避免，从而不至于引发意想不到的 side effect。<br>尝试将代码中的 <code>// console.log(calculator.divide())</code> 取消注释，会发现 <code>calculator</code> 并没有像之前那样输出 <code>Infinity</code>，而是跟 <code>safeCalculator</code> 一样报出错误。即原来的 <code>calculator</code> 对象已经被猴子补丁所改变。</p><h4 id="内置的-Proxy-对象"><a href="#内置的-Proxy-对象" class="headerlink" title="内置的 Proxy 对象"></a>内置的 Proxy 对象</h4><p>ES2015 引入了一种原生的创建 proxy 对象的方式。其语法如下：<br><code>const proxy = new Proxy(target, handler)</code></p><p>其中 <code>target</code> 代表被 proxy 代理的对象（即 subject），<code>handler</code> 对象则用来定义 proxy 的具体行为。它包含一系列可选的预定义方法（如 <code>get</code>、<code>set</code>、<code>apply</code> 等），叫做 <strong>trap methods</strong>，在 subject 上执行对应的操作时会自动触发这些方法。</p><p>示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeCalculatorHandler = &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'divide'</span>) &#123;</span><br><span class="line">      <span class="comment">// proxied method</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// additional validation logic</span></span><br><span class="line">        <span class="keyword">const</span> divisor = target.peekValue()</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">        <span class="keyword">return</span> target.divide()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegated methods and properties</span></span><br><span class="line">    <span class="keyword">return</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  calculator,</span><br><span class="line">  safeCalculatorHandler</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">4</span>)</span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，通过 <code>get</code> trap method 捕获对于原本的 <code>calculator</code> 对象的属性和方法的访问，当访问的方法是 <code>divide()</code> 时，proxy 就会返回一个添加了额外验证逻辑的新函数。<br>之后又简单地使用 <code>target[property]</code> 返回了所有未修改过的属性和方法。</p><p>总的来说，Proxy 对象为我们提供了一个非常简单的方法，只代理 subject 的一部分功能，且不需要显式地将未代理的方法移交给 subject。同时也不会对原本的 subject 做出任何改动。</p><h5 id="几种-proxy-实现机制的比较"><a href="#几种-proxy-实现机制的比较" class="headerlink" title="几种 proxy 实现机制的比较"></a>几种 proxy 实现机制的比较</h5><ul><li>Composition：最直观和安全，subject 不会被修改。但需要手动将未代理的方法指派给 subject。冗余代码</li><li>Object augmentation：会直接修改原本的 subject 对象，不够安全。不需要手动处理未代理的方法</li><li>Proxy 对象：提供了更高级的访问控制。支持更多类型的属性访问，比如可以拦截 subject 对自身属性的删除等操作。不会修改 subject 本身，只需要使用一句代码处理未代理的方法</li></ul><h4 id="实例：logging-Writable-stream"><a href="#实例：logging-Writable-stream" class="headerlink" title="实例：logging Writable stream"></a>实例：logging Writable stream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logwritting &amp;&amp; cd logwritting</span><br></pre></td></tr></table></figure><p>package.json：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>logging-writable.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createLoggingWritable</span>(<span class="params">writable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(writable, &#123;</span><br><span class="line">    get(target, propKey) &#123;</span><br><span class="line">      <span class="keyword">if</span> (propKey === <span class="string">'write'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> [chunk] = args</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Writing'</span>, chunk)</span><br><span class="line">          <span class="keyword">return</span> writable.write(...args)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[propKey]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createLoggingWritable&#125; <span class="keyword">from</span> <span class="string">'./logging-writable.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writable = createWriteStream(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> writableProxy = createLoggingWritable(writable)</span><br><span class="line"></span><br><span class="line">writableProxy.write(<span class="string">'First chunk'</span>)</span><br><span class="line">writableProxy.write(<span class="string">'Second chunk'</span>)</span><br><span class="line">writable.write(<span class="string">'This is not logged'</span>)</span><br><span class="line">writableProxy.end()</span><br><span class="line"><span class="comment">// =&gt; Writing First chunk</span></span><br><span class="line"><span class="comment">// =&gt; Writing Second chunk</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;代理（proxy）&lt;/strong&gt; 可以理解为一种对象，其能够控制客户端对另一个对象（&lt;strong&gt;subject&lt;/strong&gt;）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。&lt;br&gt;proxy 会拦截
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Proxy" scheme="https://rollingstarky.github.io/tags/Proxy/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Monkey Patching" scheme="https://rollingstarky.github.io/tags/Monkey-Patching/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Health Probe</title>
    <link href="https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/"/>
    <id>https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/</id>
    <published>2022-05-09T16:00:00.000Z</published>
    <updated>2022-05-10T13:32:21.728Z</updated>
    
    <content type="html"><![CDATA[<p><em>Health Probe</em> 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度<strong>可观测</strong>的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经准备好接收请求。<br>这些观测结果会影响 Pod 的生命周期管理，以及网络流量被路由到应用的具体路径。</p><p>Kubernetes 会定期检测容器中进程的状态，如果有错误发生，就立即重启该容器。然而在实践中，通过检查进程状态来确定应用是否健康，并不总是有效。<br>很多情况下应用提供的服务中断了，但进程仍旧在运行。比如 Java 应用有可能抛出 <code>OutOfMemoryError</code> 同时 JVM 进程仍在运行。此外，应用还有可能因为无限循环、死锁或者缓存异常等原因冻结。<br>因此 Kubernetes 需要一种可靠的方式来检查应用的健康状态，不关注应用的内部工作流程，而是通过某些指标，衡量应用能否对外提供服务。</p><p>软件行业已经接受了这样一个事实，即写出完全没有 bug 的软件是不现实的。因此当面对 failures 时，可以把关注点从避免 bug 转移到如何快速检测到失效并自动恢复。<br>但错误检测并不是一个简单的对所有应用通用的任务，存在很多不同的对于错误的定义，并且不同类型的错误也需要不同的应对方式。</p><h4 id="Process-Health-Checks"><a href="#Process-Health-Checks" class="headerlink" title="Process Health Checks"></a>Process Health Checks</h4><p><em>process health check</em> 是最简单的一种 health check 方式，由 Kubelet 持续对容器进程进行检测。若容器进程没有处于运行状态，即对其进行重启。<br>如果应用本身能够检测到任意类型的错误并自行终止，凭借 process health check 就足够完成健康检查任务。</p><h4 id="Liveness-Probes"><a href="#Liveness-Probes" class="headerlink" title="Liveness Probes"></a>Liveness Probes</h4><p>假如应用会进入某种死锁状态，进程并未停止运行，因而从 process health check 的角度看应用仍然是健康的。Kubernetes 可以通过 <em>liveness probes</em> 来检测此类错误。<br>能够从应用外部执行健康检测，而不是仅仅依靠应用本身，这一点是非常重要的。因为有些错误有可能会阻止应用本身的 watchdog 对外报告异常。<br>liveness probes 看上去和 process health check 非常相似，它们都会在检测到异常时重启容器。但前者提供了更多的灵活性：</p><ul><li>HTTP probe：向容器的 IP 地址发起 HTTP GET 请求，期待获取一个成功的 HTTP 响应码（200 - 399）</li><li>TCP Socket probe：测试是否能完成完整的 TCP 连接</li><li>Exec probe：在容器内部执行任意的命令，期待获取一个成功的退出码（0）</li></ul><p>基于 HTTP 的 liveness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-liveness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">DELAY_STARTUP</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"20"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/actuator/health</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>httpGet</code> 中的 <code>path</code> 项用于配置 HTTP probe 执行健康检测时请求的端点；<code>initialDelaySeconds</code> 用于配置执行第一次检测前等待的时间，以等待应用启动后完成 warm up。</p><p>需要注意的是，未通过 liveness probe 检查的后果就是容器被重启，若容器重启对于解决问题没有任何效果，则 liveness probe 本身也不会再有任何其他作用。</p><h4 id="Readiness-Probes"><a href="#Readiness-Probes" class="headerlink" title="Readiness Probes"></a>Readiness Probes</h4><p>Liveness 检查通过杀掉不健康的容器并将它们替换为新的容器实例，来确保应用处于健康状态。但有些时候容器遇到问题，重启它们并不会令其恢复健康。最常见的情况就是容器正处于启动过程中，还没有准备好处理任何请求。或者有可能容器负载过高导致延迟极度增长。</p><p>在上述场景下，Kubernetes 提供了 <em>readiness probe</em> 特性。Readiness 检查和 Liveness 检查提供的检测方法是一样的（都是 HTTP、TCP 和 Exec），只有触发的操作不同。<br>失败的 Readiness 检查会将容器从 Service 端点移除，确保其不再对外提供任何服务。它关注的重点在于容器是否已经准备好，有些容器在启动时需要一定的 warm up 时间才能处理请求。<br>Readiness probe 在容器启动后依然会定期运行，从而将不能对外提供服务的容器屏蔽掉，保证未准备好的容器不会接收到外部的请求。</p><p>即 Liveness probe 触发的操作是重启容器，目的是不健康的容器尽可能恢复服务；Readiness probe 触发的操作是将容器从 Service 移除，目的是确保不健康的容器不会对外提供服务，用户的请求只会转发到健康的容器。<br>当然在容器重启时，Kubernetes 也会尽力确保该容器不会再收到用户请求，不管 Readiness probe 是否通过。</p><p>Readiness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-readiness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    readinessProbe:</span></span><br><span class="line"><span class="attr">      exec:</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[</span> <span class="string">"stat"</span><span class="string">,</span> <span class="string">"/var/run/random-generator-ready"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>Process health check 和 liveness probe 的目的都是通过重启容器来使应用能从错误中自动恢复。Readiness probe 则力求为处于恢复中的容器争取足够的时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>容器技术为打包和运行应用实现了一系列统一的接口，从而可以将应用作为<strong>黑盒（black box）</strong>看待。<br>然而任何致力于成为云原生应用的容器，必须为运行时环境提供一系列必要的 API，对容器的健康状态进行统一的观测，并执行对应的操作。这是容器能统一地实现自动化升级和生命周期管理的基础需求，从而提高系统的稳定性和用户体验。<br>这意味着容器化应用必须为多种不同的健康检测（liveness 和 readiness）提供需要的 API。<br>甚至更优异的应用还必须为管理平台提供其他手段，以方便更好地观测容器化应用的状态，比如与 Prometheus 进行整合。将应用视为一种黑盒，同时实现必须的 API 接口，方便平台对其进行监控和管理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Health Probe&lt;/em&gt; 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度&lt;strong&gt;可观测&lt;/strong&gt;的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="Recovery" scheme="https://rollingstarky.github.io/tags/Recovery/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 单例模式</title>
    <link href="https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-09T14:18:38.395Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>单例（<strong>Singleton</strong>）模式是面向对象编程中最常见的设计模式之一，Node.js 已经有了很简单的实现。<br>使用单例模式的目的在于确保某个类只有一个实例存在，并对该实例的访问进行统一的控制。其主要运用场景如下：</p><ul><li>共享有状态的信息</li><li>优化资源消耗</li><li>同步对某个资源的访问</li></ul><p>比如，一个标准的 Database 类会提供对数据库的访问：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(dbName, connectionDetails) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述类的标准实现中，通常需要维护一个数据库连接池，毕竟为每一次数据库请求都分别创建一个新的 Database 实例显得不太现实。此外，Database 实例可能会保存部分有状态的数据，比如 pending 的事务列表。<br>因此，一般只在应用开始运行时初始化一个 Database 实例，此后其作为一个唯一的共享实例被所有其他组件使用。</p><p>Node.js 的新用户可能会思考该如何从逻辑层面实现单例模式，事实上远比想象中更简单。<br><strong>将某个实例从模块中导入，即可实现单例模式的所有需求。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 'dbInstance.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Database&#125; <span class="keyword">from</span> <span class="string">'./Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dbInstance = <span class="keyword">new</span> Database(<span class="string">'my-app-db'</span>, &#123;</span><br><span class="line">  url: <span class="string">'localhost:5432'</span>,</span><br><span class="line">  username: <span class="string">'user'</span>,</span><br><span class="line">  password: <span class="string">'password'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只需要简单地导出 Database 类的一个新实例（<code>dbInstance</code>），在当前的整个包中就可以认为只存在这一个 <code>dbInstance</code> 对象（单例），这得益于 Node.js 的模块系统。Node.js 会对模块进行缓存，保证不会在每次导入时都再执行一遍代码。</p><p>再通过如下一行代码即可简单地获取上面创建的共享的 <code>dbInstance</code> 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dbInstance &#125; <span class="keyword">from</span> <span class="string">'./dbInstance.js'</span></span><br></pre></td></tr></table></figure></p><h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>Node.js 中缓存的模块以完整路径作为对其进行查找的 key，所以前面实现的 Singleton 只在当前的包中生效。每个包都有可能包含其私有的依赖，放置在它自己的 <code>node_modules</code> 路径下。因而就可能导致同一个模块存在多个实例，前面实现的 Singleton 不能再保证唯一性。</p><p>例如，前面的 <code>Database.js</code> 和 <code>dbInstance.js</code> 同属于 <code>mydb</code> 包，其 <code>package.json</code> 内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"mydb"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dbInstance.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又假设有两个包（<code>package-a</code> 和 <code>package-b</code>）各自都拥有包含如下内容的 <code>index.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dbInstance&#125; <span class="keyword">from</span> <span class="string">'mydb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDbInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dbInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package-a</code> 和 <code>package-b</code> 都依赖包 <code>mydb</code>，但 <code>package-a</code> 依赖版本 1.0.0，<code>package-b</code> 依赖版本 2.0.0。结果就会出现如下结构的依赖关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">`-- node_modules</span><br><span class="line">    |-- package-a</span><br><span class="line">    |  `-- node_modules</span><br><span class="line">    |      `-- mydb</span><br><span class="line">    `-- package-b</span><br><span class="line">        `-- node_modules</span><br><span class="line">            `-- mydb</span><br></pre></td></tr></table></figure></p><p>当 <code>package-a</code> 和 <code>package-b</code> 依赖两个不兼容版本的 <code>mydb</code> 模块时，包管理器不会将 <code>mydb</code> 放置在 <code>node_modules</code> 的根路径下，而是在 <code>package-a</code> 和 <code>package-b</code> 下面各自放一个私有的 <code>mydb</code> 副本，从而解决版本冲突。</p><p>此时假如 <code>app/</code> 路径下有一个如下内容的 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromA&#125; <span class="keyword">from</span> <span class="string">'package-a'</span></span><br><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromB&#125; <span class="keyword">from</span> <span class="string">'package-b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSame = getDbFromA() === getDbFromB()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is the db instance in package-a the same '</span> +</span><br><span class="line">  <span class="string">`as package-b? <span class="subst">$&#123;isSame ? <span class="string">'YES'</span> : <span class="string">'NO'</span>&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></p><p><code>getDbFromA()</code> 和 <code>getDbFromB()</code> 并不会获得同一个 <code>dbInstance</code> 实例，打破了 Singleton 模式的假设。</p><p>当然了，大多数情况下我们并不需要一个 <em>pure</em> Singleton。事实上，通常也只会在应用的 main 包中创建和导入 Singleton。</p><h4 id="Singleton-dependencies"><a href="#Singleton-dependencies" class="headerlink" title="Singleton dependencies"></a>Singleton dependencies</h4><p>最简单地将两个模块组合在一起的方式，就是直接利用 Node.js 的模块系统。如前面所说，这样组合起来的有状态的依赖关系其实就是单例模式。</p><p>实现下面一个博客系统：<br><code>mkdir blog &amp;&amp; cd blog</code><br><code>npm install sqlite3</code></p><p><code>blog/package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"sqlite3"</span>: <span class="string">"^5.0.8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.Database(</span><br><span class="line">  join(__dirname, <span class="string">'data.sqlite'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>blog/blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"><span class="keyword">import</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbRun = promisify(db.run.bind(db))</span><br><span class="line"><span class="keyword">const</span> dbAll = promisify(db.all.bind(db))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p><code>db.js</code> 创建了一个 <code>db</code> 数据库实例并导出，<code>blog.js</code> 从 <code>db.js</code> 中导入 <code>db</code> 实例并直接在代码中使用。形成了一种简单直观的 <code>blog.js</code> 依赖于 <code>db.js</code> 模块的关系。同时整个项目中的数据库连接都由唯一的 <code>db</code> 单例进行控制。</p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">No posts available.</span><br></pre></td></tr></table></figure></p><p>可以运行下面的命令插入测试数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-posts.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'my-first-post'</span>,</span><br><span class="line">    title: <span class="string">'My first post'</span>,</span><br><span class="line">    content: <span class="string">'Hello World!\nThis is my first post'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-03'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'iterator-patterns'</span>,</span><br><span class="line">    title: <span class="string">'Node.js iterator patterns'</span>,</span><br><span class="line">    content: <span class="string">'Let\'s talk about some iterator patterns in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-06'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'dependency-injection'</span>,</span><br><span class="line">    title: <span class="string">'Dependency injection in Node.js'</span>,</span><br><span class="line">    content: <span class="string">'Today we will discuss about dependency injection in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-29'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    posts.map(</span><br><span class="line">      (post) =&gt; blog.createPost(</span><br><span class="line">        post.id,</span><br><span class="line">        post.title,</span><br><span class="line">        post.content,</span><br><span class="line">        post.created_at</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'All posts imported'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ node <span class="keyword">import</span>-posts.js</span><br><span class="line">All posts imported</span><br><span class="line">$ node index.js</span><br><span class="line">Dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line">-------------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-29</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Today we will discuss about dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Node.js iterator patterns</span><br><span class="line">-------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-06</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Let<span class="string">'s talk about some iterator patterns in Node.js</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">My first post</span></span><br><span class="line"><span class="string">-------------</span></span><br><span class="line"><span class="string">Published on 2020-02-03T00:00:00.000Z</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">This is my first post</span></span><br></pre></td></tr></table></figure><p>就如上面的代码所示，借助 Singleton 模式，将 <code>db</code> 实例自由地在文件之间传递，可以实现一个很简单的命令行博客管理系统。这也是大多数情况下我们管理有状态的依赖的方式。<br>使用 Singleton 诚然是最简单、即时，可读性最好的方案。但是，假如我们需要在测试过程中 mock 数据库，或者需要终端用户能够自主选择另一个数据库后端，而不是默认提供的 SQLite。<br>对于以上需求，Singleton 反而成为了一个设计更好结构的阻碍。可以在 <code>db.js</code> 中引入 <code>if</code> 语句根据某些条件来选择不同的实现，显然这种方式并不是很美观。</p><h4 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h4><p>Node.js 的模块系统以及 Singleton 模式可以作为一个很好的管理和组合应用组件的工具，它们非常简单，容易上手。但另一方面，它们也可能会使各组件之间的<strong>耦合</strong>程度加深。<br>在前面的例子中，<code>blog.js</code> 和 <code>db.js</code> 模块是耦合度很高的，<code>blog.js</code> 没有了 <code>db.js</code> 就无法工作，当然也无法使用另一个不同的数据库模块。<br>可以借助 <strong>Dependency Injection</strong> 来弱化模块之间的耦合度。</p><p><strong>依赖注入</strong>表示将某个组件的依赖模块由外部实体（injector）作为<strong>输入</strong>提供。<br>DI 的主要优势在于能够降低耦合度，尤其当模块依赖于有状态的实例（比如数据库连接）时。<strong>每个依赖项并不是硬编码进主体代码，而是由外部传入，意味着这些依赖项可以被替换成任意相互兼容的实例</strong>。使得主体代码本身可以以最小的改动在不同的背景下重用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-187f28cb137f94fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dependency injection schematic"></p><p>修改 <code>blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(db) &#123;</span><br><span class="line">    <span class="keyword">this</span>.db = db</span><br><span class="line">    <span class="keyword">this</span>.dbRun = promisify(db.run.bind(db))</span><br><span class="line">    <span class="keyword">this</span>.dbAll = promisify(db.all.bind(db))</span><br><span class="line">  &#125;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最主要的改动在于为 <code>Blog</code> 类添加了 <code>constructor (db)</code> 构造方法，该方法的参数 <code>db</code> 即为 Dependency，Blog 的依赖项，需要在运行时由 Blog 的客户端提供。</p><p>修改 <code>db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createDb</span>(<span class="params">dbFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> sqlite3.Database(dbFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此版本的 <code>db</code> 模块提供了一个 <code>createDB()</code> 工厂函数，可以在运行时返回一个新的数据库实例。</p><p>修改 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDb&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> db = createDb(join(__dirname, <span class="string">'data.sqlite'</span>))</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog(db)</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p>使用 <code>createDB()</code> 工厂函数创建数据库实例 <code>db</code>，然后在初始化 Blog 实例时，将 <code>db</code> 作为 Blog 的依赖进行注入。<br>从而 <code>blog.js</code> 与具体的数据库实现进行了分离。</p><p>依赖注入可以提供松耦合和代码重用等优势，但也存在一定的代价。比如无法在编码时解析依赖项，使得理解模块之间的逻辑关系变得更加困难，尤其当应用很大很复杂的时候。<br>此外，我们还必须确保数据库实例（依赖）在 Blog 实例之前创建，从而迫使我们手动构建整个应用的依赖图，以保证顺序正确。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Singleton&quot;&gt;&lt;a href=&quot;#Singleton&quot; class=&quot;headerlink&quot; title=&quot;Singleton&quot;&gt;&lt;/a&gt;Singleton&lt;/h4&gt;&lt;p&gt;单例（&lt;strong&gt;Singleton&lt;/strong&gt;）模式是面向对象编程中最常
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Singleton" scheme="https://rollingstarky.github.io/tags/Singleton/"/>
    
      <category term="Dependency Injection" scheme="https://rollingstarky.github.io/tags/Dependency-Injection/"/>
    
      <category term="Decoupling" scheme="https://rollingstarky.github.io/tags/Decoupling/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Builder 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T14:46:01.904Z</updated>
    
    <content type="html"><![CDATA[<p>Builder 是一种<strong>创建型</strong>设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。<br>最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。</p><p>比如下面的一个 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(hasMotor, motorCount, motorBrand, motorModel,</span><br><span class="line">    hasSails, sailsCount, sailsMaterial, sailsColor,</span><br><span class="line">    hullColor, hasCabin) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用上述 <code>Boat</code> 类的构造方法会导致出现非常难以阅读的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(<span class="literal">true</span>, <span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>, <span class="literal">true</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="string">'fabric'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>想要提升上述构造函数的设计，首先可以将所有的参数整合到一个单一的对象中，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">  hasMotor: <span class="literal">true</span>,</span><br><span class="line">  motorCount: <span class="number">2</span>,</span><br><span class="line">  motorBrand: <span class="string">'Best Motor Co. '</span>,</span><br><span class="line">  motorModel: <span class="string">'OM123'</span>,</span><br><span class="line">  hasSails: <span class="literal">true</span>,</span><br><span class="line">  sailsCount: <span class="number">1</span>,</span><br><span class="line">  sailsMaterial: <span class="string">'fabric'</span>,</span><br><span class="line">  sailsColor: <span class="string">'white'</span>,</span><br><span class="line">  hullColor: <span class="string">'blue'</span>,</span><br><span class="line">  hasCabin: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>新版本的构造函数跟原来相比提升了不少，比如用户可以清晰地看到每个传入的参数所代表的具体含义。<br>但是，将所有参数都放入同一个对象后再传入构造函数的方式，也有其自身的缺点。比如要想知道每个参数的具体含义，还是需要查看类的说明文档甚至类的代码。此外，没有任何强制性的协议来引导用户创建一致的对象，假如我们指定 <code>hasMotor: true</code>，意味着我们同时还需要再指定 <code>motorCount</code>、<code>motorBrand</code> 和 <code>motorModel</code> 参数的值。但我们无从获取此类信息（除非查看源代码）。</p><p>Builder 模式就非常适合解决上述问题。帮助用户创建一个平滑、易读、自说明的生成对象的接口，同时为创建具有一致性的对象提供指导信息。</p><p>使用 Builder 模式的 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoatBuilder</span> </span>&#123;</span><br><span class="line">  withMotors(count, brand, model) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasMotor = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.motorCount = count</span><br><span class="line">    <span class="keyword">this</span>.motorBrand = brand</span><br><span class="line">    <span class="keyword">this</span>.motorModel = model</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withSails(count, material, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasSails = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.sailsCount = count</span><br><span class="line">    <span class="keyword">this</span>.sailsMaterial = material</span><br><span class="line">    <span class="keyword">this</span>.sailsColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hullColor(color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hullColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withCabin() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasCabin = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">      hasMotor: <span class="keyword">this</span>.hasMotor,</span><br><span class="line">      motorCount: <span class="keyword">this</span>.motorCount,</span><br><span class="line">      motorBrand: <span class="keyword">this</span>.motorBrand,</span><br><span class="line">      motorModel: <span class="keyword">this</span>.motorModel,</span><br><span class="line">      hasSails: <span class="keyword">this</span>.hasSails,</span><br><span class="line">      sailsCount: <span class="keyword">this</span>.sailsCount,</span><br><span class="line">      sailsMaterial: <span class="keyword">this</span>.sailsMaterial,</span><br><span class="line">      sailsColor: <span class="keyword">this</span>.sailsColor,</span><br><span class="line">      hullColor: <span class="keyword">this</span>.hullColor,</span><br><span class="line">      hasCabin: <span class="keyword">this</span>.hasCabin</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> BoatBuilder()</span><br><span class="line">  .withMotors(<span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>)</span><br><span class="line">  .withSails(<span class="number">1</span>, <span class="string">'fabric'</span>, <span class="string">'white'</span>)</span><br><span class="line">  .withCabin()</span><br><span class="line">  .hullColor(<span class="string">'blue'</span>)</span><br><span class="line">  .build()</span><br></pre></td></tr></table></figure></p><p><code>BoatBuilder</code> 类的作用就是收集 <code>Boat</code> 类需要的所有参数，再通过一系列 helper 方法传递给 <code>Boat</code>。</p><p>Builder 模式的基本规则：</p><ul><li>将主要对象的复杂构建过程拆分为几个更为易读的、更容易管理的步骤</li><li>尝试创建 builder 方法，向需要创建的对象一组一组地传递相关联的参数</li><li>必要的情况下，在通过 builder 方法将参数传递给需要创建的对象前，尽可能地先对参数做一些处理</li></ul><h4 id="实例：URL-builder"><a href="#实例：URL-builder" class="headerlink" title="实例：URL builder"></a>实例：URL builder</h4><p>创建并进入 <code>url_builder</code> 文件夹，编辑如下内容的 <code>package.json</code> 文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>url.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Url</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(protocol, username, password, hostname,</span><br><span class="line">    port, pathname, search, hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.validate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  validate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.protocol || !<span class="keyword">this</span>.hostname) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must specify at least a '</span> + <span class="string">'protocol and a hostname'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">''</span></span><br><span class="line">    url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.protocol&#125;</span>://`</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.username &amp;&amp; <span class="keyword">this</span>.password) &#123;</span><br><span class="line">      url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.username&#125;</span>:<span class="subst">$&#123;<span class="keyword">this</span>.password&#125;</span>@`</span></span><br><span class="line">    &#125;</span><br><span class="line">    url += <span class="keyword">this</span>.hostname</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.port) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.port</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pathname) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.pathname</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search) &#123;</span><br><span class="line">      url += <span class="string">`?<span class="subst">$&#123;<span class="keyword">this</span>.search&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hash) &#123;</span><br><span class="line">      url += <span class="string">`#<span class="subst">$&#123;<span class="keyword">this</span>.hash&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>urlBuilder.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Url &#125; <span class="keyword">from</span> <span class="string">'./url.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlBuilder</span> </span>&#123;</span><br><span class="line">  setProtocol(protocol) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setAuthentication(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHostname(hostname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPort(port) &#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPathname(pathname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setSearch(search) &#123;</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHash(hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Url(<span class="keyword">this</span>.protocol, <span class="keyword">this</span>.username, <span class="keyword">this</span>.password,</span><br><span class="line">      <span class="keyword">this</span>.hostname, <span class="keyword">this</span>.port, <span class="keyword">this</span>.pathname, <span class="keyword">this</span>.search, <span class="keyword">this</span>.hash)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;UrlBuilder&#125; <span class="keyword">from</span> <span class="string">'./urlBuilder.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> UrlBuilder()</span><br><span class="line">  .setProtocol(<span class="string">'https'</span>)</span><br><span class="line">  .setAuthentication(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">  .setHostname(<span class="string">'example.com'</span>)</span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.toString())</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line"><span class="function">https://<span class="title">user:pass</span>@<span class="title">example.com</span></span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Builder 是一种&lt;strong&gt;创建型&lt;/strong&gt;设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。&lt;br&gt;最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。&lt;/p&gt;
&lt;p&gt;比如下面的一个
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— 声明式部署</title>
    <link href="https://rollingstarky.github.io/2022/05/05/kubernetes-patterns-reading-notes-declarative-deployment/"/>
    <id>https://rollingstarky.github.io/2022/05/05/kubernetes-patterns-reading-notes-declarative-deployment/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T14:56:55.719Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明式部署（Declarative Deployment）</strong>模式主要体现在 Kubernetes 对其 Deployment 对象的应用上。</p><p>升级某个服务意味着，需要平滑地关闭旧版本的 Pod，启动新版本的 Pod，然后等待和确认其部署成功，有时候在部署失败时还需要执行回滚操作。<br>这些步骤或者需要一定的 downtime，同时不会有多个版本的服务在并行地运行（旧版本完全停止后再启动新版本）；或者不允许有 downtime，但在升级过程中，新旧版本的服务同时在线会造成资源消耗的增长（旧版本开始停止的时候就添加新版本的实例）。</p><p>手动执行上述操作难免会有错误发生，写脚本来自动化处理又需要付出较大的时间成本。好在 Kubernetes 通过 Deployment 概念自动化了这些升级、回滚流程，可以在 Deployment 中定义替换的策略（如 <strong>RollingUpdate</strong> 和 <strong>Recreate</strong>）以及其他升级过程中的细节。</p><h4 id="Rolling-Deployment"><a href="#Rolling-Deployment" class="headerlink" title="Rolling Deployment"></a>Rolling Deployment</h4><p>下面是一个采用滚动升级（rolling update）策略的 Deployment 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">      matchLabels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      metadata:</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">      spec:</span></span><br><span class="line"><span class="attr">        containers:</span></span><br><span class="line"><span class="attr">        - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">          readinessProbe:</span></span><br><span class="line"><span class="attr">            exec:</span></span><br><span class="line"><span class="attr">              command:</span> <span class="string">[</span> <span class="string">"stat"</span><span class="string">,</span> <span class="string">"/random-generator-ready"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>replicas: 3</code> 表示副本的总数量是 3，在执行 rolling update 时，声明的副本数量必须大于 1。<br><code>maxSurge: 1</code> 表示在升级过程中，允许临时添加的 Pod 的最大数量。滚动升级有一个切换的过程，必然导致某个时间段内新旧版本的应用同时运行，从而实际运行的 Pod 数量大于声明的副本数量。此处的配置最多允许 4 个副本同时运行。<br><code>maxUnavailable: 1</code> 表示升级过程中可能无法访问的 Pods 数量。此处的配置有可能导致在升级的某个阶段，只有两个 Pods 可用。<br><code>readinessProbe</code> 配置对于执行无 downtime 的滚动升级非常关键，它用来判断某个 Pod 副本是否已经在线</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-70f64e82ecc7d7a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rolling deployment"></p><p>RollingUpdate 策略会确保升级过程中没有 downtime。<code>Deployment</code> 负责创建新的 ReplicaSet 并用新的容器替换掉旧容器，用户则可以通过配置 <code>maxSurge</code> 和 <code>maxUnavailable</code> 字段来控制切换的速率。</p><h5 id="Deployment-的优势"><a href="#Deployment-的优势" class="headerlink" title="Deployment 的优势"></a>Deployment 的优势</h5><ul><li>Deployment 是完全被 Kubernetes 内部管理的资源对象，整个的升级过程由 Server 端执行，无需客户端介入</li><li>Deployment 的声明式性质，使得用户更加关注期望达到的状态而不是达到该状态需要执行的操作步骤</li><li>整个升级过程会以版本的方式进行记录，还提供了 pause、continue 和 rollback 等选项</li></ul><h4 id="Fixed-Deployment"><a href="#Fixed-Deployment" class="headerlink" title="Fixed Deployment"></a>Fixed Deployment</h4><p>RollingUpdate 策略在需要确保无 downtime 时非常有用，但该方式也有一些负面影响。比如在升级过程中，会有两个版本的容器同时运行，这有可能导致接收服务的客户端出现一些 issue，尤其当更新引入了没有向后兼容的特性时。<br>在此类场景下，可以使用 <code>Recreate</code> 策略。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2d35f93dba9074a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fixed deployment using a Recreate strategy"></p><p><code>Recreate</code> 策略的效果类似于 <code>RollingUpdate</code> 将 <code>maxUnavailable</code> 的值设置成了副本的数量。这意味着所有当前版本的容器都会先被终止掉，在旧容器被全部清理干净之后才开始同步启动所有的新容器。<br>结果就是升级过程中会存在一定的 downtime。</p><h4 id="Blue-Green-Release"><a href="#Blue-Green-Release" class="headerlink" title="Blue-Green Release"></a>Blue-Green Release</h4><p><em>Blue-Green deployment</em> 发布策略致力于在生产环境中最小化部署时的 downtime。借助 Kubernetes 对于发布行为的抽象（Deployment），用户可以自行定义和实现将<strong>不可变</strong>的容器从一个版本转换到另一个版本的具体方式，比如 Blue-Green 部署方式。<br>如果 Kubernetes 集群中并未安装 Service Mesh 或者 Knative 等扩展组件，Blue-Green deployment 就需要手动实现。<br>其原理就是创建一个新的 Deployment，包含最新版本的容器（<em>green</em>），但是并不向外提供任何服务。旧的 Pod 副本（<em>blue</em>）依然在运行和处理请求。<br>一旦用户确认新版本的 Pod 是健康的，可以提供服务，就将入站流量从旧的 Pod 副本切换到新版本的副本。在 Kubernetes 中可以通过修改 Service selector 来完成切换动作。当新版本的容器运行稳定后，旧版本即可被删除。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-bd7365c96c887aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Blue-Green release"></p><p>Blue-Green 方案的优势在于，同一时间只会有一个特定版本的应用对外提供服务，不需要接收服务的客户端处理多个并行的服务版本；其劣势则在于需要双倍的资源去运行 blue 和 green 容器。此外，有些时候切换的过程会非常复杂。</p><h4 id="Canary-Release"><a href="#Canary-Release" class="headerlink" title="Canary Release"></a>Canary Release</h4><p><em>Canary release</em> 是一种软部署方式，一开始只会将旧版本实例的一个较小的子集替换为新版本。先只允许一小部分用户能够访问更新后的服务，从而降低新版本向生产环境引入的风险。<br>当能够确认新版本的服务对一小部分用户没有产生负面影响，再用新版全面替换掉旧版。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-45557bf5d7d50c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Canary release"></p><p>在 Kubernetes 中，上述部署方式可以通过创建一个包含新版本容器的 ReplicaSet 来实现，只不过副本的数量可以设置得很小，作为 Canary 实例。同时 Service 对象负责将一部分用户的请求转发给 Canary 容器。当我们确信新版本应用可以正常提供服务，则横向扩展新的 ReplicaSet 到期望的副本数量，同时收缩旧 ReplicaSet 的副本数量至 0。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Deployment 很好地向我们展示了，Kubernetes 将复杂的手动升级应用的流程，转化为可以重复执行、支持自动化编排的声明式部署。</p><p>上述四种部署方式的总结：<img src="https://upload-images.jianshu.io/upload_images/6875152-707a221be2108608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deployment and release strategies"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;声明式部署（Declarative Deployment）&lt;/strong&gt;模式主要体现在 Kubernetes 对其 Deployment 对象的应用上。&lt;/p&gt;
&lt;p&gt;升级某个服务意味着，需要平滑地关闭旧版本的 Pod，启动新版本的 Pod，然后等待和确
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="ReplicaSet" scheme="https://rollingstarky.github.io/tags/ReplicaSet/"/>
    
      <category term="Update" scheme="https://rollingstarky.github.io/tags/Update/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 工厂模式</title>
    <link href="https://rollingstarky.github.io/2022/04/28/node-js-design-patterns-factory-pattern/"/>
    <id>https://rollingstarky.github.io/2022/04/28/node-js-design-patterns-factory-pattern/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-04-28T14:21:34.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>工厂（Factory）模式</strong> 是 Node.js 中最常见的设计模式之一。<br>其具有以下优势：</p><ul><li>将对象的创建过程与对象的实现细节进行<strong>解耦</strong>。由工厂创建一系列对象，某个对象继承的特征在运行时确定</li><li>工厂模式允许我们对外暴露更少的接口。一个类可以被扩展或者操控，而工厂本身仅仅是一个负责创建对象的函数，没有给用户其他选项，从而使接口更健壮和容易理解</li><li>借助<strong>闭包</strong>可以帮助强化对象的<strong>封装</strong></li></ul><h4 id="解耦对象的创建和实现"><a href="#解耦对象的创建和实现" class="headerlink" title="解耦对象的创建和实现"></a>解耦对象的创建和实现</h4><p>工厂模式封装了新对象的创建过程，给这个过程提供了更多的灵活性和控制。在工厂内部我们可以选择各种不同的方式来创建某个对象的实例，工厂的消费者对于这些细节一无所知。<br>相反地，使用 <code>new</code> 关键字则会将代码绑定到一种特定的创建方式上。</p><p>比如下面的一个用于创建 <code>Image</code> 对象的工厂函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Image(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> image = createImage(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure></p><p>上述 <code>createImage</code> 工厂函数看上去完全没有必要，直接使用如下一行代码就可以搞定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> image = <span class="keyword">new</span> Image(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure></p><p>按照前面所说，<code>new</code> 关键字会将代码绑定给一种特定类型的对象，在这里就是 <code>Image</code> 类型。<br>而工厂模式则更加灵活。假设需要重构 <code>Image</code> 类，将其分割成几个更小的类型，对应不同的图片格式。<br>工厂函数 <code>createImage</code> 作为唯一的创建新图片对象的方式，即便需要创建的图片对象添加了更多的类型，也可以很简单地只对 <code>createImage</code> 的内部逻辑进行重写，其对外开放的接口不会发生改变，不会破坏任何现有的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.match(<span class="regexp">/\.jpe?g$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageJpeg(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.gif$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageGif(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.png$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImagePng(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unsupported format'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="强化封装"><a href="#强化封装" class="headerlink" title="强化封装"></a>强化封装</h4><p>借助<strong>闭包</strong>，工厂模式可以成为一种强化封装性的机制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> privateProperties = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> person = &#123;</span><br><span class="line">                setName (name) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A person must have a name'</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                        privateProperties.name = name</span><br><span class="line">                &#125;,</span><br><span class="line">                getName () &#123;</span><br><span class="line">                        <span class="keyword">return</span> privateProperties.name</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        person.setName(name)</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person = createPerson(<span class="string">'John'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName())</span><br><span class="line"><span class="comment">// =&gt; John</span></span><br><span class="line">person.setName(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName())</span><br><span class="line"><span class="comment">// =&gt; Michael</span></span><br></pre></td></tr></table></figure></p><p><code>createPerson</code> 工厂函数创建了一个 <code>person</code> 对象。由于闭包的存在，即便 <code>createPerson</code> 函数运行完毕退出了，其属性 <code>privateProperties</code> 仍可以被 <code>person</code> 对象通过其 <code>setName</code> 和 <code>getName</code> 方法访问。<br>但与此同时，该 <code>privateProperties</code> 属性无法被任何外部对象（包括 <code>person</code>）直接访问。</p><h4 id="完整实例：Profiler"><a href="#完整实例：Profiler" class="headerlink" title="完整实例：Profiler"></a>完整实例：Profiler</h4><p>创建并进入一个新的 <code>simple_profiler</code> 文件夹，编辑如下内容的 <code>package.json</code> 文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建如下内容的 <code>profiler.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (label) &#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">    <span class="keyword">this</span>.lastTime = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start () &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastTime = process.hrtime()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  end () &#123;</span><br><span class="line">    <span class="keyword">const</span> diff = process.hrtime(<span class="keyword">this</span>.lastTime)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Timer "<span class="subst">$&#123;<span class="keyword">this</span>.label&#125;</span>" took <span class="subst">$&#123;diff[<span class="number">0</span>]&#125;</span> seconds `</span> + <span class="string">`and <span class="subst">$&#123;diff[<span class="number">1</span>]&#125;</span> nanoseconds.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noopProfiler = &#123;</span><br><span class="line">  start () &#123;&#125;,</span><br><span class="line">  end () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createProfiler</span> (<span class="params">label</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> noopProfiler</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Profiler(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建如下内容的 <code>index.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createProfiler &#125; <span class="keyword">from</span> <span class="string">'./profiler.js'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllFactors</span> (<span class="params">intNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> profiler = createProfiler(</span><br><span class="line">    <span class="string">`Finding all factors of <span class="subst">$&#123;intNumber&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  profiler.start()</span><br><span class="line">  <span class="keyword">const</span> factors = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> factor = <span class="number">2</span>; factor &lt;= intNumber; factor++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((intNumber % factor) === <span class="number">0</span>) &#123;</span><br><span class="line">      factors.push(factor)</span><br><span class="line">      intNumber = intNumber / factor</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  profiler.end()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myNumber = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> myFactors = getAllFactors(myNumber)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Factors of <span class="subst">$&#123;myNumber&#125;</span> are: `</span>, myFactors)</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node index.js <span class="number">2201307499</span></span><br><span class="line">Factors of <span class="number">2201307499</span> are:  [ <span class="number">38737</span>, <span class="number">56827</span> ]</span><br><span class="line">$ node index.js <span class="number">2201307499</span></span><br><span class="line">Timer "Finding all factors of <span class="number">2201307499</span>" took <span class="number">0</span> seconds and <span class="number">9738800</span> nanoseconds.</span><br><span class="line">Factors of <span class="number">2201307499</span> are:  [ <span class="number">38737</span>, <span class="number">56827</span> ]</span><br></pre></td></tr></table></figure></p><p>简单来说，就是通过 <code>createProfiler</code> 工厂函数来创建不同的 <code>Profiler</code> 对象。若环境变量 <code>NODE_ENV</code> 的值为 <code>production</code>，则返回一个新的的 <code>noopProfiler</code>，不对运行的代码做任何额外的操作；若 <code>NODE_ENV</code> 的值不为 <code>production</code>，则返回一个新的 <code>Profiler</code> 对象，记录程序运行的时间。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;工厂（Factory）模式&lt;/strong&gt; 是 Node.js 中最常见的设计模式之一。&lt;br&gt;其具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将对象的创建过程与对象的实现细节进行&lt;strong&gt;解耦&lt;/strong&gt;。由工厂创建一系列对象，某个对象继承的特征
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Factory" scheme="https://rollingstarky.github.io/tags/Factory/"/>
    
      <category term="Patterns" scheme="https://rollingstarky.github.io/tags/Patterns/"/>
    
      <category term="Node" scheme="https://rollingstarky.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 通过 PersistentVolume 持久化数据</title>
    <link href="https://rollingstarky.github.io/2022/04/27/kubernetes-in-action-reading-notes-persistent-data-with-persistent-volume/"/>
    <id>https://rollingstarky.github.io/2022/04/27/kubernetes-in-action-reading-notes-persistent-data-with-persistent-volume/</id>
    <published>2022-04-26T16:00:00.000Z</published>
    <updated>2022-04-27T12:41:30.486Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Pods-与底层存储技术的解耦"><a href="#Pods-与底层存储技术的解耦" class="headerlink" title="Pods 与底层存储技术的解耦"></a>Pods 与底层存储技术的解耦</h4><p>理想情况下，将应用部署到 Kubernetes 上的开发者不需要知道集群提供的存储技术，就像他们不需要知道运行 Pods 的物理服务器的属性。基础设施的细节应该由集群的维护者去掌控。</p><p>比如在 Pod 中挂载一个 NFS 共享作为持久存储，Pod 的清单文件中就需要包含 NFS 服务器的 IP 地址和共享文件的路径，从而导致该 Pod 的定义与特定的集群绑定在一起，阻止其用在其他地方。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0329c69edbfa8e74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A pod manifest with infrastructure-specific volume information is not portable to other clusters"></p><h5 id="Persistent-volumes-and-claims"><a href="#Persistent-volumes-and-claims" class="headerlink" title="Persistent volumes and claims"></a>Persistent volumes and claims</h5><p>为了令 Pod 清单文件面向不同的集群是可移植的，针对存储卷的环境相关的信息被移动到 <strong>PersistentVolume</strong> 对象中，再通过一个 <strong>PersistentVolumeClaim</strong> 对象将 Pod 与 PersistentVolume 连接在一起。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f749bef8732150a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using persistent volumes and persistent volume claims to attach network storage to pods"></p><p>顾名思义，<strong>PersistentVolume</strong> 对象代表一种存储卷，用来持久化应用数据。该对象包含了底层存储的信息，从而将这些信息从 Pod 中解耦。即 Pod 的清单文件中与存储相关的部分，不必再包含基础设施相关的信息（转移到了 PersistentVolume 中），使得同样的清单文件能够部署在不同的集群上。</p><p>Pod 并不会直接引用 PersistentVolume 对象，而是指向一个 <strong>PersistentVolumeClaim</strong> 对象。PersistentVolumeClaim 代表用户对 PV 的请求或者声明，有着独立于 Pod 的生命周期，从而允许 PV 的所属权（ownership）与 Pod 解耦。<br>用户在使用 PV 前必须先声明一个 PVC 对象。Pod 可以在任意时间删除，用户并不会因此失去对 PV 的所属权。当 PV 不再被需要时，用户可以通过删除 PVC 来释放它。</p><p>Pod 清单文件中的存储定义部分只需要包含 PVC 的名称，不需要任何基础设施相关的信息，比如 NFS 服务器的 IP 地址。PVC 会负责将其绑定的代表 NFS 存储的 PV 挂载到 Pod 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d3c4f62a71307453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mounting a persistent volume into the pod’s container(s)"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6fe103345145503b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using the same persistent volume claim in multiple pods"></p><h5 id="使用-PV-和-PVC-的优势"><a href="#使用-PV-和-PVC-的优势" class="headerlink" title="使用 PV 和 PVC 的优势"></a>使用 PV 和 PVC 的优势</h5><p>为了让 Pod 使用某个存储卷，借助 PV 和 PVC 这两种额外的对象，肯定比直接在 Pod 清单文件中定义要复杂得多。<br>使用 PV 和 PVC 的最大优势在于，基础设施相关的细节从 Pod 代表的应用中解脱了出来。集群管理员比任何人都更了解数据中心本身，他们负责创建 PV 对象；软件开发者则可以集中精力通过 Pod 和 PVC 来描述应用本身的需求。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0721dd2191c07854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Persistent volumes are provisioned by cluster admins and consumed by pods through persistent volume claims"></p><p>应用开发人员不需要了解底层基础设施的任何细节，就可以直接创建 Pod 清单文件和 PVC 对象；同样的，集群管理员也可以在不了解应用的所有细节的前提下，创建一系列不同大小的存储卷。<br>更进一步的，借助 PV 的动态创建功能，管理员根本不需要提前创建好存储卷。如果集群中安装了 automated volume provisioner，物理存储卷和 PV 对象会在用户创建 PVC 之后按需自动生成。</p><h4 id="创建-PV-和-PVC"><a href="#创建-PV-和-PVC" class="headerlink" title="创建 PV 和 PVC"></a>创建 PV 和 PVC</h4><h5 id="创建-PV-对象"><a href="#创建-PV-对象" class="headerlink" title="创建 PV 对象"></a>创建 PV 对象</h5><p>测试环境使用的是 Minikube，因此这里使用工作节点的本地路径来创建 PV，而不使用网络存储。其清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadOnlyMany</span></span><br><span class="line"><span class="attr">  hostPath:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/var/quiz-data</span></span><br></pre></td></tr></table></figure></p><p>其中的 <code>capacity</code> 选项用来指定底层存储卷的大小。每个 PV 都必须指定其容量，以便于在 PVC 和 PV 绑定时，Kubernetes 可以判断具体哪个 PV 符合要求。<br>每个 PV 都必须指定其支持的 <code>accessModes</code> 列表。依赖于底层存储的具体实现，PV 可能支持也可能不支持同时被多个工作节点以 r/w 或 r/o 模式挂载。<br>注意 <code>accessModes</code> 影响的是 <strong>Nodes</strong> 而不是 <strong>Pods</strong>。一个 PV 只要能够被某个节点挂载，同时也就支持被该节点上的多个 Pods 挂载。<br><code>accessModes</code> 有 <code>ReadWriteOnce</code>、<code>ReadOnlyMany</code>、<code>ReadWriteMany</code> 三种模式。</p><h5 id="创建和查看-PV"><a href="#创建和查看-PV" class="headerlink" title="创建和查看 PV"></a>创建和查看 PV</h5><p>创建 PV：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pv.quiz-data.hostpath.yaml</span><br><span class="line">persistentvolume/quiz-data created</span><br></pre></td></tr></table></figure></p><p>查看 PV：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Available                                   <span class="number">2</span>m55s</span><br></pre></td></tr></table></figure></p><h5 id="声明一个-PV"><a href="#声明一个-PV" class="headerlink" title="声明一个 PV"></a>声明一个 PV</h5><p><strong>创建一个 PVC 对象</strong><br>需要创建 PVC 对象来声明一个 PV，PVC 对象中会指定 PV 必须符合的要求，包括最小容量、访问模式等，通常是由不同应用的具体需求来决定的。因而 PVC 对象应该由应用的作者而不是集群管理员来创建。</p><p>PVC 对象的清单文件内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  volumeName:</span> <span class="string">quiz-data</span></span><br></pre></td></tr></table></figure></p><p>上面的 PVC 对象描述了一系列需要 PV 满足的要求。比如至少 1G 大小、能够在单节点上以读写模式挂载。<br><code>storageClassName</code> 字段用来配置 PV 的动态生成，如果需要绑定一个已经预先创建好的 PV，则该字段必须为空。<br>因为前面创建的 PV 名字为 <code>quiz-data</code>，所以 PVC 中的 <code>volumeName</code> 字段也必须为 <code>quiz-data</code>；若不指定此字段，则 Kubernetes 有可能会绑定其他满足要求的 PV。<br>如果集群管理员创建了一系列没有指定名称的 PV，用户也并不在意具体会绑定哪个 PV，则可以跳过 <code>volumeName</code> 字段，让 Kubernetes 随机选择满足要求的 PV。</p><h5 id="创建和查看-PVC"><a href="#创建和查看-PVC" class="headerlink" title="创建和查看 PVC"></a>创建和查看 PVC</h5><p>创建 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pvc.quiz-data.static.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data created</span><br></pre></td></tr></table></figure></p><p>查看 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME        STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">quiz-data   Bound    quiz-data   <span class="number">1</span>Gi        RWO,ROX                       <span class="number">31</span>s</span><br></pre></td></tr></table></figure></p><p>再次查看之前创建的 PV 的状态，可以看到此时 <code>quiz-data</code> PV 的 <code>STATUS</code> 变成了 <code>BOUND</code>：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Bound    default/quiz-data                           <span class="number">92</span>m</span><br></pre></td></tr></table></figure></p><h4 id="在-Pod-中使用-PVC-和-PV"><a href="#在-Pod-中使用-PVC-和-PV" class="headerlink" title="在 Pod 中使用 PVC 和 PV"></a>在 Pod 中使用 PVC 和 PV</h4><p>参考如下清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">    persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">      claimName:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">quiz-api</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/quiz-api:0.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/data/db</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl apply -f pod.quiz.pvc.yaml</code> 命令创建 Pod，待创建完成后，可以执行如下 Shell 命令向 mongo 容器中插入数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it quiz -c mongo -- mongo kiada &lt;&lt;EOF</span><br><span class="line">db.questions.insert(&#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  text: <span class="string">"What does k8s mean?"</span>,</span><br><span class="line">  answers: [<span class="string">"Kates"</span>, <span class="string">"Kubernetes"</span>, <span class="string">"Kooba Dooba Doo!"</span>],</span><br><span class="line">  correctAnswerIndex: 1</span><br><span class="line">&#125;)</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>运行如下命令查看插入的数据：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="在-Pod-中重复使用-PVC"><a href="#在-Pod-中重复使用-PVC" class="headerlink" title="在 Pod 中重复使用 PVC"></a>在 Pod 中重复使用 PVC</h5><p>当删除某个 Pod 中的 PVC 时，对应的底层存储卷会从工作节点解除挂载。但 PV 对象仍旧是跟 PVC 相关联的。若之后创建另一个 Pod 指向同样的 PVC，则新的 Pod 可以访问 PV 对应的存储卷和文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f pod.quiz.pvc.yaml</span><br><span class="line">pod "quiz" deleted</span><br><span class="line">$ kubectl apply -f pod.quiz.pvc.yaml</span><br><span class="line">pod/quiz created</span><br><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="释放-PV"><a href="#释放-PV" class="headerlink" title="释放 PV"></a>释放 PV</h5><p>删除 PVC 会释放对应的 PV。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod quiz</span><br><span class="line">pod "quiz" deleted</span><br><span class="line">$ kubectl delete pvc quiz-data</span><br><span class="line">persistentvolumeclaim "quiz-data" deleted</span><br></pre></td></tr></table></figure></p><p>查看此时 PV 的状态：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv quiz-data</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Released   default/quiz-data                           <span class="number">45</span>h</span><br></pre></td></tr></table></figure></p><p>其 <code>STATUS</code> 项变成了 <code>Released</code> 状态。</p><p>若此时重新创建删除的 PVC，对应的 PV 不会再次被绑定。<br>原因在于，PV 已经被使用过，有可能包含一些旧的数据，需要在绑定给另一个 PVC 之前进行清理。这也是为什么 PV 已经 <code>Released</code> 之后，仍然显示关联的 <code>CLAIM</code> 是 <code>default/quiz-data</code>，为了方便集群管理员确认这些数据能否被安全的删除。</p><h5 id="令释放的-PV-重新可用"><a href="#令释放的-PV-重新可用" class="headerlink" title="令释放的 PV 重新可用"></a>令释放的 PV 重新可用</h5><p>重新创建删除的 PVC 不会自动绑定之前的 PV，该 PV 会处于 <code>Released</code> 状态。为了让 PV 对应的数据再次可用，需要删除并重新创建 PV。<br><strong>PV 对象只是一个指向底层存储的指针</strong>，它本身并不存储任何应用数据。删除并重新创建 PV 相当于创建了一个新的指向同一个底层存储卷的指针。数据和之前是相同的。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pv quiz-data</span><br><span class="line">persistentvolume "quiz-data" deleted</span><br><span class="line">$ kubectl apply -f pv.quiz-data.hostpath.yaml</span><br><span class="line">persistentvolume/quiz-data created</span><br><span class="line">$ kubectl apply -f pvc.quiz-data.static.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data created</span><br><span class="line">$ kubectl apply -f pod.quiz.pvc.yaml</span><br><span class="line">pod/quiz created</span><br><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="PV-的-reclaim-policy"><a href="#PV-的-reclaim-policy" class="headerlink" title="PV 的 reclaim policy"></a>PV 的 reclaim policy</h5><p>PV 被释放后的动作取决于其 reclaim policy。此 policy 由 PV 对象的 <code>.spec.persistentVolumeReclaimPolicy</code> 条目进行配置。前面 <code>quiz-data</code> 的 reclaim policy 是 <code>Retain</code>。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Bound    default/quiz-data                           <span class="number">5</span>m57s</span><br></pre></td></tr></table></figure></p><p>两种不同的 reclaim policy：</p><ul><li><code>Retain</code>：当 PV 被释放后（即对应的 PVC 被删除后），Kubernetes 会保留该 PV。集群管理员则必须手动回收 Volume。这是手动创建 PV 的默认配置</li><li><code>Delete</code>：PV 对象和对应的底层存储会在 PV 释放后自动删除。这是动态创建 PV 的默认配置</li></ul><h5 id="删除绑定中的-PV"><a href="#删除绑定中的-PV" class="headerlink" title="删除绑定中的 PV"></a>删除绑定中的 PV</h5><p>如果集群管理员删除了某个正在使用中的 PV（已经绑定给了某个 PVC）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pv quiz-data</span><br><span class="line">persistentvolume "quiz-data" deleted</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p><p>上述命令会告诉 Kubernetes API 删除 PV 对象，并等待 Kubernetes 控制器完成该操作。<br>事实上该操作并不会完成，直到待删除的 PV 最终被释放（绑定的 PVC 被删除）。<br>可以按 <code>Ctrl - C</code> 取消等待，但删除动作并不会被取消：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Terminating   default/quiz-data                           <span class="number">19</span>m</span><br></pre></td></tr></table></figure></p><p>该 PV 会一直处于 <code>Terminating</code> 状态，直到对应的 PVC 被删除。</p><h5 id="删除使用中的-PVC"><a href="#删除使用中的-PVC" class="headerlink" title="删除使用中的 PVC"></a>删除使用中的 PVC</h5><p>和删除 PV 类似，删除使用中的 PVC 的动作并不会立即完成。可以强制中断删除命令的执行，但并不会取消该删除流程。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pvc quiz-data</span><br><span class="line">persistentvolumeclaim "quiz-data" deleted</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p><p>删除动作会被 Pod 阻塞。毫无疑问，删除一个正在使用中的 PVC 并不会立即对 Pod 中运行的应用产生任何影响。Kubernetes 并不会因为集群管理员需要回收一些存储空间而杀掉某个 Pod。<br>只有删掉引用了该 PVC 的 Pod，删除该 PVC 的进度才会完成。</p><h4 id="理解手动创建的-PV-的生命周期"><a href="#理解手动创建的-PV-的生命周期" class="headerlink" title="理解手动创建的 PV 的生命周期"></a>理解手动创建的 PV 的生命周期</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8e5e161bccbcbc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The lifecycle of statically provisioned persistent volumes, claims and the pods that use them"></p><p>在使用手动创建的 PV 时，底层存储卷的生命周期与 PV 对象的生命周期是分离的。<br>PV 创建后的初始状态是 <code>Available</code>，当 PVC 出现且其要求能被某个 PV 满足时，PV 与 PVC 完成绑定。在此之前 PVC 处于 <code>Pending</code> 状态，绑定完成后 PV 和 PVC 都处于 <code>Bound</code> 状态。<br>在这之后，一个或多个 Pod 可以通过引用 PVC 来使用对应的存储。当所有的 Pods 运行结束后，PVC 对象可以被删除。PVC 对象删除后，PV 的回收策略决定了对 PV 和底层存储的后续操作。若策略为 <code>Delete</code>，则 PV 和 底层存储都会被删除；若策略为 <code>Retain</code>，PV 对象和底层存储都会被保留，PV 的状态变为 <code>Released</code>，无法再次被绑定。底层存储以及其中的文件会继续存在，可以通过创建一个新的指向同样位置的 PV 来再次访问这些文件。</p><h4 id="PV-的动态创建"><a href="#PV-的动态创建" class="headerlink" title="PV 的动态创建"></a>PV 的动态创建</h4><p>前面的章节中，集群管理员必须提前创建 PV 对象，每次 PV 释放后还需要管理员手动删除存储卷中的数据。<br>为了保证集群平稳地运行，管理员需要提前创建数十甚至上百个 PV，还要持续地跟踪可用的 PV 数量，确保其没有耗尽。所有这些手动操作并没有遵循 Kubernetes 自动管理的哲学。</p><p>更好的方式是动态创建 PV。集群管理员部署一个 PV provisioner，该 provisioner 可以自动化执行实时的 PV 创建流程。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f92c964bf83dba7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dynamic provisioning of persistent volumes"></p><p>与静态创建 PV 相反，在动态创建过程中，用户先创建 PVC，然后 provisioner 再从底层存储创建对应的 PV 对象。</p><h5 id="StorageClass-对象"><a href="#StorageClass-对象" class="headerlink" title="StorageClass 对象"></a>StorageClass 对象</h5><p>列出 storage classes<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get sc</span><br><span class="line">NAME                 PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">standard (default)   k8s.io/minikube-hostpath   Delete          Immediate           false                  <span class="number">158</span>d</span><br></pre></td></tr></table></figure></p><p>进一步检查 storage class<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">sc</span> <span class="string">standard</span> <span class="bullet">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &#123;"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":&#123;"annotations":&#123;"storageclass.kubernetes.io/is-default-class":"true"&#125;,"labels":&#123;"addonmanager.kubernetes.io/mode":"EnsureExists"&#125;,"name":"standard"&#125;,"provisioner":"k8s.io/minikube-hostpath"&#125;</span></span><br><span class="line"><span class="string">    storageclass.kubernetes.io/is-default-class: "true"</span></span><br><span class="line"><span class="string"></span><span class="attr">  creationTimestamp:</span> <span class="string">"2021-11-15T05:36:28Z"</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">EnsureExists</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">standard</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"298"</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="number">3</span><span class="string">d1fb350-928d-4d53-a2eb-558358814839</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s.io/minikube-hostpath</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span><br></pre></td></tr></table></figure></p><p>StorageClass 对象代表某种可以被动态创建的存储类型。每一个 StorageClass 都会指定在动态创建 Volume 时需要使用的 provisioner 以及需要传递的参数。由用户来决定每一个 PVC 具体使用那种 StorageClass。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-aa9febdc8c5c0f00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The relationship between storage classes, persistent volume claims and dynamic volume provisioners"></p><h5 id="用-default-storage-class-动态创建-PV"><a href="#用-default-storage-class-动态创建-PV" class="headerlink" title="用 default storage class 动态创建 PV"></a>用 default storage class 动态创建 PV</h5><p>可以创建一个 PVC 对象并将其 <code>storageClassName</code> 条目设置为 <code>standard</code>，或者不指定任何 <code>storageClassName</code>，Kubernetes 会自动选择默认的 storage class。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data-default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure></p><p>创建和查看 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pvc.quiz-data-default.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data-default created</span><br><span class="line">$ kubectl get pvc quiz-data-default</span><br><span class="line">NAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">quiz-data-default   Bound    pvc-eac89776-b02b-<span class="number">49</span>c1-<span class="number">9878</span>-b50b9780bd3c   <span class="number">1</span>Gi        RWO            standard       <span class="number">47</span>s</span><br></pre></td></tr></table></figure></p><p>对应的 PV 会在 PVC 创建后自动生成和绑定。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                       STORAGECLASS   REASON   AGE</span><br><span class="line">pvc-eac89776-b02b-<span class="number">49</span>c1-<span class="number">9878</span>-b50b9780bd3c   <span class="number">1</span>Gi        RWO            Delete           Bound    default/quiz-data-default   standard                <span class="number">113</span>s</span><br></pre></td></tr></table></figure></p><h5 id="动态生成-PV-的生命周期"><a href="#动态生成-PV-的生命周期" class="headerlink" title="动态生成 PV 的生命周期"></a>动态生成 PV 的生命周期</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1c0aedb1f55632dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The lifecycle of dynamically provisioned persistent volumes, claims and the pods using them"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Pods-与底层存储技术的解耦&quot;&gt;&lt;a href=&quot;#Pods-与底层存储技术的解耦&quot; class=&quot;headerlink&quot; title=&quot;Pods 与底层存储技术的解耦&quot;&gt;&lt;/a&gt;Pods 与底层存储技术的解耦&lt;/h4&gt;&lt;p&gt;理想情况下，将应用部署到 Kuber
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Disk" scheme="https://rollingstarky.github.io/tags/Disk/"/>
    
      <category term="Storage" scheme="https://rollingstarky.github.io/tags/Storage/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Volume" scheme="https://rollingstarky.github.io/tags/Volume/"/>
    
      <category term="Persistent" scheme="https://rollingstarky.github.io/tags/Persistent/"/>
    
      <category term="NFS" scheme="https://rollingstarky.github.io/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 2nd 笔记——Type hints（类型标注）介绍</title>
    <link href="https://rollingstarky.github.io/2022/04/15/fluent-python-2nd-reading-notes-type-hints/"/>
    <id>https://rollingstarky.github.io/2022/04/15/fluent-python-2nd-reading-notes-type-hints/</id>
    <published>2022-04-14T16:00:00.000Z</published>
    <updated>2022-04-15T12:37:28.484Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://peps.python.org/pep-0484/" target="_blank" rel="noopener">PEP 484—Type Hints</a> 在 Python 中引入了显式的类型标注，可以为函数参数、返回值、变量等添加类型提示。主要目的在于帮助<strong>开发工具</strong>通过<strong>静态检查</strong>发现代码中的 Bug。</p><h4 id="gradual-typing"><a href="#gradual-typing" class="headerlink" title="gradual typing"></a>gradual typing</h4><p>PEP 484 引入的是一种 <em>gradual type system</em>（渐进式类型系统），支持同样类型系统的语言还有微软的 TypeScript、Google 的 Dart 等。该系统具有以下特征：</p><ul><li>可选的。默认情况下，类型检查器不应该警告没有标注类型的代码。当无法确认某个对象的类型时，假设其为 <code>Any</code> 类型</li><li>在运行时不捕获类型错误。Type hints 主要用来帮助类型检查器、linter 和 IDE 输出警告信息，不会在运行时阻止不匹配的类型传递给某个函数</li><li>对性能没有提升。理论上讲，类型标注提供的信息能够帮助解释器对生成的字节码进行优化。目前 Python 还没有相关的实现</li></ul><p><strong>类型标注在任何层面上都是可选的</strong>。<br>简单来说，用户可以选择任何一个自己感兴趣的参数或返回值进行类型标注，不用管其它的。在没有配置 IDE 进行严格检查的时候，不会有任何报错出现。<br>即便用户错误地标注了类型，对程序的运行也不会产生任何影响。最多只是 IDE 会有报错提示。</p><h5 id="gradual-typing-示例"><a href="#gradual-typing-示例" class="headerlink" title="gradual typing 示例"></a>gradual typing 示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># messages.py</span><br><span class="line">def show_count(count, word):</span><br><span class="line">    if count == 1:</span><br><span class="line">        return f&apos;1 &#123;word&#125;&apos;</span><br><span class="line">    count_str = str(count) if count else &apos;no&apos;</span><br><span class="line">    return f&apos;&#123;count_str&#125; &#123;word&#125;s&apos;</span><br><span class="line"></span><br><span class="line">print(show_count(1, &apos;dog&apos;))</span><br><span class="line"># =&gt; 1 dog</span><br><span class="line">print(show_count(2, &apos;dog&apos;))</span><br><span class="line"># =&gt; 2 dogs</span><br></pre></td></tr></table></figure><p>安装 <code>mypy</code> 类型检查工具：<code>pip install mypy</code>。</p><p>使用 <code>mypy</code> 命令对 <code>messages.py</code> 源代码进行类型检查，没有任何错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mypy messages.py</span><br><span class="line"><span class="function">Success: <span class="title">no</span> <span class="title">issues</span> <span class="title">found</span> <span class="title">in</span> 1 <span class="title">source</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure></p><p>只有当加上 <code>--disallow-untyped-defs</code> 选项的时候才会检查出错误（函数缺少类型标注）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-untyped-defs messages.py</span><br><span class="line"><span class="function">messages.py:1: <span class="title">error</span>: <span class="title">Function</span> <span class="title">is</span> <span class="title">missing</span> <span class="title">a</span> <span class="title">type</span> <span class="title">annotation</span></span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>修改一下检查的严格程度，使用 <code>--disallow-incomplete-defs</code> 选项，此时检查是通过的：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-incomplete-defs messages.py</span><br><span class="line"><span class="function">Success: <span class="title">no</span> <span class="title">issues</span> <span class="title">found</span> <span class="title">in</span> 1 <span class="title">source</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure></p><p>将函数 <code>show_count</code> 的签名改为 <code>show_count(count, word) -&gt; str</code>，只为返回值添加类型标注，再次进行检查：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ messages.py:<span class="number">1</span>: error: Function is missing a <span class="built_in">type</span> annotation <span class="keyword">for</span> one or <span class="built_in">more</span> arguments</span><br><span class="line">Found <span class="number">1</span> error <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure></p><p>即 <code>--disallow-incomplete-defs</code> 不会去管完全没有类型标注的函数，而是会确保，只要某个函数添加了类型标注，则其类型标注必须完整应用到该函数的所有参数和返回值。</p><p>假如将函数 <code>show_count</code> 的签名改为 <code>show_count(count: int, word: str) -&gt; int</code>，运行类型检查则会报出其他错误（返回值类型不匹配）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-incomplete-defs messages.py</span><br><span class="line"><span class="function">messages.py:3: <span class="title">error</span>: <span class="title">Incompatible</span> <span class="title">return</span> <span class="title">value</span> <span class="title">type</span> (<span class="title">got</span> "<span class="title">str</span>", <span class="title">expected</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">messages.py</span>:5: <span class="title">error</span>: <span class="title">Incompatible</span> <span class="title">return</span> <span class="title">value</span> <span class="title">type</span> (<span class="title">got</span> "<span class="title">str</span>", <span class="title">expected</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 2 <span class="title">errors</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>但<strong>程序的运行不会受任何影响</strong>：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python messages.py</span><br><span class="line"><span class="number">1</span> dog</span><br><span class="line"><span class="number">2</span> dogs</span><br></pre></td></tr></table></figure></p><p>即类型标注可以帮助 IDE 等工具对代码进行静态检查，在程序运行前发现可能的语法错误。但并不会对程序的运行时施加任何影响。<br>这就是为什么称之为 Gradual。即不具备任何强制性，可以在需要的时候逐步完善任何感兴趣的变量。但加不加标注，程序该怎么跑还是怎么跑。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-53e89b8bb492af92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Type checker in VIM"></p><h5 id="使用-None-作为默认值"><a href="#使用-None-作为默认值" class="headerlink" title="使用 None 作为默认值"></a>使用 <code>None</code> 作为默认值</h5><p>前面的 <code>messages.py</code> 实际上做的事情很简单，就是输出数量和名词。数量为 1 名词用单数，数量大于 1 名词就加 <code>s</code> 变复数。<br>但很多名词并不是直接加 <code>s</code> 就能成为复数形式，比如 <code>child</code> -&gt; <code>children</code>。因此代码可以优化为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_count</span><span class="params">(count: int, singular: str, plural: str = <span class="string">''</span>)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'1 <span class="subst">&#123;singular&#125;</span>'</span></span><br><span class="line">    count_str = str(count) <span class="keyword">if</span> count <span class="keyword">else</span> <span class="string">'no'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> plural:</span><br><span class="line">        plural = singular + <span class="string">'s'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;count_str&#125;</span> <span class="subst">&#123;plural&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">print(show_count(<span class="number">2</span>, <span class="string">'dog'</span>))</span><br><span class="line"><span class="comment"># =&gt; 2 dogs</span></span><br><span class="line">print(show_count(<span class="number">2</span>, <span class="string">'child'</span>, <span class="string">'children'</span>))</span><br><span class="line"><span class="comment"># =&gt; 2 children</span></span><br></pre></td></tr></table></figure></p><p>上面的代码可以很好的工作。函数中加了一个参数 <code>plural</code> 表示名词的复数形式，默认值是空字符串 <code>&#39;&#39;</code>。但从语义的角度看，默认值用 <code>None</code> 更符合一些。<br>即某个名词要么有特殊的复数形式，要么没有。但这会导致 <code>plural</code> 参数的类型声明不适合使用 <code>str</code>，因为其取值可以是 <code>None</code>，而 <code>None</code> 不属于 <code>str</code> 类型。</p><p>把 <code>show_count</code> 函数的签名改为如下形式即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_count</span><span class="params">(count: int, singular: str, plural: Optional[str] = None)</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>Optional[str]</code> 就表示该类型可以是 <code>str</code> 或者 <code>None</code>。<br>此外，默认值 <code>=None</code> 必须显式地写在声明里，否则 Python 运行时会将 <code>plural</code> 视为必须提供的参数。<br>在类型声明里注明了某个参数是 <code>Optional</code>，并不会真的将其变为可选参数。记住<strong>对于运行时而言，类型标注总是会被忽略掉</strong>。</p><h4 id="Types-are-defined-by-supported-operations"><a href="#Types-are-defined-by-supported-operations" class="headerlink" title="Types are defined by supported operations"></a>Types are defined by supported operations</h4><p>引用 PEP 483 中的定义，类型就是一组值的集合，这些值有一个共同的特点，就是一系列特定的函数能够应用到这些值上。即<strong>某种类型支持的一系列操作定义了该类型的特征</strong>。</p><p>比如下面的 <code>double</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>x</code> 参数的类型可以是数值类型（<code>int</code>、<code>complex</code>、<code>Fraction</code>、<code>numpy.uint32</code> 等），但也可能是某种序列类型（<code>str</code>、<code>tuple</code>、<code>list</code>、<code>array</code> 等）、N 维数组 <code>numpy.array</code> 甚至任何其他类型，只要该类型实现或继承了 <code>__mul__</code> 方法且接收 int 作为参数。</p><p>但是对于另一个 <code>double</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: abc.Sequence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>将 <code>x</code> 参数的类型声明为 <code>abc.Sequence</code>，此时使用 <code>mypy</code> 检查其类型声明会报出错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy double.py</span><br><span class="line"><span class="function">double.py:4: <span class="title">error</span>: <span class="title">Unsupported</span> <span class="title">operand</span> <span class="title">types</span> <span class="title">for</span> * ("<span class="title">Sequence</span>[<span class="title">Any</span>]" <span class="title">and</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>因为 <code>Sequence</code> 虚拟基类并没有实现或者继承 <code>__mul__</code> 方法，类型检查器认为 <code>x * 2</code> 是不支持的操作。但在实际运行时，上述代码支持 <code>x</code> 为 <code>str</code>、<code>tuple</code>、<code>list</code>、<code>array</code> 等等实现了 <code>Sequence</code> 的具体类型，运行不会有任何报错。<br>原因在于，运行时会忽略类型声明。且类型检查器只会关心显式声明的对象，比如 <code>abc.Sequence</code> 中有没有 <code>__mul__</code>。</p><p>这也是为什么在 Python 中，类型的定义就是其支持的操作。任何作为参数 <code>x</code> 传给 <code>double</code> 函数的对象，Python 运行时都会接受。它可能运行通过，也可能该对象实际并不支持 <code>* 2</code> 操作，报出 <code>TypeError</code>。</p><p>在 gradual type system 中，有两种不同的看待类型的角度：</p><ul><li>Duck typing：Smalltalk 发明的“鸭子类型”，Python、JavaScript、Ruby 等采用此方式。对象有类型，而变量（包括参数）是无类型的。在实践中，<strong>对象声明的类型是不重要的，关键在于该对象实际支持的操作</strong>。鸭子类型更加灵活，代价就是<strong>允许更多的错误出现在运行时</strong>。</li><li>Nominal typing：C++、Java、C# 等采用此方式。对象和变量都有类型。但<strong>对象只存在于运行时，而类型检查器只关心源代码</strong>中标记了类型的变量。比如 <code>Duck</code> 是 <code>Bird</code> 的子类，你可以将一个 <code>Duck</code> 对象绑定给标记为 <code>birdie: Bird</code> 的参数。但是在函数体中，类型检查器会认为 <code>birdie.quack()</code> 是非法的（<code>quack()</code> 是 <code>Duck</code> 类中实现的方法）。因为 <code>Bird</code> 类并没有提供 <code>quack()</code> 方法，即便实际的参数 <code>Duck</code> 对象已经实现了 <code>quack()</code>。Nominal typing 在静态检查时强制应用，<strong>类型检查器只是读取源代码，并不会执行任何一个代码片段</strong>。Nominal typing 更加严格，优势就是可以更早地发现某些 bug，比如在 build 阶段甚至代码刚输入到 IDE 中的时候。</li></ul><p>参考下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># birds.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">(Bird)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Quack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert</span><span class="params">(birdie)</span>:</span></span><br><span class="line">    birdie.quack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert_duck</span><span class="params">(birdie: Duck)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    birdie.quack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert_bird</span><span class="params">(birdie: Bird)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    birdie.quack()</span><br></pre></td></tr></table></figure></p><p><code>Duck</code> 是 <code>Bird</code> 的子类；<br><code>alert</code> 没有类型标注，会被类型检查器忽略；<br><code>alert_duck</code> 接收一个 <code>Duck</code> 类型的参数；<br><code>alert_bird</code> 接收 <code>Bird</code> 类型的参数。</p><p>用 <code>mypy</code> 检查上述代码会报出一个错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy birds.py</span><br><span class="line"><span class="function">birds.py:15: <span class="title">error</span>: "<span class="title">Bird</span>" <span class="title">has</span> <span class="title">no</span> <span class="title">attribute</span> "<span class="title">quack</span>"</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p><code>Bird</code> 类没有 <code>quack()</code> 方法，但函数体中却有对 <code>quack()</code> 方法的调用。</p><p>编写如下代码调用前面的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># daffy.py</span></span><br><span class="line"><span class="keyword">from</span> birds <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">daffy = Duck()</span><br><span class="line">alert(daffy)</span><br><span class="line">alert_duck(daffy)</span><br><span class="line">alert_bird(daffy)</span><br></pre></td></tr></table></figure></p><p>可以成功运行：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python daffy.py</span><br><span class="line">Quack</span><br><span class="line">Quack</span><br><span class="line">Quack</span><br></pre></td></tr></table></figure></p><p>还是那句重复了无数遍的话，在运行时，Python 并不关心声明的变量，它使用 duck typing，只关心实际传入的对象是不是支持某个操作。<br>因而某些时候即便静态类型检查报出了错误，代码依旧能成功运行。</p><p>但是对于下面的例子，静态检查就显得很有用了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># woody.py</span></span><br><span class="line"><span class="keyword">from</span> birds <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">woody = Bird()</span><br><span class="line">alert(woody)</span><br><span class="line">alert_duck(woody)</span><br><span class="line">alert_bird(woody)</span><br></pre></td></tr></table></figure></p><p>此时运行 <code>woody.py</code> 会报出 <code>AttributeError: &#39;Bird&#39; object has no attribute &#39;quack&#39;</code> 错误。因为实际传入的 <code>woody</code> 对象是 <code>Bird</code> 类的实例，它确实没有 <code>quack()</code> 方法。<br>有了静态检查，就可以在程序运行前发现此类错误。</p><p>上面的几个例子表明，<strong>duck typing 更灵活更加容易上手，但同时会允许不支持的操作在运行时触发错误；Nominal typing 会在运行时之前检测错误，但有些时候会阻止本可以运行的代码</strong>。<br>在实际的环境中，函数有可能非常臃肿，有可能 <code>birdie</code> 参数被传递给了更多函数，<code>birdie</code> 还有可能来自于很长的函数调用链，会使得运行时错误很难被精确定位到。类型检查器则会阻止很多这类错误在运行时发生。</p><h4 id="Type-hints-中用到的类型"><a href="#Type-hints-中用到的类型" class="headerlink" title="Type hints 中用到的类型"></a>Type hints 中用到的类型</h4><h5 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a><code>Any</code> 类型</h5><p>gradual type system 的基础就是 <code>Any</code> 类型，也被叫做动态类型（<em>dynamic type</em>）。<br>当类型检测器遇到如下未标注类型的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: abc.Sequence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>会将其视为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: Any)</span> -&gt; Any:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><code>Any</code> 类型支持所有可能的操作，参数 <code>n: Any</code> 可以接受任意类型的值。</p><h5 id="简单类型和类"><a href="#简单类型和类" class="headerlink" title="简单类型和类"></a>简单类型和类</h5><p>简单类型比如 <code>int</code>、<code>float</code>、<code>str</code>、<code>bytes</code> 可以直接用在类型标注中。<br>来自于标准库或者第三方库，以及用户自定义的类也可以作为类型标注的关键字。<br>虚拟基类在类型标注中也比较常用。</p><p>同时还要注意一个重要的原则：子类可以用在任何声明需要其父类的地方（<strong>Liskov Substitution Principle</strong>）。</p><h5 id="Optional-和-Union-类型"><a href="#Optional-和-Union-类型" class="headerlink" title="Optional 和 Union 类型"></a><code>Optional</code> 和 <code>Union</code> 类型</h5><p><code>Optional[str]</code> 实际上是 <code>Union[str, None]</code> 类型的简写形式，表示某个值可以是 <code>str</code> <strong>或者</strong> <code>None</code>。<br>在 Python3.10 中，可以用 <code>str | None</code> 代替 <code>Union[str, None]</code>。</p><p>下面是一个有可能返回 <code>str</code> 或者 <code>float</code> 类型的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_token</span><span class="params">(token: str)</span> -&gt; Union[str, float]:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> float(token)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></p><p><code>Union</code> 在相互之间不一致的类型中比较有用，比如 <code>Union[str, float]</code>。对于有兼容关系的类型比如 <code>Union[int, float]</code> 就不是很有必要，因为声明为 <code>float</code> 类型的参数也可以接收 <code>int</code> 类型的值。</p><h5 id="通用集合类型"><a href="#通用集合类型" class="headerlink" title="通用集合类型"></a>通用集合类型</h5><p>Python 中的大多数集合类型都是<strong>不均匀</strong>的。不均匀的意思就是，比如 <code>list</code> 类型的变量中可以同时存放多种不同类型的值。但是，这种做法通常是不够实用的。<br>通常用户将一系列对象保存至某个集合中，这些对象一般至少有一个共同的接口，以便用户稍后用一个函数对所有这些对象进行处理。</p><p>Generic types 可以在声明时加上一个类型参数。比如 <code>list</code> 可以通过参数化来控制自身存储的值的类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(text: str)</span> -&gt; list[str]:</span></span><br><span class="line">    <span class="keyword">return</span> text.upper().split()</span><br></pre></td></tr></table></figure></p><p>在 Python 版本不低于 3.9 时，上述代码表示 <code>tokenize</code> 函数会返回一个列表，列表中的每一项都是 <code>str</code> 类型。</p><p>类型标注 <code>stuff: list</code> 和 <code>stuf: list[Any]</code> 是等效的，都表示 <code>stuff</code> 这个列表可以同时包含任意类型的元素。</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p><strong>元组作为记录</strong><br>比如需要保存城市、人口和国家的值 <code>(&#39;Shanghai&#39;, 24.28, &#39;China&#39;)</code>，其类型标注可以写作 <code>tuple[str, float, str]</code>。</p><p><strong>有命名字段的元组</strong><br>建议使用 <code>typing.NamedTuple</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span><span class="params">(NamedTuple)</span>:</span></span><br><span class="line">    lat: float</span><br><span class="line">    lon: float</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(lat_lon: tuple[float, float])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    lat, lon = lat_lon</span><br><span class="line">    ns = <span class="string">'N'</span> <span class="keyword">if</span> lat &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'S'</span></span><br><span class="line">    ew = <span class="string">'E'</span> <span class="keyword">if</span> lon &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'W'</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;abs(lat):<span class="number">0.1</span>f&#125;</span>°<span class="subst">&#123;ns&#125;</span>, <span class="subst">&#123;abs(lon):<span class="number">0.1</span>f&#125;</span>°<span class="subst">&#123;ew&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">display(Coordinate(<span class="number">120.20</span>, <span class="number">30.26</span>))</span><br><span class="line"><span class="comment"># =&gt; 120.2°N, 30.2°E</span></span><br></pre></td></tr></table></figure></p><p><code>NamedTuple</code> 与 <code>tuple[float, float]</code> 兼容，因而 <code>Coordinate</code> 对象可以直接传递给 <code>display</code> 函数。</p><p><strong>元组作为不可变序列</strong><br>当需要将元组作为不可变列表使用时，类型标注需要指定一个单一的类型，后面跟上逗号和 <code>...</code>。<br>比如 <code>tuple[int, ...]</code> 表示一个元组包含未知数量的 <code>int</code> 类型的元素。<br><code>stuff: tuple[Any, ...]</code> 等同于 <code>stuff: tuple</code>，表示 <code>stuff</code> 对象可以包含未指定数量的任意类型的元素。</p><h5 id="Generic-mappings"><a href="#Generic-mappings" class="headerlink" title="Generic mappings"></a>Generic mappings</h5><p>Generic mapping 类型使用 <code>MappingType[KeyType, ValueType]</code> 形式的标注。比如内置的 <code>dict</code> 和其他 <code>collections</code>/<code>collections.abc</code> 库中的 Map 类型。</p><h5 id="Abstract-Base-Class"><a href="#Abstract-Base-Class" class="headerlink" title="Abstract Base Class"></a>Abstract Base Class</h5><p>理想情况下，一个函数应该接收<strong>虚拟类型的参数</strong>，不使用某个具体的类型。<br>比如下面的函数签名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Mapping</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2hex</span><span class="params">(name: str, color_map: Mapping[str, int])</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>abc.Mapping</code> 作为函数参数的类型标注，能够允许调用者传入 <code>dict</code>、<code>defaultdict.ChainMap</code>、<code>UserDict</code> 子类或者任意 <code>Mapping</code> 的子类型作为参数。</p><p>相反的，使用下面的函数签名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2hex</span><span class="params">(name: str, color_map: dict[str, int])</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>会使得 <code>color_map</code> 参数必须接收 <code>dict</code> 或者 <code>defaultDict</code>、<code>OrderedDict</code> 等 <code>dict</code> 的子类型。<code>collections.UserDict</code> 的子类就无法通过 <code>color_map</code> 的类型检查。因为 <code>UserDict</code> 并不是 <code>dict</code> 类型的子类，它俩是兄弟关系，都是 <code>abc.MutableMapping</code> 的子类。<br>因此，在实践中最好使用 <code>abc.Mapping</code> 或者 <code>abc.MutableMapping</code> 作为参数的类型标注。</p><p>有个法则叫做 <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener"><strong>Postel’s law</strong></a>，也被称为<strong>鲁棒性原则</strong>。简单来说就是<strong>对发送的内容保持谨慎，对接收的内容保持自由</strong>。</p><p>拿列表举例来说，在标注函数的返回值类型时，最好使用 <code>list[str]</code> 这种具体的类型；在标注函数的参数时，则使用 <code>Sequence</code> 或 <code>Iterable</code> 这类抽象的集合类型。</p><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">FromTo = tuple[str, str]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_replace</span><span class="params">(text: str, changes: Iterable[FromTo])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">for</span> from_, to <span class="keyword">in</span> changes:</span><br><span class="line">        text = text.replace(from_, to)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line">l33t = [(<span class="string">'a'</span>, <span class="string">'4'</span>), (<span class="string">'e'</span>, <span class="string">'3'</span>), (<span class="string">'i'</span>, <span class="string">'1'</span>), (<span class="string">'o'</span>, <span class="string">'0'</span>)]</span><br><span class="line">text = <span class="string">'mad skilled noob powned leet'</span></span><br><span class="line">print(zip_replace(text, l33t))</span><br><span class="line"><span class="comment"># =&gt; m4d sk1ll3d n00b p0wn3d l33t</span></span><br></pre></td></tr></table></figure><p>其中 <code>FromTo</code> 是 <em>type alias</em>。</p><h5 id="参数化通用类型与-TypeVar"><a href="#参数化通用类型与-TypeVar" class="headerlink" title="参数化通用类型与 TypeVar"></a>参数化通用类型与 <code>TypeVar</code></h5><p>参数化通用类型是一种通用类型，比如 <code>list[T]</code> 中的 <code>T</code> 可以绑定任意指定类型，但是之后再次出现的 <code>T</code> 则会表示同样的类型。</p><p>参考下面的 <code>sample.py</code> 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sequence</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(population: Sequence[T], size: int)</span> -&gt; list[T]:</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'size must be &gt;= 1'</span>)</span><br><span class="line">    result = list(population)</span><br><span class="line">    shuffle(result)</span><br><span class="line">    <span class="keyword">return</span> result[:size]</span><br></pre></td></tr></table></figure></p><p>假如传给 <code>sample</code> 函数的参数类型是 <code>tuple[int, ...]</code>，该参数与 <code>Sequence[int]</code> 通用，因此类型参数 <code>T</code> 就代表 <code>int</code>，从而返回值类型变成 <code>list[int]</code>。<br>假如传入的参数类型是 <code>str</code>，与 <code>Sequence[str]</code> 通用，则 <code>T</code> 代表 <code>str</code>，因而返回值类型变成 <code>list[str]</code>。</p><p><strong>Restricted <code>TypeVar</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">NumberT = TypeVar(<span class="string">'NumberT'</span>, float, Decimal, Fraction)</span><br></pre></td></tr></table></figure></p><p>表示类型参数 <code>T</code> 只能是声明中提到的有限的几个类型之一。</p><p><strong>Bounded <code>TypeVar</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Hashable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">HashableT = TypeVar(<span class="string">'HashableT'</span>, bound=Hashable)</span><br></pre></td></tr></table></figure></p><p>表示类型参数 <code>T</code> 只能是 <code>Hashable</code> 类型或者其子类型之一。</p><h5 id="Static-Protocols"><a href="#Static-Protocols" class="headerlink" title="Static Protocols"></a>Static Protocols</h5><p><code>Protocol</code> 类型与 Go 中的接口很相似。它的定义中会指定一个或多个方法，类型检查器则会确认对应的类型是否实现了这些方法。</p><p>比如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Protocol, Any</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupportLessThan</span><span class="params">(Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other: Any)</span> -&gt; bool:</span> ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LT = TypeVar(<span class="string">'LT'</span>, bound=SupportLessThan)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(series: Iterable[LT], length: int)</span> -&gt; list[LT]:</span></span><br><span class="line">    ordered = sorted(series, reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> ordered[:length]</span><br><span class="line"></span><br><span class="line">print(top([<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>], <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; [7, 6, 5]</span></span><br><span class="line">l = <span class="string">'mango pear apple kiwi banana'</span>.split()</span><br><span class="line">print(top(l, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; ['pear', 'mango', 'kiwi']</span></span><br><span class="line">l2 = [(len(s), s) <span class="keyword">for</span> s <span class="keyword">in</span> l]</span><br><span class="line">print(top(l2, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; [(6, 'banana'), (5, 'mango'), (5, 'apple')]</span></span><br></pre></td></tr></table></figure></p><p>如果 <code>top</code> 函数中 <code>series</code> 参数的类型标注是 <code>Iterable[T]</code>，没有任何其他限制，意味着该类型参数 <code>T</code> 可以是任意类型。但将 <code>Iterable[Any]</code> 传给函数体中的 <code>sorted</code> 函数，并不总是成立，必须确保 <code>Iterable[Any]</code> 是可以被直接排序的类型。<br>因而需要先创建一个 <code>SupportLessThan</code> protocol 指定 <code>__lt__</code> 方法，再用该 protocol 来绑定类型参数 <code>LT</code>，从而限制 <code>series</code> 参数必须为可迭代对象，且其中的元素都实现了 <code>__lt__</code> 方法，使得传入的 <code>series</code> 参数支持被 <code>sorted</code> 直接排序。</p><p>当类型 <code>T</code> 实现了 protocol <code>P</code> 中定义的所有方法时，则说明该类型 <code>T</code> 与 protocol <code>P</code> 通用。</p><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p><code>Callable</code> 主要用于标注高阶函数中作为参数或者返回值的函数对象。其格式为 <code>Callable[[ParamType1, ParamType2], ReturnType]</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/" target="_blank" rel="noopener">Fluent Python, 2nd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://peps.python.org/pep-0484/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PEP 484—Type Hints&lt;/a&gt; 在 Python 中引入了显式的类型标注，可以为函数参数、返回值、变量等添加类
      
    
    </summary>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="List" scheme="https://rollingstarky.github.io/tags/List/"/>
    
      <category term="IDE" scheme="https://rollingstarky.github.io/tags/IDE/"/>
    
      <category term="Generic" scheme="https://rollingstarky.github.io/tags/Generic/"/>
    
      <category term="Tuple" scheme="https://rollingstarky.github.io/tags/Tuple/"/>
    
      <category term="Mapping" scheme="https://rollingstarky.github.io/tags/Mapping/"/>
    
      <category term="DuckTyping" scheme="https://rollingstarky.github.io/tags/DuckTyping/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 通过 Services 对象暴露 Pod 中的服务</title>
    <link href="https://rollingstarky.github.io/2022/04/12/kubernetes-in-action-reading-notes-exposing-pods-with-services/"/>
    <id>https://rollingstarky.github.io/2022/04/12/kubernetes-in-action-reading-notes-exposing-pods-with-services/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-11T16:30:28.529Z</updated>
    
    <content type="html"><![CDATA[<p>不同于只运行某个提供特定服务的单一 Pod，现在人们通常会以副本的形式部署多个 Pod 实例，以便工作负载能够均匀地分发到不同的集群节点上。<br>这也意味着同一个 Pod 的所有副本都提供相同的服务，且能够通过一个单一的地址访问。Kubernetes 中的 Services 对象就负责实现这部分功能。</p><h5 id="Pods-间如何通信"><a href="#Pods-间如何通信" class="headerlink" title="Pods 间如何通信"></a>Pods 间如何通信</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1f0d6948e37665b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods communicate via their own computer network"></p><p>每个 Pod 都拥有自己的网络接口和 IP 地址。集群中的所有 Pod 通过一个私有的 Flat network 相互通信，该 Flat network 实际上是一个定义在实体网络之上的虚拟网络层。<br>Pod 中的容器可以通过这个虚拟网络层传输数据，无需进行 NAT 转换，就像是局域网中接入到同一个交换机上的计算机一样。<br>对于应用来说，Node 之间实际的网络拓扑是不重要的。</p><h5 id="为什么需要-Service"><a href="#为什么需要-Service" class="headerlink" title="为什么需要 Service"></a>为什么需要 Service</h5><p>如果某个 Pod 中的应用需要连接其他 Pod 中的另一个应用，则它需要知道目标 Pod 的访问地址，这是显而易见的。实际上实现起来要复杂的多：</p><ul><li>Pods 是有生命周期的。一个 Pod 可以在任意时间被销毁和替代（IP 地址会变）</li><li>Pod 只有在分配给某个 Node 后才获取到 IP 地址，无法提前知道</li><li>在水平扩展中，多个 Pod 副本提供同样的服务，每个副本都有自己的 IP 地址。当另一个 Pod 访问所有这些副本时，就需要能够用一个单一的 IP 或 DNS 名称连接到负载均衡器，再通过负载均衡器在所有的副本间分担工作负载</li></ul><h4 id="Service-介绍"><a href="#Service-介绍" class="headerlink" title="Service 介绍"></a>Service 介绍</h4><p>Kubernetes Service 对象可以为一系列提供同一服务的 Pod 集合，绑定一个单一、稳定的访问点。在 Service 的生命周期里，其 IP 地址稳定不变。客户端通过该 IP 地址创建网络连接，这些请求之后再被转发给后端提供服务的 Pod。<br>简单来说，Service 就是放置在 Pods 前面的负载均衡器。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6be048f6ad064c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing pods with Service objects"></p><h5 id="Pod-和-Service-如何组合在一起"><a href="#Pod-和-Service-如何组合在一起" class="headerlink" title="Pod 和 Service 如何组合在一起"></a>Pod 和 Service 如何组合在一起</h5><p>Services 通过 <strong>label</strong> 和 <strong>label selector</strong> 机制找到对应的 Pods。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-008ee472838a47ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Label selectors determine which pods are part of the Service"></p><h4 id="创建和更新-Service"><a href="#创建和更新-Service" class="headerlink" title="创建和更新 Service"></a>创建和更新 Service</h4><p><strong>PS</strong>：作者的示例代码可以从其 Github <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition" target="_blank" rel="noopener">kubernetes-in-action-2nd-edition</a> 处下载，Service 部分的代码位于 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter11" target="_blank" rel="noopener">Chapter11</a>。<br>在创建 Service 之前，可以先进入到 Chapter11 路径下，运行 <code>kubectl apply -f SETUP/ --recursive</code> 命令，创建需要的 Pods。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">quiz           <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">001</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">002</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">003</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-canary   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br></pre></td></tr></table></figure></p><p>Kubernetes 支持如下几种 Service 类型：<code>ClusterIP</code>、<code>NodePort</code>、<code>LoadBalancer</code> 和 <code>ExternalName</code>。<br>ClusterIP 是默认的类型，仅用于集群内部通信。</p><p><strong>通过 YAML 清单文件创建 Service</strong><br><code>quote</code> Service 最小版本的清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quote</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">quote</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8e1ccb57edab4766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The quote service and the pods that it forwards traffic to"></p><p><strong>通过 kubectl expose 命令创建 Service</strong><br><code>kubectl expose pod quiz --name quiz</code></p><p><strong>获取 Services 列表</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc -o wide</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE   SELECTOR</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">8080</span>/TCP   <span class="number">45</span>s   app=quiz,rel=stable</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP     <span class="number">62</span>s   app=quote</span><br></pre></td></tr></table></figure></p><p><strong>修改 Service 的 label selector</strong><br><code>kubectl set selector service quiz app=quiz</code></p><p><strong>修改 Service 暴露的端口</strong><br>可以运行 <code>kubectl edit svc quiz</code> 命令编辑清单文件，将 <code>port</code> 字段修改为 <code>80</code>，保存退出即可。</p><h4 id="访问集群内部的-Services"><a href="#访问集群内部的-Services" class="headerlink" title="访问集群内部的 Services"></a>访问集群内部的 Services</h4><p>前面创建的 <code>ClusterIP</code> 类型的 Service 只支持集群内部访问，可以 <code>ssh</code> 到任意一个 Node 或者 Pod 上来测试其连通性。</p><h5 id="从-Pods-连接-Services"><a href="#从-Pods-连接-Services" class="headerlink" title="从 Pods 连接 Services"></a>从 Pods 连接 Services</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME           READY   STATUS    RESTARTS      AGE</span><br><span class="line">quiz           <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">001</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">002</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">003</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-canary   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">26</span>h</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">26</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl exec -it quote-<span class="number">001</span> -c nginx -- sh</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span></span><br><span class="line">This is the quiz service running <span class="keyword">in</span> pod quiz</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">002</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">002</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-canary on node minikube</span><br></pre></td></tr></table></figure><h5 id="Services-的-DNS-解析"><a href="#Services-的-DNS-解析" class="headerlink" title="Services 的 DNS 解析"></a>Services 的 DNS 解析</h5><p>Kubernetes 有一个内部的 DNS 服务器组件，供集群中所有的 Pods 使用。允许通过 Service 的名称解析其 ClusterIP 地址。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # curl quiz</span><br><span class="line">This is the quiz service running <span class="keyword">in</span> pod quiz</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-canary on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br></pre></td></tr></table></figure></p><h5 id="在-Pod-中使用-Services"><a href="#在-Pod-中使用-Services" class="headerlink" title="在 Pod 中使用 Services"></a>在 Pod 中使用 Services</h5><p>可以参考如下 YAML 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-003</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    rel:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.5</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">QUOTE_URL</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">http://quote/quote</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">QUIZ_URL</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">http://quiz</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>完整的源代码参考 Chapter11 路径下的 <code>kiada-stable-and-canary.yaml</code> 文件。<br>运行 <code>kubectl apply -f kiada-stable-and-canary.yaml</code> 命令应用该清单文件。<br>所有容器成功运行后，运行 <code>kubectl port-forward</code> 命令启用本地端口转发：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward kiada-<span class="number">001</span> <span class="number">8080</span> <span class="number">8443</span></span><br><span class="line">Forwarding from <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8080</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding from [::<span class="number">1</span>]:<span class="number">8080</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding from <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8443</span> -&gt; <span class="number">8443</span></span><br><span class="line">Forwarding from [::<span class="number">1</span>]:<span class="number">8443</span> -&gt; <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>此时打开浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 或 <a href="https://localhost:8443" target="_blank" rel="noopener">https://localhost:8443</a> 即可进入应用页面：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6fbdb8cb8e3083aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kiada App"></p><h4 id="向集群外部暴露服务"><a href="#向集群外部暴露服务" class="headerlink" title="向集群外部暴露服务"></a>向集群外部暴露服务</h4><p>为了令某个 Service 能够被外部世界访问，可以采取如下几种措施：</p><ul><li>为 Node 分配一个额外的 IP，并将其设置为 Service 的 <code>externalIP</code></li><li>将 Service 的类型配置为 <code>NodePort</code>，通过 Node 端口访问该服务</li><li>创建 <code>LoadBalancer</code> 类型的 Service 对象</li><li>Ingress 对象</li></ul><p>其中第一种方式会为 Service 对象的 <code>spec.externalIPs</code> 字段指定一个额外的 IP，这种方式并不常用。<br>更常见的方式是将 Service 类型设置为 <code>NodePort</code>。Kubernetes 会令该 Service 能够通过所有 Node 节点上的特定端口访问。通常还需要用户配置一个外部的负载均衡器负责将客户端流量转发到这些 Node 端口。<br>不同于 <code>NodePort</code> 一般需要手动配置负载均衡，Kubernetes 还支持自动完成类似搭建过程，只需要用户指定 Service 的类型为 <code>LoadBalancer</code>。但并不是所有环境下的集群都支持这样做，因为负载均衡的创建依赖特定的云服务供应商。<br>最后一种方式则是通过 <code>Ingress</code> 对象实现服务对外部的开放，其具体实现机制依赖于底层的 ingress 控制器。</p><h5 id="NodePort-Service"><a href="#NodePort-Service" class="headerlink" title="NodePort Service"></a>NodePort Service</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6e512c35866a7bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing pods through a NodePort service"></p><p>同 <code>ClusterIP</code> 类似，<code>NodePort</code> Service 支持通过内部的 cluster IP 访问。除此之外，它还可以通过任意一个 Node 的特定端口来访问。<br>最终由哪一个 Node 为客户端提供连接是不重要的，因为每一个 Node 都总是会将客户端请求转发给 Service 背后的任意 Pod，不管这个 Pod 是否运行在同一个 Node 上。<br>即 Node A 的端口接收到客户端请求，它可能会将该请求转发给 Node A 上运行的 Pod，也可能转发给 Node B 上运行的 Pod。</p><p><strong>创建 NodePort Service</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>上面的清单文件中共有 6 个 port，可以参考如下截图理解各个 port 的不同含义：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d53c91af970fdc7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing multiple ports through with a NodePort service"></p><p><strong>查看 NodePort Service</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">kiada        NodePort    <span class="number">10</span>.<span class="number">103</span>.<span class="number">96</span>.<span class="number">75</span>     &lt;none&gt;        <span class="number">80</span>:<span class="number">30080</span>/TCP,<span class="number">443</span>:<span class="number">30443</span>/TCP   <span class="number">6</span>s</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">80</span>/TCP                       <span class="number">28</span>h</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP                       <span class="number">28</span>h</span><br></pre></td></tr></table></figure></p><p><strong>访问 NodePort Service</strong><br>访问 <code>NodePort</code> Service 不仅仅需要知道端口号，还必须先获取到 Node 的 IP 地址。<br>可以使用 <code>kubectl get nodes -o wide</code> 命令查看 Node 的 IP 地址（<code>INTERNAL-IP</code> 和 <code>EXTERNAL-IP</code>）。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME       STATUS   ROLES                  AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION                   CONTAINER-RUNTIME</span><br><span class="line">minikube   Ready    control-plane,master   <span class="number">144</span>d   v1.<span class="number">22</span>.<span class="number">3</span>   <span class="number">192</span>.<span class="number">168</span>.<span class="number">49</span>.<span class="number">2</span>   &lt;none&gt;        Ubuntu <span class="number">20</span>.<span class="number">04</span>.<span class="number">2</span> LTS   <span class="number">5</span>.<span class="number">4</span>.<span class="number">72</span>-microsoft-standard-WSL2   docker://<span class="number">20</span>.<span class="number">10</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>此时在集群内部，则可以使用以下几种 IP 端口组合来访问 Kiada 应用：</p><ul><li><code>10.103.96.75:80</code>：cluster IP 和内部端口</li><li><code>192.168.49.2:30080</code>：Node IP 和 Node 端口</li></ul><p>因为是 Minikube 单机模拟的集群环境，只有一个 Node 可以使用。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="number">192</span>.<span class="number">168</span>.<span class="number">49</span>.<span class="number">2</span>:<span class="number">30080</span></span><br><span class="line">KUBERNETES <span class="keyword">IN</span> ACTION DEMO APPLICATION v0.<span class="number">5</span></span><br><span class="line"></span><br><span class="line">==== TIP OF THE MINUTE</span><br><span class="line">You can use the `jq` tool to <span class="built_in">print</span> out the value of a pod’s `phase` field like this: `kubectl get po kiada -o json | jq .status.phase`.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==== POP QUIZ</span><br><span class="line">Which of the following statements is correct?</span><br><span class="line"><span class="number">0</span>) When the readiness probe fails, the container is restarted.</span><br><span class="line"><span class="number">1</span>) When the liveness probe fails, the container is restarted.</span><br><span class="line"><span class="number">2</span>) Containers without a readiness probe are never restarted.</span><br><span class="line"><span class="number">3</span>) Containers without a liveness probe are never restarted.</span><br><span class="line"></span><br><span class="line">Submit your answer to /question/<span class="number">6</span>/answers/&lt;index of answer&gt; using the POST method.</span><br></pre></td></tr></table></figure></p><h5 id="LoadBalancer-Service"><a href="#LoadBalancer-Service" class="headerlink" title="LoadBalancer Service"></a>LoadBalancer Service</h5><p><code>LoadBalancer</code> 类型的 Service 实际上是 <code>NodePort</code> 类型的扩展。其基本配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>与前面 <code>NodePort</code> Service 的配置几乎完全一致，只是服务类型由 <code>NodePort</code> 改为了 <code>LoadBalancer</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-25f28cd7f42b3535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing a LoadBalancer service"></p><h4 id="external-traffic-policy"><a href="#external-traffic-policy" class="headerlink" title="external traffic policy"></a>external traffic policy</h4><p>任何通过 NodePort 的外部客户端连接，不管是直接访问 Node 端口还是通过 LoadBalancer 间接访问 Node 端口，客户端连接都有可能会被转发给另一个 Node 上的 Pod。即接收客户端连接的 Node 和执行任务的 Pod 所在的 Node 可能不是同一个。<br>在这种情况下，就意味着网络路径上多了一次跳转。</p><p>此外，在上述情况下，转发连接时还需要将 source IP 替换成一开始接收客户端连接的 Node 的 IP。这会导致 Pod 中运行的应用无法看到此网络连接的初始来源，即无法在其 access log 中记录真实的客户端地址。</p><h5 id="Local-external-traffic-policy-的优劣"><a href="#Local-external-traffic-policy-的优劣" class="headerlink" title="Local external traffic policy 的优劣"></a>Local external traffic policy 的优劣</h5><p>为了解决上述问题，可以选择阻止 Node 将客户端连接转发给运行在其他 Node 上的 Pod。即访问 Node 的外部连接最终只会被同一个 Node 上的 Pod 接收到。具体方法是将 Service 对象 <code>spec</code> 字段下的 <code>externalTrafficPolicy</code> 字段改为 <code>Local</code>。</p><p>但上述配置同时会引发其他问题。<br>第一，如果接收到外部连接的 Node 上并没有 Pods 在运行，则该连接会卡住。因此必须确保负载均衡器只会将外部连接转发给有 Pod 运行的 Node，可以通过令负载均衡器持续检测 <code>healthCheckNodePort</code> 来实现。<br>第二，external traffic policy 设置为 <code>Local</code> 会导致 Pods 间的负载不够均衡。LoadBalancer 均匀地分发外部连接给 Nodes，Node 再将连接转发到自身运行的 Pods 上。但是每个 Node 实际上运行着不同数量的 Pods，不能跨 Node 转发就意味着，在每个 Node 接收等量连接的前提下，有些 Node 上的 Pods 较少，则这些 Pods 平均要承担的负载就更多。</p><p><code>externalTrafficPolicy</code> 设置为 <code>Cluster</code> 与 <code>Local</code> 的区别可以参考下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-c53452efec578e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Understanding the two external traffic policies for NodePort and LoadBalancer services"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不同于只运行某个提供特定服务的单一 Pod，现在人们通常会以副本的形式部署多个 Pod 实例，以便工作负载能够均匀地分发到不同的集群节点上。&lt;br&gt;这也意味着同一个 Pod 的所有副本都提供相同的服务，且能够通过一个单一的地址访问。Kubernetes 中的 Service
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Cloud" scheme="https://rollingstarky.github.io/tags/Cloud/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="LoadBalancer" scheme="https://rollingstarky.github.io/tags/LoadBalancer/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.10 新特性 —— 结构化模式匹配（Structural Pattern Match）详解</title>
    <link href="https://rollingstarky.github.io/2022/04/02/python-3-10-new-features-structural-pattern-match/"/>
    <id>https://rollingstarky.github.io/2022/04/02/python-3-10-new-features-structural-pattern-match/</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-02T12:43:43.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><p>众所周知，Python 中是没有类似 <code>switch-case</code> 结构的语法的。但是自从 3.10 版本发布以后，这种说法就已经成为历史了。</p><p>Java 中的 <code>switch</code> 语句类似如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                var option = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 1."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 2."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 3."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(<span class="string">"Sorry you chose an invalid option."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来就像是另一种形式的 <code>if-else</code> 语句。以某个变量值作为判断条件，根据不同的判断结果执行对应的语句，最终形成一种流程上的分支结构。<br>这也许是 Python 不去实现它的依据（借口）之一？都已经有了 <code>if-else</code> 可以足够轻松地完成同样的事情。</p><blockquote><p>There should be one– and preferably only one –obvious way to do it.</p></blockquote><h5 id="字典映射"><a href="#字典映射" class="headerlink" title="字典映射"></a>字典映射</h5><p>在模式匹配出现之前，对于分支相当多的判断语句，Python 建议通过<strong>字典映射</strong>（dictionary mapping）来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_map</span><span class="params">(option)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 1.'</span>),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 2.'</span>),</span><br><span class="line">            <span class="number">3</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 3.'</span>)</span><br><span class="line">            &#125;.get(option, <span class="keyword">lambda</span>: print(<span class="string">'Sorry you chose an invalid option.'</span>))</span><br><span class="line"></span><br><span class="line">function_map(<span class="number">3</span>)()</span><br></pre></td></tr></table></figure></p><p>借助字典这种数据结构，以匹配条件作为键值，一一对应匹配后需要执行的命令。将 <code>switch</code> 结构中的条件判断转化为对字典键值的搜索匹配。</p><h4 id="Pattern-Match"><a href="#Pattern-Match" class="headerlink" title="Pattern Match"></a>Pattern Match</h4><p>用模式匹配实现 <code>switch-case</code> 语法，从形式上看就直观了很多：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">option = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">match option:</span><br><span class="line">    case <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 1."</span>)</span><br><span class="line">    case <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 2."</span>)</span><br><span class="line">    case <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 3."</span>)</span><br><span class="line">    case _:</span><br><span class="line">        print(<span class="string">"You chose an invalid option."</span>)</span><br></pre></td></tr></table></figure></p><p>实际上模式匹配不只有创建流程上的分支结构这一种功能，它的作用可以比单纯的 <code>switch-case</code> 语法强大的多。</p><p>模式匹配可以算是一种历史悠久的编程技巧了，经常可以在函数式编程语言中见到。比较有代表性的语言比如 Haskell。相对年轻的语言比如 Rust 也引入了功能强大的模式匹配语法。<br>模式匹配其实可以拆成两部分来理解：匹配和模式。<br>匹配部分可以发挥类似于 <code>if-else</code> 和 <code>switch</code> 等条件判断语句的作用，生成一种分支结构；模式则定义了特定的规则即匹配的具体条件。更进一步的，还会对匹配到的对象进行<strong>解构</strong>（destructuring）或者说<strong>拆包</strong>（unpacking）。</p><p>以不同于模式匹配的正则表达式来说：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">source_str = <span class="string">'cats are cute'</span></span><br><span class="line">pattern = re.compile(<span class="string">'(.*) are (.*)'</span>)</span><br><span class="line"></span><br><span class="line">matched = re.match(pattern, source_str)</span><br><span class="line">print(matched.groups())</span><br><span class="line"><span class="comment"># =&gt; ('cats', 'cute')</span></span><br></pre></td></tr></table></figure></p><p>正则表达式规则中的 <code>(.*)</code> 分别匹配到源字符串中的 <code>cats</code> 和 <code>cute</code>，与此同时，还把这两个匹配项提取了出来。</p><p>而模式匹配相对来说，则不仅仅能够匹配和提取 <code>cats</code>、<code>cute</code> 等字符串类型，还能够匹配更复杂类型的对象，同时对匹配到的对象进行拆包操作。</p><p>比如下面的代码就对类型为元组的对象进行了匹配和拆包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_person</span><span class="params">(person)</span>:</span></span><br><span class="line">    match person:</span><br><span class="line">        case (name, <span class="string">'M'</span>, age):</span><br><span class="line">            print(<span class="string">f'He is <span class="subst">&#123;name&#125;</span>, aged <span class="subst">&#123;age&#125;</span>.'</span>)</span><br><span class="line">        case (name, <span class="string">'F'</span>, age):</span><br><span class="line">            print(<span class="string">f'She is <span class="subst">&#123;name&#125;</span>, aged <span class="subst">&#123;age&#125;</span>.'</span>)</span><br><span class="line">        case (name,):</span><br><span class="line">            print(<span class="string">f'We only know the name is <span class="subst">&#123;name&#125;</span>, others are secrets.'</span>)</span><br><span class="line"></span><br><span class="line">person_A = (<span class="string">'John'</span>, <span class="string">'M'</span>, <span class="number">20</span>)</span><br><span class="line">person_B = (<span class="string">'Jenny'</span>, <span class="string">'F'</span>, <span class="number">18</span>)</span><br><span class="line">person_C = (<span class="string">'Lily'</span>,)</span><br><span class="line"></span><br><span class="line">match_person(person_A)</span><br><span class="line"><span class="comment"># =&gt; He is John, aged 20.</span></span><br><span class="line">match_person(person_B)</span><br><span class="line"><span class="comment"># =&gt; She is Jenny, aged 18.</span></span><br><span class="line">match_person(person_C)</span><br><span class="line"><span class="comment"># =&gt; We only know the name is Lily, others are secrets.</span></span><br></pre></td></tr></table></figure></p><p><code>match</code> 关键字后面被匹配的对象，支持很多种复杂的类型。对应的 <code>case</code> 关键字后面的模式也同样灵活：</p><ul><li>列表或元组，如 <code>(name, 18)</code></li><li>字典，如 <code>{&quot;name&quot;: name, &quot;age&quot;: 18}</code></li><li>使用 <code>*</code> 匹配列表中的剩余部分，如 <code>[first, *rest]</code></li><li>使用 <code>**</code> 匹配字典中的剩余部分</li><li>匹配对象和对象的属性</li><li>在模式中可以使用 <code>|</code> 逻辑或操作</li></ul><h4 id="模式匹配应用实例"><a href="#模式匹配应用实例" class="headerlink" title="模式匹配应用实例"></a>模式匹配应用实例</h4><p>创建一个 Python 程序，模拟交互式命令行的行为。</p><h5 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    match command:</span><br><span class="line">        case <span class="string">"quit"</span>:</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case <span class="string">"reset"</span>:</span><br><span class="line">            print(<span class="string">"Resetting the system."</span>)</span><br><span class="line">        case other:</span><br><span class="line">            print(<span class="string">f"Unknown command: <span class="subst">&#123;other!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command = input(<span class="string">"$ "</span>)</span><br><span class="line">        run_command(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果如下：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ reset</span><br><span class="line">Resetting the system.</span><br><span class="line">$ abcdefg</span><br><span class="line">Unknown command: 'abcdefg'.</span><br><span class="line">$ quit</span><br><span class="line">Quitting the program.</span><br></pre></td></tr></table></figure></p><h5 id="匹配列表"><a href="#匹配列表" class="headerlink" title="匹配列表"></a>匹配列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: str)</span>:</span></span><br><span class="line">    match command.split():</span><br><span class="line">        case [<span class="string">"load"</span>, filename]:</span><br><span class="line">            print(<span class="string">f"Loading file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case [<span class="string">"save"</span>, filename]:</span><br><span class="line">            print(<span class="string">f"Saving to file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case [<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>]:</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case _:</span><br><span class="line">            print(<span class="string">f"Unkown command: <span class="subst">&#123;command!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command = input(<span class="string">"$ "</span>)</span><br><span class="line">        run_command(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ load input_data.txt</span><br><span class="line">Loading file: input_data.txt.</span><br><span class="line">$ save output_data.txt</span><br><span class="line">Saving to file: output_data.txt.</span><br><span class="line">$ load input_data.txt output_data.txt</span><br><span class="line">Unkown command: 'load input_data.txt output_data.txt'.</span><br><span class="line">$ bye</span><br><span class="line">Quitting the program.</span><br></pre></td></tr></table></figure></p><h5 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>:</span></span><br><span class="line">    command: str</span><br><span class="line">    arguments: List[str]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: Command)</span>:</span></span><br><span class="line">    match command:</span><br><span class="line">        case Command(command=<span class="string">"load"</span>, arguments=[filename]):</span><br><span class="line">            print(<span class="string">f"Loading file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case Command(command=<span class="string">"save"</span>, arguments=[filename]):</span><br><span class="line">            print(<span class="string">f"Saving to file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case Command(command=<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>, arguments=[<span class="string">"--force"</span> | <span class="string">"-f"</span>]):</span><br><span class="line">            print(<span class="string">"Sending SIGTERM and quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case Command(command=<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>):</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case _:</span><br><span class="line">            print(<span class="string">f"Unknown command: <span class="subst">&#123;command!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command, *arguments = shlex.split(input(<span class="string">"$ "</span>))</span><br><span class="line">        run_command(Command(command, arguments))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">not</span> a command</span><br><span class="line">Unknown command: Command(command='<span class="keyword">not</span>', arguments=['a', 'command']).</span><br><span class="line">$ load input_data.txt</span><br><span class="line">Loading file: input_data.txt.</span><br><span class="line">$ save output_data.txt</span><br><span class="line">Saving to file: output_data.txt.</span><br><span class="line">$ <span class="keyword">exit</span> -f</span><br><span class="line">Sending SIGTERM and quitting the program.</span><br></pre></td></tr></table></figure></p><p>需要注意的是，模式匹配中各条 <code>case</code> 语句之间的前后顺序是至关重要的。<strong>通常来说，更“具体”更“精确”一些的规则要放在相对靠前的位置。</strong><br>假如 <code>case Command(command=&quot;quit&quot; | &quot;exit&quot; | &quot;bye&quot;)</code> 为规则 1，<code>Command(command=&quot;quit&quot; | &quot;exit&quot; | &quot;bye&quot;, arguments=[&quot;--force&quot; | &quot;-f&quot;])</code> 为规则 2。<br>则更具体一些的规则 2 要放在规则 1 前面。因为模式匹配是<strong>从上到下依次</strong>检查每一个 case 语句，若遇到匹配的模式，则执行对应的命令。不再继续向下匹配。<br>由于严格符合规则 2 的对象一定也符合规则 1，当规则 1 位于规则 2 前面时，规则 2 永远也没有被匹配的机会。</p><p>可以想象成一种逐渐“滑落”的过程。比如写一个计算成绩等级的函数，可以这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'C'</span></span><br></pre></td></tr></table></figure></p><p>如果上面 <code>if-else</code> 的条件反着排，那就，所有人都是 C 了。。。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=scNNi4860kk" target="_blank" rel="noopener">A Closer Look At Structural Pattern Matching // New In Python 3.10!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;switch-case&quot;&gt;&lt;a href=&quot;#switch-case&quot; class=&quot;headerlink&quot; title=&quot;switch-case&quot;&gt;&lt;/a&gt;switch-case&lt;/h4&gt;&lt;p&gt;众所周知，Python 中是没有类似 &lt;code&gt;switch-ca
      
    
    </summary>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Switch" scheme="https://rollingstarky.github.io/tags/Switch/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 使用 ConfigMaps、Secrets 和 Downward API 配置应用</title>
    <link href="https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/"/>
    <id>https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/</id>
    <published>2022-01-14T16:00:00.000Z</published>
    <updated>2022-01-15T11:49:22.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置命令、参数和环境变量"><a href="#设置命令、参数和环境变量" class="headerlink" title="设置命令、参数和环境变量"></a>设置命令、参数和环境变量</h4><p>同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、文件等完成配置。<br>比如容器启动时执行的命令可以由 Dockerfile 中的 <code>ENTRYPOINT</code> 选项指定；命令参数通常由 <code>CMD</code> 选项指定；环境变量则可以使用 <code>ENV</code> 选项指定；假如应用通过文件进行配置，则这些配置文件可以借助 <code>COPY</code> 选项复制到容器镜像中。</p><p>下面是一个名为 <code>kiada</code> 的示例应用。<br><code>Dockerfile</code> 配置文件：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js /app.js</span></span><br><span class="line"><span class="bash">COPY html /html</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENV INITIAL_STATUS_MESSAGE=<span class="string">"This is the default status message"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--listen-port"</span>, <span class="string">"8080"</span>]</span></span><br></pre></td></tr></table></figure></p><p>其他文件如 <code>html</code>、<code>app.js</code> 可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09/kiada-0.4" target="_blank" rel="noopener">Github</a> 处获取。同时构建好的镜像也被作者放到了 Dockerhub 的 <code>luksa/kiada:0.4</code> 位置。</p><p>借助上述 Dockerfile，应用的监听端口可以通过 <code>--listen-port</code> 命令参数配置；同时应用会读取环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来获取初始状态信息。</p><p>将配置硬编码进容器的镜像，事实上和将配置硬编码到应用的源代码中一样，都不是理想的情况。因为每当应用需要修改配置，都必须再重新 build 一遍镜像。此外，还必须避免在镜像中包含敏感的配置信息，比如认证数据或密钥等。<br>将上述配置文件放置在 Volume 中并挂载到容器上，相对而言更安全一点。</p><h5 id="配置命令和参数"><a href="#配置命令和参数" class="headerlink" title="配置命令和参数"></a>配置命令和参数</h5><p>在创建镜像时，容器启动时执行的命令和参数分别由 Dockerfile 中的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 选项指定。<br>Kubernetes 提供了两个同样功能的字段：<code>commands</code> 和 <code>args</code>。假如在 Pod 的清单文件中指定了 <code>commands</code> 和 <code>args</code>，或者其中任何一个字段，则 Dockerfile 中对应的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 配置会被覆盖。</p><p><strong>设置命令</strong><br>假如需要在运行 Kiada 应用时启用 CPU 和 heap 优化，对于 Node.js 而言，可以在执行时传入 <code>--cpu-prof</code> 和 <code>--heap-prof</code> 参数。<br>相对于修改 Dockerfile 重新 build 镜像，其实可以直接修改 Pod 的清单文件。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--cpu-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--heap-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">app.js</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><strong>设置命令参数</strong><br>比如需要将 Dockerfile 中的命令参数 <code>--listen-port 8080</code> 改为 <code>--listen-port 9090</code>，可以使用如下配置的 Pod 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>容器在创建时会自动组合 Dockerfile 中的 <code>ENTRYPOINT</code> 和 Pod 清单文件中的 <code>args</code>。</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p><strong>为环境变量设置字面量值</strong><br>Kiada 应用在运行时会显示 Pod 的名字，该名称由应用源代码从环境变量 <code>POD_NAME</code> 读取。此外还可以通过修改环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来更改状态信息。</p><p>为了修改上述环境变量，可以向 Dockerfile 中添加 <code>ENV</code> 选项并重新构建镜像，但更快速的方式时向 Pod 的清单文件中添加 <code>env</code> 选项。<br>示例清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">pod</span> <span class="string">spec.</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用上述 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada-env.yml</span></span><br><span class="line">pod/kiada unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">POD_NAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the pod spec.</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">NODE_VERSION=16.11.1</span><br><span class="line">YARN_VERSION=1.22.15</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure></p><p><strong>使用变量引用</strong><br>除了给环境变量设置一个固定值外，还可以采用 <code>$(VAR_NAME)</code> 格式引用其他变量。如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">My</span> <span class="string">name</span> <span class="string">is</span> <span class="string">$(POD_NAME).</span> <span class="string">I</span> <span class="string">run</span> <span class="string">NodeJS</span> <span class="string">version</span> <span class="string">$(NODE_VERSION).</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>引用的变量中，<code>POD_NAME</code> 是在同一个 Pod 清单文件中定义的，<code>NODE_VERSION</code> 是在容器镜像中定义的。<br>最终的状态信息会显示为 <code>My name is kiada. I run NodeJS version $(NODE_VERSION).</code>，因为此方式只支持引用同一个 Pod 清单文件中定义的变量，且该变量必须在引用位置之前定义。</p><p><strong>在命令和参数中使用变量引用</strong><br>还可以在命令和参数中引用清单文件中定义的变量。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$(LISTEN_PORT)</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">LISTEN_PORT</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure></p><h4 id="使用-config-map-将配置与-Pod-解耦"><a href="#使用-config-map-将配置与-Pod-解耦" class="headerlink" title="使用 config map 将配置与 Pod 解耦"></a>使用 config map 将配置与 Pod 解耦</h4><p>在前面的章节中，可以将应用的配置硬编码进 Pod 的 yaml 清单文件中。这种方式比将配置硬编码到容器镜像中要好很多，即不需要每次修改配置后都必须重新构建镜像。<br>但这种方式也有一定的缺陷，它意味着比如针对不同环境的部署（development、staging、production 等），可能需要多个不同版本的清单文件。<br>为了在多个环境下重复利用同一个清单文件，最好是将配置与 Pod 的清单文件解耦。</p><h5 id="ConfigMaps-介绍"><a href="#ConfigMaps-介绍" class="headerlink" title="ConfigMaps 介绍"></a>ConfigMaps 介绍</h5><p>ConfigMap 是一种包含一系列键值对的 Kubernetes API 对象。其中的值可以是短字符串，也可以是一大段结构化的文本。Pod 可以引用一个或多个 ConfigMap 中的值。<br>一个 Pod 可以引用多个 ConfigMaps，多个 Pods 可以使用同一个 ConfigMap。</p><p>如下图所示，ConfigMap 中的键值对通常作为环境变量传递给 Pod，或者通过 ConfigMap Volume 作为文件挂载到容器的文件系统中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-9c8df1bf7a6cd5ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods use config maps through environment variables andconfigMap volumes"></p><p>将配置保存在一个独立的 ConfigMap 对象中，而不是直接保存在 Pod 里。这使得在不同的环境中能够部署同一个 Pod 清单文件，与此同时应用不同的配置（引用不同的 ConfigMap 对象）。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-674fcbf8eedefb8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying the same pod manifest and different configmap manifests in different environments"></p><h5 id="创建-ConfigMap-对象"><a href="#创建-ConfigMap-对象" class="headerlink" title="创建 ConfigMap 对象"></a>创建 ConfigMap 对象</h5><p><strong>从 YAML 文件创建 ConfigMap</strong><br><code>cm.kiada-config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  status-message:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>kubectl apply -f cm.kiada-config.yml</code> 命令创建清单文件中定义的 ConfigMap 对象。</p><p><strong>查看 ConfigMap</strong><br>可以使用 <code>kubectl get cm</code> 命令列出 ConfigMap 对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">kiada-config       1      6s</span><br><span class="line">kube-root-ca.crt   1      55d</span><br></pre></td></tr></table></figure></p><p>可以使用如下命令查看 ConfigMap 的详细信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  status-message: This status message is set in the kiada-config config map</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;"apiVersion":"v1","data":&#123;"status-message":"This status message is set in the kiada-config config map"&#125;,"kind":"ConfigMap","metadata":&#123;"annotations":&#123;&#125;,"name":"kiada-config","namespace":"default"&#125;&#125;</span><br><span class="line">  creationTimestamp: "2022-01-10T05:11:35Z"</span><br><span class="line">  name: kiada-config</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: "99447"</span><br><span class="line">  uid: e39e2676-2183-4582-9922-eac963b81093</span><br></pre></td></tr></table></figure></p><p>若只想精确地查找 ConfigMap 中的配置项，可以使用如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq .data</span></span><br><span class="line">&#123;</span><br><span class="line">  "status-message": "This status message is set in the kiada-config config map"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq <span class="string">'.data["status-message"]'</span></span></span><br><span class="line">"This status message is set in the kiada-config config map"</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的值注入到环境变量"><a href="#将-ConfigMap-中的值注入到环境变量" class="headerlink" title="将 ConfigMap 中的值注入到环境变量"></a>将 ConfigMap 中的值注入到环境变量</h5><p><code>pod.kiada.env-valueFrom.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          configMapKeyRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">            key:</span> <span class="string">status-message</span></span><br><span class="line"><span class="attr">            optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看环境变量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.env-valueFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>注入整个 ConfigMap</strong><br>容器定义中的 <code>env</code> 字段接收的是由值组成的列表，因此可以同时设置多个环境变量。实际上可以使用 <code>envFrom</code> 注入整个 ConfigMap 中定义的多个值，而无需像 <code>valueFrom</code> 那样分别指定每一个键。<br>唯一需要注意的是，ConfigMap 中的键必须与实际的环境变量名称保持一致。即之前使用的键 <code>status-message</code> 必须改成 <code>INITIAL_STATUS_MESSAGE</code>。</p><p><code>cm.kiada-config.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  INITIAL_STATUS_MESSAGE:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl replace</code> 命令更新 ConfigMap：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">replace</span> <span class="bullet">-f</span> <span class="string">cm.kiada-config.yml</span></span><br><span class="line"><span class="string">configmap/kiada-config</span> <span class="string">replaced</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 清单文件 <code>pod.kiada.envFrom.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    envFrom:</span></span><br><span class="line"><span class="attr">    - configMapRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">        optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f pod.kiada.env-valueFrom.yml</span><br><span class="line">pod "kiada" deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.envFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的配置项作为文件嵌入到容器"><a href="#将-ConfigMap-中的配置项作为文件嵌入到容器" class="headerlink" title="将 ConfigMap 中的配置项作为文件嵌入到容器"></a>将 ConfigMap 中的配置项作为文件嵌入到容器</h5><p>环境变量通常用于向应用传递较小的单行的值，而多行的数据通常作为文件传递。<br>ConfigMap 中的配置项可以包含大块的数据，通过特殊的 ConfigMap volume 类型将这些数据以文件的形式注入到容器中。</p><p><strong>从文件创建 ConfigMaps</strong><br>除了直接在集群中创建 ConfigMap 对象之外，还可以先创建一个用于描述 ConfigMap 的 YAML 清单文件，从而可以将其保存到版本控制系统中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create configmap kiada-envoy-config \</span></span><br><span class="line">--from-file=envoy.yaml \</span><br><span class="line">--from-file=dummy.bin \</span><br><span class="line">--dry-run=client -o yaml &gt; cm.kiada-envoy-config.yml</span><br></pre></td></tr></table></figure></p><p>其中 dummy.bin 和 <code>envoy.yaml</code> 两个文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 <code>kiada-envoy-config</code> 的 ConfigMap 的 YAML 描述文件。当命令中使用了 <code>--dry-run</code> 选项时，该命令并不会在 API server 创建新对象，而是只生成对象的定义。后续可继续运行 <code>kubectl apply -f xxx.yml</code> 命令创建对象。</p><p>生成的 <code>cm.kiada-envoy-config.yml</code> 文件的具体内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">binaryData:</span></span><br><span class="line">  <span class="string">dummy.bin:</span> <span class="string">n2VW39IEkyQ6Jxo+rdo5J06Vi7cz5XxZzkPOtN7MOGyXxVzWv07vUz8bxY5h4njJfZixwhPwoGepLnGZdRGw1qgpFB9HpyLsqVZ6jAwjjHD0afxxwEjb6+wofmgGmS1E3U9BZScMPZGWJK7RGzZmQOeJeDPIt/1tBvQYwzMc8wu6owky4Ri3rOY9PlFnp5VOTzvBZadW8scbqtntJeWCtJFoS0AH2y4ZFyJPJ0l0V3JpY1qunnz60CyAMO9v1DgB2PUQUG/1HH89bpzf2OyMvHUJmOTIDZOh3D7aAEuYQ/6hU0uQsQ/K7Xx/nM9TA0RzEzuh8RBoXdkAvQPP5jk7yM2DqxG/CiHVp+7CDRFWgEN2GFd76RfO+pIoOFbD1Xm4yE/JBljOA9ztwm865m3A4l2ToT2p7ZWHKmdZe8pXz4ZwIGBYDUHHNVQW5UUnf0Jbd9UR8GJ//gmbxLfVxjC/lMSWGUqCpYO4YdBPjXQGM1xdxE+YP3Pzso6Z4rw27RJu5KEc2yPMxFY9dpFyVufP81kS19glNiQq+LM4B9EFPrNW1hqi+1Tb8ni+aFkriH1YuvHepIH0Px/ifFLgn+yDgwDs4UfMru2j4t5zAftUa0i6m3sH5adKcx4aCXYN9ijvEvjRmkcB/VJU6Zbd65UZVgD1Nwt2ZCrkoEdqO3Oe1/o=</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">envoy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string"></span><span class="attr">    admin:</span></span><br><span class="line"><span class="attr">      access_log_path:</span> <span class="string">/tmp/envoy.admin.log</span></span><br><span class="line"><span class="attr">      address:</span></span><br><span class="line"><span class="attr">        socket_address:</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">          port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-envoy-config</span></span><br></pre></td></tr></table></figure></p><p><strong>在 Pod 中使用 ConfigMap</strong><br>为了令 ConfigMap 能够作为文件呈现在容器的文件系统中，需要在 Pod 中定义一个 ConfigMap Volume 并将其挂载到容器里。<br>参考下面的 <code>pod.kiada-ssl.configmap-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada-ssl-proxy:0.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>创建 <code>kiada-envoy-config</code> ConfigMap：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f cm.kiada-envoy-config.yml</span></span><br><span class="line">configmap/kiada-envoy-config created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME                 DATA   AGE</span><br><span class="line">kiada-config         1      46h</span><br><span class="line">kiada-envoy-config   2      13s</span><br><span class="line">kube-root-ca.crt     1      57d</span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看文件挂载情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada-ssl.configmap-volume.yml</span></span><br><span class="line">pod/kiada-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls /etc/envoy</span></span><br><span class="line">dummy.bin</span><br><span class="line">envoy.yaml</span><br></pre></td></tr></table></figure></p><h5 id="理解-ConfigMap-Volume-是如何工作的"><a href="#理解-ConfigMap-Volume-是如何工作的" class="headerlink" title="理解 ConfigMap Volume 是如何工作的"></a>理解 ConfigMap Volume 是如何工作的</h5><p><strong>挂载 Volume 会隐藏文件系统中本来就存在的文件</strong><br>当挂载任意 volume 到容器的文件系统中时，挂载的路径下原本存在的文件就无法被访问。比如把某个 ConfigMap volume 挂载到容器的 <code>/etc</code> 路径下，则本来位于 <code>/etc</code> 下面的配置文件都会被隐藏掉。<br>如果你还是想将 ConfigMap volume 挂载到 <code>/etc</code> 目录，又不影响原来存在的文件，可以结合使用 <code>mountPath</code> 和 <code>subPath</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">my-container</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my-volume</span></span><br><span class="line"><span class="attr">      subPath:</span> <span class="string">my-app.conf</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/my-app.conf</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-c49e7b4386aac0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using subPath to mount a single file from the volume"></p><p><strong>ConfigMap volumes 使用符号链接来实现原子化更新</strong><br>有些应用会监控其配置文件的变化来决定是否重新加载配置。但是，假如应用的配置文件很大或者涉及到很多文件，应用可能会在所有更新全部完成之前检查到变化并加载更新。若应用最终读取了未全部更新的文件，可能导致出现不正常的行为。<br>为了防止上述情况发生，Kubernetes 会确保 ConfigMap volume 中所有文件的更新操作是<strong>原子</strong>的，即所有更新都会立即完成。<br>上述机制是通过文件的符号链接实现的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls -lA /etc/envoy</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan 12 03:33 ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   31 Jan 12 03:33 ..data -&gt; ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   16 Jan 12 03:33 dummy.bin -&gt; ..data/dummy.bin</span><br><span class="line">lrwxrwxrwx 1 root root   17 Jan 12 03:33 envoy.yaml -&gt; ..data/envoy.yaml</span><br></pre></td></tr></table></figure></p><p>每次用户修改 ConfigMap，Kubernetes 都会新建一个以当前时间戳命名的目录，将新的配置文件放到该目录中。再修改符号链接的指向，立即同时替换所有文件。</p><h5 id="更新和删除-ConfigMaps"><a href="#更新和删除-ConfigMaps" class="headerlink" title="更新和删除 ConfigMaps"></a>更新和删除 ConfigMaps</h5><p>和大多数 Kubernetes API 对象一样，ConfigMaps 也支持手动修改其清单文件，再使用 <code>kubectl apply</code> 命令将最新版本重新应用到集群环境。<br>此外还可以使用下面这种更快捷的方式。</p><p><strong>使用 kubectl edit 就地修改 API 对象</strong><br><code>kubectl edit cm kiada-config</code><br><img src="https://upload-images.jianshu.io/upload_images/6875152-1f41ca72be09f6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl edit"></p><p>上面的命令会使用系统默认的编辑器（比如 <code>Vim</code>）打开 ConfigMap <code>kiada-config</code> 的清单文件，允许用户直接修改该 ConfigMap 对象。当关闭编辑器时，最新的改动会自动应用到 Kubernetes API server。</p><p><strong>修改 ConfigMap 的影响</strong><br>当更新某个 ConfigMap 后，若 ConfigMap 是以存储卷的形式作为配置文件挂载到容器中，则其中的文件会自动进行更新。<br>但是不同于文件，环境变量在容器运行时不会自动进行更新。然而当容器因为某些特殊原因重启后，Kubernetes 会使用最新版本的 ConfigMap 值来初始化新容器的环境变量。</p><p>容器最重要的属性之一就是其<strong>不变性</strong>，即用户可以肯定同一个容器的多个实例一定是相同的。<br>假如应用通过 ConfigMap 以环境变量的方式注入配置，当 ConfigMap 修改后，实际上并不会影响正在运行的应用实例。但是当应用的某一部分实例因为故障重新启动，或者需要添加新的实例副本，就会导致只有这一部分实例在使用最新的配置。<br>类似的场景甚至发生在应用自动重新加载其配置文件的时候。Kubernetes 对于 ConfigMap volumes 采用异步的更新方式，这导致某些实例可能会比其他实例更早地看到配置的变化。上述更新操作有可能会持续几十秒的时间，则在这部分时间内，各应用实例上的配置文件之间实际上是不同步的。<br>从而也会导致应用的各个容器实例之间正使用着不同的配置。</p><p><strong>阻止 ConfigMap 被修改</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-immutable-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  mykey:</span> <span class="string">myvalue</span></span><br><span class="line"><span class="attr">  another-key:</span> <span class="string">another-value</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>不可变 ConfigMap 可以阻止用户意外地修改应用配置，同时也会提高 Kubernetes 集群的性能。因为工作节点上的 Kubelets 无需再接收 ConfigMap 对象变化的通知。<br>假如需要添加一系列使用不同配置的 Pods，就创建一个新的 ConfigMap。</p><p><strong>删除 ConfigMap</strong><br>ConfigMap 对象可以使用 <code>kubectl delete</code> 命令删除。删除某个 ConfigMap 后，引用它的正在运行的应用不会受到任何影响，直到容器重新启动。<br>若 ConfigMap 没有被标记成可选的，则容器会在重启时失败。</p><h4 id="使用-Secrets-向容器嵌入敏感信息"><a href="#使用-Secrets-向容器嵌入敏感信息" class="headerlink" title="使用 Secrets 向容器嵌入敏感信息"></a>使用 Secrets 向容器嵌入敏感信息</h4><h5 id="Secrets-介绍"><a href="#Secrets-介绍" class="headerlink" title="Secrets 介绍"></a>Secrets 介绍</h5><p>Secrets 和 ConfigMaps 非常相似。它们也是包含一系列键值对且能够作为环境变量或文件注入到容器中。<br>事实上 Secrets 比 ConfigMap 更早出现。但是 Secrets 在存储普通的明文文本时友好性较差，因而引入了 ConfigMaps。<br>对于 Secrets 对象，Kubernetes 在处理它们时会特别注意安全性。比如 Kubernetes 会确保 Secret 中的数据在分发时只传给有需要的节点；工作节点上的 Secrets 只保存在内存中，从来不会写入到物理存储。<br>因此，必须将敏感数据保存到 Secrets 而不是 ConfigMaps 中。</p><h5 id="创建-Secret"><a href="#创建-Secret" class="headerlink" title="创建 Secret"></a>创建 Secret</h5><p><strong>创建一个 TLS secret</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret tls kiada-tls --cert example-com.crt --key example-com.key</span></span><br><span class="line">secret/kiada-tls created</span><br></pre></td></tr></table></figure></p><p>其中 crt 文件和 key 文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter05/kiada-ssl-proxy-0.1" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 kiada-tls 的 Secret。</p><p><strong>从 YAML 清单文件创建 Secrets</strong><br>显而易见，从 YAML 文件创建 Secrets 并不是一个好主意。<br>假如你只是需要在本地创建一个 YAML 清单文件而不是直接通过 API server 创建 Secret 对象，可以使用 <code>kubectl create</code> 加上 <code>--dry-run=client -o yaml</code> 选项。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret generic my-credentials \</span></span><br><span class="line">--from-literal user=my-username \</span><br><span class="line">--from-literal pass=my-password \</span><br><span class="line">--dry-run=client -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  pass: bXktcGFzc3dvcmQ=</span><br><span class="line">  user: bXktdXNlcm5hbWU=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: my-credentials</span><br></pre></td></tr></table></figure></p><p><strong>使用 <code>stringData</code> 字段</strong><br>因为并不是所有敏感数据都是二进制形式，Kubernetes 允许用户通过 <code>stringData</code> 字段指定 Secret 中的文本数据。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">my-username</span></span><br><span class="line"><span class="attr">  pass:</span> <span class="string">my-password</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-credentials</span></span><br></pre></td></tr></table></figure></p><h5 id="在容器中使用-Secrets"><a href="#在容器中使用-Secrets" class="headerlink" title="在容器中使用 Secrets"></a>在容器中使用 Secrets</h5><p><strong>借助 Secret Volume 注入 Secret 配置</strong><br>Secret volume 和前面提到的 ConfigMap volume 用法基本相同。参考如下 YAML 配置文件 <code>pod.kiada-ssl.secret-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">kiada-tls</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.crt</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.crt</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.key</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.key</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">envoyproxy/envoy:v1.14.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/certs</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3207fa46e0b47047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Secret Volume"></p><h4 id="通过-Downward-API-向应用传递-Pod-的元数据"><a href="#通过-Downward-API-向应用传递-Pod-的元数据" class="headerlink" title="通过 Downward API 向应用传递 Pod 的元数据"></a>通过 Downward API 向应用传递 Pod 的元数据</h4><p>前面介绍了如何向容器中的应用传递配置信息。但数据并不总是静态的，假如某些数据只有在 Pod 创建之后才能被知晓，比如 Pod 的 IP 地址、工作节点的名称、容器分配到的 CPU 和内存等。<br>这些需求可以通过 Downward API 实现。</p><h5 id="Downward-API-介绍"><a href="#Downward-API-介绍" class="headerlink" title="Downward API 介绍"></a>Downward API 介绍</h5><p>Downward API 并不是一个需要应用去访问的 REST 端点，它实际上是一种将 Pod 的 metadata、spec 和 status 字段注入到容器中的方式。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6c519adcce0bfaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The Downward API exposes pod metadata throughenvironment variables or files"></p><h5 id="Downward-API-支持哪些元数据"><a href="#Downward-API-支持哪些元数据" class="headerlink" title="Downward API 支持哪些元数据"></a>Downward API 支持哪些元数据</h5><p>用户并不能通过 Downward API 注入 Pod 对象中的所有字段。实际上只有一部分数据被支持，其列表如下。</p><p><strong>通过 <code>fieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.namespace</code></td><td>Pod 的命名空间</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.uid</code></td><td>Pod 的 UID</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.labels</code></td><td>Pod 的所有标签</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.labels[&#39;key&#39;]</code></td><td>某个标签的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.annotations</code></td><td>Pod 的所有注释</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.annotations[&#39;key&#39;]</code></td><td>某个注释的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>spec.nodeName</code></td><td>Pod 运行的工作节点的名称</td><td>Yes</td><td>No</td></tr><tr><td><code>spec.serviceAccountName</code></td><td>Pod 的服务账户</td><td>Yes</td><td>No</td></tr><tr><td><code>status.podIP</code></td><td>Pod 的 IP 地址</td><td>Yes</td><td>No</td></tr><tr><td><code>status.hostIP</code></td><td>工作节点的 IP 地址</td><td>Yes</td><td>No</td></tr></tbody></table><p><strong>通过 <code>resourceFieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Resource Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>requests.cpu</code></td><td>容器的 CPU 请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.memory</code></td><td>容器的内存请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.ephemeral-storage</code></td><td>容器的临时存储请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.cpu</code></td><td>容器的 CPU 限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.memory</code></td><td>容器的内存限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>容器的临时存储限制</td><td>Yes</td><td>Yes</td></tr></tbody></table><h5 id="将-Pod-的元数据注入到环境变量中"><a href="#将-Pod-的元数据注入到环境变量中" class="headerlink" title="将 Pod 的元数据注入到环境变量中"></a>将 Pod 的元数据注入到环境变量中</h5><p><strong>注入 Pod 对象中的字段</strong><br><code>kiada.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.hostIP</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 <code>kiada.yml</code> 清单文件并查看其日志输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs -f kiada</span></span><br><span class="line">Kiada - Kubernetes in Action Demo Application</span><br><span class="line">---------------------------------------------</span><br><span class="line">Kiada 0.4 starting...</span><br><span class="line">Pod name is kiada</span><br><span class="line">Local hostname is kiada</span><br><span class="line">Local IP is 172.17.0.6</span><br><span class="line">Running on node minikube</span><br><span class="line">Node IP is 192.168.49.2</span><br><span class="line">Status message is This is the default status message</span><br><span class="line">Listening on port 8080</span><br></pre></td></tr></table></figure></p><p><strong>注入容器的资源数据</strong><br>示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_CPU_CORES</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.cpu</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_MEMORY_KB</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.memory</span></span><br><span class="line"><span class="attr">        divisor:</span> <span class="number">1</span><span class="string">k</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;设置命令、参数和环境变量&quot;&gt;&lt;a href=&quot;#设置命令、参数和环境变量&quot; class=&quot;headerlink&quot; title=&quot;设置命令、参数和环境变量&quot;&gt;&lt;/a&gt;设置命令、参数和环境变量&lt;/h4&gt;&lt;p&gt;同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 向容器挂载存储卷</title>
    <link href="https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/"/>
    <id>https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/</id>
    <published>2022-01-05T16:00:00.000Z</published>
    <updated>2022-01-06T15:30:53.513Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Volumes-介绍"><a href="#Volumes-介绍" class="headerlink" title="Volumes 介绍"></a>Volumes 介绍</h4><p>Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运行着应用的各个进程。这些进程可以共享 CPU、RAM、网络接口等计算资源。<br>在普通的计算机中，应用的进程使用同一个文件系统。但是在 Pod 中，每个容器都有自己独有的、由容器镜像提供的隔离的文件系统。</p><p>容器构建时添加到镜像中的文件构成了容器的文件系统，容器启动后，运行在容器中的进程就可以修改这些文件或者添加新的文件。<br>但是当容器终止和重启时，所有对于文件系统的改动都不会被保留。事实上容器并不是真正意义上的重启，而是完全地被一个新容器<strong>替换</strong>掉了。这对于一些类型的应用是 OK 的，其他应用则需要在重启时至少保留一部分文件系统。<br>这可以通过挂载 Volume 来实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b6512cfe7b8b10cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mounting a filesystem into the file tree"></p><h5 id="Volumes-与-Pod"><a href="#Volumes-与-Pod" class="headerlink" title="Volumes 与 Pod"></a>Volumes 与 Pod</h5><p>Volumes 并不是 Pod 或 Node 那样的顶层资源，而是和容器一样是 Pod 中的一个组件，因而会使用 Pod 的生命周期。Volumes 与其挂载的容器的生命周期是毫无关联的，也因此能够用来在容器重启时保持数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a1dbdaf7fcc1a252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes are defined at the pod level and mounted in the pod’s containers"></p><p>Volumes 在 Pod 中定义，挂载到 Pod 下的容器中。</p><p><strong>在容器重启时保持数据</strong><br>Pod 中的所有 Volumes 都会在容器启动前创建，在 Pod 关闭时销毁。<br>应用可以向挂载到容器文件系统中的 Volume 写入数据。当容器重启时，其被替换为一个新容器，文件系统也重新从镜像创建。此时则可以再次挂载同样的 Volume，完成对之前数据的访问。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-5b341a1a50a8938a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes ensure that part of the container’s filesystem is persisted across restarts"></p><p>通常由应用的作者决定哪些文件需要在容器重启时被保留，一般是一些代表应用状态的数据。但不包括应用的本地缓存数据，这些数据会阻止容器完成一次“全新”的重启。而全新的重启有利于应用的“自愈”。</p><p><strong>在一个容器中挂载多个 Volume</strong><br>一个 Pod 可以包含多个 Volumes，Pod 中的每个容器都可以挂载这些 Volumes 中的零个或多个。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f630769df6056546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A pod can contain multiple volumes and a container can mount multiple volumes"></p><p><strong>在多个容器间共享文件</strong><br>一个 Volume 可以被同时挂载到多个容器中，从而这些容器中的应用可以共享文件。<br>比如可以创建一个 Pod，包含一个 Web Server 容器和一个 content-producing agent 容器。Agent 容器负责生成静态媒体内容保存至 Volume，Web 容器则将 Volume 中的内容发布给客户端。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-8bafa09cc1369c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A volume can be mounted into more than one container"></p><p><strong>在 Pod 重启时保持数据</strong><br>Volume 与 Pod 的生命周期绑定，只会在 Pod 存在时存在。但是依靠某些特殊的 Volume 类型，其中的文件也可以在 Pod 和 Volume 消失后继续存在，后续也能够挂载到一个新的 Volume 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-ea1ae1c57074b2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod volumes can also map to storage volumes that persist across pod restarts"></p><p>如上图所示，Pod 中的 Volume 可以映射到 Pod 外面的永久存储。代表 Volume 的文件目录并不是 Pod 内部的本地路径，而是挂载的一个脱离了 Pod 生命周期的 NAS。<br>假如 Pod 被删除并被一个新的 Pod 所替换，同一个 NAS 可以被关联到新的 Pod 实例中，从而前一个 Pod 保持的数据可以被新的 Pod 访问。</p><p><strong>在多个 Pod 间共享文件</strong><br>取决于 external storage volume 使用的具体技术，同一个外挂存储也能够同时被关联给多个 Pod，从而这些 Pod 之间能够共享数据。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-db595737626572c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using volumes to share data between pods"></p><h5 id="Volume-类型"><a href="#Volume-类型" class="headerlink" title="Volume 类型"></a>Volume 类型</h5><p>当向某个 Pod 添加 Volume 时，必须指定 Volume 类型。主要的几种 Volume 类型如下：</p><ul><li><code>emptyDir</code>：一个简单的空目录，允许 Pod 在其生命周期内向该路径下存储数据</li><li><code>hostPath</code>：从工作节点的文件系统向 Pod 挂载文件</li><li><code>nfs</code>：挂载到 Pod 中的 NFS 共享</li><li><code>gcePersistentDisk</code> (Google Compute Engine Persistent Disk), <code>awsElasticBlockStore</code> (Amazon Web Services Elastic Block Store), <code>azureFile</code> (Microsoft Azure File Service), <code>azureDisk</code> (Microsoft Azure Data Disk)</li><li><code>cephfs</code>, <code>cinder</code>, <code>fc</code>, <code>flexVolume</code>, <code>flocker</code>, <code>glusterfs</code>, <code>iscsi</code>, <code>portworxVolume</code>, <code>quobyte</code>, <code>rbd</code>, <code>scaleIO</code>, <code>storageos</code>, <code>photonPersistentDisk</code>, <code>vsphereVolume</code></li><li><code>configMap</code>, <code>secret</code>, <code>downwardAPI</code>, <code>projected</code>：特殊类型的 Volume，用来暴露 Pod 及其他 Kubernetes 对象的信息</li><li><code>csi</code>：一种可插拔的通过 <strong>Container Storage Interface</strong> 添加存储的方式。任何人都可以使用这种 Volume 类型来实现自己的存储驱动</li></ul><h4 id="使用-Volumes"><a href="#使用-Volumes" class="headerlink" title="使用 Volumes"></a>使用 Volumes</h4><h5 id="使用-emptyDir-在容器重启时保留文件"><a href="#使用-emptyDir-在容器重启时保留文件" class="headerlink" title="使用 emptyDir 在容器重启时保留文件"></a>使用 <code>emptyDir</code> 在容器重启时保留文件</h5><p><code>emptyDir</code> 是最简单的 Volume 类型。它最开始以空目录的形式挂载到容器的文件系统，任何写入到该路径下的文件都会在 Pod 的整个生命周期中存在。<br>这类 Volume 通常用于在容器重启后保留部分数据；或者当整个容器的文件系统都是只读时，令其部分文件系统可写；又或者在包含两个或以上容器的 Pod 中，在各容器间传递数据。</p><p><strong>向 Pod 添加 <code>emptyDir</code> Volume</strong><br>创建如下 <code>fortune-emptydir.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-emptydir</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"ls /usr/share/nginx/html/quote || (apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote)"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>当容器第一次启动时，<code>postStart</code> hook 会执行 <code>apk add fortune</code> 命令安装 fortune 软件包，并执行 <code>fortune &gt; /usr/share/nginx/html/quote</code> 创建 <code>quote</code> 文件。<br>后续若容器因为各种原因重启，由于 <code>quote</code> 文件位于挂载的 Volume 中，不会随着容器一同被销毁。<br>并且在新容器生成后仍会挂载到原来的路径下，即不管后续容器如何重启，<code>quote</code> 文件都会保持第一次创建时的状态。</p><p>若没有挂载 Volume，则 <code>quote</code> 文件会在容器重启时随着旧容器一同被销毁，每次新容器生成，都会在同样的路径下产生一个新的不同版本的 <code>quote</code> 文件。</p><p>运行 <code>kubectl apply -f fortune-emptydir.yml</code> 命令应用清单文件，检查容器中 Volume 的挂载状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-emptydir.yml</span></span><br><span class="line">pod/fortune-emptydir created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune-emptydir -- mount --list | grep nginx/html</span></span><br><span class="line">/dev/sdb on /usr/share/nginx/html type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br></pre></td></tr></table></figure></p><h5 id="使用-emptyDir-在容器间共享文件"><a href="#使用-emptyDir-在容器间共享文件" class="headerlink" title="使用 emptyDir 在容器间共享文件"></a>使用 <code>emptyDir</code> 在容器间共享文件</h5><p>创建如下内容的清单文件 <code>fortune.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/fortune-writer:1.0</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/local/output</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>fortune</code> 容器是作者自己构建的，会每隔 30s 执行一次 <code>fortune &gt; /var/local/output/quote</code> 命令。<code>fortune</code> 每次执行都会随机输出一段名言警句类型的话，即 <code>/var/local/output/quote</code> 文件中的内容会每隔 30s 变化一次。<br>整个 Pod 包含两个容器和一个 Volume，其中 <code>fortune</code> 容器挂载 <code>content</code> Volume 到自己的 <code>/var/local/output</code> 路径下，而 <code>nginx</code> 容器挂载同一个 <code>content</code> Volume 到自己的 <code>/usr/share/nginx/html</code> 路径下。<br><code>fortune</code> 容器会每隔 30s 生成一个新的 <code>quote</code> 文件，保存到挂载的 <code>content</code> Volume 下；而另一个 <code>nginx</code> 容器也挂载了 <code>content</code> Volume，并且将其中的 <code>quote</code> 文件作为 Web 服务的静态文件向外提供服务。<br>即同一个 Pod 中的两个容器通过挂载同一个 Volume 实现文件的共享。</p><p><strong>运行 Pod</strong><br>使用 <code>kubectl apply -f fortune.yml</code> 命令应用清单文件创建 Pod，再分别从两个容器中查看 Volume 下 <code>quote</code> 文件的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune.yml</span></span><br><span class="line">pod/fortune configured</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c fortune -- cat /var/<span class="built_in">local</span>/output/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c nginx -- cat /usr/share/nginx/html/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br></pre></td></tr></table></figure></p><p>后两条命令输出了同样的内容。虽然两个容器查看的 <code>quote</code> 文件本地路径不同，它们实际上指向了同一个 Volume。</p><h4 id="理解-external-volumes-是如何挂载的"><a href="#理解-external-volumes-是如何挂载的" class="headerlink" title="理解 external volumes 是如何挂载的"></a>理解 external volumes 是如何挂载的</h4><p>如下图所示，网络存储卷首先是被宿主节点挂载，然后再授予 Pod 访问挂载点的权限。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0f593c120f4cd3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network volumes are mounted by the host node and then exposed in pods"></p><p>通常情况下，底层的存储技术并不允许一个 Volume 以读写模式同时挂载到一个以上的节点，但是同一个节点上的多个 Pods 可以同时以读写模式使用 Volume。<br>对于云环境提供的大多数存储技术，多个节点使用同一个网络存储卷的方式只有一种，即以只读模式挂载。<br>在设计分布式应用的架构时，考虑网络存储卷的上述限制是很有必要的。同一个 Pod 的多个副本通常不能以读写模式挂载同一个网络存储卷。</p><h4 id="访问工作节点上的文件系统"><a href="#访问工作节点上的文件系统" class="headerlink" title="访问工作节点上的文件系统"></a>访问工作节点上的文件系统</h4><p>绝大多数 Pods 不应该关注部署它们的宿主节点，不应该访问节点文件系统中的任何文件。除非这些 Pods 是系统级别的。<br>可以使用 <code>hostPath</code> 类型的 Volume 令 Pod 能够访问宿主节点。</p><h5 id="hostPath-Volume-介绍"><a href="#hostPath-Volume-介绍" class="headerlink" title="hostPath Volume 介绍"></a><code>hostPath</code> Volume 介绍</h5><p><code>hostPath</code> Volume 指向宿主节点文件系统中的特定文件或目录，形成 Pod 与宿主节点之间的文件共享。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-48b1a7db394ddd26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hostPath volume mounts a file or directory from the worker node’s filesystem into the container"></p><p><code>hostPath</code> Volume 并不适合存放数据库中的数据。因为此 Volume 的内容只是保存在某个特定的工作节点上，假如数据库 Pod 被重新分配给了另一个节点，则保存在 Volume 中的数据库数据对新的 Pod 不再可见。</p><p>通常情况下，<code>hostPath</code> Volume 只用在当 Pod 确实是需要读写 Node 中的文件，比如 Node 上的系统日志。<br><code>hostPath</code> 是最危险的 Volume 类型之一，一般只用于具有特殊权限的 Pod。假如不对 <code>hostPath</code> 的使用加以限制，用户有可能对工作节点做任何事。<br>比如用户可以使用 <code>hostPath</code> 挂载容器的 Docker socket 文件，然后在容器内运行 Docker 客户端，接着便可以作为 root 用户在宿主节点上执行任意命令。</p><h5 id="使用-hostPath-Volume"><a href="#使用-hostPath-Volume" class="headerlink" title="使用 hostPath Volume"></a>使用 <code>hostPath</code> Volume</h5><p>部署如下配置的 Pod：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">host-root</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"sleep"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9999999999"</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/host</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">host-root</span></span><br></pre></td></tr></table></figure></p><p>Pod 部署完成后，即可运行 <code>kubectl exec -it node-explorer -- sh</code> 命令在 Pod 中运行一个交互式命令行窗口，在执行 <code>cd /host</code> 命令即可进入宿主节点的文件系统：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it node-explorer -- sh</span></span><br><span class="line">/ # cd /host</span><br><span class="line">/host # ls</span><br><span class="line">Release.key  boot         dev          etc          kic.txt      lib          lib64        media        opt          root         sbin         sys          usr</span><br><span class="line">bin          data         docker.key   home         kind         lib32        libx32       mnt          proc         run          srv          tmp          var</span><br><span class="line">/host #</span><br></pre></td></tr></table></figure></p><p><code>hostPath</code> Volume 指向的是宿主节点的 <code>/</code> 路径，由此整个工作节点的文件系统都会向 Pod 开放。执行完上面的命令后，即可以修改工作节点上的任何文件。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Volumes-介绍&quot;&gt;&lt;a href=&quot;#Volumes-介绍&quot; class=&quot;headerlink&quot; title=&quot;Volumes 介绍&quot;&gt;&lt;/a&gt;Volumes 介绍&lt;/h4&gt;&lt;p&gt;Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Storage" scheme="https://rollingstarky.github.io/tags/Storage/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Volumes" scheme="https://rollingstarky.github.io/tags/Volumes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 管理 Pod 的生命周期</title>
    <link href="https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/"/>
    <id>https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/</id>
    <published>2022-01-04T16:00:00.000Z</published>
    <updated>2022-01-04T16:30:25.056Z</updated>
    
    <content type="html"><![CDATA[<h4 id="理解-Pod-的状态"><a href="#理解-Pod-的状态" class="headerlink" title="理解 Pod 的状态"></a>理解 Pod 的状态</h4><h5 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h5><p>在 Pod 完整的生命周期中，存在着 5 种不同的阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-fcf20a7154d53893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod’s phases"></p><ul><li><code>Pending</code>：创建 Pod 对象后的初始化阶段。会一直持续到 Pod 被分配给某个工作节点，镜像被拉取到本地并启动</li><li><code>Running</code>：Pod 中至少一个容器处于运行状态</li><li><code>Succeeded</code>：对于不打算无限期运行的 Pod，其容器部署完成后的状态</li><li><code>Failed</code>：对于不打算无限期运行的 Pod，其容器中至少有一个由于错误终止</li><li><code>Unknown</code>：由于 Kubelet 与 API Server 的通信中断，Pod 的状态未知。可能是工作节点挂掉或断网</li></ul><p>从 <code>kubia.yml</code> 清单文件创建一个 Pod。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><code>$ kubectl apply -f kubia.yml</code></p><p><strong>查看 Pod 的 Phase</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o yaml | grep phase</span></span><br><span class="line">  phase: Running</span><br></pre></td></tr></table></figure></p><p>或者借助 <code>jq</code> 工具从 JSON 格式的输出中检索 phase 字段：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.phase</span></span><br><span class="line">"Running"</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>kubectl describe</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Status:</span></span><br><span class="line">Status:       Running</span><br></pre></td></tr></table></figure></p><h5 id="Pod-conditions"><a href="#Pod-conditions" class="headerlink" title="Pod conditions"></a>Pod conditions</h5><p>Pod 的 conditions 用来表示某个 Pod 是否达到了特定的状态以及达到或未达到的原因。<br>与 phase 相反，一个 Pod 可以同时有几个 conditions。</p><ul><li><code>PodScheduled</code>：表明 Pod 是否已经被安排给了某个工作节点</li><li><code>Initialized</code>：Pod 的初始化容器已经部署完成</li><li><code>ContainersReady</code>：Pod 中的所有容器都已经准备完毕</li><li><code>Ready</code>：Pod 自身已经准备好对其客户端提供服务</li></ul><p><strong>查看 Pod 的 conditions</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Conditions: -A5</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br></pre></td></tr></table></figure></p><p><code>kubectl describe</code> 命令只会显示每个 condition 是 <code>true</code> 还是 <code>false</code>，不会显示更详细的信息。<br>为了显示某个 condition 为 false 的具体原因，需要检索 Pod 的清单文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.conditions</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Initialized"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Ready"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "ContainersReady"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "PodScheduled"</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>当 condition 为 <code>false</code> 时，上述输出中会包含 <code>reason</code> 和 <code>message</code> 字段来显示失败的具体原因和详细信息。</p><h5 id="容器的-status"><a href="#容器的-status" class="headerlink" title="容器的 status"></a>容器的 status</h5><p>容器的 status 包含多个字段。其中 <code>state</code> 字段表示该容器当前的状态，<code>restartCount</code> 表示容器重启的频率，此外还有 <code>containerID</code>、<code>image</code>、<code>imageID</code> 等。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2425c752e41b4cc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Container status"></p><p>容器的 status 包含以下几种：</p><ul><li><code>Waiting</code>：容器等待启动。<code>reason</code> 和 <code>message</code> 字段会记录容器处于此状态的原因</li><li><code>Running</code>：容器已经创建，进程正在运行</li><li><code>Terminated</code>：容器中运行的进程已经终止。<code>exitCode</code> 字段会记录进程的退出码</li><li><code>Unknown</code>：容器的状态无法确定</li></ul><p>比如修改 <code>kubia.yml</code> 清单文件中的 <code>image</code> 字段，故意改成 <code>uksa/kubia:1.0</code> 这样无效的地址，运行 <code>kubectl apply -f kubia.yml</code> 命令重新应用清单文件。<br>等待几分钟直到新的配置生效，查看容器的状态。</p><p>可以使用 <code>kubectl describe</code> 命令查看容器的状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Containers: -A15</span></span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91</span><br><span class="line">    Image:          uksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Waiting</span><br><span class="line">      Reason:       ImagePullBackOff</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Fri, 31 Dec 2021 14:50:39 +0800</span><br><span class="line">      Finished:     Fri, 31 Dec 2021 14:51:36 +0800</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl get po kubia -o json</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.containerStatuses</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">    "image": "luksa/kubia:1.0",</span><br><span class="line">    "imageID": "docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7",</span><br><span class="line">    "lastState": &#123;</span><br><span class="line">      "terminated": &#123;</span><br><span class="line">        "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">        "exitCode": 137,</span><br><span class="line">        "finishedAt": "2021-12-31T06:51:36Z",</span><br><span class="line">        "reason": "Error",</span><br><span class="line">        "startedAt": "2021-12-31T06:50:39Z"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "name": "kubia",</span><br><span class="line">    "ready": false,</span><br><span class="line">    "restartCount": 0,</span><br><span class="line">    "started": false,</span><br><span class="line">    "state": &#123;</span><br><span class="line">      "waiting": &#123;</span><br><span class="line">        "message": "Back-off pulling image \"uksa/kubia:1.0\"",</span><br><span class="line">        "reason": "ImagePullBackOff"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面输出中的 <code>state</code> 字段都表明了容器当前的状态是 <code>waiting</code>，还有 <code>reason</code> 和 <code>message</code> 字段表明处于此状态的原因：镜像拉取失败。</p><h4 id="确保容器的健康状态"><a href="#确保容器的健康状态" class="headerlink" title="确保容器的健康状态"></a>确保容器的健康状态</h4><h5 id="理解容器的自动重启机制"><a href="#理解容器的自动重启机制" class="headerlink" title="理解容器的自动重启机制"></a>理解容器的自动重启机制</h5><p>当一个 Pod 被分配给了某个工作节点，该工作节点上的 Kubelet 就会负责启动容器并保证该容器一直处于运行状态，只要该 Pod 对象一直存在没被移除。<br>如果容器中的主进程由于某些原因终止运行，Kubernetes 就会自动重启该容器。</p><p>创建如下内容的清单文件 <code>kubia-ssl.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>运行如下命令应用上述清单文件，并启用端口转发：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-ssl.yml</span></span><br><span class="line">pod/kubia-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-ssl 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>待容器启动成功后，访问 localhost 的 8080、8443、9901 端口就等同于访问容器中 8080、8443、9901 端口上运行的服务。</p><p>打开一个新的命令行窗口运行 <code>kubectl get pods -w</code> 命令，实时监控容器的运行状态。<br>打开一个新的命令行窗口运行 <code>kubectl get events -w</code> 命令，实时监控触发的事件。</p><p>打开一个新的命令行窗口，尝试终止 Envoy 容器中运行的主进程。Envoy 容器 9901 端口上运行的服务刚好提供了一个管理接口，能够接收 HTTP POST 请求来终止进程：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST http://localhost:9901/quitquitquit</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时查看前两个窗口中的输出，负责监控容器状态的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -w</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-ssl   2/2     Running   0          11m</span><br><span class="line">kubia-ssl   1/2     NotReady   0          12m</span><br><span class="line">kubia-ssl   2/2     Running    1 (2s ago)   12m</span><br></pre></td></tr></table></figure></p><p>最新的输出表明，在杀掉 Envoy 容器中的主进程后，Pod 的状态是先变成 <code>NotReady</code>，之后就立即重启该容器，Pod 的状态稍后恢复成 <code>Running</code>。</p><p>负责监控最新事件的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get events -w</span></span><br><span class="line">LAST SEEN   TYPE     REASON      OBJECT          MESSAGE</span><br><span class="line">11m         Normal   Scheduled   pod/kubia-ssl   Successfully assigned default/kubia-ssl to minikube</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container kubia</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container kubia</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container envoy</span><br><span class="line">0s          Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">0s          Normal   Started     pod/kubia-ssl   Started container envoy</span><br></pre></td></tr></table></figure></p><p>最新的事件信息中包含了新的 envoy 容器启动的过程。其中有一个很重要的细节：<strong>Kubernetes 从来不会重启容器，而是直接丢弃停止的容器并创建一个新的</strong>。一般在 Kubernetes 中提及“重启”容器，实质上都指的是“重建”。<br><strong>任何写入到容器文件系统中的数据，在容器重新创建后都会丢失。为了持久化这些数据，需要向 Pod 添加 Volume</strong>。</p><p><strong>配置容器的重启策略</strong><br>Kubernetes 支持 3 种容器重启策略：</p><ul><li><code>Always</code>：默认配置。不管容器中主进程的退出码是多少，容器都会自动重启</li><li><code>OnFailure</code>：容器只会在退出码非 0 时重启</li><li><code>Never</code>：容器永不重启</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-469232db79083201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Restart policy"></p><p><strong>容器重启时的延迟时间</strong><br>第一次容器终止时，重启会立即触发。但容器第二次重启时会先等待 10s，这个等待时间会随着重启次数依次增加到 20、40、80、160s。再之后则一直保持在 5 分钟。<br>等待过程中容器会处于 <code>Waiting</code> 状态，<code>reason</code> 字段显示 <code>CrashLoopBackOff</code>，<code>message</code> 字段显示需要等待的时间。</p><h5 id="liveness-probes"><a href="#liveness-probes" class="headerlink" title="liveness probes"></a>liveness probes</h5><p>Kubernetes 会在容器的进程终止时重启容器，以保证应用的健康。但应用实际上有可能在进程不终止的情况下无响应，比如一个 Java 应用报出 OutOfMemoryError 错误，而 JVM 进程仍在运行中。<br>理想情况下，Kubernetes 需要能够检测到此类错误并重启容器。</p><p>当然，应用自身也可以捕获这类错误并令进程立即终止。但假如应用因为进入无限循环或死锁导致无响应，又或者应用本身无法检测到错误存在呢？<br>为了确保容器能够在这些复杂情况下重启，应该提供一种从外部检查应用状态的机制。</p><p><strong>liveness probe 介绍</strong><br>Kubernetes 可以通过配置 liveness probe 来检查某个应用是否能够正常响应，Pod 中的每个容器都可以分别配置 liveness probe。一旦应用无响应或有错误发生，容器就会被认为是不健康的并被终止掉。之后容器被 Kubernetes 重新启动。</p><p>Kubernetes 支持以下三种 probe 机制：</p><ul><li><code>HTTP GET probe</code>：会发送 GET 请求到容器的 IP 地址、端口号和 URL 路径。如果 probe 收到正常的响应（2xx 或 3xx），该 probe 就被认定是成功的。如果服务返回了一个错误的响应码，或者没有在规定的时间内响应，则该 probe 被认定是失败的。</li><li><code>TCP Socket probe</code>：会尝试打开一个 TCP 连接到容器的特定端口。若连接成功，probe 就被认定是成功的；否则失败。</li><li><code>Exec probe</code>：会在容器内部执行一个命令并检查该命令的退出码。若退出码为 0，则 probe 被认定是成功的；否则失败。</li></ul><p><strong>HTTP GET liveness probe</strong><br>创建如下内容的 <code>kubia-liveness.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>其中 kubia 容器的 liveness probe 是最简单版本的 HTTP 应用的 probe。该 probe 只是向 8080 端口的 <code>/</code> 路径发送 HTTP GET，看容器是否仍然能够处理请求。当应用的响应码介于 200 到 399 之间时，该应用就被认为是健康的。<br>由于该 probe 没有配置其他选项，默认配置生效。第一次检查请求会在容器启动 10s 后发起，之后每隔 10s 发起新的请求。若应用没有在 1s 之内响应，则该次 probe 请求被认定是失败的。连续 3 次请求失败以后，容器就被认为是不健康的并被终止掉。</p><p>Envoy 容器的管理员接口提供了一个 <code>/ready</code> 入口，可以返回其健康状态，因此 envoy 容器的 liveness probe 的目标可以是容器的 <code>admin</code> 端口即 9901。<br>参数 <code>initialDelaySeconds</code> 表示容器启动后到发起第一个检测请求之间的等待时间，<code>periodSeconds</code> 表示两次连续的检测请求之间的时间间隔，<code>timeoutSeconds</code> 表示多长时间以后没有响应则认定此次检测失败，<code>failureThreshold</code> 则表示连续多少次检测失败以后才认定容器失效并重启。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-659b273518b2d676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="liveness probe"></p><p><strong>观察 liveness probe 的效果</strong><br>运行 <code>kubectl apply</code> 命令应用上述清单文件并通过 <code>kubectl port-forward</code> 命令启用端口转发，启动该 Pod 并令其能够被访问：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-liveness.yml</span></span><br><span class="line">pod/kubia-liveness created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-liveness 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>Pod 启动成功以后，liveness probe 会在初始等待时间过后持续向 Pod 中的容器发起检测请求，其检测结果只会在容器的 log 中看到。<br>kubia 容器中的 Node.js 应用会在每次处理 HTTP 请求时向标准输出打印记录，这些请求也包括 liveness probe 的检测请求。因此可以打开一个新的命令行窗口，使用如下命令查看请求记录：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-liveness -c kubia -f</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia-liveness</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>envoy 容器的 liveness probe 被配置成向其管理员接口发送 HTTP 请求，这些请求被记录在 <code>/var/log/envoy.admin.log</code> 文件中。可以使用如下命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-liveness -c envoy -- tail -f /var/<span class="built_in">log</span>/envoy.admin.log</span></span><br><span class="line">[2022-01-02T18:34:59.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:04.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:09.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:14.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br></pre></td></tr></table></figure></p><p><strong>观察失败的 liveness probe</strong><br>可以尝试手动令 liveness probe 的检测请求失败。先在一个新的窗口中运行 <code>kubectl get events -w</code> 命令，方便后续观察检测失败时输出的事件信息。<br>访问 Envoy 容器的管理员接口，手动配置其健康状态为 <code>fail</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST localhost:9901/healthcheck/fail</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时转到观察事件信息的命令行窗口，发现连续输出了 3 次 probe failed 503 错误，之后 envoy 容器开始重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get events -w</span><br><span class="line">LAST SEEN   TYPE      REASON          OBJECT               MESSAGE</span><br><span class="line">...</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Normal    Killing         pod/kubia-liveness   Container envoy failed liveness probe, will be restarted</span><br><span class="line">0s          Normal    Pulled          pod/kubia-liveness   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal    Created         pod/kubia-liveness   Created container envoy</span><br><span class="line">0s          Normal    Started         pod/kubia-liveness   Started container envoy</span><br></pre></td></tr></table></figure></p><h5 id="exec-amp-tcpSocket-liveness-probe"><a href="#exec-amp-tcpSocket-liveness-probe" class="headerlink" title="exec &amp; tcpSocket liveness probe"></a>exec &amp; tcpSocket liveness probe</h5><p><strong>添加 tcpSocket liveness probe</strong><br>对于接收非 HTTP 请求的应用，可以配置 tcpSocket liveness probe。<br>一个 tcpSocket liveness probe 的示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  tcpSocket:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">1234</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>该 probe 会检查容器的 1234 端口是否打开，每隔 2s 检查一次，一次检查失败则认定该容器是不健康的并重启它。</p><p><strong>exec liveness probe</strong><br>不接受 TCP 连接的应用可以配置一条命令去检测其状态。<br>下面的示例配置会每隔 2s 运行 <code>/usr/bin/healthcheck</code> 命令，检测容器中的应用是否仍在运行：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  exec:</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/usr/bin/healthcheck</span></span><br><span class="line"><span class="attr">  periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h5 id="startup-probe"><a href="#startup-probe" class="headerlink" title="startup probe"></a>startup probe</h5><p>默认的 liveness probe 配置会给应用 20 到 30s 的时间启动，如果应用需要更长的时间才能启动完成，容器会永远达不到 liveness probe 检测成功的状态，从而进入了无限重启的循环。<br>为了防止上述情况发生，可以增大 <code>initialDelaySeconds</code>、<code>periodSeconds</code> 或 <code>failureThreshold</code> 的值，但也会有一定的副作用。<code>periodSeconds * failureThreshold</code> 的值越大，当应用不健康时重启的时间就越长。</p><p>Kubernetes 还提供了一种 startup probe。当容器配置了 startup probe 时，容器启动时只有 startup probe 会执行。startup probe 可以按照应用的启动时间配置，检测成功之后 Kubernetes 会切换到使用 liveness probe 检测。<br>比如 Node.js 应用需要 1 分钟以上的时间启动，当启动成功以后若应用状态不正常，则在 10s 以内重启。可以这样配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  startupProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">  livenessProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>上面配置的效果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0958a2c039bc32f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startup probe &amp; liveness probe"></p><p>应用有 120s 的时间启动。Kubernetes 一开始每隔 10s 发起 startup probe 请求，最多尝试 12 次。<br>不同于 liveness probe，startup probe 失败是很正常的，只是说明应用还未成功启动。一旦某次 startup probe 检测返回成功状态，Kubernetes 就会立即切换到 liveness probe 模式，通常拥有更短的检测间隔，能够对未响应应用做出更快速的反应。</p><h4 id="在容器启动或关闭时触发动作"><a href="#在容器启动或关闭时触发动作" class="headerlink" title="在容器启动或关闭时触发动作"></a>在容器启动或关闭时触发动作</h4><p>可以向容器中添加 lifecycle hooks。Kubernetes 目前支持两种类型的钩子：</p><ul><li>Post-start hooks：在容器启动后执行</li><li>Pre-stop hooks：在容器停止前执行</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-77db56c2b1e8d783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lifecycle hooks"></p><h5 id="post-start-hooks"><a href="#post-start-hooks" class="headerlink" title="post-start hooks"></a>post-start hooks</h5><p>post-start lifecycle hook 会在容器创建完成之后立即触发。可以使用 <code>exec</code> 类型的钩子在主进程启动的同时执行一个额外的程序，或者 <code>httpGet</code> 类型的钩子向容器中运行的应用发送 HTTP 请求，以完成初始化或预热操作。<br>假如你是应用的作者，类似的操作当然可以加入到应用本身的代码中。但对于一个已经存在的并非自己创建的应用，就有可能无法做到。post-start hook 提供了一种不需要修改应用或容器镜像的替代方案。</p><p><strong>post-start hook 在容器中执行命令</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-poststart</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>上述清单文件定义的 Pod 名为 <code>fortune-poststart</code>，包含一个基于 <code>nginx:alpine</code> 镜像的容器，同时定义了一个 <code>postStart</code> 钩子。该钩子会在 Nginx 服务启动时执行以下命令：<br><code>sh -c &quot;apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote&quot;</code></p><p><code>postStart</code> 这个名称其实有些误导作用，它并不是在主进程完全启动后才开始执行，而是在容器创建后，几乎和主进程同时执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-poststart.yml</span></span><br><span class="line">pod/fortune-poststart unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward fortune-poststart 8080:80</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure><p>打开一个新的命令行窗口使用 <code>curl</code> 命令测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080/quote</span></span><br><span class="line">The Official MBA Handbook on business cards:</span><br><span class="line">        Avoid overly pretentious job titles such as "Lord of the Realm,</span><br><span class="line">        Defender of the Faith, Emperor of India" or "Director of Corporate</span><br><span class="line">        Planning."</span><br></pre></td></tr></table></figure></p><p><strong>post-startup hook 对容器的影响</strong><br>虽然 post-start hook 相对于容器的主进程以异步的方式执行，它还是会对容器产生两个方面的影响。<br>首先，在 post-start hook 的执行过程中容器会一直处于 <code>Waiting</code> 状态，原因显示为 <code>ContainerCreating</code>，直到 hook 执行完毕。<br>其次，若 hook 绑定的命令无法执行或返回了一个非零的状态值，则整个容器会被重启。</p><h5 id="在容器终止前执行命令"><a href="#在容器终止前执行命令" class="headerlink" title="在容器终止前执行命令"></a>在容器终止前执行命令</h5><p>前面 fortune Pod 中的 Nginx 服务在收到 <code>TERM</code> 信号后会立即关闭所有打开的连接并终止进程，这并不是理想的操作，不会等待正在处理的客户端请求彻底完成。<br>可以使用 pre-stop hook 执行 <code>nginx -s quit</code> 命令舒缓地关闭 Nginx 服务。示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line"><span class="attr">  preStop:</span></span><br><span class="line"><span class="attr">    exec:</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">nginx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">-s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">quit</span></span><br></pre></td></tr></table></figure></p><p>假如某个 pre-stop hook 执行失败，只会在 Pod 的 events 消息中显示一条 <code>FailedPreStopHook</code> 警告信息，并不影响容器继续被终止。</p><h4 id="理解容器的生命周期"><a href="#理解容器的生命周期" class="headerlink" title="理解容器的生命周期"></a>理解容器的生命周期</h4><p>一个 Pod 的生命周期可以被分成如下三个阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2cd22a41e5907b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod 生命周期的三个阶段"></p><ul><li>初始化阶段：Pod 的 init 容器从开始运行到启动完成</li><li>运行阶段：Pod 的普通容器从开始运行到启动完成</li><li>终止阶段：Pod 的所有容器被终止运行</li></ul><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><p>Pod 中的初始化容器会最先运行，按照 <code>spec</code> 的 <code>initContainers</code> 字段中定义的顺序。<br>第一个初始化容器的镜像被下载到工作节点并启动，完成后继续拉取第二个初始化容器的镜像，直到所有的初始化容器都成功运行。<br>若某个初始化容器因为某些错误启动失败，且其重启策略设置为 <code>Always</code> 或 <code>OnFailure</code>，则该失败的容器自动重启。若其重启策略设置为 <code>Never</code>，则 Pod 的状态显示为 <code>Init:Error</code>，必须删除并重新创建 Pod 对象。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-84a2ee1a08b66cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="All init containers must run to completion before the regular containers can start"></p><h5 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h5><p>当所有的初始化容器成功运行后，Pod 的普通容器开始以<strong>并行</strong>的方式创建（需要注意的是，容器的 post-start hook 会阻塞下一个容器的创建）。</p><p><strong>termination grace period</strong><br>容器中的应用都有一个固定的关闭时间做缓冲用，定义在 <code>spec</code> 下的 <code>terminationGracePeriodSeconds</code> 字段中，默认是 30s。<br>该时间从 pre-stop hook 触发或收到 <code>TERM</code> 信号时开始计算，若时间过了进程仍在运行，应用会收到 <code>KILL</code> 信号被强制关闭。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-63ea58db03568a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container’s termination sequence"></p><h5 id="终止阶段"><a href="#终止阶段" class="headerlink" title="终止阶段"></a>终止阶段</h5><p>Pod 的容器以并行的方式终止。对每个容器来说，pre-stop hook 触发，然后主进程接收 <code>TERM</code> 信号，如果应用关闭的时间超过了 <code>terminationGracePeriodSeconds</code>，就发送 <code>KILL</code> 信号给容器的主进程。<br>在所有的容器都被终止以后，Pod 对象被删除。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-3d36f79107e20ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="termination sequence inside a pod"></p><p>可以在删除一个 Pod 时手动指定一个新的时间覆盖 <code>terminationGracePeriodSeconds</code> 的值，如：<br><code>kubectl delete po kubia-ssl --grace-period 10</code></p><h5 id="Pod-完整生命周期图示"><a href="#Pod-完整生命周期图示" class="headerlink" title="Pod 完整生命周期图示"></a>Pod 完整生命周期图示</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8da03ba0126724f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化阶段"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8fc4e425cb34fcd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行阶段和终止阶段"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;理解-Pod-的状态&quot;&gt;&lt;a href=&quot;#理解-Pod-的状态&quot; class=&quot;headerlink&quot; title=&quot;理解 Pod 的状态&quot;&gt;&lt;/a&gt;理解 Pod 的状态&lt;/h4&gt;&lt;h5 id=&quot;Pod-phase&quot;&gt;&lt;a href=&quot;#Pod-phase&quot; c
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 深入了解 Pod 概念</title>
    <link href="https://rollingstarky.github.io/2021/12/29/kubernetes-in-action-reading-notes-understanding-pods/"/>
    <id>https://rollingstarky.github.io/2021/12/29/kubernetes-in-action-reading-notes-understanding-pods/</id>
    <published>2021-12-28T16:00:00.000Z</published>
    <updated>2021-12-28T16:33:54.248Z</updated>
    
    <content type="html"><![CDATA[<p>下图展示了 Kubernetes 如何通过 Deployment、Pod、Service 三种对象部署一个最小化应用。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-74a8e16f03a556f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Three basic objects comprising a deployed application"></p><p>其中的 Pod 对象是 Kubernetes 中最重要的一个核心概念，它代表着一个处于运行状态的应用实例。</p><h4 id="理解-Pods"><a href="#理解-Pods" class="headerlink" title="理解 Pods"></a>理解 Pods</h4><p>Pod 可以包含一个或多个有协作关系的容器，是 Kubernetes 中最基本的构造单位。</p><ul><li>容器只能借助 Pod 进行部署，无法独立运行</li><li>一个 Pod 可以包含多个容器，但只包含一个容器的 Pod 也是很常见的</li><li>Pod 中的多个容器只允许在同一个工作节点上运行，即单个 Pod 不能跨节点部署</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f32a9b5c16f87b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods"></p><h5 id="Pod-机制的优势"><a href="#Pod-机制的优势" class="headerlink" title="Pod 机制的优势"></a>Pod 机制的优势</h5><p>为什么要在一个 Pod 中运行多个容器，而不是在一个容器中运行多个进程。</p><p><strong>一个容器不应该包含多个进程</strong><br>容器就像是一台隔离的虚拟机，因此是可以同时运行多个进程的。但这样会使得容器难于管理。<br>容器被设计成只会运行一个进程（子进程不计算在内），大多数容器管理工具也都是基于这个原则去设计的。<br>比如容器中运行的进程有时候会向标准输出打印其日志信息，Kubernetes 中查看日志的命令就只会显示从这个输出中捕获到的内容。如果容器中同时运行多个进程，都向外输出日志信息，Kubernetes 捕获到的日志内容就会变得错综复杂。</p><p>另一个原因在于，容器运行时只会在容器的根进程挂掉时重启该容器。<br>为了充分利用容器运行时提供的特性，应该在每个容器中只运行一个进程。</p><p><strong>Pod 如何组合多个容器</strong><br>不应该在同一个容器中运行多个进程。与此同时，将分散在多个容器中相互关联的进程结合成一个单位，统一进行管理也是很有必要的。<br>因此引入了 Pod 机制。</p><p>Pod 可以同时运行多个关系紧密的进程（容器），给它们（几乎）相同的运行环境，使得它们就像是运行在同一个容器中那样。<br>这些进程是相互独立、隔离的，但也会共享某些资源。因而既可以使用容器提供的各种隔离特性，又能够促使多个进程相互协作。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-96652ef6b6588fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod share network interface"></p><p>如上图所示，Pod 中的多个容器共享同一个 Network 命名空间，因而共享该命名空间的网络接口、IP 地址、端口空间等。这些容器能够使用 loopback 设备进行通信，但不能绑定同一个网络端口。</p><p>同一个 Pod 中的多个容器还会共享相同的 UTS 命名空间，因而能看到同一个主机名；共享相同的 IPC 命名空间，因而不同容器中的多个进程之间可以通过 IPC 进行通信；还可以配置成共享同一个 PID 命名空间，使得这些容器中的进程使用同一个进程树。<br>与前面的内容相反，每个 Pod 总是有自己的 Mount 命名空间，这意味着每个 pod 都有自己的文件系统。当然，假如 Pod 中有两个容器需要共享部分文件系统，也可以向该 Pod 添加 Volume，作为共享存储挂载到每一个容器上。</p><h5 id="单容器-or-多容器"><a href="#单容器-or-多容器" class="headerlink" title="单容器 or 多容器"></a>单容器 or 多容器</h5><p>可以将 Pod 看作一台独立的计算机。不同于虚拟机通常需要同时运行多个应用，每个 Pod 中一般只运行一个应用。 Pod 几乎没有额外的资源开销，因而在同一个 Pod 中运行多个应用并不是必须的。</p><p>假如一个系统的前端和后端运行在同一个 Pod 中，而单个 Pod 不能跨节点存在（即单个 Pod 只能部署在某一个节点上）。如果你有一个双节点的集群且只创建了一个 Pod，则该 Pod 只会运行在其中一个节点上，造成 CPU、内存、存储和带宽等资源的闲置。<br>将前后端分别部署到不同的 Pod 中则能够提高硬件的利用率。</p><p>另一个不将多个应用部署到同一个 Pod 中的原因与横向扩展有关。<strong>Pod 不仅仅是部署的基本单位，也是扩展的基本单位</strong>。<br>当通过修改 Deployment 对象扩展应用时，Kubernetes 并不会复制 Pod 中的容器，而是直接创建新的 Pod 实例（应用副本）。<br>前端和后端组件通常有着不同的扩展需求，基本上都会独立地进行扩展。而同一个 Pod 中不同组件的扩展是同步的。如果一个容器中的某个组件相对于其他组件需要独立地进行扩展，该应用就必须部署在另一个 Pod 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-654d7387ed98ca4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Splitting application"></p><p>将多个容器放置在同一个 Pod 中的唯一场景，就是某个应用包含一个基础进程以及一个或者多个对基础进程有补充作用的附加进程。运行附加进程称为 <em>sidecar container</em>。</p><p>比如某个 Pod 包含一个运行 Node.js 应用的容器，而该 Node.js 应用只支持 HTTP 协议。为了令其支持 HTTPS，可以对 JavaScript 代码做一些小的改动。其实也可以在不改动应用代码的情况下完成此需求。<br>只需要向 Pod 中再添加一个反向代理容器，将 HTTPS 流量转发成 HTTP 传给 Node.js 容器。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d44dbea66eecf68d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sidecar container that converts HTTPS traffic to HTTP"></p><p>另一个例子如下图所示，基础容器运行一个 Web 服务，其资源文件存放在挂载的 Volume 上。Pod 中的另一个容器则挂载了同一个 Volume，作为 Agent 定期从外部拉取新的资源文件，存储在 Volume 供 Web 服务使用。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1589f4979d504c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sidecar container that delivers content to the web server container via a volume"></p><h4 id="从-YAML-文件创建-Pod"><a href="#从-YAML-文件创建-Pod" class="headerlink" title="从 YAML 文件创建 Pod"></a>从 YAML 文件创建 Pod</h4><p>可以使用 <code>kubectl create</code> 命令创建 Pod 对象（<a href="https://www.jianshu.com/p/7bc34ff88d9d" target="_blank" rel="noopener">Kubernetes in Action 笔记 —— 部署第一个应用</a>），但更常见的方式是创建一个 JSON 或 YAML 格式的清单文件，描述整个应用的架构，再将其发送给 Kubernetes API 来生成 Pod 等对象。</p><p>比如下面的 <code>kubia.yml</code> 文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    images:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><strong>创建 Pod 对象</strong><br>可以使用 <code>kubectl apply -f xxx.yml</code> 命令将清单文件发送给 API 并应用到 Kubernetes 集群：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia.yml</span></span><br><span class="line">pod/kubia created</span><br></pre></td></tr></table></figure></p><p><code>kubectl apply</code> 命令不仅仅用于创建对象，同时也可以对现有的对象进行修改。<br>比如 Pod 对象创建之后需要对其做一些改动，可以直接编辑 <code>yml</code> 文件，再运行一遍 <code>kubectl apply</code> 命令即可。但有些描述 Pod 的字段是不可变的，因而更新操作有可能会失败，此时就可以先删除后再重建。</p><p><strong>检查新创建的 Pod</strong><br>使用 <code>kubectl get pod</code> 命令获取某个 Pod 的汇总信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia   1/1     Running   0          6m37s</span><br></pre></td></tr></table></figure></p><p>想获取更详细一点的信息可以加上 <code>-o wide</code> 选项：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia -o wide</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia   1/1     Running   0          8m3s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl describe pod</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod kubia</span></span><br><span class="line">Name:         kubia</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.49.2</span><br><span class="line">Start Time:   Fri, 24 Dec 2021 15:08:57 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.3</span><br><span class="line">IPs:</span><br><span class="line">  IP:  172.17.0.3</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://aa8778766a69122de8c8b401922d2318b15b8aaf220945d747e494de2fda9199</span><br><span class="line">    Image:          luksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  9m28s  default-scheduler  Successfully assigned default/kubia to minikube</span><br><span class="line">  Normal  Pulled     9m27s  kubelet            Container image "luksa/kubia:1.0" already present on machine</span><br><span class="line">  Normal  Created    9m27s  kubelet            Created container kubia</span><br><span class="line">  Normal  Started    9m27s  kubelet            Started container kubia</span><br></pre></td></tr></table></figure></p><h4 id="与-Pod-进行交互"><a href="#与-Pod-进行交互" class="headerlink" title="与 Pod 进行交互"></a>与 Pod 进行交互</h4><h5 id="向-Pod-中的应用发起请求"><a href="#向-Pod-中的应用发起请求" class="headerlink" title="向 Pod 中的应用发起请求"></a>向 Pod 中的应用发起请求</h5><p>可以使用 <code>kubectl expose</code> 命令创建一个 Service 对象，给 Pod 分配一个负载均衡器，从而可以从外部访问 Pod 中运行的应用。但是对于开发、测试和调试等目的，有可能需要直接与 Pod 中的应用进行交互。<br>每个 Pod 都会自动绑定一个 IP 地址，从而可以被集群中的其他 Pod 访问，但该 IP 地址是仅限于集群内部的。</p><p><strong>获取 Pod 的 IP 地址</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia -o wide</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia   1/1     Running   0          58m   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p><strong>从工作节点连接 Pod</strong><br>Kubernetes 的网络模型支持从任意节点直接访问集群中所有节点上的任何 Pod。因而可以先登录某一个工作节点，再从该节点访问集群中的 Pod。<br>对于 Minikube 而言，可以使用 <code>minikube ssh</code> 命令登录工作节点。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube ssh</span></span><br><span class="line">docker@minikube:~$</span><br></pre></td></tr></table></figure></p><p>登录成功后，即可使用内部 IP 地址访问 kubia Pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker@minikube:~$ curl 172.17.0.3:8080</span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><h5 id="One-off-客户端-Pod"><a href="#One-off-客户端-Pod" class="headerlink" title="One-off 客户端 Pod"></a>One-off 客户端 Pod</h5><p>第二种测试应用连通性的方法是创建一个临时的 Pod 并运行 <code>curl</code> 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl run --image=curlimages/curl -it --restart=Never --rm client-pod curl 172.17.0.2:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:172.17.0.4.</span><br><span class="line">pod "client-pod" deleted</span><br></pre></td></tr></table></figure></p><p>上面的命令会从 <code>curlimages/curl</code> 镜像创建一个容器，执行 <code>curl 172.17.0.2:8080</code> 命令。<br>其中 <code>-it</code> 选项会将当前的终端与容器的标准输入输出绑定，<code>--restart=Never</code> 选项确保 <code>curl</code> 命令执行完后容器直接停掉，<code>--rm</code> 选项负责在最后删除 Pod。</p><p>这种方式在测试 Pod 与 Pod 之间连通性的时候非常有用。</p><p><strong>通过 Kubectl 端口转发访问 Pod</strong><br>在开发过程中，最简单的访问容器中应用的方法是使用 <code>kubectl port-forward</code> 命令。该命令可以通过绑定到本地机器端口上的代理来访问特定的 Pod。<br>此方式甚至不需要知道 Pod 的 IP 地址，只需要指定 Pod 的名字和端口号即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia 8080</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br></pre></td></tr></table></figure></p><p>上述命令会在本地机器的 8080 端口开启一个代理，指向 kubia 容器的 8080 端口。<br>此时打开另一个命令行窗口，运行 <code>curl localhost:8080</code> 命令即等同于访问 kubia 容器的 8080 端口：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6a79ebdee7b3a1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl port-forward 的底层机制"></p><h5 id="查看应用日志"><a href="#查看应用日志" class="headerlink" title="查看应用日志"></a>查看应用日志</h5><p>不同于将日志写入到文件中，容器化应用通常会将日志输出到标准输出（stdout）和标准错误输出（stderr）。这使得容器运行时能够拦截应用的日志输出，将其转存在固定的位置（通常是 <code>/var/log/containers</code>），而不需要知道容器中日志文件的保存位置。<br>当使用 Kubernetes 运行应用时，可以登录到工作节点通过 <code>docker logs</code> 命令查看应用的日志，但更简单的方式是直接在本地使用 <code>kubectl logs</code> 命令。</p><p><strong>获取某个 Pod 的日志</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.4</span><br><span class="line">Received request for / from ::ffff:172.17.0.4</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br></pre></td></tr></table></figure></p><p>加上 <code>-f (--follow)</code> 选项可以实时显示日志输出。</p><p><strong>在日志输出中显示时间戳</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia --timestamps=<span class="literal">true</span></span></span><br><span class="line">2021-12-27T13:40:21.606420000Z Kubia server starting...</span><br><span class="line">2021-12-27T13:40:21.606992200Z Local hostname is kubia</span><br><span class="line">2021-12-27T13:40:21.607003000Z Listening on port 8080</span><br><span class="line">2021-12-27T13:43:11.228907300Z Received request for / from ::ffff:172.17.0.1</span><br><span class="line">2021-12-27T13:47:45.648686300Z Received request for / from ::ffff:172.17.0.1</span><br><span class="line">2021-12-27T13:59:16.819436200Z Received request for / from ::ffff:172.17.0.4</span><br><span class="line">2021-12-27T14:01:19.101277000Z Received request for / from ::ffff:172.17.0.4</span><br><span class="line">2021-12-27T14:34:40.145715500Z Received request for / from ::ffff:127.0.0.1</span><br></pre></td></tr></table></figure></p><p>此外还可以根据时间筛选日志输出，比如只显示最近一段时间内的日志。<br><code>kubectl logs kubia --since=2h</code> 显示最近 2 小时内输出的日志内容。</p><p>也可以通过 <code>--since-time</code> 选项筛选特定时间后输出的日志：<br><code>kubectl logs kubia –-since-time=2020-02-01T09:50:00Z</code></p><p>或者直接使用 <code>--tail=n</code> 选项显示最近的 n 条日志。</p><p><strong>PS</strong><br>Kubernetes 会为每一个容器都保留一个独立的日志文件。它们通常保存在容器运行节点的 <code>/var/log/containers</code> 路径下，容器重启后其日志会写入到一个新的文件中。</p><p>如果某些容器应用将其日志写入到文件中而不是 stdout，理想情况下，应该配置一个中心化的日志系统定期收集这些日志。<br>如果只是想简单地手动访问容器中的日志文件，可以参考后面的内容。</p><h5 id="容器的文件传输"><a href="#容器的文件传输" class="headerlink" title="容器的文件传输"></a>容器的文件传输</h5><p>有些时候需要向运行的容器中添加文件，或者从容器中获取文件。虽然修改容器中的文件的场景并不多见（尤其在生产环境中），但在开发过程中还是有一定用处的。</p><p>Kubernetes 提供了 <code>cp</code> 命令，能够从本地磁盘复制文件或目录到任意 Pod，或者相反方向。<br><code>kubectl cp kubia:/etc/hosts /tmp/kubia-hosts</code> 将 kubia 容器中的 <code>/etc/hosts</code> 文件复制到本地 <code>/tmp</code> 路径下。</p><p><code>kubectl cp /path/to/local/file kubia:path/in/container</code> 将本地文件复制到 kubia 容器。</p><h5 id="在运行的容器中执行命令"><a href="#在运行的容器中执行命令" class="headerlink" title="在运行的容器中执行命令"></a>在运行的容器中执行命令</h5><p><strong>运行单个命令</strong><br>可以使用 <code>kubernetes exec</code> 命令运行容器文件系统中的某个可执行文件。<br>用户远程执行命令，无需登录到对应的工作节点上。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- ps aux</span></span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2 564436 30216 ?        Ssl  13:40   0:00 node app.js</span><br><span class="line">root          13  5.0  0.0  36632  2660 ?        Rs   15:54   0:00 ps aux</span><br></pre></td></tr></table></figure></p><p>前面的章节中曾经通过一个 one-off 客户端容器运行 <code>curl</code> 命令，向应用发送请求。实际上也可以直接在应用容器中运行 <code>curl</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s localhost:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><strong>开启一个交互式 Shell</strong><br>如果想要交互式地在容器中运行多条命令，可以开启一个 Shell：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it kubia -- bash</span></span><br><span class="line">root@kubia:/#</span><br></pre></td></tr></table></figure></p><p>之后就可以像在本地运行 Linux 命令一样在容器中执行命令了。</p><p>需要注意的是，为了保证容器的镜像足够小同时提高安全性，生产环境中使用的容器通常只包含运行应用所需要的可执行文件。这会大大减少潜在的攻击目标，同时也意味着用户无法使用 Shell 或其他 Linux 工具。</p><h4 id="在-Pod-中运行多个容器"><a href="#在-Pod-中运行多个容器" class="headerlink" title="在 Pod 中运行多个容器"></a>在 Pod 中运行多个容器</h4><p>前面的 kubia 容器只支持 HTTP 协议，可以为其添加 TLS 支持。其实有一种简单的不需要修改现有代码的方案，就是在现有的 Node.js 容器旁边添加一个提供反向代理功能的 sidecar 容器。</p><p><strong>用 Envoy 代理扩展 kubia 应用</strong><br>简单来说，Pod 中包含两个容器，其中 Node.js 容器仍然负责处理 HTTP 请求，而新加的 Envoy 容器负责转发 HTTPS 请求。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-17bb086353f53de8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构示意图"></p><p>创建如下清单文件 <code>kubia-ssl.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>kubectl apply -f kubia-ssl.yml</code> 命令应用清单文件创建 Pod，之后等待创建完成即可。<br>可以运行 <code>kubectl describe pod kubia-ssl</code> 命令查看创建的进度。</p><p><strong>与两个容器的 Pod 进行交互</strong><br>使用 <code>kubectl port-forward</code> 命令启用端口转发：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-ssl 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>打开一个新的命令行窗口，使用 <code>curl</code> 命令测试与 kubia-ssl 应用的连通性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080</span></span><br><span class="line">Hey there, this is kubia-ssl. Your IP is ::ffff:127.0.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl https://localhost:8443 --insecure</span></span><br><span class="line">Hey there, this is kubia-ssl. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><strong>查看日志</strong><br>由于 kubia-ssl 包含两个容器，因此查看日志时需要使用 <code>--container</code> 或 <code>-c</code> 选项指定容器的名称。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-ssl -c kubia</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia-ssl</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-ssl -c envoy</span></span><br><span class="line">[2021-12-28 15:08:51.671][1][info][main] [source/server/server.cc:255] initializing epoch 0 (hot restart version=11.104)</span><br><span class="line">[2021-12-28 15:08:51.671][1][info][main] [source/server/server.cc:257] statically linked extensions:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl logs kubia-ssl --all-containers</code> 命令显示所有容器的日志</p><h4 id="删除-Pod-和其他对象"><a href="#删除-Pod-和其他对象" class="headerlink" title="删除 Pod 和其他对象"></a>删除 Pod 和其他对象</h4><p>删除 kubia Pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete pod kubia</span></span><br><span class="line">pod "kubia" deleted</span><br></pre></td></tr></table></figure></p><p><code>kubectl delete</code> 命令默认会等待删除操作彻底完成后才退出，可以加上 <code>--wait=false</code> 异步执行此命令。</p><p>删除清单文件中定义的对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete -f kubia-ssl.yml</span></span><br><span class="line">pod "kubia-ssl" deleted</span><br></pre></td></tr></table></figure></p><p>删除所有 Pod：<code>kubectl delete po --all</code><br>删除所有对象：<code>kubectl delete all --all</code></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下图展示了 Kubernetes 如何通过 Deployment、Pod、Service 三种对象部署一个最小化应用。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6875152-74a8e16f0
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="MicroService" scheme="https://rollingstarky.github.io/tags/MicroService/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Administration" scheme="https://rollingstarky.github.io/tags/Administration/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 部署第一个应用</title>
    <link href="https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/"/>
    <id>https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/</id>
    <published>2021-12-13T16:00:00.000Z</published>
    <updated>2021-12-14T14:28:49.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Minikube-amp-kubectl"><a href="#Minikube-amp-kubectl" class="headerlink" title="Minikube &amp; kubectl"></a>Minikube &amp; kubectl</h4><p><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube</a> 是一个能够在本地环境搭建 Kubernetes 集群的工具，支持 Windows、Linux 和 MacOS 等平台，由 Kubernetes 社区进行维护。<br>它通常在 Linux 虚拟机中运行 Kubernetes。如果宿主机是基于 Linux 的系统，也可以通过 Docker 实现。<br>即为了运行 Minikube，需要先安装 Hypervisor 比如 Virtualbox；对于 Linux 系统，也可以直接使用 Docker。</p><p>具体的安装配置步骤可以参考官方文档 <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">Getting Started Guide</a>。</p><p>kubectl 是一个命令行工具，能够向 Kubernetes 集群发送命令并执行，支持的功能包括部署应用、查询和管理资源、查看日志等。<br>安装步骤可参考官方文档 <a href="https://kubernetes.io/docs/tasks/tools/" target="_blank" rel="noopener">Install Tools</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-cd8f312f56764487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl"></p><h4 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h4><p>通常情况下，部署应用时要准备一个 JSON 或者 YAML 文件，里面包含对该应用的所有组件的描述信息，再把该描述文件应用到 Kubernetes 集群。<br>从演示的角度来看，也可以通过单行命令的方式部署简单的应用。</p><h5 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h5><p>可以使用 <code>kubectl create deployment</code> 命令部署应用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create deployment kubia --image=luksa/kubia:1.0</span></span><br><span class="line">deployment.apps/kubia created</span><br></pre></td></tr></table></figure></p><p>其中 <code>kubia</code> 表示创建的 <strong>deployment</strong> 对象的名称，<code>luksa/kubia:1.0</code> 指代需要使用的容器镜像。</p><p><code>kubia</code> 对象的存在告诉 Kubernetes <code>luksa/kubia:1.0</code> 容器必须运行在集群中。它定义了一种用户期待的状态，而 Kubernetes 负责确保实际的状态一定会满足该期望。</p><p><code>kubectl get deployment</code> 命令可以列出当前集群中存在的所有 deployment 对象及其状态。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deployment</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   0/1     1            0           5m17s</span><br></pre></td></tr></table></figure></p><h5 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h5><p>容器并不是 Kubernetes 中部署的最小单位。不同于直接部署独立的容器，Kubernetes 实际上会部署一组相互关联的容器，称为 <strong>pod</strong>。<br>pod 包含一组一个或一个以上关系密切的容器实例，同时运行在同一个工作节点上，并共享特定的 Linux 命名空间。<br>同一个 pod 中的容器共享相同的网络和 UTS 命名空间，因而共享同样的网络接口、IP 地址、端口空间和主机名等。也可以在描述文件中定义其他需要共享的命名空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8722b456a653d61a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pods"></p><p>每个 pod 都有自己的 IP、机器名、进程、网络接口以及其他资源。同一个 pod 中的容器都会将自己看作是 pod 中唯一运行的容器，它们并不能看到其他容器中的进程。</p><p>创建 Deployment 对象后就表示已经部署了 pod，Kubernetes 会基于 Deployment 对象创建一个或多个 pod。<br>可以使用 <code>kubectl get pods</code> 来列出系统中的 pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          41m</span><br></pre></td></tr></table></figure></p><p>如果某些 issue 导致 pod 运行失败，或者单纯想查看更多 pod 相关的信息，可以使用 <code>kubectl describe pod</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod</span></span><br><span class="line">Name:         kubia-767f9bc59d-77d2z</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.49.2</span><br><span class="line">Start Time:   Tue, 14 Dec 2021 11:16:58 +0800</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">              pod-template-hash=767f9bc59d</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.3</span><br><span class="line">IPs:</span><br><span class="line">  IP:           172.17.0.3</span><br><span class="line">Controlled By:  ReplicaSet/kubia-767f9bc59d</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://e9bd5cf8f2eb15959c08bc8f154742b7194030d8ce0f9e6290cd80fc21b48692</span><br><span class="line">    Image:          luksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Tue, 14 Dec 2021 11:26:25 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-n9n9b (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  kube-api-access-n9n9b:</span><br><span class="line">    Type:                    Projected (a volume that contains injected data from multiple sources)</span><br><span class="line">    TokenExpirationSeconds:  3607</span><br><span class="line">    ConfigMapName:           kube-root-ca.crt</span><br><span class="line">    ConfigMapOptional:       &lt;nil&gt;</span><br><span class="line">    DownwardAPI:             true</span><br><span class="line">QoS Class:                   BestEffort</span><br><span class="line">Node-Selectors:              &lt;none&gt;</span><br><span class="line">Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s</span><br><span class="line">                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  11m   default-scheduler  Successfully assigned default/kubia-767f9bc59d-77d2z to minikube</span><br><span class="line">  Normal  Pulling    11m   kubelet            Pulling image "luksa/kubia:1.0"</span><br><span class="line">  Normal  Pulled     115s  kubelet            Successfully pulled image "luksa/kubia:1.0" in 9m24.3380576s</span><br><span class="line">  Normal  Created    113s  kubelet            Created container kubia</span><br><span class="line">  Normal  Started    113s  kubelet            Started container kubia</span><br></pre></td></tr></table></figure></p><p>输出的最后就包含 pod 创建和启动时触发的一系列事件（Events）。</p><h5 id="Pods-的创建流程"><a href="#Pods-的创建流程" class="headerlink" title="Pods 的创建流程"></a>Pods 的创建流程</h5><ul><li>运行 <code>kubectl create deployment</code> 命令，向 Kubernetes API Server 发送 HTTP 请求，创建一个新的 Deployment 对象</li><li>之后 Kubernetes 创建一个新的 Pod 对象，该 Pod 对象被分配给某个工作节点</li><li>工作节点上的 Kubelet agent 得知新的 Pod 对象被创建，且分配给了自己。于是 Kubelet 控制 Docker 拉取特定的镜像并创建、运行容器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a4e1b15833234eb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deployment object to a running container"></p><h4 id="向外部暴露应用"><a href="#向外部暴露应用" class="headerlink" title="向外部暴露应用"></a>向外部暴露应用</h4><p>应用已经成功运行了，接下来就是控制它如何被外部访问。每个 pod 都会获得一个专属的 IP 地址，但该地址是只有集群内部可见的。为了使 pod 能够从外部访问，还需要创建一个 <strong>Service</strong> 对象。</p><p>Service 对象有好几种类型，其中一种 LoadBalancer 会生成一个外部的负载均衡器，令服务能够从集群外部访问。<br>可以使用 <code>kubectl expose</code> 命令创建 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl expose deployment kubia --<span class="built_in">type</span>=LoadBalancer --port 8080</span></span><br><span class="line">service/kubia exposed</span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl get svc</code> 命令查看当前系统中存在的 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          29d</span><br><span class="line">kubia        LoadBalancer   10.106.111.39   &lt;pending&gt;     8080:30077/TCP   2m28s</span><br></pre></td></tr></table></figure></p><p>创建 LoadBalancer 服务时，正常情况下 Kubernetes 会访问云服务提供商，令其创建负载均衡器并获取公共 IP。<br>Minikube 是本地模拟的集群环境，因而无法完成上述操作。kubia Service 的 EXTERNAL-IP 会一直处于 <pending> 状态。</pending></p><p>在没有获取到外部 IP 的情况下，minikube 可以使用下面的方法获取服务的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube service kubia --url</span></span><br><span class="line">🏃  Starting tunnel for service kubia.</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| NAMESPACE | NAME  | TARGET PORT |          URL           |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| default   | kubia |             | http://127.0.0.1:39529 |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">http://127.0.0.1:39529</span><br><span class="line">❗  Because you are using a Docker driver on linux, the terminal needs to be open to run it.</span><br></pre></td></tr></table></figure></p><p>打开一个新的命令行窗口，可以成功访问上面的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><h5 id="LoadBalancer-的创建流程"><a href="#LoadBalancer-的创建流程" class="headerlink" title="LoadBalancer 的创建流程"></a>LoadBalancer 的创建流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-847957263408bbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service object to LoadBalancer"></p><h4 id="横向扩展应用"><a href="#横向扩展应用" class="headerlink" title="横向扩展应用"></a>横向扩展应用</h4><p>在容器中部署应用的一个主要好处就是，横向扩展应用变得非常简单和直观。<br>可以使用下列命令扩展 kubia 应用，令其同时运行 3 个实例副本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl scale deployment kubia --replicas=3</span></span><br><span class="line">deployment.apps/kubia scaled</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deploy</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   3/3     3            3           3h58m</span><br></pre></td></tr></table></figure></p><p>此时共有 3 个 pod 实例运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          3h59m</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          3m56s</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          3m56s</span><br></pre></td></tr></table></figure></p><p>可以加上 <code>-o wide</code> 选项获取更详细的 pods 信息，比如 IP、运行的节点等：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          4h      172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          5m31s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          5m31s   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>再次访问 Service 的 URL，可以看到多次访问返回的信息并不一样，可以证实后台提供服务的 pod 并不是同一个，而是 3 个 pod 轮流接收请求并提供服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-rvsdq. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><p>负载均衡架构示意图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2ec179df5ff6687c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Load balancing"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>部署应用可以使用 <code>kubectl create deployment</code> 命令，暴露应用使用 <code>kubectl expose deployment</code> 命令，横向扩展应用使用 <code>kubectl scale deployment</code> 命令。</li><li>应用部署的基本单位不是容器而是 pod，一个 pod 可以包含一个或多个相互关联的容器。</li><li>Deployments、Services、Pods 和 Nodes 都是 Kubernetes 对象/资源。可以使用 <code>kubectl get</code> 命令获取这些对象的列表，或者使用 <code>kubectl describe</code> 命令获取对象的详细信息。</li><li>Deployment 对象负责部署指定数量的 pods。Services 对象则可以令这些 pods 能够通过一个单一的 IP 地址访问。</li><li>Service 在集群内部提供负载均衡。如果指定其类型为 LoadBalancer，则 Kubernetes 会请求云服务提供商令应用可以通过公共地址访问。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Minikube-amp-kubectl&quot;&gt;&lt;a href=&quot;#Minikube-amp-kubectl&quot; class=&quot;headerlink&quot; title=&quot;Minikube &amp;amp; kubectl&quot;&gt;&lt;/a&gt;Minikube &amp;amp; kubectl&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="MicroService" scheme="https://rollingstarky.github.io/tags/MicroService/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="Cluster" scheme="https://rollingstarky.github.io/tags/Cluster/"/>
    
      <category term="LoadBalance" scheme="https://rollingstarky.github.io/tags/LoadBalance/"/>
    
  </entry>
  
  <entry>
    <title>Uncle Bob 的 SOLID 软件设计原则——Python 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/"/>
    <id>https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2021-12-13T15:27:42.347Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 <a href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank" rel="noopener">Robert C. Martin</a>（习惯上被称为 Uncle Bob）总结。可以帮助程序员写出更加灵活、容易理解、可维护性强、方便扩展的健壮代码。</p><ul><li>S 代表 <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">Single Responsibility Principle (SRP)</a>，一个类应该只包含一种单一的职责，有且仅有一种原因能促使其变更。通俗点说，让一个类只做一件事。如果需要承担更多的工作，那么分解这个类。</li><li>O 代表 <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">Open/Closed Principle (OCP)</a>，软件实体应该对扩展是开放的，同时对修改是封闭的。如果需要添加额外的功能，应该优先扩展某个类而不是修改它。</li><li>L 代表 <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">Liskov Substitution Principle (LSP)</a>，程序中的对象应该能够替换为其子类型的实例，仍不影响代码的正确性。</li><li>I 代表 <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">Interface Segregation Principle (ISP)</a>，多个专门的基于客户端的接口要好于只有一个通用的接口。一个类对另一个类的依赖性应该建立在最小的接口上，客户端不应该被强迫实现一些他们不会使用的接口。</li><li>D 代表 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">Dependency Inversion Principle (DIP)</a>，抽象不应该依赖于细节，细节应当依赖于抽象。即要针对抽象（接口）编程，而不是针对实现细节编程。</li></ul><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, payment_type, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> payment_type == <span class="string">"debit"</span>:</span><br><span class="line">            print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">elif</span> payment_type == <span class="string">"credit"</span>:</span><br><span class="line">            print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f"Unknown payment type: <span class="subst">&#123;payment_type&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">order.pay(<span class="string">"debit"</span>, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure><p>上述 Python 代码实现了一个简单的“购物车”（订单）应用。</p><ul><li><code>add_item</code> 方法可以向订单中添加新的货物</li><li><code>total_price</code> 方法可以计算订单的总价</li><li><code>pay</code> 方法实现了订单的支付功能，支持借记卡、信用卡等支付方式</li></ul><h4 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h4><p>单一职能原则。<br>将支付功能从 <code>Order</code> 类中分离出来，在另一个 <code>PaymentProcessor</code> 类中实现。同时去掉 <code>pay</code> 方法中的 <code>if-else</code> 判断，分别用两个函数 <code>pay_debit</code> 和 <code>pay_credit</code> 实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_debit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_credit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaymentProcessor()</span><br><span class="line">processor.pay_debit(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h4><p>在最新的支付功能的实现中，如果我们需要添加一个新的支付方法（比如 PayPal），就必须修改 <code>PaymentProcessor</code> 类的原始代码。这就违反了 Open/Closed 原则，额外的功能应该通过扩展而不是修改原来的类来实现。<br>改进的方法是用一个基类（<code>PaymentProcessor</code>）来定义基本的支付逻辑，再通过子类（如 <code>DebitPaymentProcessor</code>）来实现具体的支付方法。这样每当添加一种新的支付方式，直接实现一个新的子类即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = DebitPaymentProcessor()</span><br><span class="line">processor.pay(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h4><p>假设我们现在需要添加一种新的支付方式 <code>PayPalPaymentProcessor</code>，它在支付时并不依赖于 <code>security_code</code> 而是需要 <code>email_address</code> 进行验证。即 <code>pay</code> 方法的定义是 <code>pay(self, order, email_address)</code>，与基类中虚拟方法的签名冲突。<br>改进的方法是将 <code>pay</code> 方法依赖的参数 <code>security_code</code> 或 <code>email_address</code> 移动到支付类的 <code>__init__</code> 方法中，将基类和子类的 <code>pay</code> 方法签名都改为 <code>pay(self, order)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h4><p>假设我们需要在支付组件中添加一个验证短信的功能。直观的想法是直接在 <code>PaymentProcessor</code> 基类中添加一个 <code>auth_sms</code> 虚拟方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>对于需要验证短信的支付方式比如借记卡，改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>对于不需要短信验证的支付方式比如信用卡，就改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(</span><br><span class="line">            <span class="string">"Credit card payments don't support SMS code authorization."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>上述实现的问题在于，我们定义了一个通用的支付接口（<code>PaymentProcessor</code>），包含 <code>pay</code> 和 <code>auth_sms</code> 两种验证逻辑。但这两种逻辑并不总是被具体的支付方式（比如 <code>CreditPaymentProcessor</code>）所需要。<br>这违反了接口分离原则。即接口的实现应该依赖于具体的客户端（子类）需求，而不能不管客户端是否需要，就将所有的功能都放在一个胖接口中。<br>可以额外再实现一个 <code>PaymentProcessor_SMS</code> 基类来定义短信验证的逻辑，让不需要短信验证的支付方式继承 <code>PaymentProcessor</code> 基类，需要短信验证的支付方式继承 <code>PaymentProcessor_SMS</code> 基类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor_SMS</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.auth_sms(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h5 id="Composition-over-Inheritance"><a href="#Composition-over-Inheritance" class="headerlink" title="Composition over Inheritance"></a>Composition over Inheritance</h5><p>在软件设计的大部分场景中，组合要优于继承。因为继承总是意味着更紧密的耦合性。<br>实际上短信认证并不一定通过继承来实现（<code>PaymentProcessor_SMS</code>），还可以通过组合来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = SMSAuth()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.verify_code(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><p>定义一个 <code>SMS_Auth</code> 类来实现短信验证的逻辑，再通过组合的方式将其实例添加到具体的需要短信验证的支付方式中（比如 <code>DebitPaymentProcessor</code>）。</p><h4 id="Dependency-Inversion-Principle"><a href="#Dependency-Inversion-Principle" class="headerlink" title="Dependency Inversion Principle"></a>Dependency Inversion Principle</h4><p>细节应该依赖于抽象，而不是抽象依赖于细节。上述实现中就违反了这个原则。<br>比如借记卡支付方式（<code>DebitPaymentProcessor</code>）的 <code>__init__</code> 方法，签名是 <code>__init__(self, security_code, authorizer: SMSAuth)</code>。其中的 <code>SMSAuth</code> 是一个具体的短信验证类型，而不是一个通用的代表某种验证类型的抽象。<br>这样当支付方式需要的是另外一种验证方法（比如 <code>NotARobot</code>），这里的签名就需要修改。</p><p>可以创建一个 <code>Authorizer</code> 基类来代表通用的验证方式，具体的验证方式比如 <code>SMSAuth</code>、<code>NotARobot</code> 则作为 <code>Authorizer</code> 的子类来实现。<br>在支付方式的实现中，则使用 <code>Authorizer</code> 作为验证方式的类型定义。这样在使用支付类的实例时，就可以灵活地传入 <code>Authorizer</code> 的子类 <code>SMSAuth</code> 或者 <code>NotARobot</code> 进行组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authorizer</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotARobot</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">not_a_robot</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Are you a robot? Naa"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = NotARobot()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.not_a_robot()</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=pTB30aXS77U" target="_blank" rel="noopener">Uncle Bob’s SOLID principles made easy 🍀 - in Python!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 &lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_C._Martin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Robert C. Marti
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Interface" scheme="https://rollingstarky.github.io/tags/Interface/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Principle" scheme="https://rollingstarky.github.io/tags/Principle/"/>
    
      <category term="SOLID" scheme="https://rollingstarky.github.io/tags/SOLID/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Dependency" scheme="https://rollingstarky.github.io/tags/Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Linux xargs 命令解析</title>
    <link href="https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/"/>
    <id>https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-09T12:37:35.469Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>xargs</code> 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并执行。<br><code>xargs</code> 可以帮助 <code>echo</code>、<code>rm</code>、<code>mkdir</code> 等命令接收标准输入作为参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xargs mkdir</span></span><br><span class="line">test1 test2</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2</span><br></pre></td></tr></table></figure><p>比如执行 <code>xargs mkdir</code> 命令，输入 <code>test1 test2</code> 后回车，再按 <code>CTRL-D</code> 结束输入，等效于直接执行 <code>mkdir test1 test2</code> 命令。<br>即 <code>xarg</code> 读取了标准输入中的 <code>test1 test2</code>，并将它们作为参数传递给 <code>mkdir</code> 命令，组合成一个完整的 <code>mkdir test1 test2</code> 命令并执行。</p><p>实际上 <code>xargs</code> 很少用在上述交互式场景中，更多的是搭配管道符 <code>|</code>，通过前一个命令的输出构建新的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test3 test4 test5 | xargs mkdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2  test3  test4  test5</span><br></pre></td></tr></table></figure><p><code>|</code> 和 <code>| xargs</code> 的区别：</p><ul><li>管道符 <code>|</code> 是将左边命令的输出结果作为右边命令的输入值</li><li><code>| xargs</code> 则可以将左边命令的输出结果作为右边命令的参数选项</li></ul><h4 id="find-与-xargs"><a href="#find-与-xargs" class="headerlink" title="find 与 xargs"></a>find 与 xargs</h4><p><code>xargs</code> 最常见的搭配应该就是 <code>find</code> 命令了。即通过 <code>find</code> 查找特定的文件或目录，再将结果传递给 <code>xargs</code>，对找到的结果执行特定的操作。</p><p>如删除 <code>/tmp</code> 路径下最近两周内未做改动的文件：<br><code>find /tmp -type f -mtime +14 | xargs rm</code></p><p>有一点特别需要注意：默认情况下，<code>xargs</code> 从标准输入读取命令参数时，会以空格作为分隔符来识别多个选项。<br>而文件和目录的名字有时候也会包含空格，导致一个文件名被 <code>xargs</code> 识别为两个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="built_in">test</span>\ 6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'   test1   test2   test3   test4   test5</span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> d | xargs rmdir</span></span><br><span class="line">rmdir: failed to remove './test': No such file or directory</span><br><span class="line">rmdir: failed to remove '6': No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'</span><br></pre></td></tr></table></figure><p>更安全一点的做法是使用 <code>-0</code> 选项。<code>-0</code> 选项可以指定 <code>xargs</code> 在读取标准输入时使用 <code>null</code> 作为分隔符。而 <code>find</code> 命令的 <code>-print0</code> 选项同样可以将输出指定为使用 <code>null</code> 进行分割。</p><p>即将前面的命令替换为 <strong><code>find . -type d -print0 | xargs -0 rmdir</code></strong>。</p><h5 id="find-搭配-exec-选项和搭配-xargs-命令的区别"><a href="#find-搭配-exec-选项和搭配-xargs-命令的区别" class="headerlink" title="find 搭配 -exec 选项和搭配 xargs 命令的区别"></a>find 搭配 <code>-exec</code> 选项和搭配 xargs 命令的区别</h5><p><code>find</code> 命令可以使用其 <code>-exec</code> 选项对查找到的结果执行特定的操作。同样的需求 <code>xargs</code> 也可以实现。</p><p>比如需要删除当前目录下所有的 TXT 文件：</p><ul><li>使用 <code>-exec</code>：<code>find . -type f -name &quot;*.txt&quot; -exec rm {} \;</code></li><li>使用 <code>xargs</code>：<code>find . -type f -name &quot;*.txt&quot; | xargs rm</code></li></ul><p>实际上两者的执行效率存在着很大的差距。<br>比如使用 <code>for i in {1..100}; do touch $i.txt; done</code> 命令创建 100 个 TXT 文件，再分别使用上述两个命令删除这些文件（用 <code>time</code> 命令计时），具体的效率如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">1.txt    18.txt  27.txt  36.txt  45.txt  54.txt  63.txt  72.txt  81.txt  90.txt</span><br><span class="line">10.txt   19.txt  28.txt  37.txt  46.txt  55.txt  64.txt  73.txt  82.txt  91.txt</span><br><span class="line">100.txt  2.txt   29.txt  38.txt  47.txt  56.txt  65.txt  74.txt  83.txt  92.txt</span><br><span class="line">11.txt   20.txt  3.txt   39.txt  48.txt  57.txt  66.txt  75.txt  84.txt  93.txt</span><br><span class="line">12.txt   21.txt  30.txt  4.txt   49.txt  58.txt  67.txt  76.txt  85.txt  94.txt</span><br><span class="line">13.txt   22.txt  31.txt  40.txt  5.txt   59.txt  68.txt  77.txt  86.txt  95.txt</span><br><span class="line">14.txt   23.txt  32.txt  41.txt  50.txt  6.txt   69.txt  78.txt  87.txt  96.txt</span><br><span class="line">15.txt   24.txt  33.txt  42.txt  51.txt  60.txt  7.txt   79.txt  88.txt  97.txt</span><br><span class="line">16.txt   25.txt  34.txt  43.txt  52.txt  61.txt  70.txt  8.txt   89.txt  98.txt</span><br><span class="line">17.txt   26.txt  35.txt  44.txt  53.txt  62.txt  71.txt  80.txt  9.txt   99.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span></span><br><span class="line">find . -type f -name "*.txt" -exec rm &#123;&#125; \;  0.05s user 0.02s system 104% cpu 0.060 total</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> | xargs rm</span></span><br><span class="line">find . -type f -name "*.txt"  0.00s user 0.00s system 80% cpu 0.001 total</span><br><span class="line">xargs rm  0.00s user 0.00s system 94% cpu 0.003 total</span><br></pre></td></tr></table></figure></p><p>前者是 0.06，后者是 0.004。使用 <code>xargs</code> 的执行效率更高。</p><h4 id="输出执行的命令"><a href="#输出执行的命令" class="headerlink" title="输出执行的命令"></a>输出执行的命令</h4><p><code>-t</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印到终端窗口中。方便对脚本进行调试。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test1 test2 test3 | xargs -t mkdir</span></span><br><span class="line">mkdir test1 test2 test3</span><br></pre></td></tr></table></figure></p><h4 id="输出命令并提示用户确认"><a href="#输出命令并提示用户确认" class="headerlink" title="输出命令并提示用户确认"></a>输出命令并提示用户确认</h4><p><code>-p</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印出来，并等待用户进行确认。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls | xargs -p rmdir</span></span><br><span class="line">rmdir test1 test2 test3 ?...y</span><br></pre></td></tr></table></figure></p><h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>借助 <code>-I</code> 选项可以令 <code>xargs</code> 同时执行多个命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt | xargs -I % sh -c <span class="string">'echo %; mkdir %'</span></span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">foo.txt  one  three  two</span><br></pre></td></tr></table></figure></p><h4 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h4><p><strong>查找当前路径下所有的 PNG 图片并将它们归档到 <code>images.tar.gz</code> 压缩包中</strong>：<br><code>$ find . -name &quot;*.png&quot; -type f -print0 | xargs -0 tar -cvzf images.tar.gz</code></p><p><strong>获取当前系统中所有用户的用户名，以单行列表的形式输出</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="built_in">echo</span></span></span><br><span class="line">_apt backup bin daemon games gnats irc landscape list lp mail man messagebus news nobody pollinate postgres proxy root sshd starky sync sys syslog systemd-network systemd-resolve systemd-timesync tcpdump tss uucp uuidd www-data</span><br></pre></td></tr></table></figure></p><p><strong>删除当前路径下名为 <code>no_use</code> 的文件</strong>：<br><code>$ find . -name &quot;no_use&quot; -type f -print0 | xargs -0 rm -v -f</code></p><p><strong>复制一个文件到多个路径下</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">dest1  dest2  test_file</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 cp -v ./test_file</span></span><br><span class="line">'./test_file' -&gt; './dest1/test_file'</span><br><span class="line">'./test_file' -&gt; './dest2/test_file'</span><br></pre></td></tr></table></figure></p><p>上面例子中 <code>xargs</code> 的 <code>-n 1</code> 选项非常重要。<code>-n</code> 选项用于指定 <code>xargs</code> 在将标准输入作为参数与命令拼接在一起时，参数的最大长度。</p><p>简单来说，当 <code>-n</code> 为 1 时，标准输入中以空格分割的每一项都与命令进行拼接，最终形成多条命令；当不存在 <code>-n 1</code> 时，标准输入中以空格分割的所有参数项直接与命令进行拼接，形成一条命令并执行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/</span><br><span class="line">cp ./test_file ./dest2/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/ ./dest2/</span><br><span class="line">cp: -r not specified; omitting directory './dest1/'</span><br></pre></td></tr></table></figure></p><ul><li><code>echo ./dest1/ ./dest2/ | xargs -n 1 cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/</code> 和 <code>cp ./test_file ./dest2/</code> 两条命令</li><li><code>echo ./dest1/ ./dest2/ | xargs cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/ ./dest2/</code> 一条命令（语法是错的）</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://shapeshed.com/unix-xargs/" target="_blank" rel="noopener">Linux and Unix xargs command tutorial with examples</a><br><a href="https://www.tecmint.com/xargs-command-examples/" target="_blank" rel="noopener">12 Practical Examples of Linux Xargs Command for Beginners</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h4&gt;&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Script" scheme="https://rollingstarky.github.io/tags/Script/"/>
    
      <category term="Administration" scheme="https://rollingstarky.github.io/tags/Administration/"/>
    
      <category term="Xargs" scheme="https://rollingstarky.github.io/tags/Xargs/"/>
    
      <category term="Find" scheme="https://rollingstarky.github.io/tags/Find/"/>
    
  </entry>
  
  <entry>
    <title>Python code smells 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/"/>
    <id>https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2021-12-06T15:38:09.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>code smells</strong> 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。<br>很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够健壮等问题。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: str</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self, payout: bool)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday, or pay out 5 holidays."""</span></span><br><span class="line">        <span class="keyword">if</span> payout:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                            Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">                )</span><br><span class="line">            self.vacation_days -= <span class="number">1</span></span><br><span class="line">            print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        managers = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"manager"</span>:</span><br><span class="line">                managers.append(employee)</span><br><span class="line">        <span class="keyword">return</span> managers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_vice_presidents</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        vice_presidents = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"president"</span>:</span><br><span class="line">                vice_presidents.append(employee)</span><br><span class="line">        <span class="keyword">return</span> vice_presidents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_interns</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        interns = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"intern"</span>:</span><br><span class="line">                interns.append(employee)</span><br><span class="line">        <span class="keyword">return</span> interns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                            $<span class="subst">&#123;employee.hourly_rate&#125;</span> for <span class="subst">&#123;employee.amount&#125;</span> hours."</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br><span class="line">    print(company.find_vice_presidents())</span><br><span class="line">    print(company.find_managers())</span><br><span class="line">    print(company.find_interns())</span><br><span class="line">    company.pay_employee(company.employees[<span class="number">0</span>])</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday(<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码实现了一个简单的“员工管理系统”。</p><ul><li>Employee 类代表公司里的员工，有姓名、角色、假期等属性。可以请假（<code>take_a_holiday</code>），或者单独请一天，或者以 5 天为单位将假期兑换为报酬</li><li>HourlyEmployee 和 MonthlyEmployee 分别代表以时薪或者月薪来计算工资的员工</li><li>Company 类代表公司，可以招收员工（<code>add_employee</code>）、返回特定角色的员工列表（如 <code>find_managers</code>）、发放薪资等（<code>pay_employee</code>）</li></ul><h4 id="code-smells"><a href="#code-smells" class="headerlink" title="code smells"></a>code smells</h4><p>上面的代码中存在着很多可以改进的地方。</p><h5 id="用-Enum-类型替代-str-作为员工的-role-属性"><a href="#用-Enum-类型替代-str-作为员工的-role-属性" class="headerlink" title="用 Enum 类型替代 str 作为员工的 role 属性"></a>用 Enum 类型替代 str 作为员工的 role 属性</h5><p>上面的 <code>Employee</code> 类使用了 <code>str</code> 类型来存储 <code>role</code> 属性的值，比如用 <code>&quot;manager&quot;</code> 代表经理，用 <code>&quot;intern&quot;</code> 代表实习生。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br></pre></td></tr></table></figure></p><p>实际上 String 过于灵活，可以拥有任何含义，用来表示角色属性时不具有足够清晰的指向性。不同的拼写规则和大小写习惯都会导致出现错误的指向，比如 <code>&quot;Manager&quot;</code> 和 <code>&quot;manager&quot;</code>，<code>&quot;vice-president&quot;</code> 和 <code>&quot;vice_president&quot;</code>。<br>可以使用 Enum 替代 str。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br></pre></td></tr></table></figure></p><p>修改 <code>Employee</code> 类中 <code>role</code> 属性的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br></pre></td></tr></table></figure></p><p><code>Company</code> 类中 <code>find_managers</code> 等方法也做相应的修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">    managers = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == Role.MANAGER:</span><br><span class="line">            managers.append(employee)</span><br><span class="line">    <span class="keyword">return</span> managers</span><br></pre></td></tr></table></figure></p><p><code>main</code> 方法中使用新的 role 创建员工对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h5><p><code>Company</code> 类中有一个功能是返回特定角色的员工列表，即 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 三个方法。<br>这三个方法实际上有着同样的逻辑，却分散在了三个不同的函数里。可以合并成一个方法来消除重复代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line">    employees = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == role:</span><br><span class="line">            employees.append(employee)</span><br><span class="line">    <span class="keyword">return</span> employees</span><br></pre></td></tr></table></figure></p><p>同时将 <code>main</code> 函数中的 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 都改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">print(company.find_employees(Role.MANAGER))</span><br><span class="line">print(company.find_employees(Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="尽量使用内置函数"><a href="#尽量使用内置函数" class="headerlink" title="尽量使用内置函数"></a>尽量使用内置函数</h5><p>上面版本中的 <code>find_employees</code> 方法，包含了一个 <code>for</code> 循环。实际上该部分逻辑可以使用 Python 内置的<strong>列表推导</strong>来实现。<br>合理的使用 Python 内置函数可以使代码更短、更直观，同时内置函数针对很多场景在性能上也做了一定的优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br></pre></td></tr></table></figure></p><h5 id="更清晰明确的变量名"><a href="#更清晰明确的变量名" class="headerlink" title="更清晰明确的变量名"></a>更清晰明确的变量名</h5><p>旧版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>新版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h5 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h5><p>当你在代码的任何地方看到 <code>isinstance</code> 这个函数时，都需要特别地加以关注。它意味着代码中有可能存在某些有待提升的设计。</p><p>比如代码中的 <code>pay_employee</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                        $<span class="subst">&#123;employee.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;employee.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>这里 <code>isinstance</code> 的使用，实际上在 <code>pay_employee</code> 函数中引入了对 <code>Employee</code> 的子类的依赖。这种依赖导致各部分代码之间的职责划分不够清晰，耦合性变强。<br><code>pay_employee</code> 方法需要与 <code>Employee</code> 的子类的具体实现保持同步。每新增一个新的员工类型（<code>Employee</code> 的子类），此方法中的 <code>if-else</code> 也就必须再新增一个分支。即需要同时改动不同位置的两部分代码。</p><p>可以将 <code>pay_employee</code> 的实现从 <code>Company</code> 类转移到具体的 <code>Employee</code> 子类中。即特定类型的员工拥有对应的报酬支付方法，公司在发薪时只需要调用对应员工的 <code>pay</code> 方法，无需实现自己的<code>pay_employee</code> 方法。<br>由 <code>isinstance</code> 引入的依赖关系从而被移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@dataclass</span><br><span class="line">class HourlyEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot; Employee that&apos;s paid based on number of worked hours.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = 50</span><br><span class="line">    hours_worked: int = 10</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a hourly rate of \</span><br><span class="line">                    $&#123;self.hourly_rate_dollars&#125; for &#123;self.hours_worked&#125; hours.&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class SalariedEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot;Employee that&apos;s paid based on a fixed monthly salary.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    monthly_salary: float = 5000</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a monthly salary of $&#123;self.monthly_salary&#125;&quot;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>再把 <code>main</code> 函数中的 <code>company.pay_employee(company.employees[0])</code> 改为 <code>company.employees[0].pay()</code>。</p><p>由于每一个特定的 <code>Employee</code> 子类都需要实现 <code>pay</code> 方法，更好的方式是将 <code>Employee</code> 实现为虚拟基类，<code>pay</code> 成为子类必须实现的虚拟方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br></pre></td></tr></table></figure></p><h5 id="Bool-flag"><a href="#Bool-flag" class="headerlink" title="Bool flag"></a>Bool flag</h5><p><code>Employee</code> 类中的 <code>take_a_holiday</code> 方法有一个名为 <code>payout</code> 的参数。它是布尔类型，作为一个开关，来决定某个员工是请一天假，还是以 5 天为单位将假期兑换为报酬。<br>这个开关实际上导致了 <code>take_a_holiday</code> 方法包含了两种不同的职责，只通过一个布尔值来决定具体执行哪一个。</p><p><strong>函数原本的目的就是职责的分离</strong>。使得同一个代码块中不会包含过多不同类型的任务。<br>因此 <code>take_a_holiday</code> 方法最好分割成两个不同的方法，分别应对不同的休假方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                        Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h5 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h5><p><code>payout_a_holiday</code> 方法中有一步 <code>try-except</code> 代码。但该部分代码实际上对 Exception 没有做任何事。对于 Exception 而言：</p><p><strong>如果需要 catch Exception，就 catch 特定类型的某个 Exception，并对其进行处理；如果不会对该 Exception 做任何处理，就不要 catch 它</strong>。</p><p>在此处使用 <code>try-except</code> 会阻止异常向外抛出，导致外部代码在调用 <code>payout_a_holiday</code> 时获取不到异常信息。此外，使用 <code>Exception</code> 而不是某个特定类型的异常，会导致所有的异常信息都被屏蔽掉，包括语法错误、键盘中断等。<br>因此，去掉上述代码中的 <code>try-except</code>。</p><h5 id="使用自定义-Exception-替代-ValueError"><a href="#使用自定义-Exception-替代-ValueError" class="headerlink" title="使用自定义 Exception 替代 ValueError"></a>使用自定义 Exception 替代 ValueError</h5><p><code>ValueError</code> 是 Python 内置的在内部出现值错误时抛出的异常，并不适合用在自定义的场景中。最好在代码中定义自己的异常类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">        <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">            requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">            remaining_days=self.vacation_days,</span><br><span class="line">            message=<span class="string">"You don't have enough holidays left over for a payout."</span>)</span><br><span class="line">    self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">    print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h4 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=<span class="number">1</span>,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have any holidays left. Now back to work, you!"</span>)</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have enough holidays left over for a payout."</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">        print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                    $<span class="subst">&#123;self.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;self.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a monthly salary of $<span class="subst">&#123;self.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">        <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">    company.add_employee(HourlyEmployee(</span><br><span class="line">        name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br><span class="line">    print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">    print(company.find_employees(Role.MANAGER))</span><br><span class="line">    print(company.find_employees(Role.INTERN))</span><br><span class="line">    company.employees[<span class="number">0</span>].pay()</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=LrtnLEkOwFE" target="_blank" rel="noopener">7 Python Code Smells: Olfactory Offenses To Avoid At All Costs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;code smells&lt;/strong&gt; 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。&lt;br&gt;很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Refactoring" scheme="https://rollingstarky.github.io/tags/Refactoring/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Exception" scheme="https://rollingstarky.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— Kubernetes 介绍</title>
    <link href="https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/"/>
    <id>https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2021-11-30T11:39:02.008Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。</p><p><strong>Kubernetes 是一个负责自动化部署和管理应用的软件系统，主要针对由容器构成的复杂的大型应用系统</strong>。</p><h4 id="Kubernetes-的基本特性"><a href="#Kubernetes-的基本特性" class="headerlink" title="Kubernetes 的基本特性"></a>Kubernetes 的基本特性</h4><p><strong>抽象化基础设施</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8ecedf6a16f124ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Infrastructure abstraction"></p><p>Kubernetes 为用户和应用在底层的硬件之上提供了一个抽象层，底层的基础设施如计算机、网络及其他组件等对应用都是不可见的。用户通过这个抽象层部署和管理应用，不需要再面对每一台特定的机器。因此配置起来更加方便。</p><p><strong>标准化部署</strong><br>由于底层基础设施的具体细节不会再影响到应用的部署，本地数据中心和云环境都可以使用同样的部署方式。任何底层基础设施的差异都交给 Kubernetes 去处理，用户可以只关注产品及其内部逻辑。</p><p><strong>声明式部署</strong><br>Kubernetes 使用声明式的模型来定义具体的应用。用户只需要完成对应用中各组件的描述，Kubernetes 就会将这些描述转化成运行的应用。并在之后保证该应用的健康运行，在必要的时候重启或重新创建某个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-948914611a361f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Declarative model"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4474de5ae26d30a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Changes in the description"></p><p>当用户修改了某些描述，Kubernetes 会根据改动自动采取必要的步骤重新配置应用，令应用满足最新的描述。</p><p><strong>接管应用的日常管理</strong><br>一旦用户通过 Kubernetes 部署了某个应用，该应用的日常管理就会被 Kubernetes 接管。假如服务停止运行，Kubernetes 会自动重启该应用；或者由于硬件失效、基础设施架构调整导致该应用需要移动到其他机器上，Kubernetes 也会自行处理。</p><p>就像之前提到的，用户类似于船长负责更高层级的决策，而 Kubernetes 则类似于舵手负责执行具体的底层任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e8b20e65761088c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes takes over the management of applications"></p><h4 id="Kubernetes-与微服务"><a href="#Kubernetes-与微服务" class="headerlink" title="Kubernetes 与微服务"></a>Kubernetes 与微服务</h4><p>之前的年头，绝大多数应用都是单体应用。应用里的各个组件是强耦合的，全部运行在同一个进程里。<br>当应用的容量需要提升时，水平扩展单体应用是非常困难的。只能不断升级服务器的硬件，即垂直扩展。</p><p>微服务范式是后来才出现的。单体应用被分割成数十甚至数百个独立的进程（微服务）。每一个微服务都拥有自己所独有的开发和部署周期，不同微服务的依赖会随着时间的推移差距越来越大。这使得在同一个操作系统内部运行两个微服务应用变得非常困难。<br>容器正好方便解决这个问题。但每个微服务都是一个独立的应用，需要单独进行管理。随着应用数量的上升这将会越来越困难。<br>整个应用系统的各个部分不需要部署到同一台机器上，这使得扩展起来更加方便。但同时也意味着各组件之间需要配置成能够相互通信的状态。同样增加了维护成本。<br>因此当微服务的规模变得很大时，自动化管理就显得尤为必要。Kubernetes 则正好提供了这种自动化功能。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-59ad3de50dca8dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Monolithic vs Microservices"></p><h4 id="Kubernetes-的架构"><a href="#Kubernetes-的架构" class="headerlink" title="Kubernetes 的架构"></a>Kubernetes 的架构</h4><p>Kubernetes 可以看作是一个面向服务器集群的操作系统。<br>操作系统用来支撑计算机的基本功能比如 CPU 调度，作为应用和计算机硬件之间沟通的接口。类似的，Kubernetes 负责在服务器集群的各台机器上调度安排分布式应用的各个组件，作为应用和集群之间的接口。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9daef5eac57b2474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OS vs Kubernetes"></p><p>一个 Kubernetes 集群包含两组节点：</p><ul><li>主节点：负责运行 Control Plane 组件，是系统的大脑，控制整个集群</li><li>工作节点：组成 Workload Plane，承接应用和负载</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30cd2137a1a1be44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes cluster"></p><h5 id="控制平台"><a href="#控制平台" class="headerlink" title="控制平台"></a>控制平台</h5><p>Control Plane 负责控制整个集群。它运行在一台主节点上，或者以副本的方式运行在多个主节点上。包含 Scheduler、Controllers、Kubernetes API Server、etcd 等几个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d8b81875430d46ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Components of Control Plane"></p><ul><li>Kubernetes API Server 负责暴露 RESTful API 接口，用户可以通过此接口创建对象</li><li>etcd 分布式数据仓库负责持久化通过 API 创建的对象，因为 API Server 本身是无状态的。Server 是唯一一个与 etcd 交互的组件</li><li>Scheduler 负责决定每个应用实例具体运行在哪个工作节点上</li><li>Controllers 负责具体化由 API 创建的对象。它们中的大部分实际上就是负责创建其他对象，有一些也会与外部系统进行交互（比如云提供商）</li></ul><h5 id="负载平台"><a href="#负载平台" class="headerlink" title="负载平台"></a>负载平台</h5><p>工作节点就是实际上运行应用的节点，它们构成了 Workload Plane。负责运行、监控各个应用，并在各应用之间提供连通性。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f0c322b076452baf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Workload Plane"></p><p>其中各组件的功能如下：</p><ul><li>Kubelet：一个与 API Server 进行交互的 agent，负责管理当前节点上运行的应用。会通过 API 向主节点报告应用的状态</li><li>Container Runtime：可以是 Docker 或其他与 Kubernetes 兼容的容器运行时，受 kubelet 指挥，负责运行应用</li><li>Kubernetes Service Proxy：在各应用的网络流量之间提供负载均衡</li></ul><h4 id="Kubernetes-的工作流程"><a href="#Kubernetes-的工作流程" class="headerlink" title="Kubernetes 的工作流程"></a>Kubernetes 的工作流程</h4><p>Kubernetes 中的所有元素都由对象表示，可以通过 API 创建和获取这些对象。用户需要几种不同的对象来定义自己的应用，通常在 YAML 或 JSON 格式的清单文件中定义。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-541fea79d28b6f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying an application to Kubernetes"></p><p>向 Kubernetes 部署应用的具体步骤为：</p><ul><li>向 Kubernetes API 提交应用的 manifest 文件。API Server 将文件中定义的对象写入 etcd</li><li>controller 接到已经创建了新对象的通知，继续创建几个新的对象，对应不同的应用实例</li><li>Scheduler 为每一个应用实例分配工作节点</li><li>工作节点上的 Kubelet 接到通知，借助容器运行时运行应用实例</li><li>应用实例准备好接收客户端请求后，Kube Proxy 收到通知，为这些应用实例配置负载均衡</li><li>工作节点上的 Kubelets 和 Controllers 负责之后的监控工作，保证应用健康运行</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 是一个负责自动化部署和
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Microservice" scheme="https://rollingstarky.github.io/tags/Microservice/"/>
    
      <category term="Cloud" scheme="https://rollingstarky.github.io/tags/Cloud/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 理解容器技术</title>
    <link href="https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/"/>
    <id>https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2021-11-29T13:55:06.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、容器-vs-虚拟机"><a href="#一、容器-vs-虚拟机" class="headerlink" title="一、容器 vs 虚拟机"></a>一、容器 vs 虚拟机</h4><h5 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h5><p>每一台虚拟机都需要安装独属于自己的操作系统，包含一系列系统进程；而同一台宿主机上的多个容器会共享宿主机的操作系统，它们的环境仍然是独立的。<br>即对于容器而言，不需要装一个独立的操作系统。不会像虚拟机那样，存在很多套重复的系统进程。因而容器更加轻量。<br><strong>容器只包含一套隔离的进程，运行在已有的宿主机操作系统上，只会消耗这套隔离进程运行所需的系统资源</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a8f80aa3c08ae7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="overhead VM vs Container"></p><p>由于虚拟机高额的开销，通常需要将多个关联的应用部署在同一台虚拟机上。对于开销较低的容器而言，则可以为每一个应用都创建一个独立的容器。<br>实际上也应该<strong>确保每一个容器都只包含一个应用</strong>，这样方便管理，同时 Kubernetes 等容器管理平台也是默认这个原则的。</p><h5 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h5><p>容器拥有更快的启动时间。因为容器只需要启动自身包含的应用进程，不需要像启动一台新的虚拟机那样，先启动一些额外的系统进程。</p><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>无疑虚拟机的隔离性更好。<br>当使用虚拟机部署应用时，每台虚拟机都拥有一套独立的操作系统和内核。这些虚拟机的底层是 hypervisor，将物理硬件划分成一系列更小的虚拟资源，供给不同的虚拟机使用。</p><p>当虚拟机中运行的应用向虚拟机内核发起系统调用时，内核会先在虚拟的 CPU 上执行机器指令，再通过 hypervisor 转发给宿主机的物理 CPU 执行。<br>容器发起的系统调用则都可以直接传递给宿主机上运行的系统内核，再转化为机器指令传递给宿主机的 CPU。宿主机 CPU 不需要处理任何形式的虚拟化。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e7e28095583e19c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="system calls"></p><p>同一台机器上的多个容器共享同一个宿主机内核，但它们之间仍然是隔离的，相互之间并不清楚其他人的存在，也只能看到一部分物理硬件。<br>这种隔离是由宿主机内核提供的。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f1b4cacdc98d0138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Isolation"></p><h5 id="由隔离性引发的安全性"><a href="#由隔离性引发的安全性" class="headerlink" title="由隔离性引发的安全性"></a>由隔离性引发的安全性</h5><p>容器使用同一个内核。如果内核出现 bug，某个容器中的应用有可能会利用这个 bug 读取其他容器中其他应用的内存。<br>此外，容器会共享内存空间。如果不限制某个容器能够使用的内存总量，有可能会导致其他容器没有足够的内存使用。</p><h4 id="二、Docker-容器平台介绍"><a href="#二、Docker-容器平台介绍" class="headerlink" title="二、Docker 容器平台介绍"></a>二、Docker 容器平台介绍</h4><p>Docker 是一个帮助用户打包、发布和运行容器应用的平台。用户可以使用 Docker 将应用及其运行环境（可以是一些动态库等依赖，甚至操作系统提供的所有文件）打包，并可以将打包后的镜像发布到一个公共的镜像源，再部署到其他安装了 Docker 的机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-651e5432eed2654a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker Platform"></p><p>三个 Docker 中的基本概念：</p><ul><li>Images（镜像）：类似于一个 zip 压缩包，包含了应用及其运行环境</li><li>Registries（源）：一个方便用户和机器分发、共享镜像的站点。可以将打包好的镜像 push 到源，这样另一台机器就可以从镜像源 pull 该镜像到本地</li><li>Containers（容器）：相当于实例化的镜像。<strong>一个运行的容器相当于宿主机中一个普通的进程，只不过它的环境是隔离的</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e505cff02f642b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker push"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3f8802fae79fd57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker pull"></p><h5 id="Image-Layers"><a href="#Image-Layers" class="headerlink" title="Image Layers"></a>Image Layers</h5><p>不同于虚拟机镜像是由整个文件系统构成的一个大的文件块，容器镜像通常是由更小的<strong>层</strong>构成。这些层可以被多个镜像所共享。<br>如果某个镜像需要的部分镜像层已经被下载到了宿主机上（在 pull 其他镜像的时候），则 pull 该镜像时只需要下载之前未 pull 的层即可。<br>镜像层使得发布镜像变得更加高效，同时也提升了宿主机的存储空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf0919122843a478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image Layers"></p><p>如上图中的三个容器，它们可以共享访问一部分共有的文件。但它们是如何同时做到隔离的呢？其中某个容器若修改了共享的文件，如何做到不对其他容器可见？<br>文件系统的隔离由 <strong>Copy-on-Write (CoW)</strong> 机制实现。<br>容器中的文件系统由从镜像而来的只读层和加在只读层上面的一个读写层构成。当某个运行的容器修改了只读层中的文件，该文件会被整个复制到容器的读写层。每个容器都拥有自己所独有的读写层，因此对共享文件的修改并不会对其他容器可见。<br>当删除某个文件，该文件只是在读写层中被标记为已删除，实际上该文件仍然存在于只读层中。因此删除文件并不会减少镜像的大小。</p><h5 id="镜像层的潜在限制"><a href="#镜像层的潜在限制" class="headerlink" title="镜像层的潜在限制"></a>镜像层的潜在限制</h5><p>理论上讲，基于 Docker 的镜像可以运行在任意一台启用了 Docker 的机器上。但是由于容器并没有自己的内核，如果一个容器需要特定版本的内核才能运行，它有可能不会运行在每一台机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bedcb0dfebe1576c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container requires specific kernel version"></p><p>此外，容器化的应用只能运行在特定的硬件架构上。比如不能把一个构建在 x86 CPU 架构上的应用，部署在 ARM 平台的 Docker 上。</p><h4 id="三、容器背后的技术"><a href="#三、容器背后的技术" class="headerlink" title="三、容器背后的技术"></a>三、容器背后的技术</h4><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>Linux 命名空间可以确保每个进程都只能看到它自己视角的系统。即容器中的进程只能看到部分文件、进程、网络接口和机器名，就好像它运行在一个独立的虚拟机上。<br>内核可以创建额外的命名空间，然后将部分资源移动到该命名空间，并令其只对某一个或一组进程可见。</p><p>命名空间的类型：</p><ul><li>Mount 命名空间用来隔离挂载点（文件系统）</li><li>Process ID 命名空间用来隔离进程 ID</li><li>Network 命名空间用来隔离网络设备、端口等</li><li>ipc 命名空间用来隔离进程间的通信（包括管理消息队列、共享内存等）</li><li>UTS (UNIX Time-sharing System) 命名空间用来隔离系统的主机名和 NIS (Network Information Service) 域名</li><li>User ID 命名空间用来隔离用户和组 ID</li><li>Cgroup 命名空间用来隔离 Control Groups 根目录</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e436794540627a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="network namespace"></p><p>有时候并不会想要将某个容器与另一个容器完全隔离，相互关联的容器之间有可能会共享特定的资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-120889e397b108e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shared namespace"></p><p>比如上图中的两个容器。它们可以看见并使用相同的两个网络设备（<code>eth0</code> 和 <code>lo</code>），因为它们拥有相同的网络命名空间。它们也因此可以绑定相同的 IP 地址并通过 loopback 设备相互通信。<br>这两个容器还使用同一个 UTS 命名空间，因此它们可以见到相同的主机名。但它们的 Mount 命名空间是不同的，即拥有不同的文件系统。</p><p><strong>容器中运行的进程只是一个绑定了 7 类命名空间的普通进程</strong>。</p><h5 id="Linux-Control-Groups"><a href="#Linux-Control-Groups" class="headerlink" title="Linux Control Groups"></a>Linux Control Groups</h5><p>Linux 命名空间可以控制进程只能访问一部分系统资源，但它们不能限制每个进程消耗的资源总量。<br>Linux Control Groups (cgroups) 则可以限制进程只能使用预先分配好的固定额度的 CPU 时间、内存和网络带宽等。避免某些进程吃掉所有的系统资源。</p><h4 id="sys-calls"><a href="#sys-calls" class="headerlink" title="sys-calls"></a>sys-calls</h4><p>Linux 命名空间和 Cgroups 能够隔离容器的环境并防止某个容器消耗掉所有的计算资源。但这些容器中的进程仍然使用同一个系统内核，一个非法容器仍然可以通过一些恶意的系统调用来影响其他容器。</p><p>内核提供了一系列 sys-calls 可以被程序用来与操作系统及底层的硬件交互，包括创建进程、操作文件和设备、创建应用间的通信通道等。<br>其中有些 sys-calls 是安全的，可以被任意进程使用。其他一些则只允许具有更高权限的进程使用。比如容器中的应用应该允许访问它们的本地文件，但不能修改系统时钟或者以破坏其他容器的方式修改内核。</p><p>Linux 内核把这些权限分成了名为 capabilities 的单位。如：</p><ul><li>CAP_NET_ADMIN：允许进程执行网络相关的操作</li><li>CAP_NET_BIND_SERVICE：允许进程绑定小于 1024 的端口号</li><li>CAP_SYS_TIME：允许进程修改系统时钟</li></ul><p>Capabilities 能够在容器创建时添加或移除，每个 Capability 都代表一系列特殊权限。<br>此外，还可以使用 <strong>seccomp (Secure Computing Mode)</strong> 。创建一个 包含 seccomp 配置的 JSON 文件，在构建容器时提供给 Docker。</p><h5 id="AppArmor-amp-SELinux"><a href="#AppArmor-amp-SELinux" class="headerlink" title="AppArmor &amp; SELinux"></a>AppArmor &amp; SELinux</h5><p>容器还可以依靠两种 MAC（强制访问控制）机制 SELinux 和 AppArmor 来获得更高的安全性。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、容器-vs-虚拟机&quot;&gt;&lt;a href=&quot;#一、容器-vs-虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、容器 vs 虚拟机&quot;&gt;&lt;/a&gt;一、容器 vs 虚拟机&lt;/h4&gt;&lt;h5 id=&quot;系统开销&quot;&gt;&lt;a href=&quot;#系统开销&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="Isolation" scheme="https://rollingstarky.github.io/tags/Isolation/"/>
    
      <category term="VM" scheme="https://rollingstarky.github.io/tags/VM/"/>
    
  </entry>
  
</feed>
