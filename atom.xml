<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2022-11-12T13:20:03.300Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 由 Promises 和 Async、Await 实现的异步模式</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:20:03.300Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。</p><p>为了获得更好的异步编程体验，第一个出现的就是 <strong>promise</strong>，一种保存了异步操作的状态和最终结果的对象。Promise 可以轻易地被串联起来，实现串行控制流，可以像其他任何对象一样自由地转移。Pormise 大大简化了异步代码，后来在此基础上又有了 <strong>async</strong> 和 <strong>await</strong>，能够令异步代码看起来就像是同步代码一样。</p><h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>Promises 是 ECMAScript 2015 标准（ES6）的一部分，为传递异步结果提供了一种健壮的解决方案，替代原本的 CPS 样式的回调函数。Promise 能够令所有主要的异步控制流更加易读、简洁和健壮。</p><p>Promise 是一种用来代表异步操作的最终结果（或错误）的对象。在专业术语中，当异步操作未完成时，我们称 Promise 是 <strong>pending</strong> 的；当异步操作成功结束时，Promise 是 <strong>fulfilled</strong> 的；当异步操作因为错误终止时，Promise 是 <strong>rejected</strong> 的；当 Promise 或者是 <strong>fulfilled</strong> 或者是 <strong>rejected</strong>，则将其认定为 <strong>settled</strong>。</p><p>Promise 对象的 <code>then()</code> 方法可以获取成功执行后的结果或者终止时报出的错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p><p>其中 <code>onFulfilled</code> 是一个回调函数，最终会接收到 Promise 成功时的值；<code>onRejected</code>是另一个回调函数，最终会接收 Promise 异常终止时的值（如果有的话）。</p><p>基于回调函数的如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation(arg, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do stuff with the result</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promise 实现上述同样的功能，则更加优雅、结构化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do stuff with result</span></span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>asyncOperationPromise()</code> 会返回一个 Promise，可以被用来获取最终结果的值或者失败的原因。但最为关键的属性是，<code>then()</code> 方法会同步地返回另一个 Promise。<br>更进一步地，如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回一个值 <code>x</code>，那么 <code>then()</code> 方法返回的 Promise 会有以下行为：</p><ul><li>若 <code>x</code> 是一个值，则 <code>then()</code> 返回的 Promise 使用 <code>x</code> 作为自身完成时的值</li><li>若 <code>x</code> 是一个 Promise 且成功完成，则 <code>x</code> 完成时返回的值作为 <code>then()</code> 返回的 Promise 完成时的值</li><li>若 <code>x</code> 是一个 Promise 且因为错误终止，则 <code>x</code> 终止的原因作为 <code>then()</code> 返回的 Promise 终止的原因</li></ul><p>上述行为能够令我们将多个 promise 连接成链，轻松地将异步操作聚合在一起。如果我们没有指定一个 <code>onFulfilled</code> 或者 <code>onRejected</code> handler，Promise 完成时的值或者终止时的原因都会自动地传递给链条中的下一个 Promise。通过 Promise 链，任务的执行顺序突然变得很简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return another promise</span></span><br><span class="line">    <span class="keyword">return</span> asyncOperationPromise(arg2)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return a value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="literal">undefined</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// any error in the chain is caught here</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h4><p>Promise 构造函数（<code>new Promise((resolve, reject) =&gt; {})</code>）会创建一个新的 Promise 实例，其完成还是终止取决于作为参数传入的函数的行为。<br>作为参数传入的函数接收如下两个参数：</p><ul><li><code>resolve(obj)</code>：resolve 是一个函数，在调用时为 Promise 提供完成时的值。当 <code>obj</code> 是值时，则 <code>obj</code> 本身作为 Promise 完成时的值；当 <code>obj</code> 是另一个 Promise 时，则 <code>obj</code> 完成时的值作为当前 Promise 完成时的值</li><li><code>reject(err)</code>：Promise 因为 <code>err</code> 终止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds()&#125;</span>s\nDelaying...`</span>)</span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">newDate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;newDate.getSeconds()&#125;</span>s`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise 最重要的静态方法：</p><ul><li><code>Promise.resolve(obj)</code>：从另一个 Promise、thenable 对象或者值创建一个新的 Promise</li><li><code>Promise.reject(err)</code>：创建一个 Promise，该 Promise 会因为 <code>err</code> 终止</li><li><code>Promise.all(iterable)</code>：从一个可迭代对象创建 Promise，若该 iterable 中的每一项都提供了一个 fulfill 值，则 Promise 最终以包含这些值的列表作为 fulfill 值；若其中有任意一项 reject，则 Promise.all() 返回的 Promise 以第一个 reject 的 err 终止</li><li><code>Promise.allSettled(iterable)</code>：此方法会等待所有输入的 Promise 或者 fulfill 或者 reject，之后返回一个包含所有 fulfill 值和 reject 原因的列表</li><li><code>Promise.race(iterable)</code>：返回可迭代对象中第一个 fulfill 或 reject 的 Promise</li></ul><p>Promise 关键的实例方法：</p><ul><li><code>promise.catch(onRejected)</code>：实际上就是 <code>promise.then(undefined, onRejected)</code> 的语法糖</li><li><code>promise.finally(onFinally)</code>：允许我们设置一个 <code>onFinally</code> 回调函数，在 <code>promise</code> fulfill 或者 reject 时调用</li></ul><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><p>顺序执行意味着，每次只执行一系列任务中的一个，完成后再依次执行后面的任务。这一系列任务的先后顺序必须是预先定义好的，因为一个任务的结果有可能影响后续任务的执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a0d217ff414af74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of sequential execution flow with three tasks"></p><p>上述执行流程有着不同形式的变种：</p><ul><li>顺序执行一系列已知的任务，不需要在它们之间传递数据</li><li>前一个任务的输出作为后一个任务的输入（<em>chain</em>、<em>pipeline</em>、<em>waterfall</em>）</li><li>迭代任务集合，同时在每个元素上一个接一个地运行异步任务</li></ul><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"03-promises-web-spider-v2"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"cheerio"</span>: <span class="string">"^1.0.0-rc.3"</span>,</span><br><span class="line">    <span class="attr">"mkdirp"</span>: <span class="string">"^0.5.1"</span>,</span><br><span class="line">    <span class="attr">"superagent"</span>: <span class="string">"^5.2.2"</span>,</span><br><span class="line">    <span class="attr">"slug"</span>: <span class="string">"^1.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;dirname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> superagent <span class="keyword">from</span> <span class="string">'superagent'</span></span><br><span class="line"><span class="keyword">import</span> mkdirp <span class="keyword">from</span> <span class="string">'mkdirp'</span></span><br><span class="line"><span class="keyword">import</span> &#123;urlToFilename, getPageLinks&#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mkdirpPromises = promisify(mkdirp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">return</span> superagent.get(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      content = res.text</span><br><span class="line">      <span class="keyword">return</span> mkdirpPromises(dirname(filename))</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> fsPromises.writeFile(filename, content))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> content</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    promise = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">return</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The file doesn't exist, so let’s download it</span></span><br><span class="line">      <span class="keyword">return</span> download(url, filename)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">content</span> =&gt;</span> spiderLinks(url, content, nesting))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider-cli.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;spider&#125; <span class="keyword">from</span> <span class="string">'./spider.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> nesting = <span class="built_in">Number</span>.parseInt(process.argv[<span class="number">3</span>], <span class="number">10</span>) || <span class="number">1</span></span><br><span class="line"></span><br><span class="line">spider(url, nesting)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Download complete'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p><code>utils.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;join, extname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;URL&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> slug <span class="keyword">from</span> <span class="string">'slug'</span></span><br><span class="line"><span class="keyword">import</span> cheerio <span class="keyword">from</span> <span class="string">'cheerio'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLinkUrl</span>(<span class="params">currentUrl, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedLink = <span class="keyword">new</span> URL(element.attribs.href || <span class="string">''</span>, currentUrl)</span><br><span class="line">  <span class="keyword">const</span> currentParsedUrl = <span class="keyword">new</span> URL(currentUrl)</span><br><span class="line">  <span class="keyword">if</span> (parsedLink.hostname !== currentParsedUrl.hostname ||</span><br><span class="line">    !parsedLink.pathname) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parsedLink.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">urlToFilename</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedUrl = <span class="keyword">new</span> URL(url)</span><br><span class="line">  <span class="keyword">const</span> urlPath = parsedUrl.pathname.split(<span class="string">'/'</span>)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> component !== <span class="string">''</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> slug(component, &#123;<span class="attr">remove</span>: <span class="literal">null</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">let</span> filename = join(parsedUrl.hostname, urlPath)</span><br><span class="line">  <span class="keyword">if</span> (!extname(filename).match(<span class="regexp">/htm/</span>)) &#123;</span><br><span class="line">    filename += <span class="string">'.html'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filename</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPageLinks</span>(<span class="params">currentUrl, body</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(cheerio.load(body)(<span class="string">'a'</span>))</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getLinkUrl(currentUrl, element)</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>node spider-cli.js http://www.baidu.com 2</code></p><p>其中的 <code>spiderLinks()</code> 函数通过循环动态地构建了一条 Promise 链：</p><ul><li>先定义一个“空的” Promise 对象（resovle 到 <code>undefined</code>），这个空 Promise 只是作为链条的起点</li><li>在循环中，不断将 <code>promise</code> 变量更新为新的 Promise 对象（通过调用上一个 Promise 的 <code>then()</code> 方法得到）。这就是 Promise 的异步遍历模式</li></ul><p>在 <code>for</code> 循环的最后，<code>promise</code> 变量会是最后一个 <code>then()</code> 方法返回的 Promise，因而只有当链条中的所有 Promise 都 resolve 时，<code>promise</code> 才会 resolve。</p><p>纵观所有代码，我们可以不需要像使用 callback 那样，强制地包含众多错误传递逻辑。因而大大减少了代码量和出错的机会。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>在某些情况下，一系列异步任务的执行顺序并不重要，我们需要的只是当所有的任务都完成后能收到通知。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf70d3d597a899bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of parallel execution with three tasks"></p><p>虽然 Node.js 是单线程的，但得益于其 non-blocking nature，我们仍可以实现并发行为。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-ae64bdc5e85d3d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of how asynchronous tasks run in parallel"></p><p>比如我们有一个 Main 函数需要执行两个异步任务：</p><ul><li>Main 函数首先触发异步任务 Task1 和 Task2 的执行。异步任务触发后，会将程序控制权立即交还给 Main 函数，再转交给 event loop</li><li>当 Task1 中的异步任务结束时，event loop 调用 Task1 的回调函数，将控制权交给 Task1。Task1 执行完成自身内部的同步指令，通知 Main 函数并返还控制权</li><li>当 Task2 中的异步任务结束时，event loop 调用 Task2 的回调函数，将控制权交给 Task2。在 Task2 的终点，Main 函数再次被通知。Main 函数得知 Task1 和 Task2 全部结束，继续执行或者返回结果</li></ul><p>简单来说，在 Node.js 中，我们只能并发地执行异步操作，因为它们的并发行为是由内部的非阻塞 API 控制的。同步（阻塞）操作无法并发地执行，除非它们的执行与异步操作交织在一起，或者由 <code>setTimeout()</code>、<code>setImmediate()</code> 包裹。</p><p>Promise 实现并发执行流，可以借助内置的 <code>Promise.all()</code> 方法。该方法会返回一个新的 Promise，只有当所有传入的 Promise 都 fulfill 时，新 Promise 才会 fulfill。如果传入的 Promise 之间没有因果关系，这些 Promise 就会并发地执行。</p><p>对于前面的 spider 应用，只需要将 <code>spiderLinks()</code> 函数改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h4><p>Promise 链相对于 callback hell 来说肯定是要好太多的，但是我们仍然需要调用 <code>then()</code> 方法，以及为链条中的每一个任务创建新的函数，对于日常编程中非常普遍的控制流来说还是比较麻烦。而 Async/await 可以帮助我们写出像同步代码一样可读性强、容易理解的异步代码。<br>Async 函数是一种特殊的函数，在函数体里面可以使用 <code>await</code> 表达式“暂停”任意一个 Promise 的执行，将控制权交还给 async 函数的调用者，等该 Promise revolve 后再返回到暂停的地方继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithDelays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial date: '</span>, <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  <span class="keyword">const</span> dateAfterOneSecond = <span class="keyword">await</span> delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after one second: '</span>, dateAfterOneSecond)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dateAfterThreeSeconds = <span class="keyword">await</span> delay(<span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after 3 secnods: '</span>, dateAfterThreeSeconds)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">playingWithDelays()</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`After 4 seconds: <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Async/await 的另一个巨大的优势在于，它能够标准化 <code>try...catch</code> 代码块的行为，不管是针对同步代码中的 <code>throw</code>，抑或是异步代码中的 Promise reject。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayError</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Error after <span class="subst">$&#123;milliseconds&#125;</span>ms`</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithErrors</span>(<span class="params">throwSyncError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (throwSyncError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is a synchronous error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> delayError(<span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`We have an error: <span class="subst">$&#123;err.message&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// playingWithErrors(true)</span></span><br><span class="line">playingWithErrors(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>借助 Async/await，可以对之前的 spider 应用实现很多优化。比如 <code>download()</code> 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">text</span>: content&#125; = <span class="keyword">await</span> superagent.get(url)</span><br><span class="line">  <span class="keyword">await</span> mkdirpPromises(dirname(filename))</span><br><span class="line">  <span class="keyword">await</span> fsPromises.writeFile(filename, content)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整段代码行数大大减少，看起来也很“平整”，没有任何层级和缩进。</p><p>接下来是 <code>spiderLinks()</code> 函数，使用 async/await 异步地遍历一个列表：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    <span class="keyword">await</span> spider(link, nesting - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是 <code>spider()</code> 函数，如何简单地通过 <code>try...catch</code> 处理错误，令异步代码更加易读：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    content = <span class="keyword">await</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    content = <span class="keyword">await</span> download(url, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spiderLinks(url, content, nesting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="并行执行-1"><a href="#并行执行-1" class="headerlink" title="并行执行"></a>并行执行</h4><p>使用纯 async/await 实现并行的异步执行流程，可以参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而上述代码存在一定的问题。如果列表中有一个 Promise reject 了，我们不得不等待列表中其他所有的 Promise 都 resolve，<code>spiderLinks()</code> 函数返回的 Promise 才会 reject。这种行为在多数情况下都是不理想的。<br>我们通常都会想要在操作发生错误的第一时间捕获错误信息。因而并行执行异步操作，最后仍建议使用下面形式的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。&lt;/p
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Async" scheme="https://rollingstarky.github.io/tags/Async/"/>
    
      <category term="Promise" scheme="https://rollingstarky.github.io/tags/Promise/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Concurrent" scheme="https://rollingstarky.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Streams 流编程</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:23:27.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Streams</strong> 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。</p><h3 id="Buffering-vs-streaming"><a href="#Buffering-vs-streaming" class="headerlink" title="Buffering vs streaming"></a>Buffering vs streaming</h3><p>对于输入数据的处理，buffer 模式会将来自资源的所有数据收集到 buffer 中，待操作完成再将数据作为单一的 blob of data 传递给调用者；相反地，streams 允许我们一旦接收到数据就立即对其进行处理。<br>单从效率上说，streams 在空间（内存使用）和时间（CPU 时钟）的使用上都更加高效。此外 Node.js 中的 streams 还有另一个重要的优势：<strong>组合性</strong>。</p><h4 id="空间效率"><a href="#空间效率" class="headerlink" title="空间效率"></a>空间效率</h4><p><strong>使用 buffered API 完成 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;gzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gzipPromise = promisify(gzip)</span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fs.readFile(filename)</span><br><span class="line">  <span class="keyword">const</span> gzippedData = <span class="keyword">await</span> gzipPromise(data)</span><br><span class="line">  <span class="keyword">await</span> fs.writeFile(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>, gzippedData)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p><code>node gzip-buffer.js &lt;path to file&gt;</code></p><p>如果我们使用上述代码压缩一个足够大的文件（比如说 8G），我们很有可能会收到一个错误信息，类似文件大小超过了允许的最大 buffer 大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RangeError [ERR_FS_FILE_TOO_LARGE]: File size (8130792448) is greater</span><br><span class="line">than possible Buffer: 2147483647 bytes</span><br></pre></td></tr></table></figure></p><p>即便没有超过 V8 的 buffer 大小限制，也有可能出现物理内存不够用的情况。</p><p><strong>使用 streams 实现 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream, createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createWriteStream(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>))</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>))</span><br></pre></td></tr></table></figure></p><p>streams 的优势来自于其接口和可组合性，允许我们实现干净、优雅、简洁的代码。对于此处的示例，它可以对任意大小的文件进行压缩，只需要消耗常量的内存。</p><h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><p>假设我们需要创建一个应用，能够压缩一个文件并将其上传到一个远程的 HTTP 服务器。而服务器端则负责将接收到的文件解压缩并保存。<br>如果我们使用 buffer API 实现客户端组件，则只有当整个文件读取和压缩完成之后，上传操作才开始触发。同时在服务器端，也只有当所有数据都接收完毕之后才开始解压缩操作。</p><p>更好一些的方案是使用 streams。在客户端，streams 允许我们以 chunk 为单位从文件系统逐个、分段地读取数据，并立即进行压缩和发送。同时在服务器端，每个 chunk 被接收到后会立即进行解压缩。</p><p>服务端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure></p><p>客户端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>mkdir received_files</code><br><code>node gzip-receive.js</code><br><code>node gzip-send.js &lt;path to file&gt; localhost</code></p><p>借助 streams，整套流程的流水线在我们接收到第一个数据块的时候就开始启动了，完全不需要等待整个文件被读取。除此之外，下一个数据块能够被读取时，不需要等到之前的任务完成就能被处理。即另一条流水线被并行地被装配执行，Node.js 可以将这些异步的任务并行化地执行。只需要保证数据块最终的顺序是固定的，而 Node.js 中 streams 的内部实现机制保证了这一点。</p><h4 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h4><p>借助于 <code>pipe()</code> 方法，不同的 stream 能够被组合在一起。每个处理单元负责各自的单一功能，最终被 <code>pipe()</code> 连接起来。因为 streams 拥有统一的接口，它们彼此之间在 API 层面是互通的。只需要 pipeline 支持前一个 stream 生成的数据类型（可以是二进制、纯文本甚至对象等）。</p><h5 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createCipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> secret = Buffer.from(process.argv[<span class="number">4</span>], <span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">const</span> iv = randomBytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename),</span><br><span class="line">    <span class="string">'X-Initialization-Vector'</span>: iv.toString(<span class="string">'hex'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createCipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h5 id="服务端加密"><a href="#服务端加密" class="headerlink" title="服务端加密"></a>服务端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secret = randomBytes(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Generated secret: <span class="subst">$&#123;secret.toString(<span class="string">'hex'</span>)&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> iv = Buffer.from(</span><br><span class="line">    req.headers[<span class="string">'x-initialization-vector'</span>], <span class="string">'hex'</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createDecipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure><h3 id="Streams-详解"><a href="#Streams-详解" class="headerlink" title="Streams 详解"></a>Streams 详解</h3><p>实际上在 Node.js 中的任何地方都可见到 streams。比如核心模块 fs 有 <code>createReadStream()</code> 方法用来读取文件内容，<code>createWriteStream()</code> 方法用来向文件写入数据；HTTP <code>request</code> 和 <code>response</code> 对象本质上也是 stream；zlib 模块允许我们通过流接口压缩和解压缩数据；甚至 crypto 模块也提供了一些有用的流函数比如 <code>createCipheriv</code> 和 <code>createDecipheriv</code>。</p><h4 id="streams-的结构"><a href="#streams-的结构" class="headerlink" title="streams 的结构"></a>streams 的结构</h4><p>Node.js 中的每一个 stream 对象，都是对以下四种虚拟基类里任意一种的实现，这四个虚拟类都属于 <code>stream</code> 核心模块：</p><ul><li><code>Readable</code></li><li><code>Writable</code></li><li><code>Duplex</code></li><li><code>Transform</code></li></ul><p>每一个 stream 类同时也是 <code>EventEmitter</code> 的实例，实际上 Streams 可以生成几种类型的 event。比如当一个 <code>Readable</code> 流读取完毕时触发 <code>end</code> 事件，<code>Writable</code> 流吸入完毕时触发 <code>finish</code> 事件，或者当任意错误发生时抛出 <code>error</code>。</p><p>Steams 之所以足够灵活，一个重要的原因就是它们不仅仅能够处理 binary data，还支持几乎任意的 JavaScript 值。实际上 streams 有以下两种操作模式：</p><ul><li>Binary mode：以 chunk 的形式（比如 buffers 或 strings）传输数据</li><li>Object mode：通过由独立对象（可以包含任意 JavaScript 值）组成的序列传输数据</li></ul><p>上述两种模式使得我们不仅仅可以利用 streams 处理 I/O 操作，还能够帮助我们以函数式的方式将多个处理单元优雅地组合起来。</p><h4 id="从-Readable-streams-读取数据"><a href="#从-Readable-streams-读取数据" class="headerlink" title="从 Readable streams 读取数据"></a>从 Readable streams 读取数据</h4><h5 id="non-flowing-mode"><a href="#non-flowing-mode" class="headerlink" title="non-flowing mode"></a>non-flowing mode</h5><p>默认模式。<code>readable</code> 事件表示有新的数据可供读取，再通过 <code>read()</code> 方法同步地从内部 buffer 读取数据，返回一个 Buffer 对象。<br>即从 stream 按需拉取数据。当 stream 以 Binary 模式工作时，我们还可以给 <code>read()</code> 方法指定一个 <code>size</code> 值，以读取特定数量的数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="flowing-mode"><a href="#flowing-mode" class="headerlink" title="flowing mode"></a>flowing mode</h5><p>此模式下，数据并不会像之前那样通过 <code>read()</code> 方法拉取，而是一旦有数据可用，就主动推送给 <code>data</code> 事件的 listener。flowing 模式对于数据流的控制，相对而言灵活性较低一些。<br>由于默认是 non-flowing 模式，为了使用 flowing 模式，需要绑定一个 listener 给 <code>data</code> 事件或者显式地调用 <code>resume()</code> 方法。调用 <code>pause()</code> 方法会导致 stream 暂时停止发送 <code>data</code> 事件，任何传入的数据会先被缓存到内部 buffer。即 stream 又切换回 non-flowing 模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="Async-iterators"><a href="#Async-iterators" class="headerlink" title="Async iterators"></a>Async iterators</h5><p>Readable 流同时也是 async iterators。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> process.stdin) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="实现-Readable-streams"><a href="#实现-Readable-streams" class="headerlink" title="实现 Readable streams"></a>实现 Readable streams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = Chance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream()</span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>为了实现一个自定义的 Readable stream，首先必须创建一个新的类，该类继承自 <code>stream</code> 模块中的 <code>Readable</code>。其次新创建的类中必须包含 <code>_read()</code> 方法的实现。<br>上面代码中的 <code>_read()</code> 方法做了以下几件事：</p><ul><li>借助第三方的 <code>chance</code> 模块，生成一个长度为 <code>size</code> 的随机字符串</li><li>通过 <code>push()</code> 方法将字符传推送到内部 buffer</li><li>依据 5% 的几率自行终止，终止时推送 <code>null</code> 到内部 buffer，作为 stream 的结束标志</li></ul><p><strong>简化版实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">let</span> emittedBytes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> Readable(&#123;</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h5 id="从可迭代对象创建-Readable-streams"><a href="#从可迭代对象创建-Readable-streams" class="headerlink" title="从可迭代对象创建 Readable streams"></a>从可迭代对象创建 Readable streams</h5><p><code>Readable.from()</code> 方法支持从数组或者其他可迭代对象（比如 generators, iterators, async iterators）创建 Readable streams。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountains = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Everest'</span>, <span class="attr">height</span>: <span class="number">8848</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'K2'</span>, <span class="attr">height</span>: <span class="number">8611</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Kangchenjunga'</span>, <span class="attr">height</span>: <span class="number">8586</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Lhotse'</span>, <span class="attr">height</span>: <span class="number">8516</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Makalu'</span>, <span class="attr">height</span>: <span class="number">8481</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountainsStream = Readable.from(mountains)</span><br><span class="line">mountainsStream.on(<span class="string">'data'</span>, (mountain) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mountain.name.padStart(<span class="number">14</span>)&#125;</span>\t<span class="subst">$&#123;mountain.height&#125;</span>m`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Writable-streams"><a href="#Writable-streams" class="headerlink" title="Writable streams"></a>Writable streams</h4><h5 id="向流写入数据"><a href="#向流写入数据" class="headerlink" title="向流写入数据"></a>向流写入数据</h5><p><code>write()</code> 方法可以向 Writable stream 写入数据。<br><code>writable.write(chunk, [encoding], [callback])</code></p><p><code>end()</code> 方法可以向 stream 表明没有更多的数据需要写入。<br><code>writable.end([chunk], [encoding], [callback])</code></p><p><code>callback</code> 回调函数等同于为 <code>finish</code> 事件注册了一个 listener，会在流中写入的所有数据刷新到底层资源中时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">  <span class="keyword">while</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">95</span>&#125;)) &#123;</span><br><span class="line">    res.write(<span class="string">`<span class="subst">$&#123;chance.string()&#125;</span>\n`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(<span class="string">'\n\n'</span>)</span><br><span class="line">  res.on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'All data sent'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on http://localhost:8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中 HTTP 服务里的 <code>res</code> 对象是一个 <code>http.ServerResponse</code> 对象，实际上也是一个 Writable stream。</p><h5 id="实现-Writable-stream"><a href="#实现-Writable-stream" class="headerlink" title="实现 Writable stream"></a>实现 Writable stream</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFileStream</span> <span class="keyword">extends</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options, <span class="attr">objectMode</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> ToFileStream()</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> Writable(&#123;</span><br><span class="line">  objectMode: <span class="literal">true</span>,</span><br><span class="line">  write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure></p><h4 id="Duplex-streams"><a href="#Duplex-streams" class="headerlink" title="Duplex streams"></a>Duplex streams</h4><p>Duplex 流，既 Readable 又 Writable 的流。它的场景在于，有时候我们描述的实体既是数据源，也是数据的接收者，比如网络套接字。<br>Duplex 流同时继承来着 <code>stream.Readable</code> 和 <code>stream.Writable</code> 的方法。<br>为了创建一个自定义的 Duplex 流，我们必须同时提供 <code>_read()</code> 和 <code>_write()</code> 的实现。</p><h4 id="Transform-streams"><a href="#Transform-streams" class="headerlink" title="Transform streams"></a>Transform streams</h4><p>Transform 流是一种特殊类型的 Duplex 流，主要针对数据的转换。<br>对于 Duplex 流来说，流入和流出的数据之间并没有直接的联系。比如一个 TCP 套接字，只是从远端接收或者发送数据，套接字本身不知晓输入输出之间的任何关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1a65d864ebeb31b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Duplex stream"></p><p>而 Transform 流则会对收到的每一段数据都应用某种转换操作，从 Writable 端接收数据，进行某种形式地转换后再通过 Readable 端提供给外部。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7f97e927ba0479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transform stream"></p><h5 id="实现-Transform-流"><a href="#实现-Transform-流" class="headerlink" title="实现 Transform 流"></a>实现 Transform 流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceStream</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(searchStr, replaceStr, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options&#125;)</span><br><span class="line">    <span class="keyword">this</span>.searchStr = searchStr</span><br><span class="line">    <span class="keyword">this</span>.replaceStr = replaceStr</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (<span class="keyword">this</span>.tail + chunk).split(<span class="keyword">this</span>.searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = <span class="keyword">this</span>.searchStr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(<span class="keyword">this</span>.replaceStr))</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.tail)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> ReplaceStream(<span class="string">'World'</span>, <span class="string">'Node.js'</span>)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure><p>其中核心的 <code>_transform()</code> 方法，其有着和 Writable 流的 <code>_write()</code> 方法基本一致的签名，但并不会将处理后的数据写入底层资源，而是通过 <code>this.push()</code> 推送给内部 buffer，正如 Readable 流中 <code>_read()</code> 方法的行为。<br>所以形成了 Transform 流整体上接收、转换、发送的行为。<br><code>_flush()</code> 则会在流结束前调用。</p><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchStr = <span class="string">'World'</span></span><br><span class="line"><span class="keyword">const</span> replaceStr = <span class="string">'Node.js'</span></span><br><span class="line"><span class="keyword">let</span> tail = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  defaultEncoding: <span class="string">'utf-8'</span>,</span><br><span class="line"></span><br><span class="line">  transform(chunk, encoding, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (tail + chunk).split(searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = searchStr.length - <span class="number">1</span></span><br><span class="line">    tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(replaceStr))</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,</span><br><span class="line">  flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(tail)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure></p><h4 id="Transform-流筛选和聚合数据"><a href="#Transform-流筛选和聚合数据" class="headerlink" title="Transform 流筛选和聚合数据"></a>Transform 流筛选和聚合数据</h4><p>数据源 <code>data.csv</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type,country,profit</span><br><span class="line">Household,Namibia,597290.92</span><br><span class="line">Baby Food,Iceland,808579.10</span><br><span class="line">Meat,Russia,277305.60</span><br><span class="line">Meat,Italy,413270.00</span><br><span class="line">Cereal,Malta,174965.25</span><br><span class="line">Meat,Indonesia,145402.40</span><br><span class="line">Household,Italy,728880.54</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"csv-parse"</span>: <span class="string">"^4.10.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>FilterByCountry</code> Transform 流 <code>filter-by-country.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByCountry</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(country, options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.country = country</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record.country === <span class="keyword">this</span>.country) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(record)</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SumProfit</code> Transform 流 <code>sum-profit.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SumProfit</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.total = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.total += <span class="built_in">Number</span>.parseFloat(record.profit)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.total.toString())</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> parse <span class="keyword">from</span> <span class="string">'csv-parse'</span></span><br><span class="line"><span class="keyword">import</span> &#123;FilterByCountry&#125; <span class="keyword">from</span> <span class="string">'./filter-by-conutry.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;SumProfit&#125; <span class="keyword">from</span> <span class="string">'./sum-profit.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> csvParser = parse(&#123;<span class="attr">columns</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(<span class="string">'data.csv'</span>)</span><br><span class="line">  .pipe(csvParser)</span><br><span class="line">  .pipe(<span class="keyword">new</span> FilterByCountry(<span class="string">'Italy'</span>))</span><br><span class="line">  .pipe(<span class="keyword">new</span> SumProfit())</span><br><span class="line">  .pipe(process.stdout)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Streams&lt;/strong&gt; 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
      <category term="Pipe" scheme="https://rollingstarky.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Callbacks 和 Events</title>
    <link href="https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/"/>
    <id>https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/</id>
    <published>2022-09-06T16:00:00.000Z</published>
    <updated>2022-09-07T14:18:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。</p><p>而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在“后台”启动和执行的。当我们调用某个异步操作后，即使其并没有执行完毕，该异步操作之后的代码指令也会立刻继续执行。<br>在这种情况下，我们就需要一种“通知”机制。当异步操作执行完毕，我们会收到通知，获取该操作的结果并继续之前定义的执行流程。在 Node.js 中，最基础的通知机制就是<strong>回调函数</strong>。它本质上就是一种由 runtime 调用的带有异步操作结果的函数。</p><h3 id="Callback-模式"><a href="#Callback-模式" class="headerlink" title="Callback 模式"></a>Callback 模式</h3><p>回调函数是一种能够传递操作结果的函数，正是异步编程所需要的。JavaScript 对于回调函数来说是一种理想的语言，函数是<strong>第一等对象</strong>，可以轻松地赋值给变量、作为参数传递给另一个函数、作为函数的返回值，以及存储到数据结构中。</p><h4 id="The-continuation-passing-style"><a href="#The-continuation-passing-style" class="headerlink" title="The continuation-passing style"></a>The continuation-passing style</h4><p>在 JavaScript 中，回调函数会作为参数传递给另一个函数，并且在操作完成时连同结果一起被调用。即执行结果被传递给另一个函数（callback），而不是直接返回给调用者。这种方式在函数式编程里称作 <strong>continuation-passing style (CPS)</strong>。</p><p>下面是一个非常简单的同步函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上述函数等效的 CPS 形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCps</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  callback(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">addCps(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: $result`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; Result: $result</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br></pre></td></tr></table></figure></p><p><code>addCps</code> 就是一个同步的 CPS 函数。</p><h4 id="Asynchronous-CPS"><a href="#Asynchronous-CPS" class="headerlink" title="Asynchronous CPS"></a>Asynchronous CPS</h4><p><code>addCps</code> 函数的异步版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">additionAsync</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(a + b), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">additionAsync(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: <span class="subst">$&#123;result&#125;</span>`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br><span class="line"><span class="comment">// =&gt; Result: 3</span></span><br></pre></td></tr></table></figure></p><p>上面的代码使用 <code>setTimeout</code> 来模拟回调函数的异步调用。由于 <code>setTimeout</code> 触发的是异步操作，它并不会等待回调函数 callback 执行，而是立即返回。将控制权交还给 <code>additionAsync</code> 进而回到调用者身上，执行主程序中的第二个 <code>console.log</code>。当异步操作执行完毕后，程序从之前控制权转移时的位置起恢复执行，callback 中的 <code>console.log</code> 被执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9fbb0d2cfbef3f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Control flow of an asynchronous function&#39;s invocation"></p><p>总结一下就是，同步函数会阻塞其他操作步骤，直到其自身执行完毕；异步函数会立即返回，它的执行结果会在 event loop 的后续周期中传递给 handler（即回调函数）。</p><h4 id="同步-or-异步"><a href="#同步-or-异步" class="headerlink" title="同步 or 异步"></a>同步 or 异步</h4><p>指令的执行顺序取决于函数的自然属性——同步还是异步，这对于整个应用流程的正确性和效率都有很大的影响。所以需要时刻注意避免制造矛盾和困惑。</p><h5 id="Unleashing-Zalgo"><a href="#Unleashing-Zalgo" class="headerlink" title="Unleashing Zalgo"></a>Unleashing Zalgo</h5><p>一个 API 最危险的情形之一，就是有些时候表现为同步另一些情况下表现为异步。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// invoked synchronously</span></span><br><span class="line">    cb(cache.get(filename))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述程序就是危险的。假如某个文件是第一次被读取，它会表现为异步操作，读取文件设置缓存；当某个文件的内容已经存在于缓存中时，它会表现为同步操作。</p><p>参考下面的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  inconsistentRead(filename, value =&gt; &#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`First call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">  reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Second call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中 <code>createFileReader</code> 函数会创建一个新的 <code>{ onDataReady: function() }</code> 对象作为通知器，以帮助我们为文件读取操作设置多个 listener。若 <code>inconsistentRead</code> 是纯异步操作，实际上 <code>onDataReady</code> 会先被调用，将传入的 listener 添加到 listeners 列表中。之后 <code>inconsistentRead</code> 读取文件内容完毕，回调函数 <code>cb</code> 执行，遍历 listeners 列表并将读取到的文件内容传给 listener。</p><p>实际的执行结果为：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First <span class="keyword">call</span> data: some data</span><br></pre></td></tr></table></figure></p><p>第二次读取同一个文件并没有获取到任何内容。</p><p>原因在于，当 <code>reader1</code> 创建时，<code>inconsistentRead</code> 函数表现为异步的，因为该文件是第一次被读取。因而 <code>onDataReady</code> 会在刚开始读取文件时就将传入的 listener 添加到 listeners 列表中。文件读取完毕后 listeners 中注册的 listener 被调用。<br><code>reader2</code> 创建时同一个文件的缓存内容已经存在，<code>inconsistentRead</code> 表现为同步的。它的回调函数会立即调用，遍历 listeners 列表。然而我们是先创建的 <code>reader2</code> 再添加的 listener，这就导致遍历 listeners 列表时，向 listeners 添加 listener 的操作还没有执行，我们传入的 listener 并没有来得及注册。</p><p>在实际的应用中，上述类型的 bug 会非常难以定位和复现。npm 的创造者 Isaac Z. Schlueter 将类似的使用不可预测函数的行为，叫做 <em>unleashing Zalgo</em>。</p><h5 id="使用同步-API"><a href="#使用同步-API" class="headerlink" title="使用同步 API"></a>使用同步 API</h5><p>想修复前面的 <code>inconsistentRead</code> 函数，一种可能的方案就是令其彻底变成同步的。实际上 Node.js 针对基础的 I/O 操作提供了一系列同步的 API。比如 <code>fs.readFileSync</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFileSync&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadSync</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(filename)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = readFileSync(filename)</span><br><span class="line">    cache.set(filename, data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，使用同步 API 而不是异步 API 也有一定的风险：</p><ul><li>针对特定功能的同步 API 有可能不存在</li><li>同步 API 会阻塞 event loop，暂停任何并发请求。从而破坏 Node.js 的并发模型并拖慢整个应用</li></ul><p>在很多情况下，使用同步 I/O 操作在 Node.js 里都是非常不推荐的。但在一些场景下，同步 I/O 可能是最简单和高效的方案。比如在应用启动时使用同步阻塞 API 加载配置文件。</p><h5 id="通过延迟执行保证异步性"><a href="#通过延迟执行保证异步性" class="headerlink" title="通过延迟执行保证异步性"></a>通过延迟执行保证异步性</h5><p>另一种修复 <code>inconsistentRead</code> 函数的方案就是，将其变成纯异步操作。诀窍就是将同步的回调函数延期到“未来”执行，而不是在同一个 event loop 周期里立即被调用。<br>在 Node.js 中，可以通过 <code>process.nextTick()</code> 来实现。它会接收一个回调函数作为参数，将其推入到事件队列顶部，位于所有 pending 的 I/O 事件之前，然后立即返回。回调函数会在 event loop 再次收回控制权时立即被调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// deferred callback invocation</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache.get(filename)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Node-js-回调函数的最佳实践"><a href="#Node-js-回调函数的最佳实践" class="headerlink" title="Node.js 回调函数的最佳实践"></a>Node.js 回调函数的最佳实践</h4><h5 id="回调函数出现在最后"><a href="#回调函数出现在最后" class="headerlink" title="回调函数出现在最后"></a>回调函数出现在最后</h5><p>在所有核心的 Node.js 函数中，当其接收一个回调函数作为输入时，回调函数必须作为最后一个参数传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readFile(filename, [options], callback)</span><br></pre></td></tr></table></figure></p><h5 id="error-总是出现在前面"><a href="#error-总是出现在前面" class="headerlink" title="error 总是出现在前面"></a>error 总是出现在前面</h5><p>在 Node.js 中，任何 CPS 函数产生的错误都必须作为回调函数的第一个参数传递，任何实际的执行结果都从第二个参数开始。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    handleError(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processData(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最佳实践还在于总是检查 error 是否存在，以及 error 的定义必须是 <code>Error</code> 类型。</p><h5 id="传递-error"><a href="#传递-error" class="headerlink" title="传递 error"></a>传递 error</h5><p>在同步的函数中，传递 error 可以通过常用的 <code>throw</code> 语句。而在异步的 CPS 函数中，则可以简单地将 error 传递给链条上的下一个回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSON</span>(<span class="params">filename, callack</span>) </span>&#123;</span><br><span class="line">  readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsed</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// propagate the error and exit the current function</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// parse the file contents</span></span><br><span class="line">      parsed = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// catch parsing errors</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no errors, propagate just the data</span></span><br><span class="line">    callack(<span class="literal">null</span>, parsed)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在 Node.js 中另外一种非常重要和基础的模式就是<strong>观察者（Ovserver）模式</strong>。同 Reactor 模式、回调函数一起，它们都是掌握 Node.js 异步编程的绝对要求。<br>观察者模式定义了一类称为 subject 的对象，它们可以在状态改变时向一系列称为观察者的对象发送通知。它是对回调函数的完美补充。主要区别在于 subject 能够通知多个观察者，而传统的 CPS 回调函数通常只会将结果传递给一个 listener。</p><h4 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h4><p>观察者模式实际上已经通过 <code>EventEmitter</code> 类内置到 Node.js 的核心中了。<code>EventEmitter</code> 类允许我们注册一个或者多个函数作为 listener，这些 listener 会在特定的事件触发时自动被调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9577c60299839e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Listeners receiving events from an EventEmitter"></p><p><code>EventEmitter</code> 类的基础方法如下：</p><ul><li><code>on(event, listener)</code>：该方法允许我们为指定的事件类型（一个字符串）注册一个新的 listener（一个函数）</li><li><code>once(event, listener)</code>：该方法允许我们注册一个新的 listener，并且该 listener 会在事件触发一次之后自动被移除</li><li><code>emit(event, [arg1], [...])</code>：该方法会产生一个新的事件，并向指定向 listeners 传递的额外的参数</li><li><code>removeListener(event, listener)</code>：该方法用来移除某个 listener</li></ul><p>上述所有的方法都会返回一个 <code>EventEmitter</code> 实例并允许被串联起来。</p><h5 id="创建和使用-EventEmitter"><a href="#创建和使用-EventEmitter" class="headerlink" title="创建和使用 EventEmitter"></a>创建和使用 EventEmitter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findRegex</span>(<span class="params">files, regex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> emitter.emit(<span class="string">'error'</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      emitter.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line">      <span class="keyword">const</span> match = content.match(regex)</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> emitter.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> emitter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findRegex([<span class="string">'fileA.txt'</span>, <span class="string">'fileB.json'</span>], /hello \w+<span class="regexp">/g)</span></span><br><span class="line"><span class="regexp">  .on('fileread', file =&gt; console.log(`$&#123;file&#125; was read`))</span></span><br><span class="line"><span class="regexp">  .on('found', (file, match) =&gt; console.log(`Matched "$&#123;match&#125;" in $&#123;file&#125;`))</span></span><br><span class="line"><span class="regexp">  .on('error', err =&gt; console.error(`Error emitted $&#123;err.message&#125;`))</span></span><br></pre></td></tr></table></figure><h5 id="令任意对象变得“可监测”"><a href="#令任意对象变得“可监测”" class="headerlink" title="令任意对象变得“可监测”"></a>令任意对象变得“可监测”</h5><p>在 Node.js 的世界里，<code>EventEmitter</code> 很少像上面的例子那样被直接使用。更为常见的情况是其他类继承 <code>EventEmitter</code> 从而变成一个可监测的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindRegex</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(regex) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.regex = regex</span><br><span class="line">    <span class="keyword">this</span>.files = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addFile(file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.files.push(file)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> <span class="keyword">this</span>.files) &#123;</span><br><span class="line">      readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> match = content.match(<span class="keyword">this</span>.regex)</span><br><span class="line">        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">          match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRegexInstance = <span class="keyword">new</span> FindRegex(<span class="regexp">/hello \w+/g</span>)</span><br><span class="line">findRegexInstance</span><br><span class="line">  .addFile(<span class="string">'fileA.txt'</span>)</span><br><span class="line">  .addFile(<span class="string">'fileB.json'</span>)</span><br><span class="line">  .find()</span><br><span class="line">  .on(<span class="string">'found'</span>, (file, match) =&gt; <span class="built_in">console</span>.log(<span class="string">`Matched "<span class="subst">$&#123;match&#125;</span>" in file <span class="subst">$&#123;file&#125;</span>`</span>))</span><br><span class="line">  .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.error(<span class="string">`Error emitted <span class="subst">$&#123;err.message&#125;</span>`</span>))</span><br></pre></td></tr></table></figure></p><h4 id="EventEmitter-vs-Callback"><a href="#EventEmitter-vs-Callback" class="headerlink" title="EventEmitter vs Callback"></a>EventEmitter vs Callback</h4><p>以下的几点可以作为选择 EventEmitter 还是 Callback 的依据：</p><ul><li>当涉及到需要支持不同类型的事件时，Callback 会有一定的限制。实际上 Callback 也可以区分多个事件，只需要将事件类型作为参数传给回调函数，或者接收多个回调函数。但在这样的情况下，EventEmitter 可以提供更优雅的接口和更精简的代码</li><li>当同样的事件可能多次发生或者根本不会发生时，应该使用 EventEmitter。而无论操作是否成功，回调函数都只会被调用一次</li><li>回调函数机制只支持通知一个特定的 listener，而 EventEmitter 允许我们为同一个事件注册多个 listener</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。&lt;/p&gt;
&lt;p&gt;而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Callback" scheme="https://rollingstarky.github.io/tags/Callback/"/>
    
      <category term="Observer" scheme="https://rollingstarky.github.io/tags/Observer/"/>
    
      <category term="Asynchronous" scheme="https://rollingstarky.github.io/tags/Asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Node.js 的设计哲学和原理</title>
    <link href="https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/"/>
    <id>https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/</id>
    <published>2022-09-04T16:00:00.000Z</published>
    <updated>2022-09-07T14:02:50.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Node-js-哲学"><a href="#一、Node-js-哲学" class="headerlink" title="一、Node.js 哲学"></a>一、Node.js 哲学</h4><p>每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受的指导原则和规范。这些规范对语言平台本身的演进以及如何设计和开发应用都有着深刻的影响。</p><h5 id="小的核心"><a href="#小的核心" class="headerlink" title="小的核心"></a>小的核心</h5><p>Node.js 核心，包含 Node.js 运行时以及所有内置的模块。这个核心遵循一系列基本的设计原则。其中一个就是<strong>尽可能只实现所需功能的最小集合</strong>，在此之外的非核心功能则由用户自行实现。用户自己开发的模块围绕在核心周围，形成了一个自由开放的软件生态。<br>将核心的功能限制在最小程度，其他的需求则给与社区足够的自由度，去验证和实现更广泛的解决方案。不仅提升了核心本身的可维护性，同时也给整个生态环境带来了正向的文化氛围。</p><h5 id="小的模块"><a href="#小的模块" class="headerlink" title="小的模块"></a>小的模块</h5><p>Node.js 使用<strong>模块（module）</strong>这个概念来表示程序代码的基础构件，模块是构成应用和库的基本单位。<br>在 Node.js 中，一个广受推崇的原则就是，设计小的模块和包。这里的“小”不仅仅是指代码本身的规模，更为关键的是功能上的“小”和集中。<br>上述原则深受 Unix 设计哲学的影响，即：</p><ul><li>Small is beautiful（小即为美）</li><li>Make each program do one thing well（只做好一件事）</li></ul><p>小的模块具有以下特点：</p><ul><li>更容易理解和使用</li><li>更容易测试和维护</li><li>体积小，在浏览器上运行有优势</li></ul><p>更小、更集中的模块鼓励每一个人共享和重用每一段哪怕是最小的代码块，在一定程度上提升了代码的可重用性。牢记 <strong>Don’t Repeat Yourself (DRY)</strong> 原则。</p><h5 id="Small-surface-area"><a href="#Small-surface-area" class="headerlink" title="Small surface area"></a>Small surface area</h5><p>除了在代码量和功能性上更小以外，Node.js 模块的另一个理想特征就是，尽可能向外界公开一组最小的功能集合。这可以帮助我们实现更清晰、不容易被错误使用的 API。模块只向外暴露单一的功能，只向外提供唯一一个清晰的、明确无误的入口。</p><p>很多 Node.js 模块的另一个特点是，模块本身被创建出来，是为了被使用而不是被扩展。通过禁止任何扩展来锁定模块内部，听起来缺乏一定的灵活性。但同时也带来了减少用例、简化实现、增强可维护性、提升可用性等优势。<br>在实践中，这意味着更倾向于对外暴露函数而不是类，避免向外部世界泄露任何内部的细节。</p><h5 id="简单性和实用主义"><a href="#简单性和实用主义" class="headerlink" title="简单性和实用主义"></a>简单性和实用主义</h5><p><strong>Keep It Simple, Stupid (KISS)</strong><br>设计简单的，而不是“完美”的、功能完备的软件，在实践中往往是更优的选择：</p><ul><li>更少的时间和资源去实现</li><li>更快地完成交付</li><li>更容易适应不断变化和增加的需求</li><li>更容易理解和维护</li></ul><p>JavaScript 是一种非常“现实”的语言。在实践中，经常见到使用更简单的类、函数和闭包替换复杂的层级结构的类。<br>纯粹的 OO 设计常常致力于使用数学模型完整地复制现实世界，并没有考虑到现实本身的“不完美”和复杂性。事实上，我们的软件一直都是对现实世界的接近，如果能够放弃创建“完美”软件的执念，尝试构造一个有着合理复杂度、能够快速工作的成品，有可能会获取到更大的成功。</p><h4 id="二、Node-js-核心原理"><a href="#二、Node-js-核心原理" class="headerlink" title="二、Node.js 核心原理"></a>二、Node.js 核心原理</h4><h5 id="I-O-很慢"><a href="#I-O-很慢" class="headerlink" title="I/O 很慢"></a>I/O 很慢</h5><p>在计算机的世界里，I/O 算得上基础操作里最慢的一种了。比如访问 RAM 的速度处于纳秒（10^-9）量级，而访问磁盘或者网络数据的速度则处于毫秒（10^-3）量级。I/O 操作通常并不消耗多少 CPU 资源，但它实际上在请求发出和操作完成之间增添了很大的延迟。<br>此外，我们还必须考虑人为因素。很多场景下应用的输入依赖于具体的个人，比如点击鼠标等。从而导致现实里的 I/O 速度，有可能比纯技术层面的磁盘和网络读写要慢得多。</p><h5 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h5><p>在传统的阻塞式 I/O 编程中，I/O 请求关联的函数调用会阻塞线程的执行，直到 I/O 操作完成。这会导致一定程度的延迟，有可能是毫秒级别，比如 I/O 操作涉及到磁盘读写；也有可能长达几分钟甚至更久，比如等待用户提供某些输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks the thread until the data is available</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// data is available</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>很明显，由阻塞式 I/O 实现的 Web 服务无法在同一个线程中同时处理多个连接请求，因为 socket 上的每个 I/O 操作都会阻塞任何其他连接的访问。解决此问题的传统方法就是借助多线程，每个独立的线程分别处理并发连接中的一个请求。<br>一个线程被 I/O 操作阻塞，并不会影响其他的线程继续提供服务。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f4675436ce4d0fd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using multiple threads to process multiple connections"></p><p>多线程的缺点在于，从资源消耗的角度看，线程并不是一个低廉的选择。他会消耗内存，引发上下文切换等。一个长时间运行的只处理一个网络请求的线程，实际上有可能大部分时间并没有在工作，这意味着对内存和 CPU 资源的浪费。</p><h5 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h5><p>除了阻塞式 I/O 外，现代的操作系统还支持另一种访问资源的机制，称为<strong>非阻塞式 I/O</strong>。在这种模式下，系统调用会立即返回，无需等待读写操作彻底完成。若返回时还没有获取到任何结果，则返回一个预定义的对象，该对象表明此时没有任何数据可以获取到。<br>处理非阻塞式 I/O 的最基本的模式就是，通过循环主动轮询资源池中的资源，直到某个对象返回了实际的数据。这种方式称为 <strong>busy-waiting</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, fileA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (resource <span class="keyword">of</span> resources) &#123;</span><br><span class="line">    <span class="comment">// try to read</span></span><br><span class="line">    data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// there is no data to read at the moment</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the list</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//some data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述简单的机制，不同的资源即能够在同一个线程中被处理。但仍然不够高效。实际上，CPU 的大部分时钟都被循环用来查询还没有准备好的资源，轮询算法通常意味着 CPU 资源的大量浪费。</p><h5 id="解多路复用"><a href="#解多路复用" class="headerlink" title="解多路复用"></a>解多路复用</h5><p>Busy-waiting 并不是处理非阻塞资源的理想技术，好在现代的大部分操作系统还提供了一种高效的原生机制，专门用来处理并发的非阻塞需求。该机制称为 <strong>synchronous event demultiplexer</strong> 或 <strong>event notification interface</strong>。<br><strong>multiplexing</strong> 是指将多路信号合并到一条通信链路中进行传输；<strong>demultiplexing</strong> 则是指相反的操作，将合并到一条链路中的数据重新还原成原本的多路信号。</p><p>synchronous event demultiplexer 会同时监听多个资源，当其中任何一个资源对应的读写操作完成时，就会返回一个或一系列新的事件。它的优势在于 <strong>synchronous</strong>，即它是<strong>同步</strong>的，当没有任何新的事件需要处理时，它会一直处于阻塞状态。<br>因而我们可以在同一个线程中处理多个 I/O 操作，同时不至于像 busy-waiting 那样持续轮询消耗资源。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1a479833a864587d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using a single thread to process multiple connections"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watchedList.add(socketA, FOR_READ)</span><br><span class="line">watchedList.add(fileB, FOR_READ)</span><br><span class="line"><span class="keyword">while</span> (events = demultiplexer.watch(watchedList)) &#123;</span><br><span class="line">  <span class="comment">// event loop</span></span><br><span class="line">  <span class="keyword">for</span> (event <span class="keyword">of</span> events) &#123;</span><br><span class="line">    <span class="comment">// This read will never block and will always return data</span></span><br><span class="line">    data = event.resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the watched list</span></span><br><span class="line">      demultiplexer.unwatch(event.resource)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// some actual data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>demultiplexer.watch()</code> 方法是同步的，当它监听的资源没有任何一个准备好时，它会一直处于阻塞状态。直到有任意资源准备好后，才会返回一系列新的事件。这个时间点返回的事件及其关联的资源由于是已经“准备好”的，可以被直接读取而不会阻塞。</p><h5 id="Reactor-pattern"><a href="#Reactor-pattern" class="headerlink" title="Reactor pattern"></a>Reactor pattern</h5><p>Reactor 模式背后的主要理念，就是给每一个 I/O 操作绑定一个 handler。在 Node.js 中可以使用回调函数来表示 handler。当某个事件被 event loop 生产和处理完之后，对应的 handler 就会立即被触发。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1c7eb9186ecf94f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The reactor pattern"></p><ul><li>应用首先向 <strong>Event Demultiplexer</strong> 提交一个请求，由此生成一个新的 I/O 操作。与此同时应用会为该请求绑定一个 handler，当 I/O 操作结束时自动被调用。向 Event Demultiplexer 提交请求的操作是非阻塞的，该操作提交后程序控制权会立即返还给应用</li><li>当一系列 I/O 操作完成后，Event Demultiplexer 会向 <strong>Event Queue</strong> 中推入对应的事件</li><li><strong>Event Loop</strong> 会不断遍历 Event Queue 中的事件，调用每一个事件对应的 handler</li><li>handler 代码实际上是应用本身的一部分，它在执行完毕后又会把控制权给到 Event Loop。在 handler 执行的过程中，应用仍然可以向 Event Demultiplexer 提交新的异步操作请求</li></ul><p>简单来说，所谓的异步行为，就是应用先在某个时间点表达出想要访问某个资源的兴趣（这个操作是非阻塞的），并给这个资源定义一个 handler。在另一个时间节点当资源能够被访问之后，绑定的 handler 自动被调用，处理对应的资源。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、Node-js-哲学&quot;&gt;&lt;a href=&quot;#一、Node-js-哲学&quot; class=&quot;headerlink&quot; title=&quot;一、Node.js 哲学&quot;&gt;&lt;/a&gt;一、Node.js 哲学&lt;/h4&gt;&lt;p&gt;每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="KISS" scheme="https://rollingstarky.github.io/tags/KISS/"/>
    
      <category term="DRY" scheme="https://rollingstarky.github.io/tags/DRY/"/>
    
      <category term="Reactor" scheme="https://rollingstarky.github.io/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Template 模式</title>
    <link href="https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/"/>
    <id>https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-07-18T11:52:30.745Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Template</strong> 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。<br>之后由虚拟基类的子类来实现上述组件中缺失的未定义部分，这部分之前未定义的方法称为 <strong>template methods</strong>。<br>此模式的目的在于，定义一系列属于“同一家族”的类，能够囊括某个组件的所有变体。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-766fa71787b062ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML of Template pattern"></p><p>Template 和 Strategy 模式的目的是非常相似的，它们之间的区别主要在于结构和实现。<br>两者都允许我们在共享组件中通用部分的同时，修改组件中变化的部分，以此形成不同的变体。不同的地方在于，Strategy 是在运行时<strong>动态</strong>实现的，而 Template 则在子类定义的时刻就已经被确定了。</p><h4 id="配置管理模板"><a href="#配置管理模板" class="headerlink" title="配置管理模板"></a>配置管理模板</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> template &amp;&amp; <span class="built_in">cd</span> template</span><br><span class="line">npm install ini</span><br><span class="line">npm install objec-<span class="built_in">path</span></span><br></pre></td></tr></table></figure><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>configTemplate.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> objectPath <span class="keyword">from</span> <span class="string">'object-path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> load(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>._deserialize(</span><br><span class="line">      <span class="keyword">await</span> fsPromises.readFile(file, <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> save(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> fsPromises.writeFile(file, <span class="keyword">this</span>._serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(path) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(path, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, path, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'_serialize() must be implemented'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _deserialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`_deserialize() must be implemented`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>configTemplate</code> 虚拟基类实现了配置管理逻辑中的通用部分，即加载和保存文件、获取和设置属性。同时不对序列化和反序列化部分的逻辑进行定义，从而可以通过再创建不同的 Config 子类（即后面的 <code>jsonConfig</code> 和 <code>iniConfig</code>）来实现具体的序列化逻辑，进而支持特定的配置文件格式。</p><p><code>jsonConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>iniConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"><span class="keyword">import</span> ini <span class="keyword">from</span> <span class="string">'ini'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">IniConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;JsonConfig&#125; <span class="keyword">from</span> <span class="string">'./jsonConfig.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;IniConfig&#125; <span class="keyword">from</span> <span class="string">'./iniConfig.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> jsonConfig = <span class="keyword">new</span> JsonConfig()</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.load(<span class="string">'samples/conf.json'</span>)</span><br><span class="line">  jsonConfig.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.save(<span class="string">'samples/conf_mod.json'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> iniConifg = <span class="keyword">new</span> IniConfig()</span><br><span class="line">  <span class="keyword">await</span> iniConifg.load(<span class="string">'samples/conf.ini'</span>)</span><br><span class="line">  iniConifg.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> iniConifg.save(<span class="string">'samples/conf_mod.ini'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Template&lt;/strong&gt; 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。&lt;br&gt;之后由虚拟基类的子类来实现上述组件中缺失的未
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Javascript" scheme="https://rollingstarky.github.io/tags/Javascript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Template" scheme="https://rollingstarky.github.io/tags/Template/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— State 模式</title>
    <link href="https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-state-pattern/"/>
    <id>https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-state-pattern/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-07-18T11:55:27.292Z</updated>
    
    <content type="html"><![CDATA[<p><strong>State</strong> 模式是一种特殊形式的 <strong>Strategy</strong> 模式：Context 选择的具体策略根据不同的 <em>state</em> 发生变化。<br>对于 Strategy 模式，可以基于不同的变量比如传入的参数来决定选择具体哪个策略，一旦选择确定后，直到 context 剩余的整个生命周期结束，该策略都保持不变。相反在 State 模式中，策略（或者在这里的语境下，叫做<strong>状态</strong>）在 context 的生命周期里是动态变化的，从而允许对象的行为可以根据内部状态的变化自适应地更改。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6df095b24f7fe88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="State pattern"></p><p>举例来说，我们需要创建一个宾馆预定系统，由一个 <strong>Reservation</strong> 类对预定房间的行为进行建模。</p><p>考虑如下一系列事件：</p><ul><li>当 reservation 对象初次创建后，其处于<strong>未确认</strong>状态。用户可以通过一个 <code>confirm()</code> 方法对此次预定进行确认。但不能通过 <code>cancel()</code> 方法取消预订，因为此次预定还并没有被确认。可以使用 <code>delete()</code> 方法删除这条记录</li><li>一旦该 reservation 被确认，订单处于<strong>已确认</strong>状态。<code>confirm()</code> 方法将不能再次被调用（不能重复确认）；但该 reservation 支持通过 <code>cancel()</code> 方法进行取消，同时该记录无法被删除（已经有人确认预定）</li><li>在 reservation 日期的前一天，订单处于<strong>已生效</strong>状态。上述所有 3 个方法都不再支持，用户只能办理入住</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4cc6dc24c762ec3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="State pattern"></p><p>参考上图，可以实现 3 种 不同的策略，他们都实现了 <code>confirm()</code>、<code>cancel()</code>、<code>delete()</code> 这几个方法。每种策略的具体逻辑由不同的状态决定。<strong>Reservation</strong> 对象只需要在每次状态切换时，激活对应的策略。</p><h4 id="实例：failsafe-socket"><a href="#实例：failsafe-socket" class="headerlink" title="实例：failsafe socket"></a>实例：failsafe socket</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> state &amp;&amp; <span class="built_in">cd</span> state</span><br><span class="line">npm install json-over-tcp-<span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"json-over-tcp-2"</span>: <span class="string">"^0.3.5"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>failsafeSocket.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;OfflineState&#125; <span class="keyword">from</span> <span class="string">'./offlineState.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;OnlineState&#125; <span class="keyword">from</span> <span class="string">'./onlineState.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeSocket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.states = &#123;</span><br><span class="line">      offline: <span class="keyword">new</span> OfflineState(<span class="keyword">this</span>),</span><br><span class="line">      online: <span class="keyword">new</span> OnlineState(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.changeState(<span class="string">'offline'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState(state) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Activating state: <span class="subst">$&#123;state&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.states[state]</span><br><span class="line">    <span class="keyword">this</span>.currentState.activate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述 <code>FailsafeSocket</code> 类主要由以下几个组件构成：</p><ul><li>构造函数 <code>constructor</code> 会初始化一个 <code>queue</code> 队列来存储 socket 离线时发送的数据，还创建了 <code>offline</code> 和 <code>online</code> 两种不同的状态，分别对应离线时和在线时 socket 的不同行为</li><li><code>changeState()</code> 方法负责不同状态的切换。它会更新当前状态 <code>currentState</code> 并调用该状态的 <code>activate()</code> 方法</li><li><code>send()</code> 方法包含 <code>FailsafeSocket</code> 类的主要功能，它会基于在线或离线状态触发不同的行为。这里它将具体的操作指派给了当前激活的状态对象去实现</li></ul><p><code>offlineState.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonOverTcp <span class="keyword">from</span> <span class="string">'json-over-tcp-2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="keyword">const</span> retry = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.activate(), <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Trying to connect...'</span>)</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket = jsonOverTcp.connect(</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.options,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Connection established'</span>)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.socket.removeListener(<span class="string">'error'</span>, retry)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'online'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, retry)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述模块负责定义 socket 处于离线状态时的行为。</p><ul><li><code>send()</code> 方法只负责将接受到的数据存储到队列中，因为此时是离线状态，队列中的数据会在 socket 在线时取出并发送</li><li><code>activate()</code> 方法会尝试建立连接，连接失败则隔一秒重试。成功建立连接后，<code>failsafeSocket</code> 的状态变为在线状态，触发在线状态的 <code>activate()</code> 方法</li></ul><p><code>onlineState.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">    <span class="keyword">this</span>.hasDisconnected = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">    <span class="keyword">this</span>._safeWrite(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _safeWrite(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.write(data, (err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.hasDisconnected &amp;&amp; !err) &#123;</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.queue.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasDisconnected = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> <span class="keyword">this</span>.failsafeSocket.queue) &#123;</span><br><span class="line">      <span class="keyword">this</span>._safeWrite(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.hasDisconnected = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'offline'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>OnlineState</code> 模块实现了当 socket 处于在线状态时的行为。</p><ul><li><code>send()</code> 方法会将数据放入队列，并立即尝试将其写入到 socket，因为此时是在线状态。若该数据成功写入，则将其从队列中移除</li><li><code>activate()</code> 方法会在连接成功建立时触发，会尝试发送在 socket 离线时排队的所有数据并监听任意错误事件。若有错误发生，转换到离线状态，触发离线状态的 <code>activate</code> 方法，继续尝试建立连接</li></ul><p><code>server.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonOverTcp <span class="keyword">from</span> <span class="string">'json-over-tcp-2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = jsonOverTcp.createServer(&#123;<span class="attr">port</span>: <span class="number">5000</span>&#125;)</span><br><span class="line">server.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client data'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">5000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Server started'</span>))</span><br></pre></td></tr></table></figure></p><p><code>client.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;FailsafeSocket&#125; <span class="keyword">from</span> <span class="string">'./failsafeSocket.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> failsafeSocket = <span class="keyword">new</span> FailsafeSocket(&#123;<span class="attr">port</span>: <span class="number">5000</span>&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  failsafeSocket.send(process.memoryUsage())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;State&lt;/strong&gt; 模式是一种特殊形式的 &lt;strong&gt;Strategy&lt;/strong&gt; 模式：Context 选择的具体策略根据不同的 &lt;em&gt;state&lt;/em&gt; 发生变化。&lt;br&gt;对于 Strategy 模式，可以基于不同的变量比如传入的
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Javascript" scheme="https://rollingstarky.github.io/tags/Javascript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Strategy 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/26/node-js-design-patterns-strategy-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/26/node-js-design-patterns-strategy-pattern/</id>
    <published>2022-05-25T16:00:00.000Z</published>
    <updated>2022-05-25T17:08:18.915Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Strategy</strong> 模式的主体是一个 <strong>context</strong> 对象，再把逻辑中有变化的部分抽取到独立的可相互替换的 <strong>strategy</strong> 对象中，从而使 context 支持不同的策略。即 context 实现通用的逻辑，strategy 实现可替换的部分。context 与 不同的 strategy 相组合即产生了多种不同的实现。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-a70dbd6e691fcf91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Strategy"></p><p>就像雨天穿胶鞋，打篮球穿运动鞋，短跑比赛穿跑鞋。这些不同的鞋子对应的就是一系列策略，它们是同一类对象的不同变种，彼此之间可以相互替换。<br>面对不同的使用场景，选择对应的策略即可，这带来了更多的灵活性。首先鞋子和人不能是绑定的，这样的话，换鞋子就需要同时换掉整个人了；其次也没有任何一双鞋可以同时满足所有的使用场景。让鞋子作为可替换的插件无疑是最直观和方便的。<br>总的来说，策略代表了一个对象中可替换的部分。不同的策略应对同一个问题的不同变种。静态与动态分离。</p><p>比如需要实现一个 <code>Order</code> 对象，代表在线商城中的订单。该对象有一个 <code>pay()</code> 方法，负责支付行为，将用户的钱转移到商户手中。为了能够支持多种不同的支付方式，可以有以下两种选项：</p><ul><li>在 <code>pay()</code> 方法中使用 <code>if...else</code>，根据不同的支付方式，完成对应的支付动作</li><li>将支付的具体逻辑移交给独立的 strategy 对象，用户选择支付方式后，将对应的 strategy 注入到 <code>Order</code> 中</li></ul><p>对于第一种方案，当 Order 对象需要支持更多的支付方式时，就必须要修改 Order 本身的代码。这会使代码变得非常复杂，难以维护。<br>当使用第二种 Strategy 模式时，理论上可以支持无限多的支付方式。Order 只负责维护用户、商品条目、价格等信息，具体的支付逻辑则由另一个 Strategy 对象来实现。Order 本身不会由于支付方式的增加而发生任何变更。</p><h4 id="实例：支持-JSON、INI-等多种格式的-config-对象"><a href="#实例：支持-JSON、INI-等多种格式的-config-对象" class="headerlink" title="实例：支持 JSON、INI 等多种格式的 config 对象"></a>实例：支持 JSON、INI 等多种格式的 config 对象</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> strategy &amp;&amp; <span class="built_in">cd</span> strategy</span><br><span class="line">npm install ini</span><br><span class="line">npm install object-<span class="built_in">path</span></span><br></pre></td></tr></table></figure><p><code>package.json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"ini"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"object-path"</span>: <span class="string">"^0.11.8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>config.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> objectPath <span class="keyword">from</span> <span class="string">'object-path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(formatStrategy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.formatStrategy = formatStrategy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(configPath) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, configPath)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(configPath, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, configPath, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> load(filePath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>.formatStrategy.deserialize(</span><br><span class="line">      <span class="keyword">await</span> fs.readFile(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> save(filePath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> fs.writeFile(filePath,</span><br><span class="line">      <span class="keyword">this</span>.formatStrategy.serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中构造函数 <code>constructor</code> 接收一个具体的策略对象 <code>formStrategy</code> 作为参数，之后的 <code>load</code> 和 <code>save</code> 方法又使用这个 <code>formStrategy</code> 去执行与格式相关的序列化和反序列化操作。不同的 <code>formStrategy</code> 有着不同的实现，从而 <code>Config</code> 类可以凭借 <code>construcotr</code> 接收的不同参数，与不同的策略整合，灵活地应对不同的需求场景。</p><p><code>strategy.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ini <span class="keyword">from</span> <span class="string">'ini'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> iniStrategy = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.stringify(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> jsonStrategy = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的代码实现了两种不同的策略：<code>iniStrategy</code> 和 <code>jsonStrategy</code>，分别针对不同的文件格式。它们有着一致的接口，符合策略之间可以相互替换的原则，从而都可以被前面 <code>Config</code> 类的 <code>load</code> 和 <code>save</code> 方法调用。</p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Config&#125; <span class="keyword">from</span> <span class="string">'./config.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;jsonStrategy, iniStrategy&#125; <span class="keyword">from</span> <span class="string">'./strategy.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> iniConfig = <span class="keyword">new</span> Config(iniStrategy)</span><br><span class="line">  <span class="keyword">await</span> iniConfig.load(<span class="string">'samples/conf.ini'</span>)</span><br><span class="line">  iniConfig.set(<span class="string">'book.nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> iniConfig.save(<span class="string">'samples/conf_mod.ini'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> jsonConfig = <span class="keyword">new</span> Config(jsonStrategy)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.load(<span class="string">'samples/conf.json'</span>)</span><br><span class="line">  jsonConfig.set(<span class="string">'book.nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.save(<span class="string">'samples/conf_mod.json'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Strategy&lt;/strong&gt; 模式的主体是一个 &lt;strong&gt;context&lt;/strong&gt; 对象，再把逻辑中有变化的部分抽取到独立的可相互替换的 &lt;strong&gt;strategy&lt;/strong&gt; 对象中，从而使 context 支持不同的策略。
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Proxy 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/</id>
    <published>2022-05-12T16:00:00.000Z</published>
    <updated>2022-05-12T16:14:08.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理（proxy）</strong> 可以理解为一种对象，其能够控制客户端对另一个对象（<strong>subject</strong>）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。<br>proxy 会拦截所有或者部分本应该直接交给 subject 执行的操作，通过额外的预处理或后处理增强其行为，再转发给 subject。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-361cc860946b4838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Proxy pattern schematic"></p><p>Proxy 的主要应用场景：</p><ul><li>Data validation：proxy 对输入数据进行验证，再转发给 subject</li><li>Security：proxy 检查客户端是否有权限执行请求的操作，若检查通过则将请求转发给 subject</li><li>Caching：proxy 负责维护一份内部缓存，只有当请求的数据不在缓存中时，才将该请求转发给 subject 处理</li><li>Lazy initialization：若创建某个对象代价很高，proxy 可以延迟该创建操作直到必要的时候</li><li>Logging：proxy 拦截函数和对应的参数，在函数执行的同时记录日志信息</li><li>Remote objects：proxy 可以接收一个远程对象并令其表现为本地对象</li></ul><h4 id="示例代码：StackCalculator"><a href="#示例代码：StackCalculator" class="headerlink" title="示例代码：StackCalculator"></a>示例代码：StackCalculator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> dividend = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = dividend / divisor</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">const</span> multiplicand = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> multiplier = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = multiplier * multiplicand</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br></pre></td></tr></table></figure><p>现代的计算器基本上都遵循类似的逻辑，即上一个式子的计算结果可以作为下一次计算的输入。<br>在 JavaScript 中，当用户尝试除以 0 时，并不会报错而是返回 <code>Infinity</code>。现在我们尝试借助 Proxy 模式来增强 StackCalculator 除以 0 时的行为。</p><h4 id="Object-composition"><a href="#Object-composition" class="headerlink" title="Object composition"></a>Object composition</h4><p><strong>组合（Composition）</strong>表示一个对象通过引用另一个对象，来扩展或者使用后者的功能。<br>借助组合可以实现 Proxy 模式。创建一个新的对象，令其有着和 subject 完全一致的接口，同时内部还保存着一个对 subject 的引用。参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.divide()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.putValue(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.multiply()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> SafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// 12 / 0 = Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在这次的实现中，proxy 拦截了感兴趣的方法（<code>divide()</code>），为其实现了新的行为（除以 0），而其他的操作（如 <code>putValue()</code>、<code>getValue()</code>、<code>peekValue()</code>、<code>clear()</code> 和 <code>multiply()</code>）则是简单地分派给 subject 去做。<br>计算器的状态（栈中存放的值）仍由 <code>calculator</code> 实例在维护，<code>SafeCalculator</code> 只是调用 <code>calculator</code> 的方法来读取或者修改这些状态。</p><p>上面的实现方式，需要我们显式地将很多方法指派给 subject。即需要写出很多如下形式的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getValue() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这在很大程度上增加了代码的冗余度。</p><h4 id="Object-augmentation"><a href="#Object-augmentation" class="headerlink" title="Object augmentation"></a>Object augmentation</h4><p><strong>对象增强（Object augmentation）</strong>又叫做<strong>猴子补丁（monkey patching）</strong>，能够只代理某个对象的部分方法，并且可能是所有方案中最简单、最常见的一种。<br>它可以将 subject 的某个方法直接替换为 proxy 版本的实现，即直接修改 subject 对象本身。</p><p>参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchToSafeCalculator</span>(<span class="params">calculator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> divideOrig = calculator.divide</span><br><span class="line">  calculator.divide = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// additional validation logic</span></span><br><span class="line">    <span class="keyword">const</span> divisor = calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">    <span class="keyword">return</span> divideOrig.apply(calculator)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> patchToSafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// console.log(calculator.divide())  // Error, not Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>当只需要代理某一个或几个方法的时候，上述方案会非常方便。用户不需要再手动重新实现一遍 <code>putValue()</code> 等方法。<br>不幸的是，简单化也带来了一定的代价，像上面那样直接修改 subject 对象是一种危险的行为。当该 subject 对象被其他部分的代码共享时，修改行为必须尽一切可能避免，从而不至于引发意想不到的 side effect。<br>尝试将代码中的 <code>// console.log(calculator.divide())</code> 取消注释，会发现 <code>calculator</code> 并没有像之前那样输出 <code>Infinity</code>，而是跟 <code>safeCalculator</code> 一样报出错误。即原来的 <code>calculator</code> 对象已经被猴子补丁所改变。</p><h4 id="内置的-Proxy-对象"><a href="#内置的-Proxy-对象" class="headerlink" title="内置的 Proxy 对象"></a>内置的 Proxy 对象</h4><p>ES2015 引入了一种原生的创建 proxy 对象的方式。其语法如下：<br><code>const proxy = new Proxy(target, handler)</code></p><p>其中 <code>target</code> 代表被 proxy 代理的对象（即 subject），<code>handler</code> 对象则用来定义 proxy 的具体行为。它包含一系列可选的预定义方法（如 <code>get</code>、<code>set</code>、<code>apply</code> 等），叫做 <strong>trap methods</strong>，在 subject 上执行对应的操作时会自动触发这些方法。</p><p>示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeCalculatorHandler = &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'divide'</span>) &#123;</span><br><span class="line">      <span class="comment">// proxied method</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// additional validation logic</span></span><br><span class="line">        <span class="keyword">const</span> divisor = target.peekValue()</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">        <span class="keyword">return</span> target.divide()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegated methods and properties</span></span><br><span class="line">    <span class="keyword">return</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  calculator,</span><br><span class="line">  safeCalculatorHandler</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">4</span>)</span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，通过 <code>get</code> trap method 捕获对于原本的 <code>calculator</code> 对象的属性和方法的访问，当访问的方法是 <code>divide()</code> 时，proxy 就会返回一个添加了额外验证逻辑的新函数。<br>之后又简单地使用 <code>target[property]</code> 返回了所有未修改过的属性和方法。</p><p>总的来说，Proxy 对象为我们提供了一个非常简单的方法，只代理 subject 的一部分功能，且不需要显式地将未代理的方法移交给 subject。同时也不会对原本的 subject 做出任何改动。</p><h5 id="几种-proxy-实现机制的比较"><a href="#几种-proxy-实现机制的比较" class="headerlink" title="几种 proxy 实现机制的比较"></a>几种 proxy 实现机制的比较</h5><ul><li>Composition：最直观和安全，subject 不会被修改。但需要手动将未代理的方法指派给 subject。冗余代码</li><li>Object augmentation：会直接修改原本的 subject 对象，不够安全。不需要手动处理未代理的方法</li><li>Proxy 对象：提供了更高级的访问控制。支持更多类型的属性访问，比如可以拦截 subject 对自身属性的删除等操作。不会修改 subject 本身，只需要使用一句代码处理未代理的方法</li></ul><h4 id="实例：logging-Writable-stream"><a href="#实例：logging-Writable-stream" class="headerlink" title="实例：logging Writable stream"></a>实例：logging Writable stream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logwritting &amp;&amp; cd logwritting</span><br></pre></td></tr></table></figure><p>package.json：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>logging-writable.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createLoggingWritable</span>(<span class="params">writable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(writable, &#123;</span><br><span class="line">    get(target, propKey) &#123;</span><br><span class="line">      <span class="keyword">if</span> (propKey === <span class="string">'write'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> [chunk] = args</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Writing'</span>, chunk)</span><br><span class="line">          <span class="keyword">return</span> writable.write(...args)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[propKey]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createLoggingWritable&#125; <span class="keyword">from</span> <span class="string">'./logging-writable.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writable = createWriteStream(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> writableProxy = createLoggingWritable(writable)</span><br><span class="line"></span><br><span class="line">writableProxy.write(<span class="string">'First chunk'</span>)</span><br><span class="line">writableProxy.write(<span class="string">'Second chunk'</span>)</span><br><span class="line">writable.write(<span class="string">'This is not logged'</span>)</span><br><span class="line">writableProxy.end()</span><br><span class="line"><span class="comment">// =&gt; Writing First chunk</span></span><br><span class="line"><span class="comment">// =&gt; Writing Second chunk</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;代理（proxy）&lt;/strong&gt; 可以理解为一种对象，其能够控制客户端对另一个对象（&lt;strong&gt;subject&lt;/strong&gt;）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。&lt;br&gt;proxy 会拦截
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Proxy" scheme="https://rollingstarky.github.io/tags/Proxy/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Monkey Patching" scheme="https://rollingstarky.github.io/tags/Monkey-Patching/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Health Probe</title>
    <link href="https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/"/>
    <id>https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/</id>
    <published>2022-05-09T16:00:00.000Z</published>
    <updated>2022-05-10T13:32:21.728Z</updated>
    
    <content type="html"><![CDATA[<p><em>Health Probe</em> 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度<strong>可观测</strong>的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经准备好接收请求。<br>这些观测结果会影响 Pod 的生命周期管理，以及网络流量被路由到应用的具体路径。</p><p>Kubernetes 会定期检测容器中进程的状态，如果有错误发生，就立即重启该容器。然而在实践中，通过检查进程状态来确定应用是否健康，并不总是有效。<br>很多情况下应用提供的服务中断了，但进程仍旧在运行。比如 Java 应用有可能抛出 <code>OutOfMemoryError</code> 同时 JVM 进程仍在运行。此外，应用还有可能因为无限循环、死锁或者缓存异常等原因冻结。<br>因此 Kubernetes 需要一种可靠的方式来检查应用的健康状态，不关注应用的内部工作流程，而是通过某些指标，衡量应用能否对外提供服务。</p><p>软件行业已经接受了这样一个事实，即写出完全没有 bug 的软件是不现实的。因此当面对 failures 时，可以把关注点从避免 bug 转移到如何快速检测到失效并自动恢复。<br>但错误检测并不是一个简单的对所有应用通用的任务，存在很多不同的对于错误的定义，并且不同类型的错误也需要不同的应对方式。</p><h4 id="Process-Health-Checks"><a href="#Process-Health-Checks" class="headerlink" title="Process Health Checks"></a>Process Health Checks</h4><p><em>process health check</em> 是最简单的一种 health check 方式，由 Kubelet 持续对容器进程进行检测。若容器进程没有处于运行状态，即对其进行重启。<br>如果应用本身能够检测到任意类型的错误并自行终止，凭借 process health check 就足够完成健康检查任务。</p><h4 id="Liveness-Probes"><a href="#Liveness-Probes" class="headerlink" title="Liveness Probes"></a>Liveness Probes</h4><p>假如应用会进入某种死锁状态，进程并未停止运行，因而从 process health check 的角度看应用仍然是健康的。Kubernetes 可以通过 <em>liveness probes</em> 来检测此类错误。<br>能够从应用外部执行健康检测，而不是仅仅依靠应用本身，这一点是非常重要的。因为有些错误有可能会阻止应用本身的 watchdog 对外报告异常。<br>liveness probes 看上去和 process health check 非常相似，它们都会在检测到异常时重启容器。但前者提供了更多的灵活性：</p><ul><li>HTTP probe：向容器的 IP 地址发起 HTTP GET 请求，期待获取一个成功的 HTTP 响应码（200 - 399）</li><li>TCP Socket probe：测试是否能完成完整的 TCP 连接</li><li>Exec probe：在容器内部执行任意的命令，期待获取一个成功的退出码（0）</li></ul><p>基于 HTTP 的 liveness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-liveness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">DELAY_STARTUP</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"20"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/actuator/health</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>httpGet</code> 中的 <code>path</code> 项用于配置 HTTP probe 执行健康检测时请求的端点；<code>initialDelaySeconds</code> 用于配置执行第一次检测前等待的时间，以等待应用启动后完成 warm up。</p><p>需要注意的是，未通过 liveness probe 检查的后果就是容器被重启，若容器重启对于解决问题没有任何效果，则 liveness probe 本身也不会再有任何其他作用。</p><h4 id="Readiness-Probes"><a href="#Readiness-Probes" class="headerlink" title="Readiness Probes"></a>Readiness Probes</h4><p>Liveness 检查通过杀掉不健康的容器并将它们替换为新的容器实例，来确保应用处于健康状态。但有些时候容器遇到问题，重启它们并不会令其恢复健康。最常见的情况就是容器正处于启动过程中，还没有准备好处理任何请求。或者有可能容器负载过高导致延迟极度增长。</p><p>在上述场景下，Kubernetes 提供了 <em>readiness probe</em> 特性。Readiness 检查和 Liveness 检查提供的检测方法是一样的（都是 HTTP、TCP 和 Exec），只有触发的操作不同。<br>失败的 Readiness 检查会将容器从 Service 端点移除，确保其不再对外提供任何服务。它关注的重点在于容器是否已经准备好，有些容器在启动时需要一定的 warm up 时间才能处理请求。<br>Readiness probe 在容器启动后依然会定期运行，从而将不能对外提供服务的容器屏蔽掉，保证未准备好的容器不会接收到外部的请求。</p><p>即 Liveness probe 触发的操作是重启容器，目的是不健康的容器尽可能恢复服务；Readiness probe 触发的操作是将容器从 Service 移除，目的是确保不健康的容器不会对外提供服务，用户的请求只会转发到健康的容器。<br>当然在容器重启时，Kubernetes 也会尽力确保该容器不会再收到用户请求，不管 Readiness probe 是否通过。</p><p>Readiness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-readiness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    readinessProbe:</span></span><br><span class="line"><span class="attr">      exec:</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[</span> <span class="string">"stat"</span><span class="string">,</span> <span class="string">"/var/run/random-generator-ready"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>Process health check 和 liveness probe 的目的都是通过重启容器来使应用能从错误中自动恢复。Readiness probe 则力求为处于恢复中的容器争取足够的时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>容器技术为打包和运行应用实现了一系列统一的接口，从而可以将应用作为<strong>黑盒（black box）</strong>看待。<br>然而任何致力于成为云原生应用的容器，必须为运行时环境提供一系列必要的 API，对容器的健康状态进行统一的观测，并执行对应的操作。这是容器能统一地实现自动化升级和生命周期管理的基础需求，从而提高系统的稳定性和用户体验。<br>这意味着容器化应用必须为多种不同的健康检测（liveness 和 readiness）提供需要的 API。<br>甚至更优异的应用还必须为管理平台提供其他手段，以方便更好地观测容器化应用的状态，比如与 Prometheus 进行整合。将应用视为一种黑盒，同时实现必须的 API 接口，方便平台对其进行监控和管理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Health Probe&lt;/em&gt; 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度&lt;strong&gt;可观测&lt;/strong&gt;的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="Recovery" scheme="https://rollingstarky.github.io/tags/Recovery/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 单例模式</title>
    <link href="https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-09T14:18:38.395Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>单例（<strong>Singleton</strong>）模式是面向对象编程中最常见的设计模式之一，Node.js 已经有了很简单的实现。<br>使用单例模式的目的在于确保某个类只有一个实例存在，并对该实例的访问进行统一的控制。其主要运用场景如下：</p><ul><li>共享有状态的信息</li><li>优化资源消耗</li><li>同步对某个资源的访问</li></ul><p>比如，一个标准的 Database 类会提供对数据库的访问：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(dbName, connectionDetails) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述类的标准实现中，通常需要维护一个数据库连接池，毕竟为每一次数据库请求都分别创建一个新的 Database 实例显得不太现实。此外，Database 实例可能会保存部分有状态的数据，比如 pending 的事务列表。<br>因此，一般只在应用开始运行时初始化一个 Database 实例，此后其作为一个唯一的共享实例被所有其他组件使用。</p><p>Node.js 的新用户可能会思考该如何从逻辑层面实现单例模式，事实上远比想象中更简单。<br><strong>将某个实例从模块中导入，即可实现单例模式的所有需求。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 'dbInstance.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Database&#125; <span class="keyword">from</span> <span class="string">'./Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dbInstance = <span class="keyword">new</span> Database(<span class="string">'my-app-db'</span>, &#123;</span><br><span class="line">  url: <span class="string">'localhost:5432'</span>,</span><br><span class="line">  username: <span class="string">'user'</span>,</span><br><span class="line">  password: <span class="string">'password'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只需要简单地导出 Database 类的一个新实例（<code>dbInstance</code>），在当前的整个包中就可以认为只存在这一个 <code>dbInstance</code> 对象（单例），这得益于 Node.js 的模块系统。Node.js 会对模块进行缓存，保证不会在每次导入时都再执行一遍代码。</p><p>再通过如下一行代码即可简单地获取上面创建的共享的 <code>dbInstance</code> 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dbInstance &#125; <span class="keyword">from</span> <span class="string">'./dbInstance.js'</span></span><br></pre></td></tr></table></figure></p><h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>Node.js 中缓存的模块以完整路径作为对其进行查找的 key，所以前面实现的 Singleton 只在当前的包中生效。每个包都有可能包含其私有的依赖，放置在它自己的 <code>node_modules</code> 路径下。因而就可能导致同一个模块存在多个实例，前面实现的 Singleton 不能再保证唯一性。</p><p>例如，前面的 <code>Database.js</code> 和 <code>dbInstance.js</code> 同属于 <code>mydb</code> 包，其 <code>package.json</code> 内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"mydb"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dbInstance.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又假设有两个包（<code>package-a</code> 和 <code>package-b</code>）各自都拥有包含如下内容的 <code>index.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dbInstance&#125; <span class="keyword">from</span> <span class="string">'mydb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDbInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dbInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package-a</code> 和 <code>package-b</code> 都依赖包 <code>mydb</code>，但 <code>package-a</code> 依赖版本 1.0.0，<code>package-b</code> 依赖版本 2.0.0。结果就会出现如下结构的依赖关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">`-- node_modules</span><br><span class="line">    |-- package-a</span><br><span class="line">    |  `-- node_modules</span><br><span class="line">    |      `-- mydb</span><br><span class="line">    `-- package-b</span><br><span class="line">        `-- node_modules</span><br><span class="line">            `-- mydb</span><br></pre></td></tr></table></figure></p><p>当 <code>package-a</code> 和 <code>package-b</code> 依赖两个不兼容版本的 <code>mydb</code> 模块时，包管理器不会将 <code>mydb</code> 放置在 <code>node_modules</code> 的根路径下，而是在 <code>package-a</code> 和 <code>package-b</code> 下面各自放一个私有的 <code>mydb</code> 副本，从而解决版本冲突。</p><p>此时假如 <code>app/</code> 路径下有一个如下内容的 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromA&#125; <span class="keyword">from</span> <span class="string">'package-a'</span></span><br><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromB&#125; <span class="keyword">from</span> <span class="string">'package-b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSame = getDbFromA() === getDbFromB()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is the db instance in package-a the same '</span> +</span><br><span class="line">  <span class="string">`as package-b? <span class="subst">$&#123;isSame ? <span class="string">'YES'</span> : <span class="string">'NO'</span>&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></p><p><code>getDbFromA()</code> 和 <code>getDbFromB()</code> 并不会获得同一个 <code>dbInstance</code> 实例，打破了 Singleton 模式的假设。</p><p>当然了，大多数情况下我们并不需要一个 <em>pure</em> Singleton。事实上，通常也只会在应用的 main 包中创建和导入 Singleton。</p><h4 id="Singleton-dependencies"><a href="#Singleton-dependencies" class="headerlink" title="Singleton dependencies"></a>Singleton dependencies</h4><p>最简单地将两个模块组合在一起的方式，就是直接利用 Node.js 的模块系统。如前面所说，这样组合起来的有状态的依赖关系其实就是单例模式。</p><p>实现下面一个博客系统：<br><code>mkdir blog &amp;&amp; cd blog</code><br><code>npm install sqlite3</code></p><p><code>blog/package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"sqlite3"</span>: <span class="string">"^5.0.8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.Database(</span><br><span class="line">  join(__dirname, <span class="string">'data.sqlite'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>blog/blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"><span class="keyword">import</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbRun = promisify(db.run.bind(db))</span><br><span class="line"><span class="keyword">const</span> dbAll = promisify(db.all.bind(db))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p><code>db.js</code> 创建了一个 <code>db</code> 数据库实例并导出，<code>blog.js</code> 从 <code>db.js</code> 中导入 <code>db</code> 实例并直接在代码中使用。形成了一种简单直观的 <code>blog.js</code> 依赖于 <code>db.js</code> 模块的关系。同时整个项目中的数据库连接都由唯一的 <code>db</code> 单例进行控制。</p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">No posts available.</span><br></pre></td></tr></table></figure></p><p>可以运行下面的命令插入测试数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-posts.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'my-first-post'</span>,</span><br><span class="line">    title: <span class="string">'My first post'</span>,</span><br><span class="line">    content: <span class="string">'Hello World!\nThis is my first post'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-03'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'iterator-patterns'</span>,</span><br><span class="line">    title: <span class="string">'Node.js iterator patterns'</span>,</span><br><span class="line">    content: <span class="string">'Let\'s talk about some iterator patterns in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-06'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'dependency-injection'</span>,</span><br><span class="line">    title: <span class="string">'Dependency injection in Node.js'</span>,</span><br><span class="line">    content: <span class="string">'Today we will discuss about dependency injection in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-29'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    posts.map(</span><br><span class="line">      (post) =&gt; blog.createPost(</span><br><span class="line">        post.id,</span><br><span class="line">        post.title,</span><br><span class="line">        post.content,</span><br><span class="line">        post.created_at</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'All posts imported'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ node <span class="keyword">import</span>-posts.js</span><br><span class="line">All posts imported</span><br><span class="line">$ node index.js</span><br><span class="line">Dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line">-------------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-29</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Today we will discuss about dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Node.js iterator patterns</span><br><span class="line">-------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-06</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Let<span class="string">'s talk about some iterator patterns in Node.js</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">My first post</span></span><br><span class="line"><span class="string">-------------</span></span><br><span class="line"><span class="string">Published on 2020-02-03T00:00:00.000Z</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">This is my first post</span></span><br></pre></td></tr></table></figure><p>就如上面的代码所示，借助 Singleton 模式，将 <code>db</code> 实例自由地在文件之间传递，可以实现一个很简单的命令行博客管理系统。这也是大多数情况下我们管理有状态的依赖的方式。<br>使用 Singleton 诚然是最简单、即时，可读性最好的方案。但是，假如我们需要在测试过程中 mock 数据库，或者需要终端用户能够自主选择另一个数据库后端，而不是默认提供的 SQLite。<br>对于以上需求，Singleton 反而成为了一个设计更好结构的阻碍。可以在 <code>db.js</code> 中引入 <code>if</code> 语句根据某些条件来选择不同的实现，显然这种方式并不是很美观。</p><h4 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h4><p>Node.js 的模块系统以及 Singleton 模式可以作为一个很好的管理和组合应用组件的工具，它们非常简单，容易上手。但另一方面，它们也可能会使各组件之间的<strong>耦合</strong>程度加深。<br>在前面的例子中，<code>blog.js</code> 和 <code>db.js</code> 模块是耦合度很高的，<code>blog.js</code> 没有了 <code>db.js</code> 就无法工作，当然也无法使用另一个不同的数据库模块。<br>可以借助 <strong>Dependency Injection</strong> 来弱化模块之间的耦合度。</p><p><strong>依赖注入</strong>表示将某个组件的依赖模块由外部实体（injector）作为<strong>输入</strong>提供。<br>DI 的主要优势在于能够降低耦合度，尤其当模块依赖于有状态的实例（比如数据库连接）时。<strong>每个依赖项并不是硬编码进主体代码，而是由外部传入，意味着这些依赖项可以被替换成任意相互兼容的实例</strong>。使得主体代码本身可以以最小的改动在不同的背景下重用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-187f28cb137f94fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dependency injection schematic"></p><p>修改 <code>blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(db) &#123;</span><br><span class="line">    <span class="keyword">this</span>.db = db</span><br><span class="line">    <span class="keyword">this</span>.dbRun = promisify(db.run.bind(db))</span><br><span class="line">    <span class="keyword">this</span>.dbAll = promisify(db.all.bind(db))</span><br><span class="line">  &#125;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最主要的改动在于为 <code>Blog</code> 类添加了 <code>constructor (db)</code> 构造方法，该方法的参数 <code>db</code> 即为 Dependency，Blog 的依赖项，需要在运行时由 Blog 的客户端提供。</p><p>修改 <code>db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createDb</span>(<span class="params">dbFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> sqlite3.Database(dbFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此版本的 <code>db</code> 模块提供了一个 <code>createDB()</code> 工厂函数，可以在运行时返回一个新的数据库实例。</p><p>修改 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDb&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> db = createDb(join(__dirname, <span class="string">'data.sqlite'</span>))</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog(db)</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p>使用 <code>createDB()</code> 工厂函数创建数据库实例 <code>db</code>，然后在初始化 Blog 实例时，将 <code>db</code> 作为 Blog 的依赖进行注入。<br>从而 <code>blog.js</code> 与具体的数据库实现进行了分离。</p><p>依赖注入可以提供松耦合和代码重用等优势，但也存在一定的代价。比如无法在编码时解析依赖项，使得理解模块之间的逻辑关系变得更加困难，尤其当应用很大很复杂的时候。<br>此外，我们还必须确保数据库实例（依赖）在 Blog 实例之前创建，从而迫使我们手动构建整个应用的依赖图，以保证顺序正确。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Singleton&quot;&gt;&lt;a href=&quot;#Singleton&quot; class=&quot;headerlink&quot; title=&quot;Singleton&quot;&gt;&lt;/a&gt;Singleton&lt;/h4&gt;&lt;p&gt;单例（&lt;strong&gt;Singleton&lt;/strong&gt;）模式是面向对象编程中最常
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Singleton" scheme="https://rollingstarky.github.io/tags/Singleton/"/>
    
      <category term="Dependency Injection" scheme="https://rollingstarky.github.io/tags/Dependency-Injection/"/>
    
      <category term="Decoupling" scheme="https://rollingstarky.github.io/tags/Decoupling/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Builder 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T14:46:01.904Z</updated>
    
    <content type="html"><![CDATA[<p>Builder 是一种<strong>创建型</strong>设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。<br>最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。</p><p>比如下面的一个 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(hasMotor, motorCount, motorBrand, motorModel,</span><br><span class="line">    hasSails, sailsCount, sailsMaterial, sailsColor,</span><br><span class="line">    hullColor, hasCabin) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用上述 <code>Boat</code> 类的构造方法会导致出现非常难以阅读的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(<span class="literal">true</span>, <span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>, <span class="literal">true</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="string">'fabric'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>想要提升上述构造函数的设计，首先可以将所有的参数整合到一个单一的对象中，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">  hasMotor: <span class="literal">true</span>,</span><br><span class="line">  motorCount: <span class="number">2</span>,</span><br><span class="line">  motorBrand: <span class="string">'Best Motor Co. '</span>,</span><br><span class="line">  motorModel: <span class="string">'OM123'</span>,</span><br><span class="line">  hasSails: <span class="literal">true</span>,</span><br><span class="line">  sailsCount: <span class="number">1</span>,</span><br><span class="line">  sailsMaterial: <span class="string">'fabric'</span>,</span><br><span class="line">  sailsColor: <span class="string">'white'</span>,</span><br><span class="line">  hullColor: <span class="string">'blue'</span>,</span><br><span class="line">  hasCabin: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>新版本的构造函数跟原来相比提升了不少，比如用户可以清晰地看到每个传入的参数所代表的具体含义。<br>但是，将所有参数都放入同一个对象后再传入构造函数的方式，也有其自身的缺点。比如要想知道每个参数的具体含义，还是需要查看类的说明文档甚至类的代码。此外，没有任何强制性的协议来引导用户创建一致的对象，假如我们指定 <code>hasMotor: true</code>，意味着我们同时还需要再指定 <code>motorCount</code>、<code>motorBrand</code> 和 <code>motorModel</code> 参数的值。但我们无从获取此类信息（除非查看源代码）。</p><p>Builder 模式就非常适合解决上述问题。帮助用户创建一个平滑、易读、自说明的生成对象的接口，同时为创建具有一致性的对象提供指导信息。</p><p>使用 Builder 模式的 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoatBuilder</span> </span>&#123;</span><br><span class="line">  withMotors(count, brand, model) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasMotor = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.motorCount = count</span><br><span class="line">    <span class="keyword">this</span>.motorBrand = brand</span><br><span class="line">    <span class="keyword">this</span>.motorModel = model</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withSails(count, material, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasSails = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.sailsCount = count</span><br><span class="line">    <span class="keyword">this</span>.sailsMaterial = material</span><br><span class="line">    <span class="keyword">this</span>.sailsColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hullColor(color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hullColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withCabin() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasCabin = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">      hasMotor: <span class="keyword">this</span>.hasMotor,</span><br><span class="line">      motorCount: <span class="keyword">this</span>.motorCount,</span><br><span class="line">      motorBrand: <span class="keyword">this</span>.motorBrand,</span><br><span class="line">      motorModel: <span class="keyword">this</span>.motorModel,</span><br><span class="line">      hasSails: <span class="keyword">this</span>.hasSails,</span><br><span class="line">      sailsCount: <span class="keyword">this</span>.sailsCount,</span><br><span class="line">      sailsMaterial: <span class="keyword">this</span>.sailsMaterial,</span><br><span class="line">      sailsColor: <span class="keyword">this</span>.sailsColor,</span><br><span class="line">      hullColor: <span class="keyword">this</span>.hullColor,</span><br><span class="line">      hasCabin: <span class="keyword">this</span>.hasCabin</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> BoatBuilder()</span><br><span class="line">  .withMotors(<span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>)</span><br><span class="line">  .withSails(<span class="number">1</span>, <span class="string">'fabric'</span>, <span class="string">'white'</span>)</span><br><span class="line">  .withCabin()</span><br><span class="line">  .hullColor(<span class="string">'blue'</span>)</span><br><span class="line">  .build()</span><br></pre></td></tr></table></figure></p><p><code>BoatBuilder</code> 类的作用就是收集 <code>Boat</code> 类需要的所有参数，再通过一系列 helper 方法传递给 <code>Boat</code>。</p><p>Builder 模式的基本规则：</p><ul><li>将主要对象的复杂构建过程拆分为几个更为易读的、更容易管理的步骤</li><li>尝试创建 builder 方法，向需要创建的对象一组一组地传递相关联的参数</li><li>必要的情况下，在通过 builder 方法将参数传递给需要创建的对象前，尽可能地先对参数做一些处理</li></ul><h4 id="实例：URL-builder"><a href="#实例：URL-builder" class="headerlink" title="实例：URL builder"></a>实例：URL builder</h4><p>创建并进入 <code>url_builder</code> 文件夹，编辑如下内容的 <code>package.json</code> 文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>url.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Url</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(protocol, username, password, hostname,</span><br><span class="line">    port, pathname, search, hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.validate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  validate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.protocol || !<span class="keyword">this</span>.hostname) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must specify at least a '</span> + <span class="string">'protocol and a hostname'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">''</span></span><br><span class="line">    url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.protocol&#125;</span>://`</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.username &amp;&amp; <span class="keyword">this</span>.password) &#123;</span><br><span class="line">      url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.username&#125;</span>:<span class="subst">$&#123;<span class="keyword">this</span>.password&#125;</span>@`</span></span><br><span class="line">    &#125;</span><br><span class="line">    url += <span class="keyword">this</span>.hostname</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.port) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.port</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pathname) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.pathname</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search) &#123;</span><br><span class="line">      url += <span class="string">`?<span class="subst">$&#123;<span class="keyword">this</span>.search&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hash) &#123;</span><br><span class="line">      url += <span class="string">`#<span class="subst">$&#123;<span class="keyword">this</span>.hash&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>urlBuilder.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Url &#125; <span class="keyword">from</span> <span class="string">'./url.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlBuilder</span> </span>&#123;</span><br><span class="line">  setProtocol(protocol) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setAuthentication(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHostname(hostname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPort(port) &#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPathname(pathname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setSearch(search) &#123;</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHash(hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Url(<span class="keyword">this</span>.protocol, <span class="keyword">this</span>.username, <span class="keyword">this</span>.password,</span><br><span class="line">      <span class="keyword">this</span>.hostname, <span class="keyword">this</span>.port, <span class="keyword">this</span>.pathname, <span class="keyword">this</span>.search, <span class="keyword">this</span>.hash)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;UrlBuilder&#125; <span class="keyword">from</span> <span class="string">'./urlBuilder.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> UrlBuilder()</span><br><span class="line">  .setProtocol(<span class="string">'https'</span>)</span><br><span class="line">  .setAuthentication(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">  .setHostname(<span class="string">'example.com'</span>)</span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.toString())</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line"><span class="function">https://<span class="title">user:pass</span>@<span class="title">example.com</span></span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Builder 是一种&lt;strong&gt;创建型&lt;/strong&gt;设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。&lt;br&gt;最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。&lt;/p&gt;
&lt;p&gt;比如下面的一个
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— 声明式部署</title>
    <link href="https://rollingstarky.github.io/2022/05/05/kubernetes-patterns-reading-notes-declarative-deployment/"/>
    <id>https://rollingstarky.github.io/2022/05/05/kubernetes-patterns-reading-notes-declarative-deployment/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T14:56:55.719Z</updated>
    
    <content type="html"><![CDATA[<p><strong>声明式部署（Declarative Deployment）</strong>模式主要体现在 Kubernetes 对其 Deployment 对象的应用上。</p><p>升级某个服务意味着，需要平滑地关闭旧版本的 Pod，启动新版本的 Pod，然后等待和确认其部署成功，有时候在部署失败时还需要执行回滚操作。<br>这些步骤或者需要一定的 downtime，同时不会有多个版本的服务在并行地运行（旧版本完全停止后再启动新版本）；或者不允许有 downtime，但在升级过程中，新旧版本的服务同时在线会造成资源消耗的增长（旧版本开始停止的时候就添加新版本的实例）。</p><p>手动执行上述操作难免会有错误发生，写脚本来自动化处理又需要付出较大的时间成本。好在 Kubernetes 通过 Deployment 概念自动化了这些升级、回滚流程，可以在 Deployment 中定义替换的策略（如 <strong>RollingUpdate</strong> 和 <strong>Recreate</strong>）以及其他升级过程中的细节。</p><h4 id="Rolling-Deployment"><a href="#Rolling-Deployment" class="headerlink" title="Rolling Deployment"></a>Rolling Deployment</h4><p>下面是一个采用滚动升级（rolling update）策略的 Deployment 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  strategy:</span></span><br><span class="line"><span class="attr">    type:</span> <span class="string">RollingUpdate</span></span><br><span class="line"><span class="attr">    rollingUpdate:</span></span><br><span class="line"><span class="attr">      maxSurge:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">      maxUnavailable:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">    selector:</span></span><br><span class="line"><span class="attr">      matchLabels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    template:</span></span><br><span class="line"><span class="attr">      metadata:</span></span><br><span class="line"><span class="attr">        labels:</span></span><br><span class="line"><span class="attr">          app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">      spec:</span></span><br><span class="line"><span class="attr">        containers:</span></span><br><span class="line"><span class="attr">        - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">          readinessProbe:</span></span><br><span class="line"><span class="attr">            exec:</span></span><br><span class="line"><span class="attr">              command:</span> <span class="string">[</span> <span class="string">"stat"</span><span class="string">,</span> <span class="string">"/random-generator-ready"</span><span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>replicas: 3</code> 表示副本的总数量是 3，在执行 rolling update 时，声明的副本数量必须大于 1。<br><code>maxSurge: 1</code> 表示在升级过程中，允许临时添加的 Pod 的最大数量。滚动升级有一个切换的过程，必然导致某个时间段内新旧版本的应用同时运行，从而实际运行的 Pod 数量大于声明的副本数量。此处的配置最多允许 4 个副本同时运行。<br><code>maxUnavailable: 1</code> 表示升级过程中可能无法访问的 Pods 数量。此处的配置有可能导致在升级的某个阶段，只有两个 Pods 可用。<br><code>readinessProbe</code> 配置对于执行无 downtime 的滚动升级非常关键，它用来判断某个 Pod 副本是否已经在线</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-70f64e82ecc7d7a3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rolling deployment"></p><p>RollingUpdate 策略会确保升级过程中没有 downtime。<code>Deployment</code> 负责创建新的 ReplicaSet 并用新的容器替换掉旧容器，用户则可以通过配置 <code>maxSurge</code> 和 <code>maxUnavailable</code> 字段来控制切换的速率。</p><h5 id="Deployment-的优势"><a href="#Deployment-的优势" class="headerlink" title="Deployment 的优势"></a>Deployment 的优势</h5><ul><li>Deployment 是完全被 Kubernetes 内部管理的资源对象，整个的升级过程由 Server 端执行，无需客户端介入</li><li>Deployment 的声明式性质，使得用户更加关注期望达到的状态而不是达到该状态需要执行的操作步骤</li><li>整个升级过程会以版本的方式进行记录，还提供了 pause、continue 和 rollback 等选项</li></ul><h4 id="Fixed-Deployment"><a href="#Fixed-Deployment" class="headerlink" title="Fixed Deployment"></a>Fixed Deployment</h4><p>RollingUpdate 策略在需要确保无 downtime 时非常有用，但该方式也有一些负面影响。比如在升级过程中，会有两个版本的容器同时运行，这有可能导致接收服务的客户端出现一些 issue，尤其当更新引入了没有向后兼容的特性时。<br>在此类场景下，可以使用 <code>Recreate</code> 策略。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2d35f93dba9074a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Fixed deployment using a Recreate strategy"></p><p><code>Recreate</code> 策略的效果类似于 <code>RollingUpdate</code> 将 <code>maxUnavailable</code> 的值设置成了副本的数量。这意味着所有当前版本的容器都会先被终止掉，在旧容器被全部清理干净之后才开始同步启动所有的新容器。<br>结果就是升级过程中会存在一定的 downtime。</p><h4 id="Blue-Green-Release"><a href="#Blue-Green-Release" class="headerlink" title="Blue-Green Release"></a>Blue-Green Release</h4><p><em>Blue-Green deployment</em> 发布策略致力于在生产环境中最小化部署时的 downtime。借助 Kubernetes 对于发布行为的抽象（Deployment），用户可以自行定义和实现将<strong>不可变</strong>的容器从一个版本转换到另一个版本的具体方式，比如 Blue-Green 部署方式。<br>如果 Kubernetes 集群中并未安装 Service Mesh 或者 Knative 等扩展组件，Blue-Green deployment 就需要手动实现。<br>其原理就是创建一个新的 Deployment，包含最新版本的容器（<em>green</em>），但是并不向外提供任何服务。旧的 Pod 副本（<em>blue</em>）依然在运行和处理请求。<br>一旦用户确认新版本的 Pod 是健康的，可以提供服务，就将入站流量从旧的 Pod 副本切换到新版本的副本。在 Kubernetes 中可以通过修改 Service selector 来完成切换动作。当新版本的容器运行稳定后，旧版本即可被删除。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-bd7365c96c887aa9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Blue-Green release"></p><p>Blue-Green 方案的优势在于，同一时间只会有一个特定版本的应用对外提供服务，不需要接收服务的客户端处理多个并行的服务版本；其劣势则在于需要双倍的资源去运行 blue 和 green 容器。此外，有些时候切换的过程会非常复杂。</p><h4 id="Canary-Release"><a href="#Canary-Release" class="headerlink" title="Canary Release"></a>Canary Release</h4><p><em>Canary release</em> 是一种软部署方式，一开始只会将旧版本实例的一个较小的子集替换为新版本。先只允许一小部分用户能够访问更新后的服务，从而降低新版本向生产环境引入的风险。<br>当能够确认新版本的服务对一小部分用户没有产生负面影响，再用新版全面替换掉旧版。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-45557bf5d7d50c2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Canary release"></p><p>在 Kubernetes 中，上述部署方式可以通过创建一个包含新版本容器的 ReplicaSet 来实现，只不过副本的数量可以设置得很小，作为 Canary 实例。同时 Service 对象负责将一部分用户的请求转发给 Canary 容器。当我们确信新版本应用可以正常提供服务，则横向扩展新的 ReplicaSet 到期望的副本数量，同时收缩旧 ReplicaSet 的副本数量至 0。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Deployment 很好地向我们展示了，Kubernetes 将复杂的手动升级应用的流程，转化为可以重复执行、支持自动化编排的声明式部署。</p><p>上述四种部署方式的总结：<img src="https://upload-images.jianshu.io/upload_images/6875152-707a221be2108608.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deployment and release strategies"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;声明式部署（Declarative Deployment）&lt;/strong&gt;模式主要体现在 Kubernetes 对其 Deployment 对象的应用上。&lt;/p&gt;
&lt;p&gt;升级某个服务意味着，需要平滑地关闭旧版本的 Pod，启动新版本的 Pod，然后等待和确
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="ReplicaSet" scheme="https://rollingstarky.github.io/tags/ReplicaSet/"/>
    
      <category term="Update" scheme="https://rollingstarky.github.io/tags/Update/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 工厂模式</title>
    <link href="https://rollingstarky.github.io/2022/04/28/node-js-design-patterns-factory-pattern/"/>
    <id>https://rollingstarky.github.io/2022/04/28/node-js-design-patterns-factory-pattern/</id>
    <published>2022-04-27T16:00:00.000Z</published>
    <updated>2022-04-28T14:21:34.495Z</updated>
    
    <content type="html"><![CDATA[<p><strong>工厂（Factory）模式</strong> 是 Node.js 中最常见的设计模式之一。<br>其具有以下优势：</p><ul><li>将对象的创建过程与对象的实现细节进行<strong>解耦</strong>。由工厂创建一系列对象，某个对象继承的特征在运行时确定</li><li>工厂模式允许我们对外暴露更少的接口。一个类可以被扩展或者操控，而工厂本身仅仅是一个负责创建对象的函数，没有给用户其他选项，从而使接口更健壮和容易理解</li><li>借助<strong>闭包</strong>可以帮助强化对象的<strong>封装</strong></li></ul><h4 id="解耦对象的创建和实现"><a href="#解耦对象的创建和实现" class="headerlink" title="解耦对象的创建和实现"></a>解耦对象的创建和实现</h4><p>工厂模式封装了新对象的创建过程，给这个过程提供了更多的灵活性和控制。在工厂内部我们可以选择各种不同的方式来创建某个对象的实例，工厂的消费者对于这些细节一无所知。<br>相反地，使用 <code>new</code> 关键字则会将代码绑定到一种特定的创建方式上。</p><p>比如下面的一个用于创建 <code>Image</code> 对象的工厂函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Image(name)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> image = createImage(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure></p><p>上述 <code>createImage</code> 工厂函数看上去完全没有必要，直接使用如下一行代码就可以搞定：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> image = <span class="keyword">new</span> Image(<span class="string">'photo.jpeg'</span>)</span><br></pre></td></tr></table></figure></p><p>按照前面所说，<code>new</code> 关键字会将代码绑定给一种特定类型的对象，在这里就是 <code>Image</code> 类型。<br>而工厂模式则更加灵活。假设需要重构 <code>Image</code> 类，将其分割成几个更小的类型，对应不同的图片格式。<br>工厂函数 <code>createImage</code> 作为唯一的创建新图片对象的方式，即便需要创建的图片对象添加了更多的类型，也可以很简单地只对 <code>createImage</code> 的内部逻辑进行重写，其对外开放的接口不会发生改变，不会破坏任何现有的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createImage</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name.match(<span class="regexp">/\.jpe?g$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageJpeg(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.gif$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImageGif(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.match(<span class="regexp">/\.png$/</span>)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ImagePng(name)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Unsupported format'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="强化封装"><a href="#强化封装" class="headerlink" title="强化封装"></a>强化封装</h4><p>借助<strong>闭包</strong>，工厂模式可以成为一种强化封装性的机制。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">const</span> privateProperties = &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> person = &#123;</span><br><span class="line">                setName (name) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!name) &#123;</span><br><span class="line">                                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'A person must have a name'</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                        privateProperties.name = name</span><br><span class="line">                &#125;,</span><br><span class="line">                getName () &#123;</span><br><span class="line">                        <span class="keyword">return</span> privateProperties.name</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        person.setName(name)</span><br><span class="line">        <span class="keyword">return</span> person</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person = createPerson(<span class="string">'John'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName())</span><br><span class="line"><span class="comment">// =&gt; John</span></span><br><span class="line">person.setName(<span class="string">'Michael'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.getName())</span><br><span class="line"><span class="comment">// =&gt; Michael</span></span><br></pre></td></tr></table></figure></p><p><code>createPerson</code> 工厂函数创建了一个 <code>person</code> 对象。由于闭包的存在，即便 <code>createPerson</code> 函数运行完毕退出了，其属性 <code>privateProperties</code> 仍可以被 <code>person</code> 对象通过其 <code>setName</code> 和 <code>getName</code> 方法访问。<br>但与此同时，该 <code>privateProperties</code> 属性无法被任何外部对象（包括 <code>person</code>）直接访问。</p><h4 id="完整实例：Profiler"><a href="#完整实例：Profiler" class="headerlink" title="完整实例：Profiler"></a>完整实例：Profiler</h4><p>创建并进入一个新的 <code>simple_profiler</code> 文件夹，编辑如下内容的 <code>package.json</code> 文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建如下内容的 <code>profiler.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Profiler</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (label) &#123;</span><br><span class="line">    <span class="keyword">this</span>.label = label</span><br><span class="line">    <span class="keyword">this</span>.lastTime = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  start () &#123;</span><br><span class="line">    <span class="keyword">this</span>.lastTime = process.hrtime()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  end () &#123;</span><br><span class="line">    <span class="keyword">const</span> diff = process.hrtime(<span class="keyword">this</span>.lastTime)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Timer "<span class="subst">$&#123;<span class="keyword">this</span>.label&#125;</span>" took <span class="subst">$&#123;diff[<span class="number">0</span>]&#125;</span> seconds `</span> + <span class="string">`and <span class="subst">$&#123;diff[<span class="number">1</span>]&#125;</span> nanoseconds.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> noopProfiler = &#123;</span><br><span class="line">  start () &#123;&#125;,</span><br><span class="line">  end () &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createProfiler</span> (<span class="params">label</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">'production'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> noopProfiler</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Profiler(label)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>创建如下内容的 <code>index.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createProfiler &#125; <span class="keyword">from</span> <span class="string">'./profiler.js'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getAllFactors</span> (<span class="params">intNumber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> profiler = createProfiler(</span><br><span class="line">    <span class="string">`Finding all factors of <span class="subst">$&#123;intNumber&#125;</span>`</span></span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  profiler.start()</span><br><span class="line">  <span class="keyword">const</span> factors = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> factor = <span class="number">2</span>; factor &lt;= intNumber; factor++) &#123;</span><br><span class="line">    <span class="keyword">while</span> ((intNumber % factor) === <span class="number">0</span>) &#123;</span><br><span class="line">      factors.push(factor)</span><br><span class="line">      intNumber = intNumber / factor</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  profiler.end()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> factors</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myNumber = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> myFactors = getAllFactors(myNumber)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Factors of <span class="subst">$&#123;myNumber&#125;</span> are: `</span>, myFactors)</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ NODE_ENV=production node index.js <span class="number">2201307499</span></span><br><span class="line">Factors of <span class="number">2201307499</span> are:  [ <span class="number">38737</span>, <span class="number">56827</span> ]</span><br><span class="line">$ node index.js <span class="number">2201307499</span></span><br><span class="line">Timer "Finding all factors of <span class="number">2201307499</span>" took <span class="number">0</span> seconds and <span class="number">9738800</span> nanoseconds.</span><br><span class="line">Factors of <span class="number">2201307499</span> are:  [ <span class="number">38737</span>, <span class="number">56827</span> ]</span><br></pre></td></tr></table></figure></p><p>简单来说，就是通过 <code>createProfiler</code> 工厂函数来创建不同的 <code>Profiler</code> 对象。若环境变量 <code>NODE_ENV</code> 的值为 <code>production</code>，则返回一个新的的 <code>noopProfiler</code>，不对运行的代码做任何额外的操作；若 <code>NODE_ENV</code> 的值不为 <code>production</code>，则返回一个新的 <code>Profiler</code> 对象，记录程序运行的时间。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;工厂（Factory）模式&lt;/strong&gt; 是 Node.js 中最常见的设计模式之一。&lt;br&gt;其具有以下优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将对象的创建过程与对象的实现细节进行&lt;strong&gt;解耦&lt;/strong&gt;。由工厂创建一系列对象，某个对象继承的特征
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Factory" scheme="https://rollingstarky.github.io/tags/Factory/"/>
    
      <category term="Patterns" scheme="https://rollingstarky.github.io/tags/Patterns/"/>
    
      <category term="Node" scheme="https://rollingstarky.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 通过 PersistentVolume 持久化数据</title>
    <link href="https://rollingstarky.github.io/2022/04/27/kubernetes-in-action-reading-notes-persistent-data-with-persistent-volume/"/>
    <id>https://rollingstarky.github.io/2022/04/27/kubernetes-in-action-reading-notes-persistent-data-with-persistent-volume/</id>
    <published>2022-04-26T16:00:00.000Z</published>
    <updated>2022-04-27T12:41:30.486Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Pods-与底层存储技术的解耦"><a href="#Pods-与底层存储技术的解耦" class="headerlink" title="Pods 与底层存储技术的解耦"></a>Pods 与底层存储技术的解耦</h4><p>理想情况下，将应用部署到 Kubernetes 上的开发者不需要知道集群提供的存储技术，就像他们不需要知道运行 Pods 的物理服务器的属性。基础设施的细节应该由集群的维护者去掌控。</p><p>比如在 Pod 中挂载一个 NFS 共享作为持久存储，Pod 的清单文件中就需要包含 NFS 服务器的 IP 地址和共享文件的路径，从而导致该 Pod 的定义与特定的集群绑定在一起，阻止其用在其他地方。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0329c69edbfa8e74.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A pod manifest with infrastructure-specific volume information is not portable to other clusters"></p><h5 id="Persistent-volumes-and-claims"><a href="#Persistent-volumes-and-claims" class="headerlink" title="Persistent volumes and claims"></a>Persistent volumes and claims</h5><p>为了令 Pod 清单文件面向不同的集群是可移植的，针对存储卷的环境相关的信息被移动到 <strong>PersistentVolume</strong> 对象中，再通过一个 <strong>PersistentVolumeClaim</strong> 对象将 Pod 与 PersistentVolume 连接在一起。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f749bef8732150a7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using persistent volumes and persistent volume claims to attach network storage to pods"></p><p>顾名思义，<strong>PersistentVolume</strong> 对象代表一种存储卷，用来持久化应用数据。该对象包含了底层存储的信息，从而将这些信息从 Pod 中解耦。即 Pod 的清单文件中与存储相关的部分，不必再包含基础设施相关的信息（转移到了 PersistentVolume 中），使得同样的清单文件能够部署在不同的集群上。</p><p>Pod 并不会直接引用 PersistentVolume 对象，而是指向一个 <strong>PersistentVolumeClaim</strong> 对象。PersistentVolumeClaim 代表用户对 PV 的请求或者声明，有着独立于 Pod 的生命周期，从而允许 PV 的所属权（ownership）与 Pod 解耦。<br>用户在使用 PV 前必须先声明一个 PVC 对象。Pod 可以在任意时间删除，用户并不会因此失去对 PV 的所属权。当 PV 不再被需要时，用户可以通过删除 PVC 来释放它。</p><p>Pod 清单文件中的存储定义部分只需要包含 PVC 的名称，不需要任何基础设施相关的信息，比如 NFS 服务器的 IP 地址。PVC 会负责将其绑定的代表 NFS 存储的 PV 挂载到 Pod 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d3c4f62a71307453.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mounting a persistent volume into the pod’s container(s)"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6fe103345145503b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using the same persistent volume claim in multiple pods"></p><h5 id="使用-PV-和-PVC-的优势"><a href="#使用-PV-和-PVC-的优势" class="headerlink" title="使用 PV 和 PVC 的优势"></a>使用 PV 和 PVC 的优势</h5><p>为了让 Pod 使用某个存储卷，借助 PV 和 PVC 这两种额外的对象，肯定比直接在 Pod 清单文件中定义要复杂得多。<br>使用 PV 和 PVC 的最大优势在于，基础设施相关的细节从 Pod 代表的应用中解脱了出来。集群管理员比任何人都更了解数据中心本身，他们负责创建 PV 对象；软件开发者则可以集中精力通过 Pod 和 PVC 来描述应用本身的需求。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0721dd2191c07854.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Persistent volumes are provisioned by cluster admins and consumed by pods through persistent volume claims"></p><p>应用开发人员不需要了解底层基础设施的任何细节，就可以直接创建 Pod 清单文件和 PVC 对象；同样的，集群管理员也可以在不了解应用的所有细节的前提下，创建一系列不同大小的存储卷。<br>更进一步的，借助 PV 的动态创建功能，管理员根本不需要提前创建好存储卷。如果集群中安装了 automated volume provisioner，物理存储卷和 PV 对象会在用户创建 PVC 之后按需自动生成。</p><h4 id="创建-PV-和-PVC"><a href="#创建-PV-和-PVC" class="headerlink" title="创建 PV 和 PVC"></a>创建 PV 和 PVC</h4><h5 id="创建-PV-对象"><a href="#创建-PV-对象" class="headerlink" title="创建 PV 对象"></a>创建 PV 对象</h5><p>测试环境使用的是 Minikube，因此这里使用工作节点的本地路径来创建 PV，而不使用网络存储。其清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  capacity:</span></span><br><span class="line"><span class="attr">    storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadOnlyMany</span></span><br><span class="line"><span class="attr">  hostPath:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/var/quiz-data</span></span><br></pre></td></tr></table></figure></p><p>其中的 <code>capacity</code> 选项用来指定底层存储卷的大小。每个 PV 都必须指定其容量，以便于在 PVC 和 PV 绑定时，Kubernetes 可以判断具体哪个 PV 符合要求。<br>每个 PV 都必须指定其支持的 <code>accessModes</code> 列表。依赖于底层存储的具体实现，PV 可能支持也可能不支持同时被多个工作节点以 r/w 或 r/o 模式挂载。<br>注意 <code>accessModes</code> 影响的是 <strong>Nodes</strong> 而不是 <strong>Pods</strong>。一个 PV 只要能够被某个节点挂载，同时也就支持被该节点上的多个 Pods 挂载。<br><code>accessModes</code> 有 <code>ReadWriteOnce</code>、<code>ReadOnlyMany</code>、<code>ReadWriteMany</code> 三种模式。</p><h5 id="创建和查看-PV"><a href="#创建和查看-PV" class="headerlink" title="创建和查看 PV"></a>创建和查看 PV</h5><p>创建 PV：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pv.quiz-data.hostpath.yaml</span><br><span class="line">persistentvolume/quiz-data created</span><br></pre></td></tr></table></figure></p><p>查看 PV：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Available                                   <span class="number">2</span>m55s</span><br></pre></td></tr></table></figure></p><h5 id="声明一个-PV"><a href="#声明一个-PV" class="headerlink" title="声明一个 PV"></a>声明一个 PV</h5><p><strong>创建一个 PVC 对象</strong><br>需要创建 PVC 对象来声明一个 PV，PVC 对象中会指定 PV 必须符合的要求，包括最小容量、访问模式等，通常是由不同应用的具体需求来决定的。因而 PVC 对象应该由应用的作者而不是集群管理员来创建。</p><p>PVC 对象的清单文件内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">  storageClassName:</span> <span class="string">""</span></span><br><span class="line"><span class="attr">  volumeName:</span> <span class="string">quiz-data</span></span><br></pre></td></tr></table></figure></p><p>上面的 PVC 对象描述了一系列需要 PV 满足的要求。比如至少 1G 大小、能够在单节点上以读写模式挂载。<br><code>storageClassName</code> 字段用来配置 PV 的动态生成，如果需要绑定一个已经预先创建好的 PV，则该字段必须为空。<br>因为前面创建的 PV 名字为 <code>quiz-data</code>，所以 PVC 中的 <code>volumeName</code> 字段也必须为 <code>quiz-data</code>；若不指定此字段，则 Kubernetes 有可能会绑定其他满足要求的 PV。<br>如果集群管理员创建了一系列没有指定名称的 PV，用户也并不在意具体会绑定哪个 PV，则可以跳过 <code>volumeName</code> 字段，让 Kubernetes 随机选择满足要求的 PV。</p><h5 id="创建和查看-PVC"><a href="#创建和查看-PVC" class="headerlink" title="创建和查看 PVC"></a>创建和查看 PVC</h5><p>创建 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl apply -f pvc.quiz-data.static.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data created</span><br></pre></td></tr></table></figure></p><p>查看 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pvc</span><br><span class="line">NAME        STATUS   VOLUME      CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">quiz-data   Bound    quiz-data   <span class="number">1</span>Gi        RWO,ROX                       <span class="number">31</span>s</span><br></pre></td></tr></table></figure></p><p>再次查看之前创建的 PV 的状态，可以看到此时 <code>quiz-data</code> PV 的 <code>STATUS</code> 变成了 <code>BOUND</code>：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Bound    default/quiz-data                           <span class="number">92</span>m</span><br></pre></td></tr></table></figure></p><h4 id="在-Pod-中使用-PVC-和-PV"><a href="#在-Pod-中使用-PVC-和-PV" class="headerlink" title="在 Pod 中使用 PVC 和 PV"></a>在 Pod 中使用 PVC 和 PV</h4><p>参考如下清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">    persistentVolumeClaim:</span></span><br><span class="line"><span class="attr">      claimName:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">quiz-api</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/quiz-api:0.1</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">mongo</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">quiz-data</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/data/db</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl apply -f pod.quiz.pvc.yaml</code> 命令创建 Pod，待创建完成后，可以执行如下 Shell 命令向 mongo 容器中插入数据：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it quiz -c mongo -- mongo kiada &lt;&lt;EOF</span><br><span class="line">db.questions.insert(&#123;</span><br><span class="line">  id: 1,</span><br><span class="line">  text: <span class="string">"What does k8s mean?"</span>,</span><br><span class="line">  answers: [<span class="string">"Kates"</span>, <span class="string">"Kubernetes"</span>, <span class="string">"Kooba Dooba Doo!"</span>],</span><br><span class="line">  correctAnswerIndex: 1</span><br><span class="line">&#125;)</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></p><p>运行如下命令查看插入的数据：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure></p><h5 id="在-Pod-中重复使用-PVC"><a href="#在-Pod-中重复使用-PVC" class="headerlink" title="在 Pod 中重复使用 PVC"></a>在 Pod 中重复使用 PVC</h5><p>当删除某个 Pod 中的 PVC 时，对应的底层存储卷会从工作节点解除挂载。但 PV 对象仍旧是跟 PVC 相关联的。若之后创建另一个 Pod 指向同样的 PVC，则新的 Pod 可以访问 PV 对应的存储卷和文件。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete -f pod.quiz.pvc.yaml</span><br><span class="line">pod "quiz" deleted</span><br><span class="line">$ kubectl apply -f pod.quiz.pvc.yaml</span><br><span class="line">pod/quiz created</span><br><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="释放-PV"><a href="#释放-PV" class="headerlink" title="释放 PV"></a>释放 PV</h5><p>删除 PVC 会释放对应的 PV。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pod quiz</span><br><span class="line">pod "quiz" deleted</span><br><span class="line">$ kubectl delete pvc quiz-data</span><br><span class="line">persistentvolumeclaim "quiz-data" deleted</span><br></pre></td></tr></table></figure></p><p>查看此时 PV 的状态：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv quiz-data</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS     CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Released   default/quiz-data                           <span class="number">45</span>h</span><br></pre></td></tr></table></figure></p><p>其 <code>STATUS</code> 项变成了 <code>Released</code> 状态。</p><p>若此时重新创建删除的 PVC，对应的 PV 不会再次被绑定。<br>原因在于，PV 已经被使用过，有可能包含一些旧的数据，需要在绑定给另一个 PVC 之前进行清理。这也是为什么 PV 已经 <code>Released</code> 之后，仍然显示关联的 <code>CLAIM</code> 是 <code>default/quiz-data</code>，为了方便集群管理员确认这些数据能否被安全的删除。</p><h5 id="令释放的-PV-重新可用"><a href="#令释放的-PV-重新可用" class="headerlink" title="令释放的 PV 重新可用"></a>令释放的 PV 重新可用</h5><p>重新创建删除的 PVC 不会自动绑定之前的 PV，该 PV 会处于 <code>Released</code> 状态。为了让 PV 对应的数据再次可用，需要删除并重新创建 PV。<br><strong>PV 对象只是一个指向底层存储的指针</strong>，它本身并不存储任何应用数据。删除并重新创建 PV 相当于创建了一个新的指向同一个底层存储卷的指针。数据和之前是相同的。</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pv quiz-data</span><br><span class="line">persistentvolume "quiz-data" deleted</span><br><span class="line">$ kubectl apply -f pv.quiz-data.hostpath.yaml</span><br><span class="line">persistentvolume/quiz-data created</span><br><span class="line">$ kubectl apply -f pvc.quiz-data.static.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data created</span><br><span class="line">$ kubectl apply -f pod.quiz.pvc.yaml</span><br><span class="line">pod/quiz created</span><br><span class="line">$ kubectl exec -it quiz -c mongo -- mongo kiada --quiet --eval "db.questions.<span class="built_in">find</span>()"</span><br><span class="line">&#123; "_id" : ObjectId("<span class="number">625</span>fe24a095faed6c085f539"), "id" : <span class="number">1</span>, "text" : "What does k8s mean?", "answers" : [ "Kates", "Kubernetes", "Kooba Dooba Doo!" ], "correctAnswerIndex" : <span class="number">1</span> &#125;</span><br></pre></td></tr></table></figure><h5 id="PV-的-reclaim-policy"><a href="#PV-的-reclaim-policy" class="headerlink" title="PV 的 reclaim policy"></a>PV 的 reclaim policy</h5><p>PV 被释放后的动作取决于其 reclaim policy。此 policy 由 PV 对象的 <code>.spec.persistentVolumeReclaimPolicy</code> 条目进行配置。前面 <code>quiz-data</code> 的 reclaim policy 是 <code>Retain</code>。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Bound    default/quiz-data                           <span class="number">5</span>m57s</span><br></pre></td></tr></table></figure></p><p>两种不同的 reclaim policy：</p><ul><li><code>Retain</code>：当 PV 被释放后（即对应的 PVC 被删除后），Kubernetes 会保留该 PV。集群管理员则必须手动回收 Volume。这是手动创建 PV 的默认配置</li><li><code>Delete</code>：PV 对象和对应的底层存储会在 PV 释放后自动删除。这是动态创建 PV 的默认配置</li></ul><h5 id="删除绑定中的-PV"><a href="#删除绑定中的-PV" class="headerlink" title="删除绑定中的 PV"></a>删除绑定中的 PV</h5><p>如果集群管理员删除了某个正在使用中的 PV（已经绑定给了某个 PVC）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pv quiz-data</span><br><span class="line">persistentvolume "quiz-data" deleted</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p><p>上述命令会告诉 Kubernetes API 删除 PV 对象，并等待 Kubernetes 控制器完成该操作。<br>事实上该操作并不会完成，直到待删除的 PV 最终被释放（绑定的 PVC 被删除）。<br>可以按 <code>Ctrl - C</code> 取消等待，但删除动作并不会被取消：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME        CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS        CLAIM               STORAGECLASS   REASON   AGE</span><br><span class="line">quiz-data   <span class="number">1</span>Gi        RWO,ROX        Retain           Terminating   default/quiz-data                           <span class="number">19</span>m</span><br></pre></td></tr></table></figure></p><p>该 PV 会一直处于 <code>Terminating</code> 状态，直到对应的 PVC 被删除。</p><h5 id="删除使用中的-PVC"><a href="#删除使用中的-PVC" class="headerlink" title="删除使用中的 PVC"></a>删除使用中的 PVC</h5><p>和删除 PV 类似，删除使用中的 PVC 的动作并不会立即完成。可以强制中断删除命令的执行，但并不会取消该删除流程。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl delete pvc quiz-data</span><br><span class="line">persistentvolumeclaim "quiz-data" deleted</span><br><span class="line">^C</span><br></pre></td></tr></table></figure></p><p>删除动作会被 Pod 阻塞。毫无疑问，删除一个正在使用中的 PVC 并不会立即对 Pod 中运行的应用产生任何影响。Kubernetes 并不会因为集群管理员需要回收一些存储空间而杀掉某个 Pod。<br>只有删掉引用了该 PVC 的 Pod，删除该 PVC 的进度才会完成。</p><h4 id="理解手动创建的-PV-的生命周期"><a href="#理解手动创建的-PV-的生命周期" class="headerlink" title="理解手动创建的 PV 的生命周期"></a>理解手动创建的 PV 的生命周期</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8e5e161bccbcbc3d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The lifecycle of statically provisioned persistent volumes, claims and the pods that use them"></p><p>在使用手动创建的 PV 时，底层存储卷的生命周期与 PV 对象的生命周期是分离的。<br>PV 创建后的初始状态是 <code>Available</code>，当 PVC 出现且其要求能被某个 PV 满足时，PV 与 PVC 完成绑定。在此之前 PVC 处于 <code>Pending</code> 状态，绑定完成后 PV 和 PVC 都处于 <code>Bound</code> 状态。<br>在这之后，一个或多个 Pod 可以通过引用 PVC 来使用对应的存储。当所有的 Pods 运行结束后，PVC 对象可以被删除。PVC 对象删除后，PV 的回收策略决定了对 PV 和底层存储的后续操作。若策略为 <code>Delete</code>，则 PV 和 底层存储都会被删除；若策略为 <code>Retain</code>，PV 对象和底层存储都会被保留，PV 的状态变为 <code>Released</code>，无法再次被绑定。底层存储以及其中的文件会继续存在，可以通过创建一个新的指向同样位置的 PV 来再次访问这些文件。</p><h4 id="PV-的动态创建"><a href="#PV-的动态创建" class="headerlink" title="PV 的动态创建"></a>PV 的动态创建</h4><p>前面的章节中，集群管理员必须提前创建 PV 对象，每次 PV 释放后还需要管理员手动删除存储卷中的数据。<br>为了保证集群平稳地运行，管理员需要提前创建数十甚至上百个 PV，还要持续地跟踪可用的 PV 数量，确保其没有耗尽。所有这些手动操作并没有遵循 Kubernetes 自动管理的哲学。</p><p>更好的方式是动态创建 PV。集群管理员部署一个 PV provisioner，该 provisioner 可以自动化执行实时的 PV 创建流程。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f92c964bf83dba7a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dynamic provisioning of persistent volumes"></p><p>与静态创建 PV 相反，在动态创建过程中，用户先创建 PVC，然后 provisioner 再从底层存储创建对应的 PV 对象。</p><h5 id="StorageClass-对象"><a href="#StorageClass-对象" class="headerlink" title="StorageClass 对象"></a>StorageClass 对象</h5><p>列出 storage classes<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get sc</span><br><span class="line">NAME                 PROVISIONER                RECLAIMPOLICY   VOLUMEBINDINGMODE   ALLOWVOLUMEEXPANSION   AGE</span><br><span class="line">standard (default)   k8s.io/minikube-hostpath   Delete          Immediate           false                  <span class="number">158</span>d</span><br></pre></td></tr></table></figure></p><p>进一步检查 storage class<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">sc</span> <span class="string">standard</span> <span class="bullet">-o</span> <span class="string">yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StorageClass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">kubectl.kubernetes.io/last-applied-configuration:</span> <span class="string">|</span></span><br><span class="line"><span class="string">      &#123;"apiVersion":"storage.k8s.io/v1","kind":"StorageClass","metadata":&#123;"annotations":&#123;"storageclass.kubernetes.io/is-default-class":"true"&#125;,"labels":&#123;"addonmanager.kubernetes.io/mode":"EnsureExists"&#125;,"name":"standard"&#125;,"provisioner":"k8s.io/minikube-hostpath"&#125;</span></span><br><span class="line"><span class="string">    storageclass.kubernetes.io/is-default-class: "true"</span></span><br><span class="line"><span class="string"></span><span class="attr">  creationTimestamp:</span> <span class="string">"2021-11-15T05:36:28Z"</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line">    <span class="string">addonmanager.kubernetes.io/mode:</span> <span class="string">EnsureExists</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">standard</span></span><br><span class="line"><span class="attr">  resourceVersion:</span> <span class="string">"298"</span></span><br><span class="line"><span class="attr">  uid:</span> <span class="number">3</span><span class="string">d1fb350-928d-4d53-a2eb-558358814839</span></span><br><span class="line"><span class="attr">provisioner:</span> <span class="string">k8s.io/minikube-hostpath</span></span><br><span class="line"><span class="attr">reclaimPolicy:</span> <span class="string">Delete</span></span><br><span class="line"><span class="attr">volumeBindingMode:</span> <span class="string">Immediate</span></span><br></pre></td></tr></table></figure></p><p>StorageClass 对象代表某种可以被动态创建的存储类型。每一个 StorageClass 都会指定在动态创建 Volume 时需要使用的 provisioner 以及需要传递的参数。由用户来决定每一个 PVC 具体使用那种 StorageClass。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-aa9febdc8c5c0f00.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The relationship between storage classes, persistent volume claims and dynamic volume provisioners"></p><h5 id="用-default-storage-class-动态创建-PV"><a href="#用-default-storage-class-动态创建-PV" class="headerlink" title="用 default storage class 动态创建 PV"></a>用 default storage class 动态创建 PV</h5><p>可以创建一个 PVC 对象并将其 <code>storageClassName</code> 条目设置为 <code>standard</code>，或者不指定任何 <code>storageClassName</code>，Kubernetes 会自动选择默认的 storage class。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quiz-data-default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  resources:</span></span><br><span class="line"><span class="attr">    requests:</span></span><br><span class="line"><span class="attr">      storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">  accessModes:</span></span><br><span class="line"><span class="bullet">  -</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure></p><p>创建和查看 PVC：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f pvc.quiz-data-default.yaml</span><br><span class="line">persistentvolumeclaim/quiz-data-default created</span><br><span class="line">$ kubectl get pvc quiz-data-default</span><br><span class="line">NAME                STATUS   VOLUME                                     CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">quiz-data-default   Bound    pvc-eac89776-b02b-<span class="number">49</span>c1-<span class="number">9878</span>-b50b9780bd3c   <span class="number">1</span>Gi        RWO            standard       <span class="number">47</span>s</span><br></pre></td></tr></table></figure></p><p>对应的 PV 会在 PVC 创建后自动生成和绑定。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get pv</span><br><span class="line">NAME                                       CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                       STORAGECLASS   REASON   AGE</span><br><span class="line">pvc-eac89776-b02b-<span class="number">49</span>c1-<span class="number">9878</span>-b50b9780bd3c   <span class="number">1</span>Gi        RWO            Delete           Bound    default/quiz-data-default   standard                <span class="number">113</span>s</span><br></pre></td></tr></table></figure></p><h5 id="动态生成-PV-的生命周期"><a href="#动态生成-PV-的生命周期" class="headerlink" title="动态生成 PV 的生命周期"></a>动态生成 PV 的生命周期</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1c0aedb1f55632dc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The lifecycle of dynamically provisioned persistent volumes, claims and the pods using them"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Pods-与底层存储技术的解耦&quot;&gt;&lt;a href=&quot;#Pods-与底层存储技术的解耦&quot; class=&quot;headerlink&quot; title=&quot;Pods 与底层存储技术的解耦&quot;&gt;&lt;/a&gt;Pods 与底层存储技术的解耦&lt;/h4&gt;&lt;p&gt;理想情况下，将应用部署到 Kuber
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Disk" scheme="https://rollingstarky.github.io/tags/Disk/"/>
    
      <category term="Storage" scheme="https://rollingstarky.github.io/tags/Storage/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Volume" scheme="https://rollingstarky.github.io/tags/Volume/"/>
    
      <category term="Persistent" scheme="https://rollingstarky.github.io/tags/Persistent/"/>
    
      <category term="NFS" scheme="https://rollingstarky.github.io/tags/NFS/"/>
    
  </entry>
  
  <entry>
    <title>Fluent Python 2nd 笔记——Type hints（类型标注）介绍</title>
    <link href="https://rollingstarky.github.io/2022/04/15/fluent-python-2nd-reading-notes-type-hints/"/>
    <id>https://rollingstarky.github.io/2022/04/15/fluent-python-2nd-reading-notes-type-hints/</id>
    <published>2022-04-14T16:00:00.000Z</published>
    <updated>2022-04-15T12:37:28.484Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://peps.python.org/pep-0484/" target="_blank" rel="noopener">PEP 484—Type Hints</a> 在 Python 中引入了显式的类型标注，可以为函数参数、返回值、变量等添加类型提示。主要目的在于帮助<strong>开发工具</strong>通过<strong>静态检查</strong>发现代码中的 Bug。</p><h4 id="gradual-typing"><a href="#gradual-typing" class="headerlink" title="gradual typing"></a>gradual typing</h4><p>PEP 484 引入的是一种 <em>gradual type system</em>（渐进式类型系统），支持同样类型系统的语言还有微软的 TypeScript、Google 的 Dart 等。该系统具有以下特征：</p><ul><li>可选的。默认情况下，类型检查器不应该警告没有标注类型的代码。当无法确认某个对象的类型时，假设其为 <code>Any</code> 类型</li><li>在运行时不捕获类型错误。Type hints 主要用来帮助类型检查器、linter 和 IDE 输出警告信息，不会在运行时阻止不匹配的类型传递给某个函数</li><li>对性能没有提升。理论上讲，类型标注提供的信息能够帮助解释器对生成的字节码进行优化。目前 Python 还没有相关的实现</li></ul><p><strong>类型标注在任何层面上都是可选的</strong>。<br>简单来说，用户可以选择任何一个自己感兴趣的参数或返回值进行类型标注，不用管其它的。在没有配置 IDE 进行严格检查的时候，不会有任何报错出现。<br>即便用户错误地标注了类型，对程序的运行也不会产生任何影响。最多只是 IDE 会有报错提示。</p><h5 id="gradual-typing-示例"><a href="#gradual-typing-示例" class="headerlink" title="gradual typing 示例"></a>gradual typing 示例</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># messages.py</span><br><span class="line">def show_count(count, word):</span><br><span class="line">    if count == 1:</span><br><span class="line">        return f&apos;1 &#123;word&#125;&apos;</span><br><span class="line">    count_str = str(count) if count else &apos;no&apos;</span><br><span class="line">    return f&apos;&#123;count_str&#125; &#123;word&#125;s&apos;</span><br><span class="line"></span><br><span class="line">print(show_count(1, &apos;dog&apos;))</span><br><span class="line"># =&gt; 1 dog</span><br><span class="line">print(show_count(2, &apos;dog&apos;))</span><br><span class="line"># =&gt; 2 dogs</span><br></pre></td></tr></table></figure><p>安装 <code>mypy</code> 类型检查工具：<code>pip install mypy</code>。</p><p>使用 <code>mypy</code> 命令对 <code>messages.py</code> 源代码进行类型检查，没有任何错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mypy messages.py</span><br><span class="line"><span class="function">Success: <span class="title">no</span> <span class="title">issues</span> <span class="title">found</span> <span class="title">in</span> 1 <span class="title">source</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure></p><p>只有当加上 <code>--disallow-untyped-defs</code> 选项的时候才会检查出错误（函数缺少类型标注）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-untyped-defs messages.py</span><br><span class="line"><span class="function">messages.py:1: <span class="title">error</span>: <span class="title">Function</span> <span class="title">is</span> <span class="title">missing</span> <span class="title">a</span> <span class="title">type</span> <span class="title">annotation</span></span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>修改一下检查的严格程度，使用 <code>--disallow-incomplete-defs</code> 选项，此时检查是通过的：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-incomplete-defs messages.py</span><br><span class="line"><span class="function">Success: <span class="title">no</span> <span class="title">issues</span> <span class="title">found</span> <span class="title">in</span> 1 <span class="title">source</span> <span class="title">file</span></span></span><br></pre></td></tr></table></figure></p><p>将函数 <code>show_count</code> 的签名改为 <code>show_count(count, word) -&gt; str</code>，只为返回值添加类型标注，再次进行检查：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ messages.py:<span class="number">1</span>: error: Function is missing a <span class="built_in">type</span> annotation <span class="keyword">for</span> one or <span class="built_in">more</span> arguments</span><br><span class="line">Found <span class="number">1</span> error <span class="keyword">in</span> <span class="number">1</span> file (checked <span class="number">1</span> source file)</span><br></pre></td></tr></table></figure></p><p>即 <code>--disallow-incomplete-defs</code> 不会去管完全没有类型标注的函数，而是会确保，只要某个函数添加了类型标注，则其类型标注必须完整应用到该函数的所有参数和返回值。</p><p>假如将函数 <code>show_count</code> 的签名改为 <code>show_count(count: int, word: str) -&gt; int</code>，运行类型检查则会报出其他错误（返回值类型不匹配）：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ mypy --disallow-incomplete-defs messages.py</span><br><span class="line"><span class="function">messages.py:3: <span class="title">error</span>: <span class="title">Incompatible</span> <span class="title">return</span> <span class="title">value</span> <span class="title">type</span> (<span class="title">got</span> "<span class="title">str</span>", <span class="title">expected</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">messages.py</span>:5: <span class="title">error</span>: <span class="title">Incompatible</span> <span class="title">return</span> <span class="title">value</span> <span class="title">type</span> (<span class="title">got</span> "<span class="title">str</span>", <span class="title">expected</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 2 <span class="title">errors</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>但<strong>程序的运行不会受任何影响</strong>：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ python messages.py</span><br><span class="line"><span class="number">1</span> dog</span><br><span class="line"><span class="number">2</span> dogs</span><br></pre></td></tr></table></figure></p><p>即类型标注可以帮助 IDE 等工具对代码进行静态检查，在程序运行前发现可能的语法错误。但并不会对程序的运行时施加任何影响。<br>这就是为什么称之为 Gradual。即不具备任何强制性，可以在需要的时候逐步完善任何感兴趣的变量。但加不加标注，程序该怎么跑还是怎么跑。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-53e89b8bb492af92.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Type checker in VIM"></p><h5 id="使用-None-作为默认值"><a href="#使用-None-作为默认值" class="headerlink" title="使用 None 作为默认值"></a>使用 <code>None</code> 作为默认值</h5><p>前面的 <code>messages.py</code> 实际上做的事情很简单，就是输出数量和名词。数量为 1 名词用单数，数量大于 1 名词就加 <code>s</code> 变复数。<br>但很多名词并不是直接加 <code>s</code> 就能成为复数形式，比如 <code>child</code> -&gt; <code>children</code>。因此代码可以优化为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_count</span><span class="params">(count: int, singular: str, plural: str = <span class="string">''</span>)</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f'1 <span class="subst">&#123;singular&#125;</span>'</span></span><br><span class="line">    count_str = str(count) <span class="keyword">if</span> count <span class="keyword">else</span> <span class="string">'no'</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> plural:</span><br><span class="line">        plural = singular + <span class="string">'s'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">f'<span class="subst">&#123;count_str&#125;</span> <span class="subst">&#123;plural&#125;</span>'</span></span><br><span class="line"></span><br><span class="line">print(show_count(<span class="number">2</span>, <span class="string">'dog'</span>))</span><br><span class="line"><span class="comment"># =&gt; 2 dogs</span></span><br><span class="line">print(show_count(<span class="number">2</span>, <span class="string">'child'</span>, <span class="string">'children'</span>))</span><br><span class="line"><span class="comment"># =&gt; 2 children</span></span><br></pre></td></tr></table></figure></p><p>上面的代码可以很好的工作。函数中加了一个参数 <code>plural</code> 表示名词的复数形式，默认值是空字符串 <code>&#39;&#39;</code>。但从语义的角度看，默认值用 <code>None</code> 更符合一些。<br>即某个名词要么有特殊的复数形式，要么没有。但这会导致 <code>plural</code> 参数的类型声明不适合使用 <code>str</code>，因为其取值可以是 <code>None</code>，而 <code>None</code> 不属于 <code>str</code> 类型。</p><p>把 <code>show_count</code> 函数的签名改为如下形式即可：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Optional</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show_count</span><span class="params">(count: int, singular: str, plural: Optional[str] = None)</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>Optional[str]</code> 就表示该类型可以是 <code>str</code> 或者 <code>None</code>。<br>此外，默认值 <code>=None</code> 必须显式地写在声明里，否则 Python 运行时会将 <code>plural</code> 视为必须提供的参数。<br>在类型声明里注明了某个参数是 <code>Optional</code>，并不会真的将其变为可选参数。记住<strong>对于运行时而言，类型标注总是会被忽略掉</strong>。</p><h4 id="Types-are-defined-by-supported-operations"><a href="#Types-are-defined-by-supported-operations" class="headerlink" title="Types are defined by supported operations"></a>Types are defined by supported operations</h4><p>引用 PEP 483 中的定义，类型就是一组值的集合，这些值有一个共同的特点，就是一系列特定的函数能够应用到这些值上。即<strong>某种类型支持的一系列操作定义了该类型的特征</strong>。</p><p>比如下面的 <code>double</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>x</code> 参数的类型可以是数值类型（<code>int</code>、<code>complex</code>、<code>Fraction</code>、<code>numpy.uint32</code> 等），但也可能是某种序列类型（<code>str</code>、<code>tuple</code>、<code>list</code>、<code>array</code> 等）、N 维数组 <code>numpy.array</code> 甚至任何其他类型，只要该类型实现或继承了 <code>__mul__</code> 方法且接收 int 作为参数。</p><p>但是对于另一个 <code>double</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> abc</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: abc.Sequence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>将 <code>x</code> 参数的类型声明为 <code>abc.Sequence</code>，此时使用 <code>mypy</code> 检查其类型声明会报出错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy double.py</span><br><span class="line"><span class="function">double.py:4: <span class="title">error</span>: <span class="title">Unsupported</span> <span class="title">operand</span> <span class="title">types</span> <span class="title">for</span> * ("<span class="title">Sequence</span>[<span class="title">Any</span>]" <span class="title">and</span> "<span class="title">int</span>")</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p>因为 <code>Sequence</code> 虚拟基类并没有实现或者继承 <code>__mul__</code> 方法，类型检查器认为 <code>x * 2</code> 是不支持的操作。但在实际运行时，上述代码支持 <code>x</code> 为 <code>str</code>、<code>tuple</code>、<code>list</code>、<code>array</code> 等等实现了 <code>Sequence</code> 的具体类型，运行不会有任何报错。<br>原因在于，运行时会忽略类型声明。且类型检查器只会关心显式声明的对象，比如 <code>abc.Sequence</code> 中有没有 <code>__mul__</code>。</p><p>这也是为什么在 Python 中，类型的定义就是其支持的操作。任何作为参数 <code>x</code> 传给 <code>double</code> 函数的对象，Python 运行时都会接受。它可能运行通过，也可能该对象实际并不支持 <code>* 2</code> 操作，报出 <code>TypeError</code>。</p><p>在 gradual type system 中，有两种不同的看待类型的角度：</p><ul><li>Duck typing：Smalltalk 发明的“鸭子类型”，Python、JavaScript、Ruby 等采用此方式。对象有类型，而变量（包括参数）是无类型的。在实践中，<strong>对象声明的类型是不重要的，关键在于该对象实际支持的操作</strong>。鸭子类型更加灵活，代价就是<strong>允许更多的错误出现在运行时</strong>。</li><li>Nominal typing：C++、Java、C# 等采用此方式。对象和变量都有类型。但<strong>对象只存在于运行时，而类型检查器只关心源代码</strong>中标记了类型的变量。比如 <code>Duck</code> 是 <code>Bird</code> 的子类，你可以将一个 <code>Duck</code> 对象绑定给标记为 <code>birdie: Bird</code> 的参数。但是在函数体中，类型检查器会认为 <code>birdie.quack()</code> 是非法的（<code>quack()</code> 是 <code>Duck</code> 类中实现的方法）。因为 <code>Bird</code> 类并没有提供 <code>quack()</code> 方法，即便实际的参数 <code>Duck</code> 对象已经实现了 <code>quack()</code>。Nominal typing 在静态检查时强制应用，<strong>类型检查器只是读取源代码，并不会执行任何一个代码片段</strong>。Nominal typing 更加严格，优势就是可以更早地发现某些 bug，比如在 build 阶段甚至代码刚输入到 IDE 中的时候。</li></ul><p>参考下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># birds.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bird</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Duck</span><span class="params">(Bird)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">quack</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'Quack'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert</span><span class="params">(birdie)</span>:</span></span><br><span class="line">    birdie.quack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert_duck</span><span class="params">(birdie: Duck)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    birdie.quack()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">alert_bird</span><span class="params">(birdie: Bird)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    birdie.quack()</span><br></pre></td></tr></table></figure></p><p><code>Duck</code> 是 <code>Bird</code> 的子类；<br><code>alert</code> 没有类型标注，会被类型检查器忽略；<br><code>alert_duck</code> 接收一个 <code>Duck</code> 类型的参数；<br><code>alert_bird</code> 接收 <code>Bird</code> 类型的参数。</p><p>用 <code>mypy</code> 检查上述代码会报出一个错误：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ mypy birds.py</span><br><span class="line"><span class="function">birds.py:15: <span class="title">error</span>: "<span class="title">Bird</span>" <span class="title">has</span> <span class="title">no</span> <span class="title">attribute</span> "<span class="title">quack</span>"</span></span><br><span class="line"><span class="function"><span class="title">Found</span> 1 <span class="title">error</span> <span class="title">in</span> 1 <span class="title">file</span> (<span class="title">checked</span> 1 <span class="title">source</span> <span class="title">file</span>)</span></span><br></pre></td></tr></table></figure></p><p><code>Bird</code> 类没有 <code>quack()</code> 方法，但函数体中却有对 <code>quack()</code> 方法的调用。</p><p>编写如下代码调用前面的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># daffy.py</span></span><br><span class="line"><span class="keyword">from</span> birds <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">daffy = Duck()</span><br><span class="line">alert(daffy)</span><br><span class="line">alert_duck(daffy)</span><br><span class="line">alert_bird(daffy)</span><br></pre></td></tr></table></figure></p><p>可以成功运行：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ python daffy.py</span><br><span class="line">Quack</span><br><span class="line">Quack</span><br><span class="line">Quack</span><br></pre></td></tr></table></figure></p><p>还是那句重复了无数遍的话，在运行时，Python 并不关心声明的变量，它使用 duck typing，只关心实际传入的对象是不是支持某个操作。<br>因而某些时候即便静态类型检查报出了错误，代码依旧能成功运行。</p><p>但是对于下面的例子，静态检查就显得很有用了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># woody.py</span></span><br><span class="line"><span class="keyword">from</span> birds <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">woody = Bird()</span><br><span class="line">alert(woody)</span><br><span class="line">alert_duck(woody)</span><br><span class="line">alert_bird(woody)</span><br></pre></td></tr></table></figure></p><p>此时运行 <code>woody.py</code> 会报出 <code>AttributeError: &#39;Bird&#39; object has no attribute &#39;quack&#39;</code> 错误。因为实际传入的 <code>woody</code> 对象是 <code>Bird</code> 类的实例，它确实没有 <code>quack()</code> 方法。<br>有了静态检查，就可以在程序运行前发现此类错误。</p><p>上面的几个例子表明，<strong>duck typing 更灵活更加容易上手，但同时会允许不支持的操作在运行时触发错误；Nominal typing 会在运行时之前检测错误，但有些时候会阻止本可以运行的代码</strong>。<br>在实际的环境中，函数有可能非常臃肿，有可能 <code>birdie</code> 参数被传递给了更多函数，<code>birdie</code> 还有可能来自于很长的函数调用链，会使得运行时错误很难被精确定位到。类型检查器则会阻止很多这类错误在运行时发生。</p><h4 id="Type-hints-中用到的类型"><a href="#Type-hints-中用到的类型" class="headerlink" title="Type hints 中用到的类型"></a>Type hints 中用到的类型</h4><h5 id="Any-类型"><a href="#Any-类型" class="headerlink" title="Any 类型"></a><code>Any</code> 类型</h5><p>gradual type system 的基础就是 <code>Any</code> 类型，也被叫做动态类型（<em>dynamic type</em>）。<br>当类型检测器遇到如下未标注类型的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: abc.Sequence)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>会将其视为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Any</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">double</span><span class="params">(x: Any)</span> -&gt; Any:</span></span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p><code>Any</code> 类型支持所有可能的操作，参数 <code>n: Any</code> 可以接受任意类型的值。</p><h5 id="简单类型和类"><a href="#简单类型和类" class="headerlink" title="简单类型和类"></a>简单类型和类</h5><p>简单类型比如 <code>int</code>、<code>float</code>、<code>str</code>、<code>bytes</code> 可以直接用在类型标注中。<br>来自于标准库或者第三方库，以及用户自定义的类也可以作为类型标注的关键字。<br>虚拟基类在类型标注中也比较常用。</p><p>同时还要注意一个重要的原则：子类可以用在任何声明需要其父类的地方（<strong>Liskov Substitution Principle</strong>）。</p><h5 id="Optional-和-Union-类型"><a href="#Optional-和-Union-类型" class="headerlink" title="Optional 和 Union 类型"></a><code>Optional</code> 和 <code>Union</code> 类型</h5><p><code>Optional[str]</code> 实际上是 <code>Union[str, None]</code> 类型的简写形式，表示某个值可以是 <code>str</code> <strong>或者</strong> <code>None</code>。<br>在 Python3.10 中，可以用 <code>str | None</code> 代替 <code>Union[str, None]</code>。</p><p>下面是一个有可能返回 <code>str</code> 或者 <code>float</code> 类型的函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Union</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">parse_token</span><span class="params">(token: str)</span> -&gt; Union[str, float]:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> float(token)</span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        <span class="keyword">return</span> token</span><br></pre></td></tr></table></figure></p><p><code>Union</code> 在相互之间不一致的类型中比较有用，比如 <code>Union[str, float]</code>。对于有兼容关系的类型比如 <code>Union[int, float]</code> 就不是很有必要，因为声明为 <code>float</code> 类型的参数也可以接收 <code>int</code> 类型的值。</p><h5 id="通用集合类型"><a href="#通用集合类型" class="headerlink" title="通用集合类型"></a>通用集合类型</h5><p>Python 中的大多数集合类型都是<strong>不均匀</strong>的。不均匀的意思就是，比如 <code>list</code> 类型的变量中可以同时存放多种不同类型的值。但是，这种做法通常是不够实用的。<br>通常用户将一系列对象保存至某个集合中，这些对象一般至少有一个共同的接口，以便用户稍后用一个函数对所有这些对象进行处理。</p><p>Generic types 可以在声明时加上一个类型参数。比如 <code>list</code> 可以通过参数化来控制自身存储的值的类型：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tokenize</span><span class="params">(text: str)</span> -&gt; list[str]:</span></span><br><span class="line">    <span class="keyword">return</span> text.upper().split()</span><br></pre></td></tr></table></figure></p><p>在 Python 版本不低于 3.9 时，上述代码表示 <code>tokenize</code> 函数会返回一个列表，列表中的每一项都是 <code>str</code> 类型。</p><p>类型标注 <code>stuff: list</code> 和 <code>stuf: list[Any]</code> 是等效的，都表示 <code>stuff</code> 这个列表可以同时包含任意类型的元素。</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><p><strong>元组作为记录</strong><br>比如需要保存城市、人口和国家的值 <code>(&#39;Shanghai&#39;, 24.28, &#39;China&#39;)</code>，其类型标注可以写作 <code>tuple[str, float, str]</code>。</p><p><strong>有命名字段的元组</strong><br>建议使用 <code>typing.NamedTuple</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> NamedTuple</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coordinate</span><span class="params">(NamedTuple)</span>:</span></span><br><span class="line">    lat: float</span><br><span class="line">    lon: float</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(lat_lon: tuple[float, float])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    lat, lon = lat_lon</span><br><span class="line">    ns = <span class="string">'N'</span> <span class="keyword">if</span> lat &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'S'</span></span><br><span class="line">    ew = <span class="string">'E'</span> <span class="keyword">if</span> lon &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'W'</span></span><br><span class="line">    print(<span class="string">f'<span class="subst">&#123;abs(lat):<span class="number">0.1</span>f&#125;</span>°<span class="subst">&#123;ns&#125;</span>, <span class="subst">&#123;abs(lon):<span class="number">0.1</span>f&#125;</span>°<span class="subst">&#123;ew&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">display(Coordinate(<span class="number">120.20</span>, <span class="number">30.26</span>))</span><br><span class="line"><span class="comment"># =&gt; 120.2°N, 30.2°E</span></span><br></pre></td></tr></table></figure></p><p><code>NamedTuple</code> 与 <code>tuple[float, float]</code> 兼容，因而 <code>Coordinate</code> 对象可以直接传递给 <code>display</code> 函数。</p><p><strong>元组作为不可变序列</strong><br>当需要将元组作为不可变列表使用时，类型标注需要指定一个单一的类型，后面跟上逗号和 <code>...</code>。<br>比如 <code>tuple[int, ...]</code> 表示一个元组包含未知数量的 <code>int</code> 类型的元素。<br><code>stuff: tuple[Any, ...]</code> 等同于 <code>stuff: tuple</code>，表示 <code>stuff</code> 对象可以包含未指定数量的任意类型的元素。</p><h5 id="Generic-mappings"><a href="#Generic-mappings" class="headerlink" title="Generic mappings"></a>Generic mappings</h5><p>Generic mapping 类型使用 <code>MappingType[KeyType, ValueType]</code> 形式的标注。比如内置的 <code>dict</code> 和其他 <code>collections</code>/<code>collections.abc</code> 库中的 Map 类型。</p><h5 id="Abstract-Base-Class"><a href="#Abstract-Base-Class" class="headerlink" title="Abstract Base Class"></a>Abstract Base Class</h5><p>理想情况下，一个函数应该接收<strong>虚拟类型的参数</strong>，不使用某个具体的类型。<br>比如下面的函数签名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Mapping</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2hex</span><span class="params">(name: str, color_map: Mapping[str, int])</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>abc.Mapping</code> 作为函数参数的类型标注，能够允许调用者传入 <code>dict</code>、<code>defaultdict.ChainMap</code>、<code>UserDict</code> 子类或者任意 <code>Mapping</code> 的子类型作为参数。</p><p>相反的，使用下面的函数签名：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name2hex</span><span class="params">(name: str, color_map: dict[str, int])</span> -&gt; str:</span></span><br></pre></td></tr></table></figure></p><p>会使得 <code>color_map</code> 参数必须接收 <code>dict</code> 或者 <code>defaultDict</code>、<code>OrderedDict</code> 等 <code>dict</code> 的子类型。<code>collections.UserDict</code> 的子类就无法通过 <code>color_map</code> 的类型检查。因为 <code>UserDict</code> 并不是 <code>dict</code> 类型的子类，它俩是兄弟关系，都是 <code>abc.MutableMapping</code> 的子类。<br>因此，在实践中最好使用 <code>abc.Mapping</code> 或者 <code>abc.MutableMapping</code> 作为参数的类型标注。</p><p>有个法则叫做 <a href="https://en.wikipedia.org/wiki/Robustness_principle" target="_blank" rel="noopener"><strong>Postel’s law</strong></a>，也被称为<strong>鲁棒性原则</strong>。简单来说就是<strong>对发送的内容保持谨慎，对接收的内容保持自由</strong>。</p><p>拿列表举例来说，在标注函数的返回值类型时，最好使用 <code>list[str]</code> 这种具体的类型；在标注函数的参数时，则使用 <code>Sequence</code> 或 <code>Iterable</code> 这类抽象的集合类型。</p><h5 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"></span><br><span class="line">FromTo = tuple[str, str]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip_replace</span><span class="params">(text: str, changes: Iterable[FromTo])</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">for</span> from_, to <span class="keyword">in</span> changes:</span><br><span class="line">        text = text.replace(from_, to)</span><br><span class="line">    <span class="keyword">return</span> text</span><br><span class="line"></span><br><span class="line">l33t = [(<span class="string">'a'</span>, <span class="string">'4'</span>), (<span class="string">'e'</span>, <span class="string">'3'</span>), (<span class="string">'i'</span>, <span class="string">'1'</span>), (<span class="string">'o'</span>, <span class="string">'0'</span>)]</span><br><span class="line">text = <span class="string">'mad skilled noob powned leet'</span></span><br><span class="line">print(zip_replace(text, l33t))</span><br><span class="line"><span class="comment"># =&gt; m4d sk1ll3d n00b p0wn3d l33t</span></span><br></pre></td></tr></table></figure><p>其中 <code>FromTo</code> 是 <em>type alias</em>。</p><h5 id="参数化通用类型与-TypeVar"><a href="#参数化通用类型与-TypeVar" class="headerlink" title="参数化通用类型与 TypeVar"></a>参数化通用类型与 <code>TypeVar</code></h5><p>参数化通用类型是一种通用类型，比如 <code>list[T]</code> 中的 <code>T</code> 可以绑定任意指定类型，但是之后再次出现的 <code>T</code> 则会表示同样的类型。</p><p>参考下面的 <code>sample.py</code> 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Sequence</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> shuffle</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span><span class="params">(population: Sequence[T], size: int)</span> -&gt; list[T]:</span></span><br><span class="line">    <span class="keyword">if</span> size &lt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">'size must be &gt;= 1'</span>)</span><br><span class="line">    result = list(population)</span><br><span class="line">    shuffle(result)</span><br><span class="line">    <span class="keyword">return</span> result[:size]</span><br></pre></td></tr></table></figure></p><p>假如传给 <code>sample</code> 函数的参数类型是 <code>tuple[int, ...]</code>，该参数与 <code>Sequence[int]</code> 通用，因此类型参数 <code>T</code> 就代表 <code>int</code>，从而返回值类型变成 <code>list[int]</code>。<br>假如传入的参数类型是 <code>str</code>，与 <code>Sequence[str]</code> 通用，则 <code>T</code> 代表 <code>str</code>，因而返回值类型变成 <code>list[str]</code>。</p><p><strong>Restricted <code>TypeVar</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> decimal <span class="keyword">import</span> Decimal</span><br><span class="line"><span class="keyword">from</span> fractions <span class="keyword">import</span> Fraction</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">NumberT = TypeVar(<span class="string">'NumberT'</span>, float, Decimal, Fraction)</span><br></pre></td></tr></table></figure></p><p>表示类型参数 <code>T</code> 只能是声明中提到的有限的几个类型之一。</p><p><strong>Bounded <code>TypeVar</code></strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Hashable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar</span><br><span class="line"></span><br><span class="line">HashableT = TypeVar(<span class="string">'HashableT'</span>, bound=Hashable)</span><br></pre></td></tr></table></figure></p><p>表示类型参数 <code>T</code> 只能是 <code>Hashable</code> 类型或者其子类型之一。</p><h5 id="Static-Protocols"><a href="#Static-Protocols" class="headerlink" title="Static Protocols"></a>Static Protocols</h5><p><code>Protocol</code> 类型与 Go 中的接口很相似。它的定义中会指定一个或多个方法，类型检查器则会确认对应的类型是否实现了这些方法。</p><p>比如下面的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Protocol, Any</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SupportLessThan</span><span class="params">(Protocol)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other: Any)</span> -&gt; bool:</span> ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">LT = TypeVar(<span class="string">'LT'</span>, bound=SupportLessThan)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">top</span><span class="params">(series: Iterable[LT], length: int)</span> -&gt; list[LT]:</span></span><br><span class="line">    ordered = sorted(series, reverse=<span class="keyword">True</span>)</span><br><span class="line">    <span class="keyword">return</span> ordered[:length]</span><br><span class="line"></span><br><span class="line">print(top([<span class="number">4</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">3</span>], <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; [7, 6, 5]</span></span><br><span class="line">l = <span class="string">'mango pear apple kiwi banana'</span>.split()</span><br><span class="line">print(top(l, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; ['pear', 'mango', 'kiwi']</span></span><br><span class="line">l2 = [(len(s), s) <span class="keyword">for</span> s <span class="keyword">in</span> l]</span><br><span class="line">print(top(l2, <span class="number">3</span>))</span><br><span class="line"><span class="comment"># =&gt; [(6, 'banana'), (5, 'mango'), (5, 'apple')]</span></span><br></pre></td></tr></table></figure></p><p>如果 <code>top</code> 函数中 <code>series</code> 参数的类型标注是 <code>Iterable[T]</code>，没有任何其他限制，意味着该类型参数 <code>T</code> 可以是任意类型。但将 <code>Iterable[Any]</code> 传给函数体中的 <code>sorted</code> 函数，并不总是成立，必须确保 <code>Iterable[Any]</code> 是可以被直接排序的类型。<br>因而需要先创建一个 <code>SupportLessThan</code> protocol 指定 <code>__lt__</code> 方法，再用该 protocol 来绑定类型参数 <code>LT</code>，从而限制 <code>series</code> 参数必须为可迭代对象，且其中的元素都实现了 <code>__lt__</code> 方法，使得传入的 <code>series</code> 参数支持被 <code>sorted</code> 直接排序。</p><p>当类型 <code>T</code> 实现了 protocol <code>P</code> 中定义的所有方法时，则说明该类型 <code>T</code> 与 protocol <code>P</code> 通用。</p><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p><code>Callable</code> 主要用于标注高阶函数中作为参数或者返回值的函数对象。其格式为 <code>Callable[[ParamType1, ParamType2], ReturnType]</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.oreilly.com/library/view/fluent-python-2nd/9781492056348/" target="_blank" rel="noopener">Fluent Python, 2nd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://peps.python.org/pep-0484/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PEP 484—Type Hints&lt;/a&gt; 在 Python 中引入了显式的类型标注，可以为函数参数、返回值、变量等添加类
      
    
    </summary>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="List" scheme="https://rollingstarky.github.io/tags/List/"/>
    
      <category term="IDE" scheme="https://rollingstarky.github.io/tags/IDE/"/>
    
      <category term="Generic" scheme="https://rollingstarky.github.io/tags/Generic/"/>
    
      <category term="Tuple" scheme="https://rollingstarky.github.io/tags/Tuple/"/>
    
      <category term="Mapping" scheme="https://rollingstarky.github.io/tags/Mapping/"/>
    
      <category term="DuckTyping" scheme="https://rollingstarky.github.io/tags/DuckTyping/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 通过 Services 对象暴露 Pod 中的服务</title>
    <link href="https://rollingstarky.github.io/2022/04/12/kubernetes-in-action-reading-notes-exposing-pods-with-services/"/>
    <id>https://rollingstarky.github.io/2022/04/12/kubernetes-in-action-reading-notes-exposing-pods-with-services/</id>
    <published>2022-04-11T16:00:00.000Z</published>
    <updated>2022-04-11T16:30:28.529Z</updated>
    
    <content type="html"><![CDATA[<p>不同于只运行某个提供特定服务的单一 Pod，现在人们通常会以副本的形式部署多个 Pod 实例，以便工作负载能够均匀地分发到不同的集群节点上。<br>这也意味着同一个 Pod 的所有副本都提供相同的服务，且能够通过一个单一的地址访问。Kubernetes 中的 Services 对象就负责实现这部分功能。</p><h5 id="Pods-间如何通信"><a href="#Pods-间如何通信" class="headerlink" title="Pods 间如何通信"></a>Pods 间如何通信</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1f0d6948e37665b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods communicate via their own computer network"></p><p>每个 Pod 都拥有自己的网络接口和 IP 地址。集群中的所有 Pod 通过一个私有的 Flat network 相互通信，该 Flat network 实际上是一个定义在实体网络之上的虚拟网络层。<br>Pod 中的容器可以通过这个虚拟网络层传输数据，无需进行 NAT 转换，就像是局域网中接入到同一个交换机上的计算机一样。<br>对于应用来说，Node 之间实际的网络拓扑是不重要的。</p><h5 id="为什么需要-Service"><a href="#为什么需要-Service" class="headerlink" title="为什么需要 Service"></a>为什么需要 Service</h5><p>如果某个 Pod 中的应用需要连接其他 Pod 中的另一个应用，则它需要知道目标 Pod 的访问地址，这是显而易见的。实际上实现起来要复杂的多：</p><ul><li>Pods 是有生命周期的。一个 Pod 可以在任意时间被销毁和替代（IP 地址会变）</li><li>Pod 只有在分配给某个 Node 后才获取到 IP 地址，无法提前知道</li><li>在水平扩展中，多个 Pod 副本提供同样的服务，每个副本都有自己的 IP 地址。当另一个 Pod 访问所有这些副本时，就需要能够用一个单一的 IP 或 DNS 名称连接到负载均衡器，再通过负载均衡器在所有的副本间分担工作负载</li></ul><h4 id="Service-介绍"><a href="#Service-介绍" class="headerlink" title="Service 介绍"></a>Service 介绍</h4><p>Kubernetes Service 对象可以为一系列提供同一服务的 Pod 集合，绑定一个单一、稳定的访问点。在 Service 的生命周期里，其 IP 地址稳定不变。客户端通过该 IP 地址创建网络连接，这些请求之后再被转发给后端提供服务的 Pod。<br>简单来说，Service 就是放置在 Pods 前面的负载均衡器。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6be048f6ad064c51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing pods with Service objects"></p><h5 id="Pod-和-Service-如何组合在一起"><a href="#Pod-和-Service-如何组合在一起" class="headerlink" title="Pod 和 Service 如何组合在一起"></a>Pod 和 Service 如何组合在一起</h5><p>Services 通过 <strong>label</strong> 和 <strong>label selector</strong> 机制找到对应的 Pods。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-008ee472838a47ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Label selectors determine which pods are part of the Service"></p><h4 id="创建和更新-Service"><a href="#创建和更新-Service" class="headerlink" title="创建和更新 Service"></a>创建和更新 Service</h4><p><strong>PS</strong>：作者的示例代码可以从其 Github <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition" target="_blank" rel="noopener">kubernetes-in-action-2nd-edition</a> 处下载，Service 部分的代码位于 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter11" target="_blank" rel="noopener">Chapter11</a>。<br>在创建 Service 之前，可以先进入到 Chapter11 路径下，运行 <code>kubectl apply -f SETUP/ --recursive</code> 命令，创建需要的 Pods。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME           READY   STATUS    RESTARTS   AGE</span><br><span class="line">quiz           <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">001</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">002</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-<span class="number">003</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br><span class="line">quote-canary   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">0</span>          <span class="number">33</span>m</span><br></pre></td></tr></table></figure></p><p>Kubernetes 支持如下几种 Service 类型：<code>ClusterIP</code>、<code>NodePort</code>、<code>LoadBalancer</code> 和 <code>ExternalName</code>。<br>ClusterIP 是默认的类型，仅用于集群内部通信。</p><p><strong>通过 YAML 清单文件创建 Service</strong><br><code>quote</code> Service 最小版本的清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">quote</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">quote</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8e1ccb57edab4766.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The quote service and the pods that it forwards traffic to"></p><p><strong>通过 kubectl expose 命令创建 Service</strong><br><code>kubectl expose pod quiz --name quiz</code></p><p><strong>获取 Services 列表</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc -o wide</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE   SELECTOR</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">8080</span>/TCP   <span class="number">45</span>s   app=quiz,rel=stable</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP     <span class="number">62</span>s   app=quote</span><br></pre></td></tr></table></figure></p><p><strong>修改 Service 的 label selector</strong><br><code>kubectl set selector service quiz app=quiz</code></p><p><strong>修改 Service 暴露的端口</strong><br>可以运行 <code>kubectl edit svc quiz</code> 命令编辑清单文件，将 <code>port</code> 字段修改为 <code>80</code>，保存退出即可。</p><h4 id="访问集群内部的-Services"><a href="#访问集群内部的-Services" class="headerlink" title="访问集群内部的 Services"></a>访问集群内部的 Services</h4><p>前面创建的 <code>ClusterIP</code> 类型的 Service 只支持集群内部访问，可以 <code>ssh</code> 到任意一个 Node 或者 Pod 上来测试其连通性。</p><h5 id="从-Pods-连接-Services"><a href="#从-Pods-连接-Services" class="headerlink" title="从 Pods 连接 Services"></a>从 Pods 连接 Services</h5><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get po</span><br><span class="line">NAME           READY   STATUS    RESTARTS      AGE</span><br><span class="line">quiz           <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">001</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">002</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-<span class="number">003</span>      <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line">quote-canary   <span class="number">2</span>/<span class="number">2</span>     Running   <span class="number">2</span> (<span class="number">26</span>h ago)   <span class="number">27</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl get svc</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)   AGE</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">26</span>h</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP    <span class="number">26</span>h</span><br><span class="line"></span><br><span class="line">$ kubectl exec -it quote-<span class="number">001</span> -c nginx -- sh</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span></span><br><span class="line">This is the quiz service running <span class="keyword">in</span> pod quiz</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">002</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">002</span> on node minikube</span><br><span class="line">/ # curl <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span></span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-canary on node minikube</span><br></pre></td></tr></table></figure><h5 id="Services-的-DNS-解析"><a href="#Services-的-DNS-解析" class="headerlink" title="Services 的 DNS 解析"></a>Services 的 DNS 解析</h5><p>Kubernetes 有一个内部的 DNS 服务器组件，供集群中所有的 Pods 使用。允许通过 Service 的名称解析其 ClusterIP 地址。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/ # curl quiz</span><br><span class="line">This is the quiz service running <span class="keyword">in</span> pod quiz</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-canary on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br><span class="line">/ # curl quote</span><br><span class="line">This is the quote service running <span class="keyword">in</span> pod quote-<span class="number">003</span> on node minikube</span><br></pre></td></tr></table></figure></p><h5 id="在-Pod-中使用-Services"><a href="#在-Pod-中使用-Services" class="headerlink" title="在 Pod 中使用 Services"></a>在 Pod 中使用 Services</h5><p>可以参考如下 YAML 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-003</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    rel:</span> <span class="string">stable</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.5</span></span><br><span class="line"><span class="attr">    imagePullPolicy:</span> <span class="string">Always</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">QUOTE_URL</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">http://quote/quote</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">QUIZ_URL</span></span><br><span class="line"><span class="attr">      value:</span> <span class="attr">http://quiz</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>完整的源代码参考 Chapter11 路径下的 <code>kiada-stable-and-canary.yaml</code> 文件。<br>运行 <code>kubectl apply -f kiada-stable-and-canary.yaml</code> 命令应用该清单文件。<br>所有容器成功运行后，运行 <code>kubectl port-forward</code> 命令启用本地端口转发：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl port-forward kiada-<span class="number">001</span> <span class="number">8080</span> <span class="number">8443</span></span><br><span class="line">Forwarding from <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8080</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding from [::<span class="number">1</span>]:<span class="number">8080</span> -&gt; <span class="number">8080</span></span><br><span class="line">Forwarding from <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span>:<span class="number">8443</span> -&gt; <span class="number">8443</span></span><br><span class="line">Forwarding from [::<span class="number">1</span>]:<span class="number">8443</span> -&gt; <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>此时打开浏览器访问 <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 或 <a href="https://localhost:8443" target="_blank" rel="noopener">https://localhost:8443</a> 即可进入应用页面：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6fbdb8cb8e3083aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kiada App"></p><h4 id="向集群外部暴露服务"><a href="#向集群外部暴露服务" class="headerlink" title="向集群外部暴露服务"></a>向集群外部暴露服务</h4><p>为了令某个 Service 能够被外部世界访问，可以采取如下几种措施：</p><ul><li>为 Node 分配一个额外的 IP，并将其设置为 Service 的 <code>externalIP</code></li><li>将 Service 的类型配置为 <code>NodePort</code>，通过 Node 端口访问该服务</li><li>创建 <code>LoadBalancer</code> 类型的 Service 对象</li><li>Ingress 对象</li></ul><p>其中第一种方式会为 Service 对象的 <code>spec.externalIPs</code> 字段指定一个额外的 IP，这种方式并不常用。<br>更常见的方式是将 Service 类型设置为 <code>NodePort</code>。Kubernetes 会令该 Service 能够通过所有 Node 节点上的特定端口访问。通常还需要用户配置一个外部的负载均衡器负责将客户端流量转发到这些 Node 端口。<br>不同于 <code>NodePort</code> 一般需要手动配置负载均衡，Kubernetes 还支持自动完成类似搭建过程，只需要用户指定 Service 的类型为 <code>LoadBalancer</code>。但并不是所有环境下的集群都支持这样做，因为负载均衡的创建依赖特定的云服务供应商。<br>最后一种方式则是通过 <code>Ingress</code> 对象实现服务对外部的开放，其具体实现机制依赖于底层的 ingress 控制器。</p><h5 id="NodePort-Service"><a href="#NodePort-Service" class="headerlink" title="NodePort Service"></a>NodePort Service</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6e512c35866a7bde.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing pods through a NodePort service"></p><p>同 <code>ClusterIP</code> 类似，<code>NodePort</code> Service 支持通过内部的 cluster IP 访问。除此之外，它还可以通过任意一个 Node 的特定端口来访问。<br>最终由哪一个 Node 为客户端提供连接是不重要的，因为每一个 Node 都总是会将客户端请求转发给 Service 背后的任意 Pod，不管这个 Pod 是否运行在同一个 Node 上。<br>即 Node A 的端口接收到客户端请求，它可能会将该请求转发给 Node A 上运行的 Pod，也可能转发给 Node B 上运行的 Pod。</p><p><strong>创建 NodePort Service</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>上面的清单文件中共有 6 个 port，可以参考如下截图理解各个 port 的不同含义：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d53c91af970fdc7b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing multiple ports through with a NodePort service"></p><p><strong>查看 NodePort Service</strong><br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get svc</span><br><span class="line">NAME         <span class="built_in">TYPE</span>        CLUSTER-IP       EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">kiada        NodePort    <span class="number">10</span>.<span class="number">103</span>.<span class="number">96</span>.<span class="number">75</span>     &lt;none&gt;        <span class="number">80</span>:<span class="number">30080</span>/TCP,<span class="number">443</span>:<span class="number">30443</span>/TCP   <span class="number">6</span>s</span><br><span class="line">quiz         ClusterIP   <span class="number">10</span>.<span class="number">106</span>.<span class="number">164</span>.<span class="number">155</span>   &lt;none&gt;        <span class="number">80</span>/TCP                       <span class="number">28</span>h</span><br><span class="line">quote        ClusterIP   <span class="number">10</span>.<span class="number">102</span>.<span class="number">134</span>.<span class="number">27</span>    &lt;none&gt;        <span class="number">80</span>/TCP                       <span class="number">28</span>h</span><br></pre></td></tr></table></figure></p><p><strong>访问 NodePort Service</strong><br>访问 <code>NodePort</code> Service 不仅仅需要知道端口号，还必须先获取到 Node 的 IP 地址。<br>可以使用 <code>kubectl get nodes -o wide</code> 命令查看 Node 的 IP 地址（<code>INTERNAL-IP</code> 和 <code>EXTERNAL-IP</code>）。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes -o wide</span><br><span class="line">NAME       STATUS   ROLES                  AGE    VERSION   INTERNAL-IP    EXTERNAL-IP   OS-IMAGE             KERNEL-VERSION                   CONTAINER-RUNTIME</span><br><span class="line">minikube   Ready    control-plane,master   <span class="number">144</span>d   v1.<span class="number">22</span>.<span class="number">3</span>   <span class="number">192</span>.<span class="number">168</span>.<span class="number">49</span>.<span class="number">2</span>   &lt;none&gt;        Ubuntu <span class="number">20</span>.<span class="number">04</span>.<span class="number">2</span> LTS   <span class="number">5</span>.<span class="number">4</span>.<span class="number">72</span>-microsoft-standard-WSL2   docker://<span class="number">20</span>.<span class="number">10</span>.<span class="number">8</span></span><br></pre></td></tr></table></figure></p><p>此时在集群内部，则可以使用以下几种 IP 端口组合来访问 Kiada 应用：</p><ul><li><code>10.103.96.75:80</code>：cluster IP 和内部端口</li><li><code>192.168.49.2:30080</code>：Node IP 和 Node 端口</li></ul><p>因为是 Minikube 单机模拟的集群环境，只有一个 Node 可以使用。<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ curl <span class="number">192</span>.<span class="number">168</span>.<span class="number">49</span>.<span class="number">2</span>:<span class="number">30080</span></span><br><span class="line">KUBERNETES <span class="keyword">IN</span> ACTION DEMO APPLICATION v0.<span class="number">5</span></span><br><span class="line"></span><br><span class="line">==== TIP OF THE MINUTE</span><br><span class="line">You can use the `jq` tool to <span class="built_in">print</span> out the value of a pod’s `phase` field like this: `kubectl get po kiada -o json | jq .status.phase`.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">==== POP QUIZ</span><br><span class="line">Which of the following statements is correct?</span><br><span class="line"><span class="number">0</span>) When the readiness probe fails, the container is restarted.</span><br><span class="line"><span class="number">1</span>) When the liveness probe fails, the container is restarted.</span><br><span class="line"><span class="number">2</span>) Containers without a readiness probe are never restarted.</span><br><span class="line"><span class="number">3</span>) Containers without a liveness probe are never restarted.</span><br><span class="line"></span><br><span class="line">Submit your answer to /question/<span class="number">6</span>/answers/&lt;index of answer&gt; using the POST method.</span><br></pre></td></tr></table></figure></p><h5 id="LoadBalancer-Service"><a href="#LoadBalancer-Service" class="headerlink" title="LoadBalancer Service"></a>LoadBalancer Service</h5><p><code>LoadBalancer</code> 类型的 Service 实际上是 <code>NodePort</code> 类型的扩展。其基本配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30080</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">443</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30443</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8443</span></span><br></pre></td></tr></table></figure></p><p>与前面 <code>NodePort</code> Service 的配置几乎完全一致，只是服务类型由 <code>NodePort</code> 改为了 <code>LoadBalancer</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-25f28cd7f42b3535.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Exposing a LoadBalancer service"></p><h4 id="external-traffic-policy"><a href="#external-traffic-policy" class="headerlink" title="external traffic policy"></a>external traffic policy</h4><p>任何通过 NodePort 的外部客户端连接，不管是直接访问 Node 端口还是通过 LoadBalancer 间接访问 Node 端口，客户端连接都有可能会被转发给另一个 Node 上的 Pod。即接收客户端连接的 Node 和执行任务的 Pod 所在的 Node 可能不是同一个。<br>在这种情况下，就意味着网络路径上多了一次跳转。</p><p>此外，在上述情况下，转发连接时还需要将 source IP 替换成一开始接收客户端连接的 Node 的 IP。这会导致 Pod 中运行的应用无法看到此网络连接的初始来源，即无法在其 access log 中记录真实的客户端地址。</p><h5 id="Local-external-traffic-policy-的优劣"><a href="#Local-external-traffic-policy-的优劣" class="headerlink" title="Local external traffic policy 的优劣"></a>Local external traffic policy 的优劣</h5><p>为了解决上述问题，可以选择阻止 Node 将客户端连接转发给运行在其他 Node 上的 Pod。即访问 Node 的外部连接最终只会被同一个 Node 上的 Pod 接收到。具体方法是将 Service 对象 <code>spec</code> 字段下的 <code>externalTrafficPolicy</code> 字段改为 <code>Local</code>。</p><p>但上述配置同时会引发其他问题。<br>第一，如果接收到外部连接的 Node 上并没有 Pods 在运行，则该连接会卡住。因此必须确保负载均衡器只会将外部连接转发给有 Pod 运行的 Node，可以通过令负载均衡器持续检测 <code>healthCheckNodePort</code> 来实现。<br>第二，external traffic policy 设置为 <code>Local</code> 会导致 Pods 间的负载不够均衡。LoadBalancer 均匀地分发外部连接给 Nodes，Node 再将连接转发到自身运行的 Pods 上。但是每个 Node 实际上运行着不同数量的 Pods，不能跨 Node 转发就意味着，在每个 Node 接收等量连接的前提下，有些 Node 上的 Pods 较少，则这些 Pods 平均要承担的负载就更多。</p><p><code>externalTrafficPolicy</code> 设置为 <code>Cluster</code> 与 <code>Local</code> 的区别可以参考下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-c53452efec578e3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Understanding the two external traffic policies for NodePort and LoadBalancer services"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;不同于只运行某个提供特定服务的单一 Pod，现在人们通常会以副本的形式部署多个 Pod 实例，以便工作负载能够均匀地分发到不同的集群节点上。&lt;br&gt;这也意味着同一个 Pod 的所有副本都提供相同的服务，且能够通过一个单一的地址访问。Kubernetes 中的 Service
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Cloud" scheme="https://rollingstarky.github.io/tags/Cloud/"/>
    
      <category term="LoadBalancer" scheme="https://rollingstarky.github.io/tags/LoadBalancer/"/>
    
  </entry>
  
  <entry>
    <title>Python 3.10 新特性 —— 结构化模式匹配（Structural Pattern Match）详解</title>
    <link href="https://rollingstarky.github.io/2022/04/02/python-3-10-new-features-structural-pattern-match/"/>
    <id>https://rollingstarky.github.io/2022/04/02/python-3-10-new-features-structural-pattern-match/</id>
    <published>2022-04-01T16:00:00.000Z</published>
    <updated>2022-04-02T12:43:43.240Z</updated>
    
    <content type="html"><![CDATA[<h4 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h4><p>众所周知，Python 中是没有类似 <code>switch-case</code> 结构的语法的。但是自从 3.10 版本发布以后，这种说法就已经成为历史了。</p><p>Java 中的 <code>switch</code> 语句类似如下形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">                var option = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">switch</span> (option) &#123;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 1."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 2."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                                System.out.println(<span class="string">"You have chosen option 3."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                        <span class="keyword">default</span>:</span><br><span class="line">                                System.out.println(<span class="string">"Sorry you chose an invalid option."</span>);</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>看起来就像是另一种形式的 <code>if-else</code> 语句。以某个变量值作为判断条件，根据不同的判断结果执行对应的语句，最终形成一种流程上的分支结构。<br>这也许是 Python 不去实现它的依据（借口）之一？都已经有了 <code>if-else</code> 可以足够轻松地完成同样的事情。</p><blockquote><p>There should be one– and preferably only one –obvious way to do it.</p></blockquote><h5 id="字典映射"><a href="#字典映射" class="headerlink" title="字典映射"></a>字典映射</h5><p>在模式匹配出现之前，对于分支相当多的判断语句，Python 建议通过<strong>字典映射</strong>（dictionary mapping）来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_map</span><span class="params">(option)</span>:</span></span><br><span class="line">     <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="number">1</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 1.'</span>),</span><br><span class="line">            <span class="number">2</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 2.'</span>),</span><br><span class="line">            <span class="number">3</span>: <span class="keyword">lambda</span> : print(<span class="string">'You have chose option 3.'</span>)</span><br><span class="line">            &#125;.get(option, <span class="keyword">lambda</span>: print(<span class="string">'Sorry you chose an invalid option.'</span>))</span><br><span class="line"></span><br><span class="line">function_map(<span class="number">3</span>)()</span><br></pre></td></tr></table></figure></p><p>借助字典这种数据结构，以匹配条件作为键值，一一对应匹配后需要执行的命令。将 <code>switch</code> 结构中的条件判断转化为对字典键值的搜索匹配。</p><h4 id="Pattern-Match"><a href="#Pattern-Match" class="headerlink" title="Pattern Match"></a>Pattern Match</h4><p>用模式匹配实现 <code>switch-case</code> 语法，从形式上看就直观了很多：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">option = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">match option:</span><br><span class="line">    case <span class="number">1</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 1."</span>)</span><br><span class="line">    case <span class="number">2</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 2."</span>)</span><br><span class="line">    case <span class="number">3</span>:</span><br><span class="line">        print(<span class="string">"You have chosen option 3."</span>)</span><br><span class="line">    case _:</span><br><span class="line">        print(<span class="string">"You chose an invalid option."</span>)</span><br></pre></td></tr></table></figure></p><p>实际上模式匹配不只有创建流程上的分支结构这一种功能，它的作用可以比单纯的 <code>switch-case</code> 语法强大的多。</p><p>模式匹配可以算是一种历史悠久的编程技巧了，经常可以在函数式编程语言中见到。比较有代表性的语言比如 Haskell。相对年轻的语言比如 Rust 也引入了功能强大的模式匹配语法。<br>模式匹配其实可以拆成两部分来理解：匹配和模式。<br>匹配部分可以发挥类似于 <code>if-else</code> 和 <code>switch</code> 等条件判断语句的作用，生成一种分支结构；模式则定义了特定的规则即匹配的具体条件。更进一步的，还会对匹配到的对象进行<strong>解构</strong>（destructuring）或者说<strong>拆包</strong>（unpacking）。</p><p>以不同于模式匹配的正则表达式来说：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">source_str = <span class="string">'cats are cute'</span></span><br><span class="line">pattern = re.compile(<span class="string">'(.*) are (.*)'</span>)</span><br><span class="line"></span><br><span class="line">matched = re.match(pattern, source_str)</span><br><span class="line">print(matched.groups())</span><br><span class="line"><span class="comment"># =&gt; ('cats', 'cute')</span></span><br></pre></td></tr></table></figure></p><p>正则表达式规则中的 <code>(.*)</code> 分别匹配到源字符串中的 <code>cats</code> 和 <code>cute</code>，与此同时，还把这两个匹配项提取了出来。</p><p>而模式匹配相对来说，则不仅仅能够匹配和提取 <code>cats</code>、<code>cute</code> 等字符串类型，还能够匹配更复杂类型的对象，同时对匹配到的对象进行拆包操作。</p><p>比如下面的代码就对类型为元组的对象进行了匹配和拆包：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">match_person</span><span class="params">(person)</span>:</span></span><br><span class="line">    match person:</span><br><span class="line">        case (name, <span class="string">'M'</span>, age):</span><br><span class="line">            print(<span class="string">f'He is <span class="subst">&#123;name&#125;</span>, aged <span class="subst">&#123;age&#125;</span>.'</span>)</span><br><span class="line">        case (name, <span class="string">'F'</span>, age):</span><br><span class="line">            print(<span class="string">f'She is <span class="subst">&#123;name&#125;</span>, aged <span class="subst">&#123;age&#125;</span>.'</span>)</span><br><span class="line">        case (name,):</span><br><span class="line">            print(<span class="string">f'We only know the name is <span class="subst">&#123;name&#125;</span>, others are secrets.'</span>)</span><br><span class="line"></span><br><span class="line">person_A = (<span class="string">'John'</span>, <span class="string">'M'</span>, <span class="number">20</span>)</span><br><span class="line">person_B = (<span class="string">'Jenny'</span>, <span class="string">'F'</span>, <span class="number">18</span>)</span><br><span class="line">person_C = (<span class="string">'Lily'</span>,)</span><br><span class="line"></span><br><span class="line">match_person(person_A)</span><br><span class="line"><span class="comment"># =&gt; He is John, aged 20.</span></span><br><span class="line">match_person(person_B)</span><br><span class="line"><span class="comment"># =&gt; She is Jenny, aged 18.</span></span><br><span class="line">match_person(person_C)</span><br><span class="line"><span class="comment"># =&gt; We only know the name is Lily, others are secrets.</span></span><br></pre></td></tr></table></figure></p><p><code>match</code> 关键字后面被匹配的对象，支持很多种复杂的类型。对应的 <code>case</code> 关键字后面的模式也同样灵活：</p><ul><li>列表或元组，如 <code>(name, 18)</code></li><li>字典，如 <code>{&quot;name&quot;: name, &quot;age&quot;: 18}</code></li><li>使用 <code>*</code> 匹配列表中的剩余部分，如 <code>[first, *rest]</code></li><li>使用 <code>**</code> 匹配字典中的剩余部分</li><li>匹配对象和对象的属性</li><li>在模式中可以使用 <code>|</code> 逻辑或操作</li></ul><h4 id="模式匹配应用实例"><a href="#模式匹配应用实例" class="headerlink" title="模式匹配应用实例"></a>模式匹配应用实例</h4><p>创建一个 Python 程序，模拟交互式命令行的行为。</p><h5 id="匹配字符串"><a href="#匹配字符串" class="headerlink" title="匹配字符串"></a>匹配字符串</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    match command:</span><br><span class="line">        case <span class="string">"quit"</span>:</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case <span class="string">"reset"</span>:</span><br><span class="line">            print(<span class="string">"Resetting the system."</span>)</span><br><span class="line">        case other:</span><br><span class="line">            print(<span class="string">f"Unknown command: <span class="subst">&#123;other!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command = input(<span class="string">"$ "</span>)</span><br><span class="line">        run_command(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果如下：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ reset</span><br><span class="line">Resetting the system.</span><br><span class="line">$ abcdefg</span><br><span class="line">Unknown command: 'abcdefg'.</span><br><span class="line">$ quit</span><br><span class="line">Quitting the program.</span><br></pre></td></tr></table></figure></p><h5 id="匹配列表"><a href="#匹配列表" class="headerlink" title="匹配列表"></a>匹配列表</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: str)</span>:</span></span><br><span class="line">    match command.split():</span><br><span class="line">        case [<span class="string">"load"</span>, filename]:</span><br><span class="line">            print(<span class="string">f"Loading file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case [<span class="string">"save"</span>, filename]:</span><br><span class="line">            print(<span class="string">f"Saving to file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case [<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>]:</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case _:</span><br><span class="line">            print(<span class="string">f"Unkown command: <span class="subst">&#123;command!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command = input(<span class="string">"$ "</span>)</span><br><span class="line">        run_command(command)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ load input_data.txt</span><br><span class="line">Loading file: input_data.txt.</span><br><span class="line">$ save output_data.txt</span><br><span class="line">Saving to file: output_data.txt.</span><br><span class="line">$ load input_data.txt output_data.txt</span><br><span class="line">Unkown command: 'load input_data.txt output_data.txt'.</span><br><span class="line">$ bye</span><br><span class="line">Quitting the program.</span><br></pre></td></tr></table></figure></p><h5 id="匹配对象"><a href="#匹配对象" class="headerlink" title="匹配对象"></a>匹配对象</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">import</span> shlex</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Command</span>:</span></span><br><span class="line">    command: str</span><br><span class="line">    arguments: List[str]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_command</span><span class="params">(command: Command)</span>:</span></span><br><span class="line">    match command:</span><br><span class="line">        case Command(command=<span class="string">"load"</span>, arguments=[filename]):</span><br><span class="line">            print(<span class="string">f"Loading file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case Command(command=<span class="string">"save"</span>, arguments=[filename]):</span><br><span class="line">            print(<span class="string">f"Saving to file: <span class="subst">&#123;filename&#125;</span>."</span>)</span><br><span class="line">        case Command(command=<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>, arguments=[<span class="string">"--force"</span> | <span class="string">"-f"</span>]):</span><br><span class="line">            print(<span class="string">"Sending SIGTERM and quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case Command(command=<span class="string">"quit"</span> | <span class="string">"exit"</span> | <span class="string">"bye"</span>):</span><br><span class="line">            print(<span class="string">"Quitting the program."</span>)</span><br><span class="line">            quit()</span><br><span class="line">        case _:</span><br><span class="line">            print(<span class="string">f"Unknown command: <span class="subst">&#123;command!r&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        command, *arguments = shlex.split(input(<span class="string">"$ "</span>))</span><br><span class="line">        run_command(Command(command, arguments))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">not</span> a command</span><br><span class="line">Unknown command: Command(command='<span class="keyword">not</span>', arguments=['a', 'command']).</span><br><span class="line">$ load input_data.txt</span><br><span class="line">Loading file: input_data.txt.</span><br><span class="line">$ save output_data.txt</span><br><span class="line">Saving to file: output_data.txt.</span><br><span class="line">$ <span class="keyword">exit</span> -f</span><br><span class="line">Sending SIGTERM and quitting the program.</span><br></pre></td></tr></table></figure></p><p>需要注意的是，模式匹配中各条 <code>case</code> 语句之间的前后顺序是至关重要的。<strong>通常来说，更“具体”更“精确”一些的规则要放在相对靠前的位置。</strong><br>假如 <code>case Command(command=&quot;quit&quot; | &quot;exit&quot; | &quot;bye&quot;)</code> 为规则 1，<code>Command(command=&quot;quit&quot; | &quot;exit&quot; | &quot;bye&quot;, arguments=[&quot;--force&quot; | &quot;-f&quot;])</code> 为规则 2。<br>则更具体一些的规则 2 要放在规则 1 前面。因为模式匹配是<strong>从上到下依次</strong>检查每一个 case 语句，若遇到匹配的模式，则执行对应的命令。不再继续向下匹配。<br>由于严格符合规则 2 的对象一定也符合规则 1，当规则 1 位于规则 2 前面时，规则 2 永远也没有被匹配的机会。</p><p>可以想象成一种逐渐“滑落”的过程。比如写一个计算成绩等级的函数，可以这样实现：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grade</span><span class="params">(score)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> score &gt;= <span class="number">90</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'A'</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt;= <span class="number">70</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'B'</span></span><br><span class="line">    <span class="keyword">elif</span> score &gt;= <span class="number">60</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'C'</span></span><br></pre></td></tr></table></figure></p><p>如果上面 <code>if-else</code> 的条件反着排，那就，所有人都是 C 了。。。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=scNNi4860kk" target="_blank" rel="noopener">A Closer Look At Structural Pattern Matching // New In Python 3.10!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;switch-case&quot;&gt;&lt;a href=&quot;#switch-case&quot; class=&quot;headerlink&quot; title=&quot;switch-case&quot;&gt;&lt;/a&gt;switch-case&lt;/h4&gt;&lt;p&gt;众所周知，Python 中是没有类似 &lt;code&gt;switch-ca
      
    
    </summary>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Switch" scheme="https://rollingstarky.github.io/tags/Switch/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 使用 ConfigMaps、Secrets 和 Downward API 配置应用</title>
    <link href="https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/"/>
    <id>https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/</id>
    <published>2022-01-14T16:00:00.000Z</published>
    <updated>2022-01-15T11:49:22.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置命令、参数和环境变量"><a href="#设置命令、参数和环境变量" class="headerlink" title="设置命令、参数和环境变量"></a>设置命令、参数和环境变量</h4><p>同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、文件等完成配置。<br>比如容器启动时执行的命令可以由 Dockerfile 中的 <code>ENTRYPOINT</code> 选项指定；命令参数通常由 <code>CMD</code> 选项指定；环境变量则可以使用 <code>ENV</code> 选项指定；假如应用通过文件进行配置，则这些配置文件可以借助 <code>COPY</code> 选项复制到容器镜像中。</p><p>下面是一个名为 <code>kiada</code> 的示例应用。<br><code>Dockerfile</code> 配置文件：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js /app.js</span></span><br><span class="line"><span class="bash">COPY html /html</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENV INITIAL_STATUS_MESSAGE=<span class="string">"This is the default status message"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--listen-port"</span>, <span class="string">"8080"</span>]</span></span><br></pre></td></tr></table></figure></p><p>其他文件如 <code>html</code>、<code>app.js</code> 可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09/kiada-0.4" target="_blank" rel="noopener">Github</a> 处获取。同时构建好的镜像也被作者放到了 Dockerhub 的 <code>luksa/kiada:0.4</code> 位置。</p><p>借助上述 Dockerfile，应用的监听端口可以通过 <code>--listen-port</code> 命令参数配置；同时应用会读取环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来获取初始状态信息。</p><p>将配置硬编码进容器的镜像，事实上和将配置硬编码到应用的源代码中一样，都不是理想的情况。因为每当应用需要修改配置，都必须再重新 build 一遍镜像。此外，还必须避免在镜像中包含敏感的配置信息，比如认证数据或密钥等。<br>将上述配置文件放置在 Volume 中并挂载到容器上，相对而言更安全一点。</p><h5 id="配置命令和参数"><a href="#配置命令和参数" class="headerlink" title="配置命令和参数"></a>配置命令和参数</h5><p>在创建镜像时，容器启动时执行的命令和参数分别由 Dockerfile 中的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 选项指定。<br>Kubernetes 提供了两个同样功能的字段：<code>commands</code> 和 <code>args</code>。假如在 Pod 的清单文件中指定了 <code>commands</code> 和 <code>args</code>，或者其中任何一个字段，则 Dockerfile 中对应的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 配置会被覆盖。</p><p><strong>设置命令</strong><br>假如需要在运行 Kiada 应用时启用 CPU 和 heap 优化，对于 Node.js 而言，可以在执行时传入 <code>--cpu-prof</code> 和 <code>--heap-prof</code> 参数。<br>相对于修改 Dockerfile 重新 build 镜像，其实可以直接修改 Pod 的清单文件。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--cpu-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--heap-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">app.js</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><strong>设置命令参数</strong><br>比如需要将 Dockerfile 中的命令参数 <code>--listen-port 8080</code> 改为 <code>--listen-port 9090</code>，可以使用如下配置的 Pod 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>容器在创建时会自动组合 Dockerfile 中的 <code>ENTRYPOINT</code> 和 Pod 清单文件中的 <code>args</code>。</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p><strong>为环境变量设置字面量值</strong><br>Kiada 应用在运行时会显示 Pod 的名字，该名称由应用源代码从环境变量 <code>POD_NAME</code> 读取。此外还可以通过修改环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来更改状态信息。</p><p>为了修改上述环境变量，可以向 Dockerfile 中添加 <code>ENV</code> 选项并重新构建镜像，但更快速的方式时向 Pod 的清单文件中添加 <code>env</code> 选项。<br>示例清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">pod</span> <span class="string">spec.</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用上述 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada-env.yml</span></span><br><span class="line">pod/kiada unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">POD_NAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the pod spec.</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">NODE_VERSION=16.11.1</span><br><span class="line">YARN_VERSION=1.22.15</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure></p><p><strong>使用变量引用</strong><br>除了给环境变量设置一个固定值外，还可以采用 <code>$(VAR_NAME)</code> 格式引用其他变量。如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">My</span> <span class="string">name</span> <span class="string">is</span> <span class="string">$(POD_NAME).</span> <span class="string">I</span> <span class="string">run</span> <span class="string">NodeJS</span> <span class="string">version</span> <span class="string">$(NODE_VERSION).</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>引用的变量中，<code>POD_NAME</code> 是在同一个 Pod 清单文件中定义的，<code>NODE_VERSION</code> 是在容器镜像中定义的。<br>最终的状态信息会显示为 <code>My name is kiada. I run NodeJS version $(NODE_VERSION).</code>，因为此方式只支持引用同一个 Pod 清单文件中定义的变量，且该变量必须在引用位置之前定义。</p><p><strong>在命令和参数中使用变量引用</strong><br>还可以在命令和参数中引用清单文件中定义的变量。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$(LISTEN_PORT)</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">LISTEN_PORT</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure></p><h4 id="使用-config-map-将配置与-Pod-解耦"><a href="#使用-config-map-将配置与-Pod-解耦" class="headerlink" title="使用 config map 将配置与 Pod 解耦"></a>使用 config map 将配置与 Pod 解耦</h4><p>在前面的章节中，可以将应用的配置硬编码进 Pod 的 yaml 清单文件中。这种方式比将配置硬编码到容器镜像中要好很多，即不需要每次修改配置后都必须重新构建镜像。<br>但这种方式也有一定的缺陷，它意味着比如针对不同环境的部署（development、staging、production 等），可能需要多个不同版本的清单文件。<br>为了在多个环境下重复利用同一个清单文件，最好是将配置与 Pod 的清单文件解耦。</p><h5 id="ConfigMaps-介绍"><a href="#ConfigMaps-介绍" class="headerlink" title="ConfigMaps 介绍"></a>ConfigMaps 介绍</h5><p>ConfigMap 是一种包含一系列键值对的 Kubernetes API 对象。其中的值可以是短字符串，也可以是一大段结构化的文本。Pod 可以引用一个或多个 ConfigMap 中的值。<br>一个 Pod 可以引用多个 ConfigMaps，多个 Pods 可以使用同一个 ConfigMap。</p><p>如下图所示，ConfigMap 中的键值对通常作为环境变量传递给 Pod，或者通过 ConfigMap Volume 作为文件挂载到容器的文件系统中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-9c8df1bf7a6cd5ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods use config maps through environment variables andconfigMap volumes"></p><p>将配置保存在一个独立的 ConfigMap 对象中，而不是直接保存在 Pod 里。这使得在不同的环境中能够部署同一个 Pod 清单文件，与此同时应用不同的配置（引用不同的 ConfigMap 对象）。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-674fcbf8eedefb8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying the same pod manifest and different configmap manifests in different environments"></p><h5 id="创建-ConfigMap-对象"><a href="#创建-ConfigMap-对象" class="headerlink" title="创建 ConfigMap 对象"></a>创建 ConfigMap 对象</h5><p><strong>从 YAML 文件创建 ConfigMap</strong><br><code>cm.kiada-config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  status-message:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>kubectl apply -f cm.kiada-config.yml</code> 命令创建清单文件中定义的 ConfigMap 对象。</p><p><strong>查看 ConfigMap</strong><br>可以使用 <code>kubectl get cm</code> 命令列出 ConfigMap 对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">kiada-config       1      6s</span><br><span class="line">kube-root-ca.crt   1      55d</span><br></pre></td></tr></table></figure></p><p>可以使用如下命令查看 ConfigMap 的详细信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  status-message: This status message is set in the kiada-config config map</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;"apiVersion":"v1","data":&#123;"status-message":"This status message is set in the kiada-config config map"&#125;,"kind":"ConfigMap","metadata":&#123;"annotations":&#123;&#125;,"name":"kiada-config","namespace":"default"&#125;&#125;</span><br><span class="line">  creationTimestamp: "2022-01-10T05:11:35Z"</span><br><span class="line">  name: kiada-config</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: "99447"</span><br><span class="line">  uid: e39e2676-2183-4582-9922-eac963b81093</span><br></pre></td></tr></table></figure></p><p>若只想精确地查找 ConfigMap 中的配置项，可以使用如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq .data</span></span><br><span class="line">&#123;</span><br><span class="line">  "status-message": "This status message is set in the kiada-config config map"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq <span class="string">'.data["status-message"]'</span></span></span><br><span class="line">"This status message is set in the kiada-config config map"</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的值注入到环境变量"><a href="#将-ConfigMap-中的值注入到环境变量" class="headerlink" title="将 ConfigMap 中的值注入到环境变量"></a>将 ConfigMap 中的值注入到环境变量</h5><p><code>pod.kiada.env-valueFrom.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          configMapKeyRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">            key:</span> <span class="string">status-message</span></span><br><span class="line"><span class="attr">            optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看环境变量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.env-valueFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>注入整个 ConfigMap</strong><br>容器定义中的 <code>env</code> 字段接收的是由值组成的列表，因此可以同时设置多个环境变量。实际上可以使用 <code>envFrom</code> 注入整个 ConfigMap 中定义的多个值，而无需像 <code>valueFrom</code> 那样分别指定每一个键。<br>唯一需要注意的是，ConfigMap 中的键必须与实际的环境变量名称保持一致。即之前使用的键 <code>status-message</code> 必须改成 <code>INITIAL_STATUS_MESSAGE</code>。</p><p><code>cm.kiada-config.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  INITIAL_STATUS_MESSAGE:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl replace</code> 命令更新 ConfigMap：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">replace</span> <span class="bullet">-f</span> <span class="string">cm.kiada-config.yml</span></span><br><span class="line"><span class="string">configmap/kiada-config</span> <span class="string">replaced</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 清单文件 <code>pod.kiada.envFrom.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    envFrom:</span></span><br><span class="line"><span class="attr">    - configMapRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">        optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f pod.kiada.env-valueFrom.yml</span><br><span class="line">pod "kiada" deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.envFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的配置项作为文件嵌入到容器"><a href="#将-ConfigMap-中的配置项作为文件嵌入到容器" class="headerlink" title="将 ConfigMap 中的配置项作为文件嵌入到容器"></a>将 ConfigMap 中的配置项作为文件嵌入到容器</h5><p>环境变量通常用于向应用传递较小的单行的值，而多行的数据通常作为文件传递。<br>ConfigMap 中的配置项可以包含大块的数据，通过特殊的 ConfigMap volume 类型将这些数据以文件的形式注入到容器中。</p><p><strong>从文件创建 ConfigMaps</strong><br>除了直接在集群中创建 ConfigMap 对象之外，还可以先创建一个用于描述 ConfigMap 的 YAML 清单文件，从而可以将其保存到版本控制系统中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create configmap kiada-envoy-config \</span></span><br><span class="line">--from-file=envoy.yaml \</span><br><span class="line">--from-file=dummy.bin \</span><br><span class="line">--dry-run=client -o yaml &gt; cm.kiada-envoy-config.yml</span><br></pre></td></tr></table></figure></p><p>其中 dummy.bin 和 <code>envoy.yaml</code> 两个文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 <code>kiada-envoy-config</code> 的 ConfigMap 的 YAML 描述文件。当命令中使用了 <code>--dry-run</code> 选项时，该命令并不会在 API server 创建新对象，而是只生成对象的定义。后续可继续运行 <code>kubectl apply -f xxx.yml</code> 命令创建对象。</p><p>生成的 <code>cm.kiada-envoy-config.yml</code> 文件的具体内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">binaryData:</span></span><br><span class="line">  <span class="string">dummy.bin:</span> <span class="string">n2VW39IEkyQ6Jxo+rdo5J06Vi7cz5XxZzkPOtN7MOGyXxVzWv07vUz8bxY5h4njJfZixwhPwoGepLnGZdRGw1qgpFB9HpyLsqVZ6jAwjjHD0afxxwEjb6+wofmgGmS1E3U9BZScMPZGWJK7RGzZmQOeJeDPIt/1tBvQYwzMc8wu6owky4Ri3rOY9PlFnp5VOTzvBZadW8scbqtntJeWCtJFoS0AH2y4ZFyJPJ0l0V3JpY1qunnz60CyAMO9v1DgB2PUQUG/1HH89bpzf2OyMvHUJmOTIDZOh3D7aAEuYQ/6hU0uQsQ/K7Xx/nM9TA0RzEzuh8RBoXdkAvQPP5jk7yM2DqxG/CiHVp+7CDRFWgEN2GFd76RfO+pIoOFbD1Xm4yE/JBljOA9ztwm865m3A4l2ToT2p7ZWHKmdZe8pXz4ZwIGBYDUHHNVQW5UUnf0Jbd9UR8GJ//gmbxLfVxjC/lMSWGUqCpYO4YdBPjXQGM1xdxE+YP3Pzso6Z4rw27RJu5KEc2yPMxFY9dpFyVufP81kS19glNiQq+LM4B9EFPrNW1hqi+1Tb8ni+aFkriH1YuvHepIH0Px/ifFLgn+yDgwDs4UfMru2j4t5zAftUa0i6m3sH5adKcx4aCXYN9ijvEvjRmkcB/VJU6Zbd65UZVgD1Nwt2ZCrkoEdqO3Oe1/o=</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">envoy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string"></span><span class="attr">    admin:</span></span><br><span class="line"><span class="attr">      access_log_path:</span> <span class="string">/tmp/envoy.admin.log</span></span><br><span class="line"><span class="attr">      address:</span></span><br><span class="line"><span class="attr">        socket_address:</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">          port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-envoy-config</span></span><br></pre></td></tr></table></figure></p><p><strong>在 Pod 中使用 ConfigMap</strong><br>为了令 ConfigMap 能够作为文件呈现在容器的文件系统中，需要在 Pod 中定义一个 ConfigMap Volume 并将其挂载到容器里。<br>参考下面的 <code>pod.kiada-ssl.configmap-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada-ssl-proxy:0.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>创建 <code>kiada-envoy-config</code> ConfigMap：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f cm.kiada-envoy-config.yml</span></span><br><span class="line">configmap/kiada-envoy-config created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME                 DATA   AGE</span><br><span class="line">kiada-config         1      46h</span><br><span class="line">kiada-envoy-config   2      13s</span><br><span class="line">kube-root-ca.crt     1      57d</span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看文件挂载情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada-ssl.configmap-volume.yml</span></span><br><span class="line">pod/kiada-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls /etc/envoy</span></span><br><span class="line">dummy.bin</span><br><span class="line">envoy.yaml</span><br></pre></td></tr></table></figure></p><h5 id="理解-ConfigMap-Volume-是如何工作的"><a href="#理解-ConfigMap-Volume-是如何工作的" class="headerlink" title="理解 ConfigMap Volume 是如何工作的"></a>理解 ConfigMap Volume 是如何工作的</h5><p><strong>挂载 Volume 会隐藏文件系统中本来就存在的文件</strong><br>当挂载任意 volume 到容器的文件系统中时，挂载的路径下原本存在的文件就无法被访问。比如把某个 ConfigMap volume 挂载到容器的 <code>/etc</code> 路径下，则本来位于 <code>/etc</code> 下面的配置文件都会被隐藏掉。<br>如果你还是想将 ConfigMap volume 挂载到 <code>/etc</code> 目录，又不影响原来存在的文件，可以结合使用 <code>mountPath</code> 和 <code>subPath</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">my-container</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my-volume</span></span><br><span class="line"><span class="attr">      subPath:</span> <span class="string">my-app.conf</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/my-app.conf</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-c49e7b4386aac0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using subPath to mount a single file from the volume"></p><p><strong>ConfigMap volumes 使用符号链接来实现原子化更新</strong><br>有些应用会监控其配置文件的变化来决定是否重新加载配置。但是，假如应用的配置文件很大或者涉及到很多文件，应用可能会在所有更新全部完成之前检查到变化并加载更新。若应用最终读取了未全部更新的文件，可能导致出现不正常的行为。<br>为了防止上述情况发生，Kubernetes 会确保 ConfigMap volume 中所有文件的更新操作是<strong>原子</strong>的，即所有更新都会立即完成。<br>上述机制是通过文件的符号链接实现的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls -lA /etc/envoy</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan 12 03:33 ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   31 Jan 12 03:33 ..data -&gt; ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   16 Jan 12 03:33 dummy.bin -&gt; ..data/dummy.bin</span><br><span class="line">lrwxrwxrwx 1 root root   17 Jan 12 03:33 envoy.yaml -&gt; ..data/envoy.yaml</span><br></pre></td></tr></table></figure></p><p>每次用户修改 ConfigMap，Kubernetes 都会新建一个以当前时间戳命名的目录，将新的配置文件放到该目录中。再修改符号链接的指向，立即同时替换所有文件。</p><h5 id="更新和删除-ConfigMaps"><a href="#更新和删除-ConfigMaps" class="headerlink" title="更新和删除 ConfigMaps"></a>更新和删除 ConfigMaps</h5><p>和大多数 Kubernetes API 对象一样，ConfigMaps 也支持手动修改其清单文件，再使用 <code>kubectl apply</code> 命令将最新版本重新应用到集群环境。<br>此外还可以使用下面这种更快捷的方式。</p><p><strong>使用 kubectl edit 就地修改 API 对象</strong><br><code>kubectl edit cm kiada-config</code><br><img src="https://upload-images.jianshu.io/upload_images/6875152-1f41ca72be09f6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl edit"></p><p>上面的命令会使用系统默认的编辑器（比如 <code>Vim</code>）打开 ConfigMap <code>kiada-config</code> 的清单文件，允许用户直接修改该 ConfigMap 对象。当关闭编辑器时，最新的改动会自动应用到 Kubernetes API server。</p><p><strong>修改 ConfigMap 的影响</strong><br>当更新某个 ConfigMap 后，若 ConfigMap 是以存储卷的形式作为配置文件挂载到容器中，则其中的文件会自动进行更新。<br>但是不同于文件，环境变量在容器运行时不会自动进行更新。然而当容器因为某些特殊原因重启后，Kubernetes 会使用最新版本的 ConfigMap 值来初始化新容器的环境变量。</p><p>容器最重要的属性之一就是其<strong>不变性</strong>，即用户可以肯定同一个容器的多个实例一定是相同的。<br>假如应用通过 ConfigMap 以环境变量的方式注入配置，当 ConfigMap 修改后，实际上并不会影响正在运行的应用实例。但是当应用的某一部分实例因为故障重新启动，或者需要添加新的实例副本，就会导致只有这一部分实例在使用最新的配置。<br>类似的场景甚至发生在应用自动重新加载其配置文件的时候。Kubernetes 对于 ConfigMap volumes 采用异步的更新方式，这导致某些实例可能会比其他实例更早地看到配置的变化。上述更新操作有可能会持续几十秒的时间，则在这部分时间内，各应用实例上的配置文件之间实际上是不同步的。<br>从而也会导致应用的各个容器实例之间正使用着不同的配置。</p><p><strong>阻止 ConfigMap 被修改</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-immutable-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  mykey:</span> <span class="string">myvalue</span></span><br><span class="line"><span class="attr">  another-key:</span> <span class="string">another-value</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>不可变 ConfigMap 可以阻止用户意外地修改应用配置，同时也会提高 Kubernetes 集群的性能。因为工作节点上的 Kubelets 无需再接收 ConfigMap 对象变化的通知。<br>假如需要添加一系列使用不同配置的 Pods，就创建一个新的 ConfigMap。</p><p><strong>删除 ConfigMap</strong><br>ConfigMap 对象可以使用 <code>kubectl delete</code> 命令删除。删除某个 ConfigMap 后，引用它的正在运行的应用不会受到任何影响，直到容器重新启动。<br>若 ConfigMap 没有被标记成可选的，则容器会在重启时失败。</p><h4 id="使用-Secrets-向容器嵌入敏感信息"><a href="#使用-Secrets-向容器嵌入敏感信息" class="headerlink" title="使用 Secrets 向容器嵌入敏感信息"></a>使用 Secrets 向容器嵌入敏感信息</h4><h5 id="Secrets-介绍"><a href="#Secrets-介绍" class="headerlink" title="Secrets 介绍"></a>Secrets 介绍</h5><p>Secrets 和 ConfigMaps 非常相似。它们也是包含一系列键值对且能够作为环境变量或文件注入到容器中。<br>事实上 Secrets 比 ConfigMap 更早出现。但是 Secrets 在存储普通的明文文本时友好性较差，因而引入了 ConfigMaps。<br>对于 Secrets 对象，Kubernetes 在处理它们时会特别注意安全性。比如 Kubernetes 会确保 Secret 中的数据在分发时只传给有需要的节点；工作节点上的 Secrets 只保存在内存中，从来不会写入到物理存储。<br>因此，必须将敏感数据保存到 Secrets 而不是 ConfigMaps 中。</p><h5 id="创建-Secret"><a href="#创建-Secret" class="headerlink" title="创建 Secret"></a>创建 Secret</h5><p><strong>创建一个 TLS secret</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret tls kiada-tls --cert example-com.crt --key example-com.key</span></span><br><span class="line">secret/kiada-tls created</span><br></pre></td></tr></table></figure></p><p>其中 crt 文件和 key 文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter05/kiada-ssl-proxy-0.1" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 kiada-tls 的 Secret。</p><p><strong>从 YAML 清单文件创建 Secrets</strong><br>显而易见，从 YAML 文件创建 Secrets 并不是一个好主意。<br>假如你只是需要在本地创建一个 YAML 清单文件而不是直接通过 API server 创建 Secret 对象，可以使用 <code>kubectl create</code> 加上 <code>--dry-run=client -o yaml</code> 选项。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret generic my-credentials \</span></span><br><span class="line">--from-literal user=my-username \</span><br><span class="line">--from-literal pass=my-password \</span><br><span class="line">--dry-run=client -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  pass: bXktcGFzc3dvcmQ=</span><br><span class="line">  user: bXktdXNlcm5hbWU=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: my-credentials</span><br></pre></td></tr></table></figure></p><p><strong>使用 <code>stringData</code> 字段</strong><br>因为并不是所有敏感数据都是二进制形式，Kubernetes 允许用户通过 <code>stringData</code> 字段指定 Secret 中的文本数据。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">my-username</span></span><br><span class="line"><span class="attr">  pass:</span> <span class="string">my-password</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-credentials</span></span><br></pre></td></tr></table></figure></p><h5 id="在容器中使用-Secrets"><a href="#在容器中使用-Secrets" class="headerlink" title="在容器中使用 Secrets"></a>在容器中使用 Secrets</h5><p><strong>借助 Secret Volume 注入 Secret 配置</strong><br>Secret volume 和前面提到的 ConfigMap volume 用法基本相同。参考如下 YAML 配置文件 <code>pod.kiada-ssl.secret-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">kiada-tls</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.crt</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.crt</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.key</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.key</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">envoyproxy/envoy:v1.14.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/certs</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3207fa46e0b47047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Secret Volume"></p><h4 id="通过-Downward-API-向应用传递-Pod-的元数据"><a href="#通过-Downward-API-向应用传递-Pod-的元数据" class="headerlink" title="通过 Downward API 向应用传递 Pod 的元数据"></a>通过 Downward API 向应用传递 Pod 的元数据</h4><p>前面介绍了如何向容器中的应用传递配置信息。但数据并不总是静态的，假如某些数据只有在 Pod 创建之后才能被知晓，比如 Pod 的 IP 地址、工作节点的名称、容器分配到的 CPU 和内存等。<br>这些需求可以通过 Downward API 实现。</p><h5 id="Downward-API-介绍"><a href="#Downward-API-介绍" class="headerlink" title="Downward API 介绍"></a>Downward API 介绍</h5><p>Downward API 并不是一个需要应用去访问的 REST 端点，它实际上是一种将 Pod 的 metadata、spec 和 status 字段注入到容器中的方式。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6c519adcce0bfaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The Downward API exposes pod metadata throughenvironment variables or files"></p><h5 id="Downward-API-支持哪些元数据"><a href="#Downward-API-支持哪些元数据" class="headerlink" title="Downward API 支持哪些元数据"></a>Downward API 支持哪些元数据</h5><p>用户并不能通过 Downward API 注入 Pod 对象中的所有字段。实际上只有一部分数据被支持，其列表如下。</p><p><strong>通过 <code>fieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.namespace</code></td><td>Pod 的命名空间</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.uid</code></td><td>Pod 的 UID</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.labels</code></td><td>Pod 的所有标签</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.labels[&#39;key&#39;]</code></td><td>某个标签的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.annotations</code></td><td>Pod 的所有注释</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.annotations[&#39;key&#39;]</code></td><td>某个注释的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>spec.nodeName</code></td><td>Pod 运行的工作节点的名称</td><td>Yes</td><td>No</td></tr><tr><td><code>spec.serviceAccountName</code></td><td>Pod 的服务账户</td><td>Yes</td><td>No</td></tr><tr><td><code>status.podIP</code></td><td>Pod 的 IP 地址</td><td>Yes</td><td>No</td></tr><tr><td><code>status.hostIP</code></td><td>工作节点的 IP 地址</td><td>Yes</td><td>No</td></tr></tbody></table><p><strong>通过 <code>resourceFieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Resource Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>requests.cpu</code></td><td>容器的 CPU 请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.memory</code></td><td>容器的内存请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.ephemeral-storage</code></td><td>容器的临时存储请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.cpu</code></td><td>容器的 CPU 限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.memory</code></td><td>容器的内存限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>容器的临时存储限制</td><td>Yes</td><td>Yes</td></tr></tbody></table><h5 id="将-Pod-的元数据注入到环境变量中"><a href="#将-Pod-的元数据注入到环境变量中" class="headerlink" title="将 Pod 的元数据注入到环境变量中"></a>将 Pod 的元数据注入到环境变量中</h5><p><strong>注入 Pod 对象中的字段</strong><br><code>kiada.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.hostIP</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 <code>kiada.yml</code> 清单文件并查看其日志输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs -f kiada</span></span><br><span class="line">Kiada - Kubernetes in Action Demo Application</span><br><span class="line">---------------------------------------------</span><br><span class="line">Kiada 0.4 starting...</span><br><span class="line">Pod name is kiada</span><br><span class="line">Local hostname is kiada</span><br><span class="line">Local IP is 172.17.0.6</span><br><span class="line">Running on node minikube</span><br><span class="line">Node IP is 192.168.49.2</span><br><span class="line">Status message is This is the default status message</span><br><span class="line">Listening on port 8080</span><br></pre></td></tr></table></figure></p><p><strong>注入容器的资源数据</strong><br>示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_CPU_CORES</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.cpu</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_MEMORY_KB</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.memory</span></span><br><span class="line"><span class="attr">        divisor:</span> <span class="number">1</span><span class="string">k</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;设置命令、参数和环境变量&quot;&gt;&lt;a href=&quot;#设置命令、参数和环境变量&quot; class=&quot;headerlink&quot; title=&quot;设置命令、参数和环境变量&quot;&gt;&lt;/a&gt;设置命令、参数和环境变量&lt;/h4&gt;&lt;p&gt;同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 向容器挂载存储卷</title>
    <link href="https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/"/>
    <id>https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/</id>
    <published>2022-01-05T16:00:00.000Z</published>
    <updated>2022-01-06T15:30:53.513Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Volumes-介绍"><a href="#Volumes-介绍" class="headerlink" title="Volumes 介绍"></a>Volumes 介绍</h4><p>Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运行着应用的各个进程。这些进程可以共享 CPU、RAM、网络接口等计算资源。<br>在普通的计算机中，应用的进程使用同一个文件系统。但是在 Pod 中，每个容器都有自己独有的、由容器镜像提供的隔离的文件系统。</p><p>容器构建时添加到镜像中的文件构成了容器的文件系统，容器启动后，运行在容器中的进程就可以修改这些文件或者添加新的文件。<br>但是当容器终止和重启时，所有对于文件系统的改动都不会被保留。事实上容器并不是真正意义上的重启，而是完全地被一个新容器<strong>替换</strong>掉了。这对于一些类型的应用是 OK 的，其他应用则需要在重启时至少保留一部分文件系统。<br>这可以通过挂载 Volume 来实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b6512cfe7b8b10cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mounting a filesystem into the file tree"></p><h5 id="Volumes-与-Pod"><a href="#Volumes-与-Pod" class="headerlink" title="Volumes 与 Pod"></a>Volumes 与 Pod</h5><p>Volumes 并不是 Pod 或 Node 那样的顶层资源，而是和容器一样是 Pod 中的一个组件，因而会使用 Pod 的生命周期。Volumes 与其挂载的容器的生命周期是毫无关联的，也因此能够用来在容器重启时保持数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a1dbdaf7fcc1a252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes are defined at the pod level and mounted in the pod’s containers"></p><p>Volumes 在 Pod 中定义，挂载到 Pod 下的容器中。</p><p><strong>在容器重启时保持数据</strong><br>Pod 中的所有 Volumes 都会在容器启动前创建，在 Pod 关闭时销毁。<br>应用可以向挂载到容器文件系统中的 Volume 写入数据。当容器重启时，其被替换为一个新容器，文件系统也重新从镜像创建。此时则可以再次挂载同样的 Volume，完成对之前数据的访问。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-5b341a1a50a8938a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes ensure that part of the container’s filesystem is persisted across restarts"></p><p>通常由应用的作者决定哪些文件需要在容器重启时被保留，一般是一些代表应用状态的数据。但不包括应用的本地缓存数据，这些数据会阻止容器完成一次“全新”的重启。而全新的重启有利于应用的“自愈”。</p><p><strong>在一个容器中挂载多个 Volume</strong><br>一个 Pod 可以包含多个 Volumes，Pod 中的每个容器都可以挂载这些 Volumes 中的零个或多个。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f630769df6056546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A pod can contain multiple volumes and a container can mount multiple volumes"></p><p><strong>在多个容器间共享文件</strong><br>一个 Volume 可以被同时挂载到多个容器中，从而这些容器中的应用可以共享文件。<br>比如可以创建一个 Pod，包含一个 Web Server 容器和一个 content-producing agent 容器。Agent 容器负责生成静态媒体内容保存至 Volume，Web 容器则将 Volume 中的内容发布给客户端。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-8bafa09cc1369c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A volume can be mounted into more than one container"></p><p><strong>在 Pod 重启时保持数据</strong><br>Volume 与 Pod 的生命周期绑定，只会在 Pod 存在时存在。但是依靠某些特殊的 Volume 类型，其中的文件也可以在 Pod 和 Volume 消失后继续存在，后续也能够挂载到一个新的 Volume 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-ea1ae1c57074b2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod volumes can also map to storage volumes that persist across pod restarts"></p><p>如上图所示，Pod 中的 Volume 可以映射到 Pod 外面的永久存储。代表 Volume 的文件目录并不是 Pod 内部的本地路径，而是挂载的一个脱离了 Pod 生命周期的 NAS。<br>假如 Pod 被删除并被一个新的 Pod 所替换，同一个 NAS 可以被关联到新的 Pod 实例中，从而前一个 Pod 保持的数据可以被新的 Pod 访问。</p><p><strong>在多个 Pod 间共享文件</strong><br>取决于 external storage volume 使用的具体技术，同一个外挂存储也能够同时被关联给多个 Pod，从而这些 Pod 之间能够共享数据。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-db595737626572c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using volumes to share data between pods"></p><h5 id="Volume-类型"><a href="#Volume-类型" class="headerlink" title="Volume 类型"></a>Volume 类型</h5><p>当向某个 Pod 添加 Volume 时，必须指定 Volume 类型。主要的几种 Volume 类型如下：</p><ul><li><code>emptyDir</code>：一个简单的空目录，允许 Pod 在其生命周期内向该路径下存储数据</li><li><code>hostPath</code>：从工作节点的文件系统向 Pod 挂载文件</li><li><code>nfs</code>：挂载到 Pod 中的 NFS 共享</li><li><code>gcePersistentDisk</code> (Google Compute Engine Persistent Disk), <code>awsElasticBlockStore</code> (Amazon Web Services Elastic Block Store), <code>azureFile</code> (Microsoft Azure File Service), <code>azureDisk</code> (Microsoft Azure Data Disk)</li><li><code>cephfs</code>, <code>cinder</code>, <code>fc</code>, <code>flexVolume</code>, <code>flocker</code>, <code>glusterfs</code>, <code>iscsi</code>, <code>portworxVolume</code>, <code>quobyte</code>, <code>rbd</code>, <code>scaleIO</code>, <code>storageos</code>, <code>photonPersistentDisk</code>, <code>vsphereVolume</code></li><li><code>configMap</code>, <code>secret</code>, <code>downwardAPI</code>, <code>projected</code>：特殊类型的 Volume，用来暴露 Pod 及其他 Kubernetes 对象的信息</li><li><code>csi</code>：一种可插拔的通过 <strong>Container Storage Interface</strong> 添加存储的方式。任何人都可以使用这种 Volume 类型来实现自己的存储驱动</li></ul><h4 id="使用-Volumes"><a href="#使用-Volumes" class="headerlink" title="使用 Volumes"></a>使用 Volumes</h4><h5 id="使用-emptyDir-在容器重启时保留文件"><a href="#使用-emptyDir-在容器重启时保留文件" class="headerlink" title="使用 emptyDir 在容器重启时保留文件"></a>使用 <code>emptyDir</code> 在容器重启时保留文件</h5><p><code>emptyDir</code> 是最简单的 Volume 类型。它最开始以空目录的形式挂载到容器的文件系统，任何写入到该路径下的文件都会在 Pod 的整个生命周期中存在。<br>这类 Volume 通常用于在容器重启后保留部分数据；或者当整个容器的文件系统都是只读时，令其部分文件系统可写；又或者在包含两个或以上容器的 Pod 中，在各容器间传递数据。</p><p><strong>向 Pod 添加 <code>emptyDir</code> Volume</strong><br>创建如下 <code>fortune-emptydir.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-emptydir</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"ls /usr/share/nginx/html/quote || (apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote)"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>当容器第一次启动时，<code>postStart</code> hook 会执行 <code>apk add fortune</code> 命令安装 fortune 软件包，并执行 <code>fortune &gt; /usr/share/nginx/html/quote</code> 创建 <code>quote</code> 文件。<br>后续若容器因为各种原因重启，由于 <code>quote</code> 文件位于挂载的 Volume 中，不会随着容器一同被销毁。<br>并且在新容器生成后仍会挂载到原来的路径下，即不管后续容器如何重启，<code>quote</code> 文件都会保持第一次创建时的状态。</p><p>若没有挂载 Volume，则 <code>quote</code> 文件会在容器重启时随着旧容器一同被销毁，每次新容器生成，都会在同样的路径下产生一个新的不同版本的 <code>quote</code> 文件。</p><p>运行 <code>kubectl apply -f fortune-emptydir.yml</code> 命令应用清单文件，检查容器中 Volume 的挂载状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-emptydir.yml</span></span><br><span class="line">pod/fortune-emptydir created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune-emptydir -- mount --list | grep nginx/html</span></span><br><span class="line">/dev/sdb on /usr/share/nginx/html type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br></pre></td></tr></table></figure></p><h5 id="使用-emptyDir-在容器间共享文件"><a href="#使用-emptyDir-在容器间共享文件" class="headerlink" title="使用 emptyDir 在容器间共享文件"></a>使用 <code>emptyDir</code> 在容器间共享文件</h5><p>创建如下内容的清单文件 <code>fortune.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/fortune-writer:1.0</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/local/output</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>fortune</code> 容器是作者自己构建的，会每隔 30s 执行一次 <code>fortune &gt; /var/local/output/quote</code> 命令。<code>fortune</code> 每次执行都会随机输出一段名言警句类型的话，即 <code>/var/local/output/quote</code> 文件中的内容会每隔 30s 变化一次。<br>整个 Pod 包含两个容器和一个 Volume，其中 <code>fortune</code> 容器挂载 <code>content</code> Volume 到自己的 <code>/var/local/output</code> 路径下，而 <code>nginx</code> 容器挂载同一个 <code>content</code> Volume 到自己的 <code>/usr/share/nginx/html</code> 路径下。<br><code>fortune</code> 容器会每隔 30s 生成一个新的 <code>quote</code> 文件，保存到挂载的 <code>content</code> Volume 下；而另一个 <code>nginx</code> 容器也挂载了 <code>content</code> Volume，并且将其中的 <code>quote</code> 文件作为 Web 服务的静态文件向外提供服务。<br>即同一个 Pod 中的两个容器通过挂载同一个 Volume 实现文件的共享。</p><p><strong>运行 Pod</strong><br>使用 <code>kubectl apply -f fortune.yml</code> 命令应用清单文件创建 Pod，再分别从两个容器中查看 Volume 下 <code>quote</code> 文件的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune.yml</span></span><br><span class="line">pod/fortune configured</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c fortune -- cat /var/<span class="built_in">local</span>/output/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c nginx -- cat /usr/share/nginx/html/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br></pre></td></tr></table></figure></p><p>后两条命令输出了同样的内容。虽然两个容器查看的 <code>quote</code> 文件本地路径不同，它们实际上指向了同一个 Volume。</p><h4 id="理解-external-volumes-是如何挂载的"><a href="#理解-external-volumes-是如何挂载的" class="headerlink" title="理解 external volumes 是如何挂载的"></a>理解 external volumes 是如何挂载的</h4><p>如下图所示，网络存储卷首先是被宿主节点挂载，然后再授予 Pod 访问挂载点的权限。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0f593c120f4cd3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network volumes are mounted by the host node and then exposed in pods"></p><p>通常情况下，底层的存储技术并不允许一个 Volume 以读写模式同时挂载到一个以上的节点，但是同一个节点上的多个 Pods 可以同时以读写模式使用 Volume。<br>对于云环境提供的大多数存储技术，多个节点使用同一个网络存储卷的方式只有一种，即以只读模式挂载。<br>在设计分布式应用的架构时，考虑网络存储卷的上述限制是很有必要的。同一个 Pod 的多个副本通常不能以读写模式挂载同一个网络存储卷。</p><h4 id="访问工作节点上的文件系统"><a href="#访问工作节点上的文件系统" class="headerlink" title="访问工作节点上的文件系统"></a>访问工作节点上的文件系统</h4><p>绝大多数 Pods 不应该关注部署它们的宿主节点，不应该访问节点文件系统中的任何文件。除非这些 Pods 是系统级别的。<br>可以使用 <code>hostPath</code> 类型的 Volume 令 Pod 能够访问宿主节点。</p><h5 id="hostPath-Volume-介绍"><a href="#hostPath-Volume-介绍" class="headerlink" title="hostPath Volume 介绍"></a><code>hostPath</code> Volume 介绍</h5><p><code>hostPath</code> Volume 指向宿主节点文件系统中的特定文件或目录，形成 Pod 与宿主节点之间的文件共享。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-48b1a7db394ddd26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hostPath volume mounts a file or directory from the worker node’s filesystem into the container"></p><p><code>hostPath</code> Volume 并不适合存放数据库中的数据。因为此 Volume 的内容只是保存在某个特定的工作节点上，假如数据库 Pod 被重新分配给了另一个节点，则保存在 Volume 中的数据库数据对新的 Pod 不再可见。</p><p>通常情况下，<code>hostPath</code> Volume 只用在当 Pod 确实是需要读写 Node 中的文件，比如 Node 上的系统日志。<br><code>hostPath</code> 是最危险的 Volume 类型之一，一般只用于具有特殊权限的 Pod。假如不对 <code>hostPath</code> 的使用加以限制，用户有可能对工作节点做任何事。<br>比如用户可以使用 <code>hostPath</code> 挂载容器的 Docker socket 文件，然后在容器内运行 Docker 客户端，接着便可以作为 root 用户在宿主节点上执行任意命令。</p><h5 id="使用-hostPath-Volume"><a href="#使用-hostPath-Volume" class="headerlink" title="使用 hostPath Volume"></a>使用 <code>hostPath</code> Volume</h5><p>部署如下配置的 Pod：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">host-root</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"sleep"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9999999999"</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/host</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">host-root</span></span><br></pre></td></tr></table></figure></p><p>Pod 部署完成后，即可运行 <code>kubectl exec -it node-explorer -- sh</code> 命令在 Pod 中运行一个交互式命令行窗口，在执行 <code>cd /host</code> 命令即可进入宿主节点的文件系统：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it node-explorer -- sh</span></span><br><span class="line">/ # cd /host</span><br><span class="line">/host # ls</span><br><span class="line">Release.key  boot         dev          etc          kic.txt      lib          lib64        media        opt          root         sbin         sys          usr</span><br><span class="line">bin          data         docker.key   home         kind         lib32        libx32       mnt          proc         run          srv          tmp          var</span><br><span class="line">/host #</span><br></pre></td></tr></table></figure></p><p><code>hostPath</code> Volume 指向的是宿主节点的 <code>/</code> 路径，由此整个工作节点的文件系统都会向 Pod 开放。执行完上面的命令后，即可以修改工作节点上的任何文件。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Volumes-介绍&quot;&gt;&lt;a href=&quot;#Volumes-介绍&quot; class=&quot;headerlink&quot; title=&quot;Volumes 介绍&quot;&gt;&lt;/a&gt;Volumes 介绍&lt;/h4&gt;&lt;p&gt;Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Storage" scheme="https://rollingstarky.github.io/tags/Storage/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Volumes" scheme="https://rollingstarky.github.io/tags/Volumes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 管理 Pod 的生命周期</title>
    <link href="https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/"/>
    <id>https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/</id>
    <published>2022-01-04T16:00:00.000Z</published>
    <updated>2022-01-04T16:30:25.056Z</updated>
    
    <content type="html"><![CDATA[<h4 id="理解-Pod-的状态"><a href="#理解-Pod-的状态" class="headerlink" title="理解 Pod 的状态"></a>理解 Pod 的状态</h4><h5 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h5><p>在 Pod 完整的生命周期中，存在着 5 种不同的阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-fcf20a7154d53893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod’s phases"></p><ul><li><code>Pending</code>：创建 Pod 对象后的初始化阶段。会一直持续到 Pod 被分配给某个工作节点，镜像被拉取到本地并启动</li><li><code>Running</code>：Pod 中至少一个容器处于运行状态</li><li><code>Succeeded</code>：对于不打算无限期运行的 Pod，其容器部署完成后的状态</li><li><code>Failed</code>：对于不打算无限期运行的 Pod，其容器中至少有一个由于错误终止</li><li><code>Unknown</code>：由于 Kubelet 与 API Server 的通信中断，Pod 的状态未知。可能是工作节点挂掉或断网</li></ul><p>从 <code>kubia.yml</code> 清单文件创建一个 Pod。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><code>$ kubectl apply -f kubia.yml</code></p><p><strong>查看 Pod 的 Phase</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o yaml | grep phase</span></span><br><span class="line">  phase: Running</span><br></pre></td></tr></table></figure></p><p>或者借助 <code>jq</code> 工具从 JSON 格式的输出中检索 phase 字段：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.phase</span></span><br><span class="line">"Running"</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>kubectl describe</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Status:</span></span><br><span class="line">Status:       Running</span><br></pre></td></tr></table></figure></p><h5 id="Pod-conditions"><a href="#Pod-conditions" class="headerlink" title="Pod conditions"></a>Pod conditions</h5><p>Pod 的 conditions 用来表示某个 Pod 是否达到了特定的状态以及达到或未达到的原因。<br>与 phase 相反，一个 Pod 可以同时有几个 conditions。</p><ul><li><code>PodScheduled</code>：表明 Pod 是否已经被安排给了某个工作节点</li><li><code>Initialized</code>：Pod 的初始化容器已经部署完成</li><li><code>ContainersReady</code>：Pod 中的所有容器都已经准备完毕</li><li><code>Ready</code>：Pod 自身已经准备好对其客户端提供服务</li></ul><p><strong>查看 Pod 的 conditions</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Conditions: -A5</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br></pre></td></tr></table></figure></p><p><code>kubectl describe</code> 命令只会显示每个 condition 是 <code>true</code> 还是 <code>false</code>，不会显示更详细的信息。<br>为了显示某个 condition 为 false 的具体原因，需要检索 Pod 的清单文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.conditions</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Initialized"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Ready"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "ContainersReady"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "PodScheduled"</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>当 condition 为 <code>false</code> 时，上述输出中会包含 <code>reason</code> 和 <code>message</code> 字段来显示失败的具体原因和详细信息。</p><h5 id="容器的-status"><a href="#容器的-status" class="headerlink" title="容器的 status"></a>容器的 status</h5><p>容器的 status 包含多个字段。其中 <code>state</code> 字段表示该容器当前的状态，<code>restartCount</code> 表示容器重启的频率，此外还有 <code>containerID</code>、<code>image</code>、<code>imageID</code> 等。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2425c752e41b4cc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Container status"></p><p>容器的 status 包含以下几种：</p><ul><li><code>Waiting</code>：容器等待启动。<code>reason</code> 和 <code>message</code> 字段会记录容器处于此状态的原因</li><li><code>Running</code>：容器已经创建，进程正在运行</li><li><code>Terminated</code>：容器中运行的进程已经终止。<code>exitCode</code> 字段会记录进程的退出码</li><li><code>Unknown</code>：容器的状态无法确定</li></ul><p>比如修改 <code>kubia.yml</code> 清单文件中的 <code>image</code> 字段，故意改成 <code>uksa/kubia:1.0</code> 这样无效的地址，运行 <code>kubectl apply -f kubia.yml</code> 命令重新应用清单文件。<br>等待几分钟直到新的配置生效，查看容器的状态。</p><p>可以使用 <code>kubectl describe</code> 命令查看容器的状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Containers: -A15</span></span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91</span><br><span class="line">    Image:          uksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Waiting</span><br><span class="line">      Reason:       ImagePullBackOff</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Fri, 31 Dec 2021 14:50:39 +0800</span><br><span class="line">      Finished:     Fri, 31 Dec 2021 14:51:36 +0800</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl get po kubia -o json</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.containerStatuses</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">    "image": "luksa/kubia:1.0",</span><br><span class="line">    "imageID": "docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7",</span><br><span class="line">    "lastState": &#123;</span><br><span class="line">      "terminated": &#123;</span><br><span class="line">        "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">        "exitCode": 137,</span><br><span class="line">        "finishedAt": "2021-12-31T06:51:36Z",</span><br><span class="line">        "reason": "Error",</span><br><span class="line">        "startedAt": "2021-12-31T06:50:39Z"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "name": "kubia",</span><br><span class="line">    "ready": false,</span><br><span class="line">    "restartCount": 0,</span><br><span class="line">    "started": false,</span><br><span class="line">    "state": &#123;</span><br><span class="line">      "waiting": &#123;</span><br><span class="line">        "message": "Back-off pulling image \"uksa/kubia:1.0\"",</span><br><span class="line">        "reason": "ImagePullBackOff"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面输出中的 <code>state</code> 字段都表明了容器当前的状态是 <code>waiting</code>，还有 <code>reason</code> 和 <code>message</code> 字段表明处于此状态的原因：镜像拉取失败。</p><h4 id="确保容器的健康状态"><a href="#确保容器的健康状态" class="headerlink" title="确保容器的健康状态"></a>确保容器的健康状态</h4><h5 id="理解容器的自动重启机制"><a href="#理解容器的自动重启机制" class="headerlink" title="理解容器的自动重启机制"></a>理解容器的自动重启机制</h5><p>当一个 Pod 被分配给了某个工作节点，该工作节点上的 Kubelet 就会负责启动容器并保证该容器一直处于运行状态，只要该 Pod 对象一直存在没被移除。<br>如果容器中的主进程由于某些原因终止运行，Kubernetes 就会自动重启该容器。</p><p>创建如下内容的清单文件 <code>kubia-ssl.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>运行如下命令应用上述清单文件，并启用端口转发：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-ssl.yml</span></span><br><span class="line">pod/kubia-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-ssl 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>待容器启动成功后，访问 localhost 的 8080、8443、9901 端口就等同于访问容器中 8080、8443、9901 端口上运行的服务。</p><p>打开一个新的命令行窗口运行 <code>kubectl get pods -w</code> 命令，实时监控容器的运行状态。<br>打开一个新的命令行窗口运行 <code>kubectl get events -w</code> 命令，实时监控触发的事件。</p><p>打开一个新的命令行窗口，尝试终止 Envoy 容器中运行的主进程。Envoy 容器 9901 端口上运行的服务刚好提供了一个管理接口，能够接收 HTTP POST 请求来终止进程：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST http://localhost:9901/quitquitquit</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时查看前两个窗口中的输出，负责监控容器状态的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -w</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-ssl   2/2     Running   0          11m</span><br><span class="line">kubia-ssl   1/2     NotReady   0          12m</span><br><span class="line">kubia-ssl   2/2     Running    1 (2s ago)   12m</span><br></pre></td></tr></table></figure></p><p>最新的输出表明，在杀掉 Envoy 容器中的主进程后，Pod 的状态是先变成 <code>NotReady</code>，之后就立即重启该容器，Pod 的状态稍后恢复成 <code>Running</code>。</p><p>负责监控最新事件的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get events -w</span></span><br><span class="line">LAST SEEN   TYPE     REASON      OBJECT          MESSAGE</span><br><span class="line">11m         Normal   Scheduled   pod/kubia-ssl   Successfully assigned default/kubia-ssl to minikube</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container kubia</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container kubia</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container envoy</span><br><span class="line">0s          Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">0s          Normal   Started     pod/kubia-ssl   Started container envoy</span><br></pre></td></tr></table></figure></p><p>最新的事件信息中包含了新的 envoy 容器启动的过程。其中有一个很重要的细节：<strong>Kubernetes 从来不会重启容器，而是直接丢弃停止的容器并创建一个新的</strong>。一般在 Kubernetes 中提及“重启”容器，实质上都指的是“重建”。<br><strong>任何写入到容器文件系统中的数据，在容器重新创建后都会丢失。为了持久化这些数据，需要向 Pod 添加 Volume</strong>。</p><p><strong>配置容器的重启策略</strong><br>Kubernetes 支持 3 种容器重启策略：</p><ul><li><code>Always</code>：默认配置。不管容器中主进程的退出码是多少，容器都会自动重启</li><li><code>OnFailure</code>：容器只会在退出码非 0 时重启</li><li><code>Never</code>：容器永不重启</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-469232db79083201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Restart policy"></p><p><strong>容器重启时的延迟时间</strong><br>第一次容器终止时，重启会立即触发。但容器第二次重启时会先等待 10s，这个等待时间会随着重启次数依次增加到 20、40、80、160s。再之后则一直保持在 5 分钟。<br>等待过程中容器会处于 <code>Waiting</code> 状态，<code>reason</code> 字段显示 <code>CrashLoopBackOff</code>，<code>message</code> 字段显示需要等待的时间。</p><h5 id="liveness-probes"><a href="#liveness-probes" class="headerlink" title="liveness probes"></a>liveness probes</h5><p>Kubernetes 会在容器的进程终止时重启容器，以保证应用的健康。但应用实际上有可能在进程不终止的情况下无响应，比如一个 Java 应用报出 OutOfMemoryError 错误，而 JVM 进程仍在运行中。<br>理想情况下，Kubernetes 需要能够检测到此类错误并重启容器。</p><p>当然，应用自身也可以捕获这类错误并令进程立即终止。但假如应用因为进入无限循环或死锁导致无响应，又或者应用本身无法检测到错误存在呢？<br>为了确保容器能够在这些复杂情况下重启，应该提供一种从外部检查应用状态的机制。</p><p><strong>liveness probe 介绍</strong><br>Kubernetes 可以通过配置 liveness probe 来检查某个应用是否能够正常响应，Pod 中的每个容器都可以分别配置 liveness probe。一旦应用无响应或有错误发生，容器就会被认为是不健康的并被终止掉。之后容器被 Kubernetes 重新启动。</p><p>Kubernetes 支持以下三种 probe 机制：</p><ul><li><code>HTTP GET probe</code>：会发送 GET 请求到容器的 IP 地址、端口号和 URL 路径。如果 probe 收到正常的响应（2xx 或 3xx），该 probe 就被认定是成功的。如果服务返回了一个错误的响应码，或者没有在规定的时间内响应，则该 probe 被认定是失败的。</li><li><code>TCP Socket probe</code>：会尝试打开一个 TCP 连接到容器的特定端口。若连接成功，probe 就被认定是成功的；否则失败。</li><li><code>Exec probe</code>：会在容器内部执行一个命令并检查该命令的退出码。若退出码为 0，则 probe 被认定是成功的；否则失败。</li></ul><p><strong>HTTP GET liveness probe</strong><br>创建如下内容的 <code>kubia-liveness.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>其中 kubia 容器的 liveness probe 是最简单版本的 HTTP 应用的 probe。该 probe 只是向 8080 端口的 <code>/</code> 路径发送 HTTP GET，看容器是否仍然能够处理请求。当应用的响应码介于 200 到 399 之间时，该应用就被认为是健康的。<br>由于该 probe 没有配置其他选项，默认配置生效。第一次检查请求会在容器启动 10s 后发起，之后每隔 10s 发起新的请求。若应用没有在 1s 之内响应，则该次 probe 请求被认定是失败的。连续 3 次请求失败以后，容器就被认为是不健康的并被终止掉。</p><p>Envoy 容器的管理员接口提供了一个 <code>/ready</code> 入口，可以返回其健康状态，因此 envoy 容器的 liveness probe 的目标可以是容器的 <code>admin</code> 端口即 9901。<br>参数 <code>initialDelaySeconds</code> 表示容器启动后到发起第一个检测请求之间的等待时间，<code>periodSeconds</code> 表示两次连续的检测请求之间的时间间隔，<code>timeoutSeconds</code> 表示多长时间以后没有响应则认定此次检测失败，<code>failureThreshold</code> 则表示连续多少次检测失败以后才认定容器失效并重启。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-659b273518b2d676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="liveness probe"></p><p><strong>观察 liveness probe 的效果</strong><br>运行 <code>kubectl apply</code> 命令应用上述清单文件并通过 <code>kubectl port-forward</code> 命令启用端口转发，启动该 Pod 并令其能够被访问：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-liveness.yml</span></span><br><span class="line">pod/kubia-liveness created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-liveness 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>Pod 启动成功以后，liveness probe 会在初始等待时间过后持续向 Pod 中的容器发起检测请求，其检测结果只会在容器的 log 中看到。<br>kubia 容器中的 Node.js 应用会在每次处理 HTTP 请求时向标准输出打印记录，这些请求也包括 liveness probe 的检测请求。因此可以打开一个新的命令行窗口，使用如下命令查看请求记录：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-liveness -c kubia -f</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia-liveness</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>envoy 容器的 liveness probe 被配置成向其管理员接口发送 HTTP 请求，这些请求被记录在 <code>/var/log/envoy.admin.log</code> 文件中。可以使用如下命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-liveness -c envoy -- tail -f /var/<span class="built_in">log</span>/envoy.admin.log</span></span><br><span class="line">[2022-01-02T18:34:59.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:04.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:09.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:14.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br></pre></td></tr></table></figure></p><p><strong>观察失败的 liveness probe</strong><br>可以尝试手动令 liveness probe 的检测请求失败。先在一个新的窗口中运行 <code>kubectl get events -w</code> 命令，方便后续观察检测失败时输出的事件信息。<br>访问 Envoy 容器的管理员接口，手动配置其健康状态为 <code>fail</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST localhost:9901/healthcheck/fail</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时转到观察事件信息的命令行窗口，发现连续输出了 3 次 probe failed 503 错误，之后 envoy 容器开始重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get events -w</span><br><span class="line">LAST SEEN   TYPE      REASON          OBJECT               MESSAGE</span><br><span class="line">...</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Normal    Killing         pod/kubia-liveness   Container envoy failed liveness probe, will be restarted</span><br><span class="line">0s          Normal    Pulled          pod/kubia-liveness   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal    Created         pod/kubia-liveness   Created container envoy</span><br><span class="line">0s          Normal    Started         pod/kubia-liveness   Started container envoy</span><br></pre></td></tr></table></figure></p><h5 id="exec-amp-tcpSocket-liveness-probe"><a href="#exec-amp-tcpSocket-liveness-probe" class="headerlink" title="exec &amp; tcpSocket liveness probe"></a>exec &amp; tcpSocket liveness probe</h5><p><strong>添加 tcpSocket liveness probe</strong><br>对于接收非 HTTP 请求的应用，可以配置 tcpSocket liveness probe。<br>一个 tcpSocket liveness probe 的示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  tcpSocket:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">1234</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>该 probe 会检查容器的 1234 端口是否打开，每隔 2s 检查一次，一次检查失败则认定该容器是不健康的并重启它。</p><p><strong>exec liveness probe</strong><br>不接受 TCP 连接的应用可以配置一条命令去检测其状态。<br>下面的示例配置会每隔 2s 运行 <code>/usr/bin/healthcheck</code> 命令，检测容器中的应用是否仍在运行：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  exec:</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/usr/bin/healthcheck</span></span><br><span class="line"><span class="attr">  periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h5 id="startup-probe"><a href="#startup-probe" class="headerlink" title="startup probe"></a>startup probe</h5><p>默认的 liveness probe 配置会给应用 20 到 30s 的时间启动，如果应用需要更长的时间才能启动完成，容器会永远达不到 liveness probe 检测成功的状态，从而进入了无限重启的循环。<br>为了防止上述情况发生，可以增大 <code>initialDelaySeconds</code>、<code>periodSeconds</code> 或 <code>failureThreshold</code> 的值，但也会有一定的副作用。<code>periodSeconds * failureThreshold</code> 的值越大，当应用不健康时重启的时间就越长。</p><p>Kubernetes 还提供了一种 startup probe。当容器配置了 startup probe 时，容器启动时只有 startup probe 会执行。startup probe 可以按照应用的启动时间配置，检测成功之后 Kubernetes 会切换到使用 liveness probe 检测。<br>比如 Node.js 应用需要 1 分钟以上的时间启动，当启动成功以后若应用状态不正常，则在 10s 以内重启。可以这样配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  startupProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">  livenessProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>上面配置的效果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0958a2c039bc32f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startup probe &amp; liveness probe"></p><p>应用有 120s 的时间启动。Kubernetes 一开始每隔 10s 发起 startup probe 请求，最多尝试 12 次。<br>不同于 liveness probe，startup probe 失败是很正常的，只是说明应用还未成功启动。一旦某次 startup probe 检测返回成功状态，Kubernetes 就会立即切换到 liveness probe 模式，通常拥有更短的检测间隔，能够对未响应应用做出更快速的反应。</p><h4 id="在容器启动或关闭时触发动作"><a href="#在容器启动或关闭时触发动作" class="headerlink" title="在容器启动或关闭时触发动作"></a>在容器启动或关闭时触发动作</h4><p>可以向容器中添加 lifecycle hooks。Kubernetes 目前支持两种类型的钩子：</p><ul><li>Post-start hooks：在容器启动后执行</li><li>Pre-stop hooks：在容器停止前执行</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-77db56c2b1e8d783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lifecycle hooks"></p><h5 id="post-start-hooks"><a href="#post-start-hooks" class="headerlink" title="post-start hooks"></a>post-start hooks</h5><p>post-start lifecycle hook 会在容器创建完成之后立即触发。可以使用 <code>exec</code> 类型的钩子在主进程启动的同时执行一个额外的程序，或者 <code>httpGet</code> 类型的钩子向容器中运行的应用发送 HTTP 请求，以完成初始化或预热操作。<br>假如你是应用的作者，类似的操作当然可以加入到应用本身的代码中。但对于一个已经存在的并非自己创建的应用，就有可能无法做到。post-start hook 提供了一种不需要修改应用或容器镜像的替代方案。</p><p><strong>post-start hook 在容器中执行命令</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-poststart</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>上述清单文件定义的 Pod 名为 <code>fortune-poststart</code>，包含一个基于 <code>nginx:alpine</code> 镜像的容器，同时定义了一个 <code>postStart</code> 钩子。该钩子会在 Nginx 服务启动时执行以下命令：<br><code>sh -c &quot;apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote&quot;</code></p><p><code>postStart</code> 这个名称其实有些误导作用，它并不是在主进程完全启动后才开始执行，而是在容器创建后，几乎和主进程同时执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-poststart.yml</span></span><br><span class="line">pod/fortune-poststart unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward fortune-poststart 8080:80</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure><p>打开一个新的命令行窗口使用 <code>curl</code> 命令测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080/quote</span></span><br><span class="line">The Official MBA Handbook on business cards:</span><br><span class="line">        Avoid overly pretentious job titles such as "Lord of the Realm,</span><br><span class="line">        Defender of the Faith, Emperor of India" or "Director of Corporate</span><br><span class="line">        Planning."</span><br></pre></td></tr></table></figure></p><p><strong>post-startup hook 对容器的影响</strong><br>虽然 post-start hook 相对于容器的主进程以异步的方式执行，它还是会对容器产生两个方面的影响。<br>首先，在 post-start hook 的执行过程中容器会一直处于 <code>Waiting</code> 状态，原因显示为 <code>ContainerCreating</code>，直到 hook 执行完毕。<br>其次，若 hook 绑定的命令无法执行或返回了一个非零的状态值，则整个容器会被重启。</p><h5 id="在容器终止前执行命令"><a href="#在容器终止前执行命令" class="headerlink" title="在容器终止前执行命令"></a>在容器终止前执行命令</h5><p>前面 fortune Pod 中的 Nginx 服务在收到 <code>TERM</code> 信号后会立即关闭所有打开的连接并终止进程，这并不是理想的操作，不会等待正在处理的客户端请求彻底完成。<br>可以使用 pre-stop hook 执行 <code>nginx -s quit</code> 命令舒缓地关闭 Nginx 服务。示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line"><span class="attr">  preStop:</span></span><br><span class="line"><span class="attr">    exec:</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">nginx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">-s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">quit</span></span><br></pre></td></tr></table></figure></p><p>假如某个 pre-stop hook 执行失败，只会在 Pod 的 events 消息中显示一条 <code>FailedPreStopHook</code> 警告信息，并不影响容器继续被终止。</p><h4 id="理解容器的生命周期"><a href="#理解容器的生命周期" class="headerlink" title="理解容器的生命周期"></a>理解容器的生命周期</h4><p>一个 Pod 的生命周期可以被分成如下三个阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2cd22a41e5907b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod 生命周期的三个阶段"></p><ul><li>初始化阶段：Pod 的 init 容器从开始运行到启动完成</li><li>运行阶段：Pod 的普通容器从开始运行到启动完成</li><li>终止阶段：Pod 的所有容器被终止运行</li></ul><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><p>Pod 中的初始化容器会最先运行，按照 <code>spec</code> 的 <code>initContainers</code> 字段中定义的顺序。<br>第一个初始化容器的镜像被下载到工作节点并启动，完成后继续拉取第二个初始化容器的镜像，直到所有的初始化容器都成功运行。<br>若某个初始化容器因为某些错误启动失败，且其重启策略设置为 <code>Always</code> 或 <code>OnFailure</code>，则该失败的容器自动重启。若其重启策略设置为 <code>Never</code>，则 Pod 的状态显示为 <code>Init:Error</code>，必须删除并重新创建 Pod 对象。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-84a2ee1a08b66cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="All init containers must run to completion before the regular containers can start"></p><h5 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h5><p>当所有的初始化容器成功运行后，Pod 的普通容器开始以<strong>并行</strong>的方式创建（需要注意的是，容器的 post-start hook 会阻塞下一个容器的创建）。</p><p><strong>termination grace period</strong><br>容器中的应用都有一个固定的关闭时间做缓冲用，定义在 <code>spec</code> 下的 <code>terminationGracePeriodSeconds</code> 字段中，默认是 30s。<br>该时间从 pre-stop hook 触发或收到 <code>TERM</code> 信号时开始计算，若时间过了进程仍在运行，应用会收到 <code>KILL</code> 信号被强制关闭。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-63ea58db03568a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container’s termination sequence"></p><h5 id="终止阶段"><a href="#终止阶段" class="headerlink" title="终止阶段"></a>终止阶段</h5><p>Pod 的容器以并行的方式终止。对每个容器来说，pre-stop hook 触发，然后主进程接收 <code>TERM</code> 信号，如果应用关闭的时间超过了 <code>terminationGracePeriodSeconds</code>，就发送 <code>KILL</code> 信号给容器的主进程。<br>在所有的容器都被终止以后，Pod 对象被删除。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-3d36f79107e20ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="termination sequence inside a pod"></p><p>可以在删除一个 Pod 时手动指定一个新的时间覆盖 <code>terminationGracePeriodSeconds</code> 的值，如：<br><code>kubectl delete po kubia-ssl --grace-period 10</code></p><h5 id="Pod-完整生命周期图示"><a href="#Pod-完整生命周期图示" class="headerlink" title="Pod 完整生命周期图示"></a>Pod 完整生命周期图示</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8da03ba0126724f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化阶段"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8fc4e425cb34fcd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行阶段和终止阶段"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;理解-Pod-的状态&quot;&gt;&lt;a href=&quot;#理解-Pod-的状态&quot; class=&quot;headerlink&quot; title=&quot;理解 Pod 的状态&quot;&gt;&lt;/a&gt;理解 Pod 的状态&lt;/h4&gt;&lt;h5 id=&quot;Pod-phase&quot;&gt;&lt;a href=&quot;#Pod-phase&quot; c
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
  </entry>
  
</feed>
