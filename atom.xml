<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2021-11-29T13:55:06.259Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 理解容器技术</title>
    <link href="https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/"/>
    <id>https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2021-11-29T13:55:06.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、容器-vs-虚拟机"><a href="#一、容器-vs-虚拟机" class="headerlink" title="一、容器 vs 虚拟机"></a>一、容器 vs 虚拟机</h4><h5 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h5><p>每一台虚拟机都需要安装独属于自己的操作系统，包含一系列系统进程；而同一台宿主机上的多个容器会共享宿主机的操作系统，它们的环境仍然是独立的。<br>即对于容器而言，不需要装一个独立的操作系统。不会像虚拟机那样，存在很多套重复的系统进程。因而容器更加轻量。<br><strong>容器只包含一套隔离的进程，运行在已有的宿主机操作系统上，只会消耗这套隔离进程运行所需的系统资源</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a8f80aa3c08ae7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="overhead VM vs Container"></p><p>由于虚拟机高额的开销，通常需要将多个关联的应用部署在同一台虚拟机上。对于开销较低的容器而言，则可以为每一个应用都创建一个独立的容器。<br>实际上也应该<strong>确保每一个容器都只包含一个应用</strong>，这样方便管理，同时 Kubernetes 等容器管理平台也是默认这个原则的。</p><h5 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h5><p>容器拥有更快的启动时间。因为容器只需要启动自身包含的应用进程，不需要像启动一台新的虚拟机那样，先启动一些额外的系统进程。</p><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>无疑虚拟机的隔离性更好。<br>当使用虚拟机部署应用时，每台虚拟机都拥有一套独立的操作系统和内核。这些虚拟机的底层是 hypervisor，将物理硬件划分成一系列更小的虚拟资源，供给不同的虚拟机使用。</p><p>当虚拟机中运行的应用向虚拟机内核发起系统调用时，内核会先在虚拟的 CPU 上执行机器指令，再通过 hypervisor 转发给宿主机的物理 CPU 执行。<br>容器发起的系统调用则都可以直接传递给宿主机上运行的系统内核，再转化为机器指令传递给宿主机的 CPU。宿主机 CPU 不需要处理任何形式的虚拟化。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e7e28095583e19c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="system calls"></p><p>同一台机器上的多个容器共享同一个宿主机内核，但它们之间仍然是隔离的，相互之间并不清楚其他人的存在，也只能看到一部分物理硬件。<br>这种隔离是由宿主机内核提供的。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f1b4cacdc98d0138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Isolation"></p><h5 id="由隔离性引发的安全性"><a href="#由隔离性引发的安全性" class="headerlink" title="由隔离性引发的安全性"></a>由隔离性引发的安全性</h5><p>容器使用同一个内核。如果内核出现 bug，某个容器中的应用有可能会利用这个 bug 读取其他容器中其他应用的内存。<br>此外，容器会共享内存空间。如果不限制某个容器能够使用的内存总量，有可能会导致其他容器没有足够的内存使用。</p><h4 id="二、Docker-容器平台介绍"><a href="#二、Docker-容器平台介绍" class="headerlink" title="二、Docker 容器平台介绍"></a>二、Docker 容器平台介绍</h4><p>Docker 是一个帮助用户打包、发布和运行容器应用的平台。用户可以使用 Docker 将应用及其运行环境（可以是一些动态库等依赖，甚至操作系统提供的所有文件）打包，并可以将打包后的镜像发布到一个公共的镜像源，再部署到其他安装了 Docker 的机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-651e5432eed2654a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker Platform"></p><p>三个 Docker 中的基本概念：</p><ul><li>Images（镜像）：类似于一个 zip 压缩包，包含了应用及其运行环境</li><li>Registries（源）：一个方便用户和机器分发、共享镜像的站点。可以将打包好的镜像 push 到源，这样另一台机器就可以从镜像源 pull 该镜像到本地</li><li>Containers（容器）：相当于实例化的镜像。<strong>一个运行的容器相当于宿主机中一个普通的进程，只不过它的环境是隔离的</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e505cff02f642b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker push"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3f8802fae79fd57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker pull"></p><h5 id="Image-Layers"><a href="#Image-Layers" class="headerlink" title="Image Layers"></a>Image Layers</h5><p>不同于虚拟机镜像是由整个文件系统构成的一个大的文件块，容器镜像通常是由更小的<strong>层</strong>构成。这些层可以被多个镜像所共享。<br>如果某个镜像需要的部分镜像层已经被下载到了宿主机上（在 pull 其他镜像的时候），则 pull 该镜像时只需要下载之前未 pull 的层即可。<br>镜像层使得发布镜像变得更加高效，同时也提升了宿主机的存储空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf0919122843a478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image Layers"></p><p>如上图中的三个容器，它们可以共享访问一部分共有的文件。但它们是如何同时做到隔离的呢？其中某个容器若修改了共享的文件，如何做到不对其他容器可见？<br>文件系统的隔离由 <strong>Copy-on-Write (CoW)</strong> 机制实现。<br>容器中的文件系统由从镜像而来的只读层和加在只读层上面的一个读写层构成。当某个运行的容器修改了只读层中的文件，该文件会被整个复制到容器的读写层。每个容器都拥有自己所独有的读写层，因此对共享文件的修改并不会对其他容器可见。<br>当删除某个文件，该文件只是在读写层中被标记为已删除，实际上该文件仍然存在于只读层中。因此删除文件并不会减少镜像的大小。</p><h5 id="镜像层的潜在限制"><a href="#镜像层的潜在限制" class="headerlink" title="镜像层的潜在限制"></a>镜像层的潜在限制</h5><p>理论上讲，基于 Docker 的镜像可以运行在任意一台启用了 Docker 的机器上。但是由于容器并没有自己的内核，如果一个容器需要特定版本的内核才能运行，它有可能不会运行在每一台机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bedcb0dfebe1576c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container requires specific kernel version"></p><p>此外，容器化的应用只能运行在特定的硬件架构上。比如不能把一个构建在 x86 CPU 架构上的应用，部署在 ARM 平台的 Docker 上。</p><h4 id="三、容器背后的技术"><a href="#三、容器背后的技术" class="headerlink" title="三、容器背后的技术"></a>三、容器背后的技术</h4><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>Linux 命名空间可以确保每个进程都只能看到它自己视角的系统。即容器中的进程只能看到部分文件、进程、网络接口和机器名，就好像它运行在一个独立的虚拟机上。<br>内核可以创建额外的命名空间，然后将部分资源移动到该命名空间，并令其只对某一个或一组进程可见。</p><p>命名空间的类型：</p><ul><li>Mount 命名空间用来隔离挂载点（文件系统）</li><li>Process ID 命名空间用来隔离进程 ID</li><li>Network 命名空间用来隔离网络设备、端口等</li><li>ipc 命名空间用来隔离进程间的通信（包括管理消息队列、共享内存等）</li><li>UTS (UNIX Time-sharing System) 命名空间用来隔离系统的主机名和 NIS (Network Information Service) 域名</li><li>User ID 命名空间用来隔离用户和组 ID</li><li>Cgroup 命名空间用来隔离 Control Groups 根目录</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e436794540627a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="network namespace"></p><p>有时候并不会想要将某个容器与另一个容器完全隔离，相互关联的容器之间有可能会共享特定的资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-120889e397b108e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shared namespace"></p><p>比如上图中的两个容器。它们可以看见并使用相同的两个网络设备（<code>eth0</code> 和 <code>lo</code>），因为它们拥有相同的网络命名空间。它们也因此可以绑定相同的 IP 地址并通过 loopback 设备相互通信。<br>这两个容器还使用同一个 UTS 命名空间，因此它们可以见到相同的主机名。但它们的 Mount 命名空间是不同的，即拥有不同的文件系统。</p><p><strong>容器中运行的进程只是一个绑定了 7 类命名空间的普通进程</strong>。</p><h5 id="Linux-Control-Groups"><a href="#Linux-Control-Groups" class="headerlink" title="Linux Control Groups"></a>Linux Control Groups</h5><p>Linux 命名空间可以控制进程只能访问一部分系统资源，但它们不能限制每个进程消耗的资源总量。<br>Linux Control Groups (cgroups) 则可以限制进程只能使用预先分配好的固定额度的 CPU 时间、内存和网络带宽等。避免某些进程吃掉所有的系统资源。</p><h4 id="sys-calls"><a href="#sys-calls" class="headerlink" title="sys-calls"></a>sys-calls</h4><p>Linux 命名空间和 Cgroups 能够隔离容器的环境并防止某个容器消耗掉所有的计算资源。但这些容器中的进程仍然使用同一个系统内核，一个非法容器仍然可以通过一些恶意的系统调用来影响其他容器。</p><p>内核提供了一系列 sys-calls 可以被程序用来与操作系统及底层的硬件交互，包括创建进程、操作文件和设备、创建应用间的通信通道等。<br>其中有些 sys-calls 是安全的，可以被任意进程使用。其他一些则只允许具有更高权限的进程使用。比如容器中的应用应该允许访问它们的本地文件，但不能修改系统时钟或者以破坏其他容器的方式修改内核。</p><p>Linux 内核把这些权限分成了名为 capabilities 的单位。如：</p><ul><li>CAP_NET_ADMIN：允许进程执行网络相关的操作</li><li>CAP_NET_BIND_SERVICE：允许进程绑定小于 1024 的端口号</li><li>CAP_SYS_TIME：允许进程修改系统时钟</li></ul><p>Capabilities 能够在容器创建时添加或移除，每个 Capability 都代表一系列特殊权限。<br>此外，还可以使用 <strong>seccomp (Secure Computing Mode)</strong> 。创建一个 包含 seccomp 配置的 JSON 文件，在构建容器时提供给 Docker。</p><h5 id="AppArmor-amp-SELinux"><a href="#AppArmor-amp-SELinux" class="headerlink" title="AppArmor &amp; SELinux"></a>AppArmor &amp; SELinux</h5><p>容器还可以依靠两种 MAC（强制访问控制）机制 SELinux 和 AppArmor 来获得更高的安全性。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、容器-vs-虚拟机&quot;&gt;&lt;a href=&quot;#一、容器-vs-虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、容器 vs 虚拟机&quot;&gt;&lt;/a&gt;一、容器 vs 虚拟机&lt;/h4&gt;&lt;h5 id=&quot;系统开销&quot;&gt;&lt;a href=&quot;#系统开销&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="Isolation" scheme="https://rollingstarky.github.io/tags/Isolation/"/>
    
      <category term="VM" scheme="https://rollingstarky.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Python 语言实现循环的最快方式（for、while 等速度对比）</title>
    <link href="https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/"/>
    <id>https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/</id>
    <published>2021-11-22T16:00:00.000Z</published>
    <updated>2021-11-23T12:51:53.254Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。<br>假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。</p><p><code>while</code> 和 <code>for</code> 是 Python 中常用的两种实现循环的关键字，它们的运行效率实际上是有差距的。比如下面的测试代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br></pre></td></tr></table></figure></p><p>这是一个简单的求和操作，计算从 1 到 n 之间所有自然数的总和。<br>可以看到 <code>for</code> 循环相比 <code>while</code> 要快 1.5 秒。其中的差距主要在于两者的机制不同。<br>在每次循环中，<code>while</code> 实际上比 <code>for</code> 多执行了两步操作：边界检查和变量 <code>i</code> 的自增。即每进行一次循环，while 都会做一次边界检查 (<code>while i &lt; n</code>）和自增计算（<code>i +=1</code>）。这两步操作都是显式的纯 Python 代码。<br><code>for</code> 循环不需要执行边界检查和自增操作，没有增加显式的 Python 代码（纯 Python 代码效率低于底层的 C 代码）。当循环的次数足够多，就出现了明显的效率差距。</p><p>可以再增加两个函数，在 <code>for</code> 循环中加上不必要的边界检查和自增计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_inc</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_test</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with increment\t\t'</span>,</span><br><span class="line">          timeit.timeit(for_loop_with_inc, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with test\t\t'</span>, timeit.timeit(for_loop_with_test, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; for loop with increment          4.602369500091299</span></span><br><span class="line"><span class="comment"># =&gt; for loop with test               4.18337869993411</span></span><br></pre></td></tr></table></figure></p><p>可以看出，增加的边界检查和自增操作确实大大影响了 <code>for</code> 循环的执行效率。</p><p>前面提到过，Python 底层的解释器和内置函数是用 C 语言实现的。而 C 语言的执行效率远大于 Python。<br>对于上面的求等差数列之和的操作，借助于 Python 内置的 <code>sum</code> 函数，可以获得远大于 <code>for</code> 或 <code>while</code> 循环的执行效率。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br></pre></td></tr></table></figure></p><p>可以看到，使用内置函数 <code>sum</code> 替代循环之后，代码的执行效率实现了成倍的增长。内置函数 <code>sum</code> 的累加操作实际上也是一种循环，但它由 C 语言实现，而 <code>for</code> 循环中的求和操作是由纯 Python 代码 <code>s += i</code> 实现的。C &gt; Python。</p><p>再拓展一下思维。小时候都听说过童年高斯巧妙地计算 1 到 100 之和的故事。1…100 之和等于 (1 + 100) * 50。这个计算方法同样可以应用到上面的求和操作中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math_sum</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n * (n - <span class="number">1</span>)) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'math sum\t\t'</span>, timeit.timeit(math_sum, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br><span class="line"><span class="comment"># =&gt; math sum                 2.400018274784088e-06</span></span><br></pre></td></tr></table></figure></p><p>最终 math sum 的执行时间约为 <code>2.4e-6</code>，缩短了上百万倍。这里的思路就是，既然循环的效率低，一段代码要重复执行上亿次。<br>索性直接不要循环，通过数学公式，把上亿次的循环操作变成只有一步操作。效率自然得到了空前的加强。</p><p>最后的结论（有点谜语人）：</p><p><strong>实现循环的最快方式</strong><br>——<br>——<br>——<br><strong>就是不用循环</strong></p><p>对于 Python 而言，则尽可能地使用内置函数，将循环中的纯 Python 代码降到最低。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://youtu.be/Qgevy75co8c" target="_blank" rel="noopener">The Fastest Way to Loop in Python - mCoding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。&lt;br&gt;假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 和 
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="loop" scheme="https://rollingstarky.github.io/tags/loop/"/>
    
      <category term="C" scheme="https://rollingstarky.github.io/tags/C/"/>
    
      <category term="big-O" scheme="https://rollingstarky.github.io/tags/big-O/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 使用 lineinfile 模块修改配置文件</title>
    <link href="https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/"/>
    <id>https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-11-16T14:33:03.362Z</updated>
    
    <content type="html"><![CDATA[<p>需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 <code>shell</code> 模块，<code>echo</code> 加 <code>&gt;&gt;</code> 就完事了。<br>但仔细一琢磨，很可能会引发一些意想不到的问题，比如：</p><ul><li>如果需要添加的配置已经存在，<code>echo</code> 仍会向配置文件底部添加同样的内容</li><li>如果添加配置的任务重复执行多次，则配置文件中也会多次出现重复的内容。无法做到<strong>幂等</strong></li><li>如何做到，当对应的配置已经存在，则将该配置改为期望的值；当对应的配置不存在，不做任何操作（有就修改，没有就不动。好像可以用 <code>sed</code>）</li><li>如何安全地移除指定的配置项</li></ul><p>诸如此类。运维工作常常要关系到生产环境。任何无法预期的效果都可能产生严重的影响。而单纯使用 <code>echo</code> 和 <code>&gt;&gt;</code> 向配置文件中添加内容，具有很大的不确定性。<br>当然可以形成一个 Shell 脚本，对各种边界进行足够的检查和判定，但这会导致代码量变大，结构复杂难以标准化；同时也容易出现遗漏的情况。</p><p>实际上 Ansible 内置的 <code>lineinfile</code> 就是专门用来处理上述任务的模块。</p><p>比如针对如下内容的配置文件 <code>test_conf.ini</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>需要添加一行配置 <code>THIRD=3</code>。</p><p>可以运行如下内容的 playbook <code>change_config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">THIRD=3</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>lineinfile</code> 模块的 <code>path</code> 参数用于指定目标配置文件的路径；<code>regexp</code> 参数则用于指定对文件内容进行匹配时使用的正则表达式；最后的 <code>line</code> 参数表示希望在目标文件中出现的内容。</p><p>具体的步骤为：</p><ul><li>检查 <code>line</code> 对应的内容是否存在于 <code>path</code> 对应的目标文件中</li><li>若已经存在。则目标文件符合要求，不对该文件做任何操作</li><li>若不存在。通过 <code>regexp</code> 指定的正则表达式对目标文件进行匹配</li><li>若 <code>regexp</code> 匹配到文本行，则将该行内容修改为 <code>line</code> 指定的内容</li><li>若 <code>regexp</code> 未匹配到文本行，则将 <code>line</code> 对应的内容作为新的一行添加到目标文件末尾</li></ul><p>运行效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>此时 <code>test_conf.ini</code> 配置文件的内容被修改为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>若再次运行 <code>ansible-playbook change_config.yml</code> 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">ok: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>可以看到修改配置文件的任务执行结果为 <code>ok</code>，而不同于上一次的 <code>changed</code>。这表示 <code>lineinfile</code> 模块对配置文件的内容进行了检查，发现需要添加的配置行已经存在，因此未做任何改动。符合<strong>幂等</strong>的原则。</p><p>假如将配置文件中的 <code>THIRD=3</code> 改为 <code>THIRD=false</code>，再次运行 playbook：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>正则表达式 <code>^THIRD</code> 会匹配到配置文件的第三行 <code>THIRD=false</code>，再将该行内容替换为 <code>THIRD=3</code>。</p><p>最终仍可以得到我们想要的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>对于 Ansible playbook 而言，我们只需要关注<strong>期望达到的状态</strong>，而不用纠结<strong>为了达到该状态需要执行哪些步骤</strong>。<br>如 <code>lineinfile</code> 模块，<code>line</code> 指定的内容即为我们期望目标文件达到的状态。即该文件最终一定会包含一行与 <code>line</code> 相同的文本。<br>不管该行内容是本就已经存在的，还是通过修改 <code>regexp</code> 匹配到的文本行得到的，还是直接在目标文件末尾新增的。而我们只需要定义 <code>path</code>、<code>regexp</code>、<code>line</code> 三个参数即可。</p><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><h5 id="backrefs"><a href="#backrefs" class="headerlink" title="backrefs"></a>backrefs</h5><p><code>lineinfile</code> 默认的行为是若 <code>line</code> 指定的内容未存在，<code>regexp</code> 正则表达式也没有任何匹配，就在文件末尾添加一行 <code>line</code> 指定的内容。<br><code>backrefs</code> 参数可以修改此行为。当 <code>backrefs</code> 设定为 <code>true</code> 时，若 <code>line</code> 指定的内容不存在，正则表达式也没有匹配。则不做任何操作。</p><p>比如如下 playbook：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'THIRD=3'</span></span><br><span class="line"><span class="attr">        backrefs:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>当目标文件的内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>playbook 实际不会对其做任何修改，不会在文件末尾添加 <code>THIRD=3</code>。只有当文件中存在如 <code>THIRD=false</code> 这类内容时，playbook 才会完成匹配并替换对应的行。</p><p>没有 <code>backrefs</code> 表示匹配就替换，不匹配就在文件末尾添加；有 <code>backrefs</code> 表示匹配就替换，不匹配就不动。</p><h5 id="删除一行内容"><a href="#删除一行内容" class="headerlink" title="删除一行内容"></a>删除一行内容</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">absent</span></span><br></pre></td></tr></table></figure><h5 id="在匹配行前-后添加"><a href="#在匹配行前-后添加" class="headerlink" title="在匹配行前/后添加"></a>在匹配行前/后添加</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertbefore:</span> <span class="string">'^FIRST'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'ZERO=false'</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertafter:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'FOURTH=4'</span></span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><ul><li>当 <code>line</code> 指定的内容已经存在于目标文件中时，不管其具体在什么位置，目标文件都不会做任何修改</li><li>当 <code>insertbefore</code> 或 <code>insertafter</code> 指定的正则表达式没有任何匹配时，都会在文件末尾添加 <code>line</code> 指定的内容</li></ul><h4 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a>官网示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">SELinux</span> <span class="string">is</span> <span class="string">set</span> <span class="string">to</span> <span class="string">enforcing</span> <span class="string">mode</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/selinux/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^SELINUX='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">SELINUX=enforcing</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Make</span> <span class="string">sure</span> <span class="string">group</span> <span class="string">wheel</span> <span class="string">is</span> <span class="string">not</span> <span class="string">in</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">configuration</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">absent</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%wheel'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">with</span> <span class="string">our</span> <span class="string">own</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^127\.0\.0\.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">searching</span> <span class="string">for</span> <span class="string">a</span> <span class="string">literal</span> <span class="string">string</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">escaping</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">default</span> <span class="string">Apache</span> <span class="string">port</span> <span class="string">is</span> <span class="number">8080</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^Listen '</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^#Listen '</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">Listen</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">php</span> <span class="string">extension</span> <span class="string">matches</span> <span class="string">new</span> <span class="string">pattern</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'&lt;FilesMatch ".php[45]?$"&gt;'</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^\t&lt;Location \/&gt;\n'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'        &lt;FilesMatch ".php[34]?$"&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">we</span> <span class="string">have</span> <span class="string">our</span> <span class="string">own</span> <span class="string">comment</span> <span class="string">added</span> <span class="string">to</span> <span class="string">/etc/services</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/services</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^# port for http'</span></span><br><span class="line"><span class="attr">    insertbefore:</span> <span class="string">'^www.*80/tcp'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'# port for http by default'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Add</span> <span class="string">a</span> <span class="string">line</span> <span class="string">to</span> <span class="string">a</span> <span class="string">file</span> <span class="string">if</span> <span class="string">the</span> <span class="string">file</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist,</span> <span class="string">without</span> <span class="string">passing</span> <span class="string">regexp</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/testfile</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.99</span> <span class="string">foo.lab.net</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    create:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Yaml requires escaping backslashes in double quotes but not in single quotes</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">JBoss</span> <span class="string">memory</span> <span class="string">settings</span> <span class="string">are</span> <span class="string">exactly</span> <span class="string">as</span> <span class="string">needed</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/opt/jboss-as/bin/standalone.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^(.*)Xms(\d+)m(.*)$'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'\1Xms$&#123;xms&#125;m\3'</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Validate</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">file</span> <span class="string">before</span> <span class="string">saving</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%ADMIN ALL='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'%ADMIN ALL=(ALL) NOPASSWD: ALL'</span></span><br><span class="line"><span class="attr">    validate:</span> <span class="string">/usr/sbin/visudo</span> <span class="bullet">-cf</span> <span class="string">%s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3/library/re.html for further details on syntax</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Use</span> <span class="string">backrefs</span> <span class="string">with</span> <span class="string">alternative</span> <span class="string">group</span> <span class="string">syntax</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">conflicts</span> <span class="string">with</span> <span class="string">variable</span> <span class="string">values</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">^(host=).*</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">\g&lt;1&gt;&#123;&#123;</span> <span class="string">hostname</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/lineinfile_module.html" target="_blank" rel="noopener">ansible.builtin.lineinfile – Manage lines in text files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 &lt;code&gt;shell&lt;/code&gt; 模块，&lt;code&gt;echo&lt;/code&gt; 加 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 就完事了。&lt;br&gt;但仔细一琢磨，很可能会引发一些意想不
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Ansible" scheme="https://rollingstarky.github.io/tags/Ansible/"/>
    
      <category term="Devops" scheme="https://rollingstarky.github.io/tags/Devops/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（Queue）</title>
    <link href="https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/"/>
    <id>https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:08:25.436Z</updated>
    
    <content type="html"><![CDATA[<h4 id="借助-Queue-实现多线程间的协同"><a href="#借助-Queue-实现多线程间的协同" class="headerlink" title="借助 Queue 实现多线程间的协同"></a>借助 Queue 实现多线程间的协同</h4><h5 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h5><p>并行地执行多个任务的 Python 程序通常都需要一种协作机制，使得多个线程负责的各部分之间的工作能够相互协同。<br>其中一种协作机制称为<strong>管线</strong>（<em>pipeline</em>）。pipeline 的工作方式类似于工厂里的流水线，分为串行排列的多道工序（<em>phase</em>）。每道工序都由特定的函数处理，函数之间可以并行地执行。</p><p>比如需要创建这样一个系统，可以从相机接收持续的图片流，再将收到的图片更改尺寸，最后上传到线上的图片库中。<br>这样的系统就可以分为三道工序，分别用 <code>download</code>、<code>resize</code>、<code>upload</code> 三个函数去处理。此外还需要一个在各道工序间传递任务对象的媒介，这个可以通过线程安全的 <strong>producer-consumer</strong> 队列去实现。</p><p>具体的示例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items = deque()</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> self.items.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line">        self.polled_count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># self.work_done = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            self.polled_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = self.in_queue.get()</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = self.func(item)</span><br><span class="line">                self.out_queue.put(result)</span><br><span class="line">                <span class="comment"># self.work_done += 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = MyQueue()</span><br><span class="line">resize_queue = MyQueue()</span><br><span class="line">upload_queue = MyQueue()</span><br><span class="line">done_queue = MyQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    Worker(download, download_queue, resize_queue),</span><br><span class="line">    Worker(resize, resize_queue, upload_queue),</span><br><span class="line">    Worker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(done_queue.items) &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">processed = len(done_queue.items)</span><br><span class="line">polled = sum(t.polled_count <span class="keyword">for</span> t <span class="keyword">in</span> threads)</span><br><span class="line">print(<span class="string">f'Processed <span class="subst">&#123;processed&#125;</span> items after '</span></span><br><span class="line">      <span class="string">f'polling <span class="subst">&#123;polled&#125;</span> times'</span>)</span><br><span class="line"><span class="comment"># Processed 100 items after polling 308 times</span></span><br></pre></td></tr></table></figure></p><p>上述实现虽然能够处理完成输入的所有任务，但仍存在很多问题。<br>首先是 <code>polled_count</code> 值远大于任务的数量。即工作线程的 <code>run</code> 方法中定义的从队列中取项目的动作执行了太多次。<br>各个工作函数的执行速度其实是不一致的，前置位的工作函数（比如 <code>download</code>）运行缓慢，会导致后一道工序（比如 <code>resize</code>）上的函数持续不断的向其队列请求新的任务，然而队列为空导致不断地触发 <code>IndexError</code> 错误，最终导致 CPU 时间的浪费。</p><p>其次，确认所有任务是否全部完成，需要一个 <code>while</code> 循环不断地检查 <code>done_queue</code> 队列中元素的数量。</p><p>再次，工作线程中的 <code>run</code> 方法会一直处于 <code>while True</code> 的循环当中，没有一种明显的方法可以向该工作线程发送任务完成可以退出的消息。</p><p>最后，当第一道工序执行很快而第二道工序执行很慢时，处于两道工序之间的队列中的元素数量会持续增长。如果有足够多的任务和足够长的时间，程序最终会耗尽内存并崩溃。</p><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>内置的 <code>queue</code> 模块中的 <code>Queue</code> 类可以解决上述问题。</p><p><code>Queue</code> 类中的 <code>get</code> 方法是阻塞的，即在有新的项目放置到队列中以前，<code>get</code> 会一直处于等待状态，直到获取到某个项目。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">my_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>即便线程先于主程序运行，它也会先处于等待状态，直到一个新的项目被放置到队列中，能够被 <code>get</code> 获取到。<br>这可以解决前面的程序中 <code>polled_count</code> 值过大的问题。</p><p><code>Queue</code> 类可以指定 buffer size，从而限制了两道工序间 pending 的任务的最大数量。即队列中的元素数量达到最大值后，向队列中放入新元素的 <code>put</code> 方法会阻塞，等待队列中某个元素被消耗从而为新元素腾出空间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">my_queue = Queue(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 1'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 2'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 1'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 2'</span>)</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Producer put 1</span></span><br><span class="line"><span class="comment"># Consumer got 1</span></span><br><span class="line"><span class="comment"># Producer put 2</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer got 2</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>Consumer 线程中的 <code>sleep</code> 应该使得主程序有足够的时间将两个对象都放置到队列中。但队列的大小是 1，就导致队列中先放入的元素必须通过 <code>get</code> 方法取出之后，才能继续使用 <code>put</code> 方法放置新的元素进去。<br>即 Producer 会等待 Consumer 线程把放置到队列中的旧元素消耗掉，才能继续向队列中添加新的元素。</p><h5 id="task-done"><a href="#task-done" class="headerlink" title="task_done"></a>task_done</h5><p><code>Queue</code> 类可以使用其 <code>task_done</code> 方法来追踪任务的进度，使得程序可以确保在某个特定的时间点，队列中的所有任务都已经被处理完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    work = in_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer working'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line">    in_queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">in_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer waiting'</span>)</span><br><span class="line">in_queue.join()</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer waiting</span></span><br><span class="line"><span class="comment"># Consumer working</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br></pre></td></tr></table></figure></p><p>在代码中调用 <code>in_queue.join()</code> 后，只有队列 <code>in_queue</code> 中的所有元素都执行了一遍 <code>task_done</code>（即有几个元素就需要几条 <code>task_done</code>），<code>in_queue.join()</code> 之后的代码才会执行。否则就继续等待，直到 Consumer 调用了足够次数的 <code>task_done</code>。</p><p>结合前面提到的特性，可以创建一个新的 <code>Queue</code> 类，它能够告知工作线程什么时候该停止执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br></pre></td></tr></table></figure></p><p>更新后的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    StoppableWorker(download, download_queue, resize_queue),</span><br><span class="line">    StoppableWorker(resize, resize_queue, upload_queue),</span><br><span class="line">    StoppableWorker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">download_queue.close()</span><br><span class="line">download_queue.join()</span><br><span class="line">resize_queue.close()</span><br><span class="line">resize_queue.join()</span><br><span class="line">upload_queue.close()</span><br><span class="line">upload_queue.join()</span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><p>逻辑上就是给 <code>Queue</code> 类加了一个 <code>SENTINEL</code> 对象，用来作为队列结束的标志。工作线程通过循环读取输入队列中的任务，这些任务对象经过特定函数处理后放置到输出队列中。若读取到的任务是 <code>SENTINEL</code> 对象，则线程结束运行。</p><p><code>task_done</code> 方法和主程序中的 <code>xxx_queue.join</code> 用于确保某个队列中的所有任务都已经处理完成，转移到了下一个队列中。后面再调用下一个队列的 <code>close</code> 方法在该队列尾部添加一个 <code>SENTINEL</code> 对象，作为队列的结束标志。</p><p>上述实现的好处在于，工作线程会在读取到 <code>SENTINEL</code> 对象时自动结束运行；主程序中 <code>upload_queue.join()</code> 执行结束后就能保证三个阶段的所有任务都被处理完了，而不再需要频繁地去检查 <code>done_queue</code> 中的元素数量。</p><h5 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h5><p>当需要对不同的阶段（<code>download</code>、<code>resize</code>、<code>upload</code>）都分别绑定多个线程去处理时，只稍微修改下代码就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_threads</span><span class="params">(count, *args)</span>:</span></span><br><span class="line">    threads = [StoppableWorker(*args) <span class="keyword">for</span> _ <span class="keyword">in</span> range(count)]</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">return</span> threads</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_threads</span><span class="params">(closable_queue, threads)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> threads:</span><br><span class="line">        closable_queue.close()</span><br><span class="line"></span><br><span class="line">    closable_queue.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">download_threads = start_threads(</span><br><span class="line">    <span class="number">3</span>, download, download_queue, resize_queue)</span><br><span class="line">resize_threads = start_threads(</span><br><span class="line">    <span class="number">4</span>, resize, resize_queue, upload_queue)</span><br><span class="line">upload_threads = start_threads(</span><br><span class="line">    <span class="number">5</span>, upload, upload_queue, done_queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">stop_threads(download_queue, download_threads)</span><br><span class="line">stop_threads(resize_queue, resize_threads)</span><br><span class="line">stop_threads(upload_queue, upload_threads)</span><br><span class="line"></span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>Pipeline 可以很好地组织流水线类型的工作，尤其是 IO 相关的 Python 多线程程序</li><li>需要特别注意构建 pipeline 时的隐藏问题：怎样告诉工作线程终止运行、busy waiting 以及潜在的内存爆炸等</li><li><code>Queue</code> 类具备构建健壮的 pipeline 所需的特性，如阻塞式操作、buffer size 和 joining 等。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;借助-Queue-实现多线程间的协同&quot;&gt;&lt;a href=&quot;#借助-Queue-实现多线程间的协同&quot; class=&quot;headerlink&quot; title=&quot;借助 Queue 实现多线程间的协同&quot;&gt;&lt;/a&gt;借助 Queue 实现多线程间的协同&lt;/h4&gt;&lt;h5 id=&quot;P
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Queue" scheme="https://rollingstarky.github.io/tags/Queue/"/>
    
      <category term="Pipeline" scheme="https://rollingstarky.github.io/tags/Pipeline/"/>
    
      <category term="Producer" scheme="https://rollingstarky.github.io/tags/Producer/"/>
    
      <category term="Consumer" scheme="https://rollingstarky.github.io/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>Vim 技巧 —— 实现多行注释的几种方法</title>
    <link href="https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/"/>
    <id>https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:12:59.653Z</updated>
    
    <content type="html"><![CDATA[<p>习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。<br>于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。</p><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>命令模式下可以使用 <code>:s/old/new</code> 替换当前文本行中的指定字符串。前面还可以加上数字等用来指定范围。如：</p><ul><li><code>:n1,n2 s/old/new</code>：从 <code>n1</code> 行开始，到 <code>n2</code> 行结束，将每一行中符合 <code>old</code> 模式的内容替换为 <code>new</code></li><li><code>:% s/old/new</code>：将整个文件中的 <code>old</code> 替换为 <code>new</code></li></ul><p>类似于 Vim 中内置了一个 <code>sed</code> 工具。</p><p>对于 Python 代码，注释代码块当然可以用双 <code>&#39;&#39;&#39;</code>，临时的注释我个人比较偏向行首加 <code>#</code>。借助字符串替换可以很方便的实现。命令如下：<br><code>:n1,n2 s/^/#</code><br>将 <code>n1</code> 到 <code>n2</code> 行中的行首空白字符替换为 <code>#</code>，等同于在每一行行首插入 <code>#</code></p><p>对于如下 Python 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30ef29b5184224b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before replace"></p><p>在 Vim 中运行 <code>:1,3 s/^/#</code>，后，效果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from datetime import datetime</span></span><br><span class="line"><span class="comment"># import calendar</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>如果要取消注释，再运行如下命令即可：<br><code>:1,3 s/# /</code><br>将 1 - 3 行行首的 <code>#</code> 替换为空字符串（即移除行首的 <code>#</code>)</p><h5 id="visual-模式下指定文本范围"><a href="#visual-模式下指定文本范围" class="headerlink" title="visual 模式下指定文本范围"></a>visual 模式下指定文本范围</h5><p>如果不喜欢用数字行号指定施行替换的文本行，也可以在 Visual 模式下手动选择生效的文本范围。</p><p>Normal 模式下按键盘上的 <code>v</code> 键进入 visual 模式，然后就可以通过光标移动命令（如 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>、<code>{</code>、<code>}</code> 等）选中多行文本。</p><p>接着在命令模式下运行 <code>:&#39;&lt;,&#39;&gt; s/^/#</code> 即可在选中的文本上执行文本替换。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-161da4aa97379bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="select &amp; replace"></p><p>其中 <code>&#39;&lt;,&#39;&gt;</code> 即代表 visual 模式下选中的文本行。一般情况下，选中文本以后再按 <code>:</code> 进入命令模式，<code>&#39;&lt;,&#39;&gt;</code> 部分内容会自动补全。</p><h4 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h4><p>多行编辑指同时在多行文本中每一行的相同位置插入相同的内容。只需要编辑某一行文本，其他文本行就会自动进行同样的修改。</p><p>比如需要注释 Python 代码的前 3 行，就可以同时编辑这 3 行文本，在第一行行首插入 <code>#</code>，则前 3 行会同时被注释掉。</p><p>首先光标定位到第一行行首，按下键盘上的 <code>ctrl + v</code> 组合键（Windows 下可以用 <code>ctrl + q</code>）进入 Visual Block 模式，按两次 <code>j</code> 键下移光标，选中前三行的首字符。<br>再按下键盘上 <code>I</code>（大写）键进入插入模式，在第一行行首插入 <code>#</code> 字符。<br>按下 <code>Esc</code> 退出插入模式，则后两行行首也会自动插入 <code>#</code> 字符。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b302ab3a0626969b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VISUAL BLOCK"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e830dec31ab8eef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before Esc"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7546479fe2f06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="after Esc"></p><h4 id="录制-Macro"><a href="#录制-Macro" class="headerlink" title="录制 Macro"></a>录制 Macro</h4><p>Vim 中的<strong>宏</strong>（Macro）即一系列编辑操作的合集。<br>在 Vim 中，可以把需要重复执行的多步编辑操作录制下来，绑定到某个按键上。之后就可以按下 <code>@绑定的按键</code> 重复执行录制好的步骤。<br>有点像定义和调用函数。</p><p>使用 <code>q某按键</code> 开始录制宏，执行某些编辑操作后，再按下 <code>q</code> 结束录制。随后按下 <code>@某按键</code> 调用录制好的宏。</p><p>如需要注释前 3 行 Python 代码，则可以录制包含如下步骤的宏：</p><ul><li>在当前行的行首开始插入文本（<code>I</code>）</li><li>输入注释符号（<code>#</code>）</li><li>退出插入模式（<code>Esc</code>）</li><li>移动到下一行（<code>j</code>)</li></ul><p>上述宏中的操作步骤可以首尾相接，无限循环。即注释当前行，移动到下一行；注释当前行，移动到下一行。。。</p><p>具体的操作步骤如下：</p><ul><li>在 Normal 模式下，光标移动到首行，按下 <code>qq</code> 开始录制宏（录制结束后会绑定给 <code>q</code>）</li><li>按下 <code>I</code> 键（大写），进入行首插入模式</li><li>输入 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 移动光标到下一行文本</li><li>按下 <code>q</code> 结束宏的录制</li></ul><p>宏录制结束后，即可连按两次 <code>@q</code> 连续调用两次宏，分别注释第二行和第三行内容。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-397bc3a22c028f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recording macro"></p><h5 id="命令"><a href="#命令" class="headerlink" title=". 命令"></a><code>.</code> 命令</h5><p><code>.</code> 命令相当于一种简化了的宏。它表示重复应用上一步中对内容的更改。<br><code>.</code> 命令无需录制，但只会重复对内容的编辑（如插入、替换等），不会重复其他操作。<br>比如前面的需要注释 Python 代码的前三行，可以执行如下操作：</p><ul><li>光标定位到首行，按 <code>I</code>（大写）在行首插入内容</li><li>输入注释符号 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 跳转到下一行，按 <code>.</code> 重复执行对上一行的编辑操作（行首插入 <code>#</code>）</li><li>重复上一步操作（<code>j.</code>），注释第三行</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在查阅资料的时候，还发现一个 <code>norm</code> 命令。<br>比如还是需要注释前 3 行，可以执行如下命令：<br><code>:1,3 norm I #</code></p><p>其中 <code>1,3</code> 表示只对 1 - 3 行应用后面的命令；<br><code>norm</code> 表示从 Normal 模式下开始；<br><code>I #</code> 表示进入插入模式（同时光标移动到行首），插入文本 <code>#</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://stackoverflow.com/questions/9549729/vim-insert-the-same-characters-across-multiple-lines" target="_blank" rel="noopener">Vim: insert the same characters across multiple lines</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。&lt;br&gt;于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。&lt;/p&gt;
&lt;h4 id=&quot;字符串替换&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Tools" scheme="https://rollingstarky.github.io/tags/Tools/"/>
    
      <category term="Tricks" scheme="https://rollingstarky.github.io/tags/Tricks/"/>
    
      <category term="Vim" scheme="https://rollingstarky.github.io/tags/Vim/"/>
    
      <category term="Editor" scheme="https://rollingstarky.github.io/tags/Editor/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="Macro" scheme="https://rollingstarky.github.io/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（subprocess、Thread、Lock）</title>
    <link href="https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/"/>
    <id>https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-23T14:32:01.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用-subprocess-管理子进程"><a href="#使用-subprocess-管理子进程" class="headerlink" title="使用 subprocess 管理子进程"></a>使用 <code>subprocess</code> 管理子进程</h4><p>由 Python 启动的子进程能够以<strong>并行</strong>的方式运行，从而最大化地利用 CPU 的多个核心。</p><p>可以借助 <code>subprocess</code> 内置模块调用子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [<span class="string">'echo'</span>, <span class="string">'Hello from the child!'</span>],</span><br><span class="line">    capture_output=<span class="keyword">True</span>,</span><br><span class="line">    encoding=<span class="string">'utf-8'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result.check_returncode()</span><br><span class="line">print(result.stdout)</span><br><span class="line"><span class="comment"># =&gt; Hello from the child!</span></span><br></pre></td></tr></table></figure></p><p>子进程相对于其父进程是独立地运行的。<br>如果使用 <code>Popen</code> 类创建一个子进程处理某个任务，则主程序能够在处理其他任务的同时，通过轮询的方式定期查看子进程的状态，确认其是否已经终止运行。<br><code>Popen</code> 中的 <code>poll</code> 方法可以实时地检查子进程的运行状态。若子进程还在运行中，则返回 <code>None</code>；若子进程执行完毕，则返回一个 <em>returncode</em> 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">'Working...'</span>)</span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># Exit status 0</span></span><br></pre></td></tr></table></figure><p>解耦子进程与父进程使得父进程可以同时调用多个并行执行的子程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">sleep_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line">    sleep_procs.append(proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> sleep_procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Finished in <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># =&gt; Finished in 1.01 seconds</span></span><br></pre></td></tr></table></figure></p><p>代码中的 <code>communicate</code> 方法可以用来与子进程通信并等待其终止，此处用于等待所有的子进程执行完毕。<br>如果上述代码中的子进程以顺序的方式执行，最终整体的延迟会达到 10s 以上。而实际的延迟只略大于 1s，即多个子进程之间是并行的关系。</p><p>可以通过<strong>管道</strong>从 Python 程序向调用的子进程传递数据，并获取子进程的输出内容。<br>比如调用如下形式的 Shell 测试脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> input your name</span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> your name is <span class="variable">$name</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen(<span class="string">'bash name.sh'</span>,</span><br><span class="line">                        stdin=subprocess.PIPE,</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        shell=<span class="keyword">True</span>)</span><br><span class="line">proc.stdin.write(<span class="string">b'john'</span>)</span><br><span class="line">proc.stdin.flush()</span><br><span class="line"></span><br><span class="line">stdout, stderr = proc.communicate()</span><br><span class="line">print(stdout)</span><br><span class="line"><span class="comment"># b'input your name\nyour name is john\n'</span></span><br></pre></td></tr></table></figure><p>其中在初始化 <code>Popen</code> 对象时，传入了 <code>stdin=subprocess.PIPE</code> 和 <code>stdout=subprocess.PIPE</code> 两个参数，目的是将子进程的标准输入 STDIN 绑定到 <code>proc</code> 实例的 <code>stdin</code> 属性上，将标准输出 STDOUT 绑定到 <code>proc</code> 实例的 <code>stdout</code> 属性上。从而可以使用 <code>proc.stdin.write()</code> 方法向子进程传入数据。<br><code>proc</code> 实例的 <code>communicate</code> 方法会等待子进程终止，并返回 <code>stdout</code> 和 <code>stderr</code>，即子进程的标准输出和标准错误输出。<br>若初始化 <code>Popen</code> 时未传入 <code>stdout=subprocess.PIPE</code> 参数，则上面返回的 <code>stdout</code> 为 <code>None</code>。</p><p>如果担心子程序永远不会终止或者长时间阻塞了输入和输出，可以向 <code>communicate</code> 方法传入 <code>timeout</code> 参数来指定等待的最长时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'10'</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    proc.communicate(timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">    proc.terminate()</span><br><span class="line">    proc.wait()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Exit status -15</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul><li><code>subprocess</code> 模块可以调用子进程，且能够管理子进程的输入流和输出流，达到源程序与子进程交互的目的</li><li>子进程和 Python 解释器之间是并行运行的，因而可以最大化地利用 CPU 的多个核心</li><li><code>subprocess</code> 模块提供的 <code>run</code> 函数可以完成简单的调用操作，而 <code>Popen</code> 类提供了类似 Unix 管线的高级功能</li><li><code>communicate</code> 方法的 <code>timeout</code> 参数可以避免死锁及卡住的子进程</li></ul><h4 id="使用线程处理阻塞式-IO"><a href="#使用线程处理阻塞式-IO" class="headerlink" title="使用线程处理阻塞式 IO"></a>使用线程处理阻塞式 IO</h4><p>Python 的标准实现叫做 <strong>CPython</strong>。CPython 在运行 Python 程序时，会首先解析源代码并将其编译为字节码，再通过一个基于栈的解释器来运行字节码。<br>CPython 通过一种称为 <strong>GIL</strong> 的机制来管理解释器自身的状态信息，强化其一致性。GIL 是一种可以阻止 CPython 解释器受<strong>抢占式</strong>多线程影响的<strong>互斥锁</strong>（mutex），从而使控制程序的线程不会被另一个线程意外中断，导致解释器的状态发生混乱。</p><p>但 GIL 有一个非常严重的负面影响。不像 C++ 或 Java 等语言可以利用多线程最大化多核心 CPU 的计算能力，Python 虽然支持多线程，但 <strong>GIL 会导致任一时刻实际上都只能有一个线程在推进</strong>。<br>简单来说，Python 中的多线程不是<strong>并行</strong>计算，无法同时利用 CPU 的多个核心来提升<strong>计算密集型</strong>多任务的效率。</p><p>单线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    list(factorize(number))</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.19 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactorizeThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.number = number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.factors = list(factorize(self.number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    thread = FactorizeThread(number)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end -start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.3 seconds</span></span><br></pre></td></tr></table></figure></p><p>可以看出，Python 中的单线程和多线程在应对计算密集型任务时，两者的处理时间没有相差多少。</p><p>但是对于 <strong>IO 密集</strong> 型的任务，比如从磁盘读写文件、网络传输等<strong>阻塞式 IO</strong> 操作，使用 Python 中的多线程对于效率的提升就会非常显著。<br>多线程使得 CPU 不必去等待缓慢的文件读写等 IO 操作。</p><p>单线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    get_example_page()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.853585243225098 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target=get_example_page)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 0.8039891719818115 seconds</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h5><ul><li>由于 GIL 的存在，Python 中的线程无法并行地在多个 CPU 核心上执行</li><li>Python 中的多线程能够并行地发起多个系统调用，因而可以同时处理计算任务和阻塞式 IO</li></ul><h4 id="使用-Lock-避免数据竞争"><a href="#使用-Lock-避免数据竞争" class="headerlink" title="使用 Lock 避免数据竞争"></a>使用 Lock 避免数据竞争</h4><p>GIL 总是会阻止 Python 代码在多个 CPU 核心上并行执行，任意时刻都只能有一个 Python 线程处于活跃状态。<br>但 GIL 并不会保护代码不受数据竞争的影响。一个线程对于数据结构的操作仍有可能被 Python 解释器中邻近的字节码破坏，尤其是在通过多线程同步地去访问同一个对象的时候。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = Counter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 252472</span></span><br></pre></td></tr></table></figure></p><p>上述代码模拟了一个从传感器网络并行地读取数据并计数的过程。对任意一个传感器，其数据的读取都属于阻塞式 IO，由独立的工作线程去处理，数据读取完成后该工作线程会调用一个计数器对象来累计结果。</p><p>但程序运行后，实际得到的计数结果与预期差距很大。<br>Python 解释器在执行多个线程时会确保这些线程之间的“平等关系”，令它们获得几乎相等的处理时间。这因此需要 Python 时不时地在线程间进行切换，暂时挂起一个正在运行的线程，转而去恢复执行另一个线程。<br>一个线程甚至有可能在看似符合原子性的操作中间被暂停。</p><p>比如 <code>+=</code> 操作符在作用到实例的属性上时，类似这样的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter.count += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>实际上等同于 Python 做出如下所示的三个分开的步骤：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result = value + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result)</span><br></pre></td></tr></table></figure></p><p>再加上线程切换，就有可能导致出现下面这种情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running in Thread A</span></span><br><span class="line">value_a = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line"><span class="comment"># Context switch to Thread B</span></span><br><span class="line">value_b = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result_b = value_b + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_b)</span><br><span class="line"><span class="comment"># Context switch back to Thread A</span></span><br><span class="line">result_a = value_a + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_a)</span><br></pre></td></tr></table></figure></p><p>即原本应该计算两次的累加操作实际上只有一次生效了，最终导致出现错误的结果。</p><p>为避免上述情形中的数据竞争或者其他形式的数据结构损坏现象，可以借助 <code>Lock</code> 类保护特定的值不被多个线程同步访问。即任一时刻都只能有一个线程可以获得该数据的锁。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = LockingCounter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 500000</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><ul><li>Python 有 GIL，但在编写代码时仍需关注多线程中的数据竞争</li><li>允许多个线程修改同一个不加锁的对象，有可能会损坏数据结构</li><li><code>Lock</code> 类可以保护多线程中数据的一致性</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用-subprocess-管理子进程&quot;&gt;&lt;a href=&quot;#使用-subprocess-管理子进程&quot; class=&quot;headerlink&quot; title=&quot;使用 subprocess 管理子进程&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;subprocess&lt;/code&gt; 管理
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Process" scheme="https://rollingstarky.github.io/tags/Process/"/>
    
      <category term="Lock" scheme="https://rollingstarky.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——不安全 Rust</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:11:49.524Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 内部隐藏了一种不会强制实施内存安全保障的语言：<strong>不安全 Rust</strong>。<br>其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。<br>使用不安全代码的缺点在于程序员需要对自己的行为负责。若错误地使用了不安全代码，就可能引发不安全的内存问题，如空指针解引用等。</p><p>另一个原因在于底层计算机硬件固有的不安全性。若 Rust 不允许进行不安全的操作，则某些底层任务可能根本就完成不了。</p><p>不安全 Rust 允许你执行 4 种在安全 Rust 中不被允许的操作：</p><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现不安全 trait</li></ul><p>可以在代码块前使用关键字 <code>unsafe</code> 来切换到不安全模式。<code>unsafe</code> 关键字并不会关闭借用检查器或禁用任何其他 Rust 安全检查。<code>unsafe</code> 仅仅令你可以访问上述 4 种不会被编译器检查的特性。因此即便处于不安全的代码块中，也仍然可以获得一定程度的安全性。</p><p><code>unsafe</code> 并不意味着块中的代码一定就是危险的或一定会导致内存安全问题，它仅仅是将责任转移到了程序员的肩上。<br>通过对 4 种不安全操作标记上 <code>unsafe</code>，可以在出现内存相关的错误时快速地将问题定位到 <code>unsafe</code> 代码块中。<br><strong>应当尽量避免使用 <code>unsafe</code> 代码块</strong>。</p><p>为了尽可能地隔离不安全代码，可以将其封装在一个安全的抽象中并提供一套安全的 API。实际上某些标准库功能同样使用了不安全代码，并以此为基础提供了安全的抽象接口。</p><h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p>不安全 Rust 拥有两种类似于引用的新指针类型，都被叫做<strong>裸指针（raw pointer）</strong>。与引用类似，裸指针要么是可变的，要么是不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号 <code>*</code> 是类型名的一部分而不代表解引用操作。</p><p>裸指针与引用、智能指针的区别：</p><ul><li>允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针</li><li>不能保证自己总是指向了有效的内存地址</li><li>允许为空</li><li>没有实现任何自动清理机制</li></ul><p>在避免 Rust 强制执行某些保障后，就能够以放弃安全保障为代价换取更好的性能，或者与其他语言、硬件进行交互的能力。</p><p><strong>通过引用创建裸指针</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中并没有使用 <code>unsafe</code> 关键字。你可以在安全代码内合法地创建裸指针，但不能在不安全代码块外解引用裸指针。</p><p>创建一个指向任意内存地址的裸指针，这个地址可能有数据，也可能没有数据，因此无法确定其有效性。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure></p><p>为了使用 <code>*</code> 解引用裸指针，需要添加一个 <code>unsafe</code> 块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用裸指针时，我们可以创建同时指向同一地址的可变指针和不可变指针，并通过可变指针来修改数据。这样的修改操作会导致潜在的数据竞争。<br>裸指针主要用来与 C 代码接口进行交互，或者构造一些借用检查器无法理解的安全抽象。</p><h4 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h4><p>除了在定义前面要标记 <code>unsafe</code>，不安全函数或方法看上去与正常的函数或方法几乎一模一样。<br>这里的 <code>unsafe</code> 关键字意味着我们需要在调用该函数时手动满足一些先决条件，因为 Rust 无法对这些条件进行验证。通过在 <code>unsafe</code> 代码块中调用不安全函数，我们向 Rust 表明自己确实理解并实现了相关约定。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    dangerous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为不安全函数的函数体也是 <code>unsafe</code> 代码块，你可以直接在一个不安全函数中执行其他不安全操作而无需添加额外的 <code>unsafe</code> 代码块。</p><h5 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" class="headerlink" title="创建不安全代码的安全抽象"></a>创建不安全代码的安全抽象</h5><p>函数中包含不安全代码并不意味着我们需要将整个函数都标记为不安全的。实际上，将不安全代码封装在安全函数中是一种十分常见的抽象。</p><p>比如标准库中使用了不安全代码的 <code>split_at_mut</code> 函数。这个安全方法被定义在可变切片上，它接收一个切片并从给定的索引参数处将其分割为两个切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = r.split_at_mut(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们无法仅仅使用安全 Rust 来实现这个函数。比如尝试用安全代码将 <code>split_at_mut</code> 实现为函数，并只处理 i32 类型的切片：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid], &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会首先取得整个切片的长度，并通过断言检查给定的参数是否小于或等于当前切片的长度。若大于则会在尝试使用该索引前触发 panic。<br>我们会返回一个包含两个可变切片的元组，一个从原切片的起始位置到 <code>mid</code> 索引的位置，另一个则从 <code>mid</code> 索引的位置到原切片的末尾。</p><p>尝试编译上述代码会触发 <code>error[E0499]: cannot borrow `*slice` as mutable more than once at a time</code> 错误。<br>Rust 的借用检查器无法理解我们正在借用一个切片的不同部分，它只知道我们借用了两次同一个切片。借用一个切片的不同部分从原理上来讲是没有任何问题的，因为没有交叉的地方。但 Rust 没有足够智能到理解这些信息。此类场景即适用于不安全代码。</p><p>使用 <code>unsafe</code>、裸指针及一些不安全函数实现 <code>split_at_mut</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line">    <span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (</span><br><span class="line">            slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">            slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = split_at_mut(r, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 unsafe 代码中，<code>slice::from_raw_parts_mut</code> 函数接收一个裸指针和长度来创建一个切片。这里使用该函数从 <code>ptr</code> 处创建了一个拥有 <code>mid</code> 个元素的切片，接着又在 <code>ptr</code> 上使用 <code>mid</code> 作为偏移量参数调用 <code>offset</code> 方法得到了一个从 <code>mid</code> 处开始的裸指针，并基于它创建了另外一个起始于 <code>mid</code> 处且拥有剩余所有元素的切片。</p><p>函数 <code>slice::from_raw_parts_mut</code> 接收一个裸指针作为参数并默认该参数的合法性，所以它是不安全的。裸指针的 <code>offset</code> 方法默认此地址的偏移量也是一个有效的指针，它也是不安全的。<br>因此我们必须在 <code>unsafe</code> 代码块中调用上述两个函数。通过审查代码并添加断言，我们可以确定 <code>unsafe</code> 中的裸指针都会指向有效的切片数据且不会产生数据竞争。这就是一个恰当的 <code>unsafe</code> 使用场景。</p><p>代码没有将 <code>split_at_mut</code> 函数标记为 <code>unsafe</code>，因此我们可以在安全 Rust 中调用该函数。这就是对不安全代码的安全抽象。</p><p>与上述代码相反，下面对 <code>slice::from_raw_parts_mut</code> 函数的调用就很有可能导致崩溃。其试图用一个随意的内存地址来创建拥有 10000 个元素的切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> address = <span class="number">0x01234usize</span>;</span><br><span class="line">    <span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = <span class="keyword">unsafe</span> &#123; slice::from_raw_parts_mut(r, <span class="number">10000</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 <code>extern</code> 函数调用外部代码</h5><p>Rust 代码可能需要与另外一种语言编写的代码进行交互。Rust 为此提供了 <code>extern</code> 关键字来简化创建和使用<strong>外部函数接口（FFI）</strong>的过程。<br>任何 <code>extern</code> 块中声明的函数都是不安全的。因为其他语言不会强制执行 Rust 遵守的规则，Rust 又无法对它们进行检查。因此保证安全的责任就落到了开发者身上。</p><p>下面的代码集成了 C 标准库中的 <code>abs</code> 函数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Absolute value of -3: &#123;&#125;"</span>, abs(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问或修改静态变量"><a href="#访问或修改静态变量" class="headerlink" title="访问或修改静态变量"></a>访问或修改静态变量</h4><p>Rust 支持全局变量，但在使用的过程中可能因为所有权机制而产生某些问题。如果两个线程同时访问同一个可变的全局变量，就会产生数据竞争。<br>全局变量也被称为<strong>静态（static）变量</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name is: &#123;&#125;"</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态变量必须要标注类型，访问一个不可变的静态变量是安全的。<br>静态变量的值在内存中拥有固定的地址，使用它的值总会访问到同样的数据。而常量则允许在任何被使用到的时候复制其数据。<br>与常量不同的是，静态变量是可变的。但访问和修改可变的静态变量是不安全的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，任何读写静态变量 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 代码块中。</p><h4 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h4><p>当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，我们就称这个 trait 是不安全的。可以在 trait 定义的前面加上 <code>unsafe</code> 关键字来声明一个不安全 trait，同时该 trait 也只能在 <code>unsafe</code> 代码块中实现。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 某些方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 对应的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过使用 <code>unsafe impl</code>，我们向 Rust 保证我们会手动维护好那些编译器无法验证的不安全因素。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 内部隐藏了一种不会强制实施内存安全保障的语言：&lt;strong&gt;不安全 Rust&lt;/strong&gt;。&lt;br&gt;其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。&lt;br&gt;使用不安全代码的缺点在于程序员需要对自己的行为负责。若
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
      <category term="Unsafe" scheme="https://rollingstarky.github.io/tags/Unsafe/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——面向对象编程</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:18:48.184Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象编程（OOP）</strong>是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。</p><p><strong>对象包含数据和行为</strong></p><p>面向对象的程序由对象构成。对象包装了数据和操作这些数据的流程（称作方法)。<br>基于这个定义，Rust 是面向对象的。比如结构体和枚举都可以包含数据，而 <code>impl</code> 块则提供了可用于结构体和枚举的方法。</p><h4 id="封装实现细节"><a href="#封装实现细节" class="headerlink" title="封装实现细节"></a>封装实现细节</h4><p>封装使得调用对象的外部代码无法直接访问对象内部的实现细节，而唯一可以与对象进行交互的方法便是通过它公开的接口。<br><strong>使用对象的代码不应当深入对象的内部去改变数据或行为，封装使得开发者在修改或重构对象的内部实现时无需改变调用这个对象的外部代码</strong>。</p><p>在 Rust 中，我们可以使用 <code>pub</code> 关键字来决定代码中哪些模块、类型、函数和方法是公开的，而默认情况下所有内容都是私有的。</p><p>如下面计算移动平均值的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AveragedCollection</span></span> &#123;</span><br><span class="line">    list: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">    average: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> AveragedCollection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.push(value);</span><br><span class="line">        <span class="keyword">self</span>.update_average();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.list.pop();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.update_average();</span><br><span class="line">                <span class="literal">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">average</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_average</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> total: <span class="built_in">i32</span> = <span class="keyword">self</span>.list.iter().sum();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.list.len() <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> collection = AveragedCollection &#123;</span><br><span class="line">        list: <span class="built_in">vec!</span>[],</span><br><span class="line">        average: <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    collection.add(<span class="number">1</span>);</span><br><span class="line">    collection.add(<span class="number">2</span>);</span><br><span class="line">    collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The average of the collection is: &#123;&#125;"</span>, collection.average());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先是定义了一个名为 <code>AveragedCollection</code> 的结构体，其 <code>list</code> 字段包含了一个存储 <code>i32</code> 元素的动态数组；为了避免每次取元素平均值的时候重复计算，又添加了一个用于存储平均值的 <code>average</code> 字段。<br>结构体本身被标记为 <code>pub</code> 使得其他代码可以使用它，但其内部字段仍然保持私有。<br>公共方法 <code>add</code>、<code>remove</code>、<code>average</code> 是仅有的几个可以访问或修改 <code>AveragedCollection</code> 实例中数据的方法。当用户调用 <code>add</code> 方法向 <code>list</code> 中添加元素，或者调用 <code>remove</code> 从 <code>list</code> 中删除元素时，方法内部的实现都会再调用私有方法 <code>update_average</code> 来更新 <code>average</code> 字段。</p><p>由于 <code>list</code> 和 <code>average</code> 字段是私有的，外部代码无法直接读取 <code>list</code> 字段来增加或删除其中的元素。<br>一旦缺少了这样的封装，<code>average</code> 字段便无法在用户私自更新 <code>list</code> 字段时同步保持更新。</p><p>因为结构体 <code>AveragedCollection</code> 封装了内部的实现细节，我们能够在未来轻松地改变数据结构等内部实现。比如可以在 <code>list</code> 字段上使用 <code>HashSet&lt;i32&gt;</code> 替代 <code>Vec&lt;i32&gt;</code>。<br>只要 <code>add</code>、<code>remove</code>、<code>average</code> 这几个公共方法的签名保持不变，正在使用 <code>AveragedCollection</code> 的外部代码就无需进行任何修改。<br>假如将 <code>list</code> 字段声明为 <code>pub</code>，就必然会失去上面这一优势。<code>HashSet&lt;i32&gt;</code> 和 <code>Vec&lt;i32&gt;</code> 在增加或删除元素时使用的具体方法是不同的，因此若直接修改 <code>list</code>，外部代码将不得不随之发生变化。</p><h4 id="作为类型系统和代码共享机制的继承"><a href="#作为类型系统和代码共享机制的继承" class="headerlink" title="作为类型系统和代码共享机制的继承"></a>作为类型系统和代码共享机制的继承</h4><p>继承机制使得对象可以沿用另一个对象的数据与行为，而无需重复定义代码。<br>Rust 中无法定义一个继承父结构体字段和方法的子结构体。</p><p>选择继承主要有两个原因。其一是代码复用，作为替代方案，可以使用 Rust 中的默认 <code>trait</code> 方法来进行代码共享。<br>它与继承十分相似，父类中实现的方法可以被继承它的子类所拥有；子类也可以选择覆盖父类中的方法。</p><p>另一个使用继承的原因与类型系统有关，希望子类型能够被应用到一个需要父类型的地方。即<strong>多态</strong>：<strong>如果一些对象具有某些共同的特征，则这些对象就可以在运行时相互替换使用</strong>。<br>可以在 Rust 中使用泛型来构建不同类型的抽象，并使用 <code>trait</code> 约束来决定类型必须提供的具体特性。这一技术被称为<strong>限定参数化多态</strong>。</p><p>许多较为新潮的语言已经不太喜欢将继承作为内置的程序设计方案，因为<strong>使用继承意味着你会无意间共享出比所需内容更多的代码</strong>。<br>子类并不应该总是共享父类的所有特性，但使用继承机制却会始终产生这样的结果，进而使程序设计缺乏灵活性。而某些语言强制要求子类只能继承自单个父类，进一步限制了程序设计的灵活性。</p><h4 id="使用-trait-对象来存储不同类型的值"><a href="#使用-trait-对象来存储不同类型的值" class="headerlink" title="使用 trait 对象来存储不同类型的值"></a>使用 trait 对象来存储不同类型的值</h4><p>动态数组有一个限制，即只能存储同一类型的元素。有些时候的变通方案可以使用枚举。<br>比如定义一个 <code>SpreadsheetCell</code> 枚举同时包含了可以持有整数、浮点数和文本的变体。这样我们就可以在每个表格中存储不同的数据类型，且依然能够用一个动态数组来表示一整行单元格。<br>但是总有某些时候，我们希望用户能够在特定的场景下为类型的集合进行扩展。</p><p>比如需要创建一个含有 GUI 库架构的 gui 包，并在包中提供一些可供用户使用的具体类型，如 <code>Button</code> 或 <code>TextField</code> 等，这些类型都实现了 <code>draw</code> 方法用于支持将其绘制到屏幕中。<br>此外，gui 的用户也应当能够创建支持绘制的自定义类型，如某些开发者可能会添加 <code>Image</code>，另一些可能会添加 <code>SelectBox</code> 等。<br>在那些支持继承的语言中，我们可以定义出一个拥有 <code>draw</code> 方法的 <code>Component</code> 类。其他如 <code>Button</code>、<code>Image</code>、<code>SelectBox</code> 等则都需要继承 <code>Component</code> 类来获得 <code>draw</code> 方法。<br>当然也可以选择覆盖 <code>draw</code> 方法来实现自定义行为，但框架会在处理过程中将它们全部视作 <code>Component</code> 类型的实例，并以此调用 <code>draw</code> 方法。</p><h5 id="为共有行为定义一个-trait"><a href="#为共有行为定义一个-trait" class="headerlink" title="为共有行为定义一个 trait"></a>为共有行为定义一个 trait</h5><p>Rust 没有继承功能。<br>为了在 gui 中实现预期的功能，需要定义一个拥有 <code>draw</code> 方法的 <code>Draw</code> trait。trait 对象可以被用在泛型或具体类型所处的位置，无论我们在哪里使用 trait 对象，Rust 类型系统都会在编译时确保出现在相应位置上的值实现了 trait 对象中的指定方法。</p><p>Rust 有意避免将结构体和枚举称为对象，以便于与其他语言中的对象区别开。<strong>对于结构体和枚举而言，其字段中的数据与 <code>impl</code> 块中的行为是分开的；而在其他语言中，数据和行为往往被组合在名为对象的概念中</strong>。<br>trait 对象则有些类似于其他语言中的对象，它也在某种程度上组合了数据和行为。但 trait 对象被专门用于抽象某些共有行为，没有其他语言中的对象那么通用。</p><p>创建一个名为 <code>gui</code> 的 Rust 项目：<br><code>cargo new gui</code></p><p>在 <code>lib.rs</code> 中定义一个拥有 <code>draw</code> 方法的 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个持有 <code>components</code> 动态数组的 <code>Screen</code> 结构体，代码中的 <code>Box&lt;dyn Draw&gt;</code> 代表所有被放置在 <code>Box</code> 中且实现了 Draw trait 的具体类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Screen</code> 结构体定义了一个名为 <code>run</code> 的方法，会逐一调用 <code>components</code> 中每个元素的 <code>draw</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> Screen &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="实现-trait"><a href="#实现-trait" class="headerlink" title="实现 trait"></a>实现 trait</h5><p>在代码中添加一些实现了 Draw trait 的具体类型。需要注意的是，<code>draw</code> 方法不会包含任何有意义的内容，仅作为演示：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> height: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> label: <span class="built_in">String</span>, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a button, the button's label is &#123;&#125;"</span>, <span class="keyword">self</span>.label);</span><br><span class="line">        <span class="comment">// 实际绘制一个按钮的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Button</code> 中持有的 <code>width</code>、<code>height</code> 和 <code>label</code> 字段也许会不同于其他组件中的字段，比如 <code>TextField</code> 类型就可能在这些字段外额外持有一个 <code>placeholder</code> 字段。<br>每一个希望绘制在屏幕上的类型都应当实现 Draw trait，并在 <code>draw</code> 方法中使用不同的代码来自定义具体的绘制行为。<br>除了实现 Draw trait，<code>Button</code> 类型也许会在另外的 <code>impl</code> 块中实现响应用户点击按钮时的行为，这些方法并不适用于 <code>TextField</code> 等其他类型。</p><p>用户也可以在 <code>main.rs</code> 中为<code>SelectBox</code> 这种自定义类型实现 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">    options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a selectbox, the options are &#123;:?&#125;"</span>, <span class="keyword">self</span>.options);</span><br><span class="line">        <span class="comment">// 实际绘制一个选择框的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时就可以在编写 <code>main</code> 函数的时候创建 <code>Screen</code> 实例了。使用 <code>Box&lt;T&gt;</code> 生成 <code>SelectBox</code> 或 <code>Button</code> 的 trait 对象，再将它们添加到 <code>Screen</code> 实例中。便可以运行 <code>Screen</code> 实例的 <code>run</code> 方法来依次调用所有组件的 <code>draw</code> 实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> scrren = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">Box</span>::new(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Yes"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Maybe"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"No"</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="built_in">Box</span>::new(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="built_in">String</span>::from(<span class="string">"OK"</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">    scrren.run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; Drawing a selectbox, the options are ["Yes", "Maybe", "No"]</span></span><br><span class="line"><span class="comment">// =&gt; Drawing a button, the button's label is OK</span></span><br></pre></td></tr></table></figure></p><p>我们在编写库的时候无法得知用户是否会添加自定义的 <code>SelectBox</code> 类型，但我们的 <code>Screen</code> 实现依然能够接收新的类型并完成绘制工作。因为 <code>SelectBox</code> 实现了 Draw trait 及其 <code>draw</code> 方法。</p><p><code>run</code> 方法只关心值对行为的响应，而不在意值的具体类型。这一概念与动态类型中的 <strong>duck typing</strong> 十分相似。<br>通过在定义动态数组 <code>components</code> 时指定 <code>Box&lt;dyn Draw&gt;</code> 元素类型，<code>Screen</code> 实例只会接收那些能够调用 <code>draw</code> 方法的值，而不会去检查该值究竟是 <code>Button</code> 实例还是 <code>SelectBox</code> 实例。</p><p>使用 trait 对象与类型系统实现 duck typing 的优势在于，不需要在运行时检查某个值是否实现了指定的方法，或者担心出现调用未定义方法等运行时错误。Rust 会在编译时发现这类错误。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;面向对象编程（OOP）&lt;/strong&gt;是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象包含数据和行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向对象的程序由对象构成。对象包装了数据和操作这些数据
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Trait" scheme="https://rollingstarky.github.io/tags/Trait/"/>
    
      <category term="Encapsulation" scheme="https://rollingstarky.github.io/tags/Encapsulation/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Polymorphism" scheme="https://rollingstarky.github.io/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——并发</title>
    <link href="https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/"/>
    <id>https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-07-28T16:58:34.590Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发编程（concurrent programming）</strong>允许程序中的不同部分相互独立地运行，而<strong>并行编程（parallel programming）</strong>则允许程序中的不同部分同时执行。<br>Rust 中的所有权和类型系统能够同时帮助开发者管理内存安全及并发问题。</p><p>高级语言往往通过放弃部分控制能力来获得有益于用户的抽象，因此只支持全部解决方案的一部分是可以理解的设计策略。比如 Erlang 提供了一套优雅的消息传递并发特性，但没有提供可以在线程间共享状态的简单方法。<br>底层语言被期望在任意场景下都可以提供一套性能最佳的解决方案，并对硬件建立尽可能少的抽象，因此 Rust 提供了多种建模并发问题的工具。</p><h4 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h4><p>多个线程可以同时运行，因此将程序中的计算操作拆分至多个线程可以提高性能。但也增加了程序的复杂度，因为<strong>不同线程在执行过程中的具体顺序是无法确定的</strong>。可能导致下列问题：</p><ul><li>当多个线程以不一致的顺序访问数据或资源时产生的<strong>竞争状态（race condition）</strong></li><li>当两个线程同时尝试获取对方持有的资源时产生的<strong>死锁（deadlock）</strong>，会导致这两个线程都无法继续运行</li><li>只会出现在特定情形下且难以稳定复现和修复的 bug</li></ul><h5 id="使用-spawn-创建新线程"><a href="#使用-spawn-创建新线程" class="headerlink" title="使用 spawn 创建新线程"></a>使用 <code>spawn</code> 创建新线程</h5><p>可以调用 <code>thread::spawn</code> 函数来创建线程，它接收一个闭包作为参数，该闭包会包含我们想要在新线程中运行的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>主线程首先打印出了文本，即便新线程的打印语句出现得更早一些。这些线程可能会交替执行，执行顺序由操作系统的线程调度策略决定。<br>需要注意的是，只要上述程序中的主线程运行结束，创建出的新线程也会停止，不管其打印任务是否完成。<br>虽然我们要求新线程不停打印文本直到 <code>i</code> 迭代到 9，但它在主线程停止前仅迭代到了 5。</p><h5 id="使用-join-句柄等待所有线程结束"><a href="#使用-join-句柄等待所有线程结束" class="headerlink" title="使用 join 句柄等待所有线程结束"></a>使用 <code>join</code> 句柄等待所有线程结束</h5><p><code>thread::spawn</code> 的返回类型是一个自持有所有权的 <code>joinHandle</code>，调用它的 <code>join</code> 方法可以阻塞当前线程直到对应的新线程运行结束。</p><p>调用 <code>join</code> 方法保证新线程能够在 <code>main</code> 函数退出前执行完毕：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>假如将 <code>handle.join()</code> 放置到 <code>main</code> 函数的 <code>for</code> 循环之前，即：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，由于主线程会等待新线程执行完毕后才开始执行自己的 <code>for</code> 循环，程序的输出将不再出现交替的情形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 4 from the main thread!</span><br></pre></td></tr></table></figure></p><p>在并发编程中，诸如在哪里调用 <code>join</code> 等微小细节也会影响到多个线程是否能够同时运行。</p><h5 id="在线程中使用-move-闭包"><a href="#在线程中使用-move-闭包" class="headerlink" title="在线程中使用 move 闭包"></a>在线程中使用 <code>move</code> 闭包</h5><p><code>move</code> 闭包常被用来与 <code>thread::spawn</code> 函数配合使用，允许在某个线程中使用来自另一个线程的数据。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译上述代码时会报出 <code>error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</code> 错误。<br>Rust 在推导出如何捕获 <code>v</code> 后决定让闭包借用 <code>v</code>，因为闭包中的 <code>println!</code> 只需要使用 <code>v</code> 的引用。但 Rust 不知道新线程会运行多久，因此它无法确定 <code>v</code> 的引用是否一直有效。</p><p>通过在闭包前添加 <code>move</code> 关键字，会强制闭包获得它所需值的所有权，而不仅仅是基于 Rust 的推导来获得值的借用。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用消息传递在线程间转移数据"><a href="#使用消息传递在线程间转移数据" class="headerlink" title="使用消息传递在线程间转移数据"></a>使用消息传递在线程间转移数据</h4><p>使用消息传递（message passing）机制来保证并发安全正变得越来越流行。Go 语言文档中的口号正体现了这样的思路：<strong>不要通过共享内存来通信，而是通过通信来共享内存</strong>。</p><p>Rust 的标准库中实现了一个名为<strong>通道（channel）</strong>的编程概念，可以被用来实现基于消息传递的并发机制。<br>通道由发送者（transmitter）和接收者（receiver）两部分组成。发送者位于通道的上游，接收者位于下游。<br>某一处的代码可以通过调用发送者的方法来传送数据，另一处代码则可以通过检查接收者来获取数据。<br>当发送者或接收者的任何一端被丢弃，则相应的通道被关闭。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br></pre></td></tr></table></figure><p>上述代码使用 <code>mpsc::channel</code> 函数创建了一个新的通道。<strong>mpsc</strong> 是英文 <strong>multiple producer, single consum</strong>（多个生产者，单个消费者）的缩写。<br><code>mpsc::channel</code> 会返回一个含有发送端与接收端的元组。<br>再使用 <code>thread::spawn</code> 生成一个新线程。为了令新线程拥有发送端 <code>tx</code> 的所有权，使用 <code>move</code> 关键字将 <code>tx</code> 移动到了闭包的环境中。<br>新线程必须拥有通道发送端的所有权才能通过通道来发送消息。<br>发送端提供了 <code>send</code> 方法来处理我们想要发送的值，该方法会返回 <code>Result&lt;T, E&gt;</code> 类型作为结果。当接收端已经被丢弃而无法继续传递内容时，执行发送操作会返回一个错误。</p><p>通道的接收端有两个可用于获取消息的方法。其中 <code>recv</code> 会阻塞主线程的执行直到有值被传入通道。一旦有值传入通道，<code>recv</code> 就会将其包裹在 <code>Result&lt;T, E&gt;</code> 中返回。若通道的发送端全部关闭了，<code>recv</code> 会返回一个错误来表明当前通道再也没有可接收的值。<br><code>try_recv</code> 方法不会阻塞线程，它会立即返回 <code>Result&lt;T, E&gt;</code>。当通道中存在消息时，返回包含该消息的 <code>Ok</code> 变体；否则返回 <code>Err</code> 变体。可以编写一个不断调用 <code>try_recv</code> 方法的循环，并在有消息时对其进行处理，没有消息时执行其他指令。</p><h5 id="发送多个值"><a href="#发送多个值" class="headerlink" title="发送多个值"></a>发送多个值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure><p>上述代码会迭代新线程中的动态数组来逐个发送其中的字符串，并在每次发送后调用 <code>thread::sleep</code> 函数来稍作暂停。<br>在主线程中，我们会将 <code>rx</code> 视作迭代器，不再显式地调用 <code>recv</code> 函数。迭代中的代码会打印出每个接收到的值，并在通道关闭时退出循环。<br>代码执行时每次打印后都会出现 1 秒的时间间隔。但我们并没有在主线程的 <code>for</code> 循环中执行延迟指令，表明主线程确实在等待接收新线程中传递过来的值。</p><h5 id="通过克隆发送者创建多个生产者"><a href="#通过克隆发送者创建多个生产者" class="headerlink" title="通过克隆发送者创建多个生产者"></a>通过克隆发送者创建多个生产者</h5><p>通过克隆通道的发送端来创建出多个能够发送值到同一个接收端的线程：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"more"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"messages"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"for"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"you"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: more</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: messages</span></span><br><span class="line"><span class="comment">// =&gt; Got: for</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: you</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure></p><h4 id="共享状态的并发"><a href="#共享状态的并发" class="headerlink" title="共享状态的并发"></a>共享状态的并发</h4><p>从某种程度上来说，任何编程语言中的通道都有些类似于<strong>单一所有权</strong>的概念。因为用户不应该在值传递给通道后再次使用它。<br>基于共享内存的并发通信机制更类似于<strong>多重所有权</strong>概念，多个线程可以同时访问相同的内存地址。<br>我们可以通过智能指针实现多重所有权，但由于需要同时管理多个所有者，会为系统增加额外的复杂性。当然，Rust 的类型系统和所有权规则有助于正确地管理这些所有权。</p><h5 id="互斥体（mutex）"><a href="#互斥体（mutex）" class="headerlink" title="互斥体（mutex）"></a>互斥体（mutex）</h5><p><strong>互斥体在任意时刻只允许一个线程访问数据</strong>。为了访问互斥体中的数据，线程必须首先发出信号来获取互斥体的锁（lock）。<br>锁是互斥体的一部分，这种数据结构被用来记录当前谁拥有数据的唯一访问权。</p><p>关于互斥体必须牢记以下两条规则：</p><ul><li>必须在使用数据前尝试获取锁</li><li>必须在使用完互斥体守护的数据后释放锁，这样其他线程才能继续执行获取锁的操作</li></ul><p>在单线程环境中使用互斥体：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; m = Mutex &#123; data: 6 &#125;</span></span><br></pre></td></tr></table></figure></p><p>为了访问 <code>Mutex&lt;T&gt;</code> 实例中的数据，我们首先需要调用其 <code>lock</code> 方法来获取锁。此调用会阻塞当前线程直到我们取得锁为止。<br>当前线程对于 <code>lock</code> 函数的调用会在其他某个持有锁的线程发生 <code>panic</code> 时失败，因此上述代码选择使用 <code>unwrap</code> 在意外发生时触发当前线程的 <code>panic</code>。</p><p>一旦获取了锁，便可以将它的返回值 <code>num</code> 视作一个指向内部数据的可变引用。<br>Rust 的类型系统会确保我们在使用 <code>m</code> 的值之前执行加锁操作。因为 <code>Mutex&lt;i32&gt;</code> 并不是 <code>i32</code> 类型，我们必须获取锁才能使用其内部的 <code>i32</code> 值。</p><p>实际上对 <code>lock</code> 的调用会返回一个名为 <code>MutexGuard</code> 的智能指针。该智能指针通过实现 <code>Deref</code> 来指向存储在内部的数据，通过实现 <code>Drop</code> 完成自己离开作用域时的自动解锁操作。<br>这种释放过程会发生在内部作用域的结尾处，因此我们不会因为忘记释放锁而导致其他线程无法继续使用该互斥体。</p><h5 id="多个线程间共享-Mutex-lt-T-gt"><a href="#多个线程间共享-Mutex-lt-T-gt" class="headerlink" title="多个线程间共享 Mutex&lt;T&gt;"></a>多个线程间共享 <code>Mutex&lt;T&gt;</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Mutex::new(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次启动 10 个线程，并在每个线程中分别为共享的计数器的值加 1。<br>但代码目前无法通过编译，会报出 <strong>error[E0382]: use of moved value: <code>counter</code></strong> 错误。<br>原因是变量 <code>counter</code> 被移动进了 <code>handle</code> 指代的线程中，这一移动行为阻止我们在另一个线程中调用 <code>lock</code> 来再次捕获 <code>counter</code>。</p><h5 id="多线程与多重所有权"><a href="#多线程与多重所有权" class="headerlink" title="多线程与多重所有权"></a>多线程与多重所有权</h5><p>智能指针 <code>Rc&lt;T&gt;</code> 提供的引用计数能够为单个值赋予多个所有者。<br>现在尝试使用 <code>Rc&lt;T&gt;</code> 来包裹 <code>Mutex&lt;T&gt;</code>，并在每次需要移动所有权至线程时克隆 <code>Rc&lt;T&gt;</code>。看改进后的程序能否编译通过。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Rc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Rc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次尝试编译代码，报出另外一个错误：<code>error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。<br>原因是 <code>Rc&lt;T&gt;</code> 在跨线程使用时并不安全。<code>Rc&lt;T&gt;</code> 会在每次调用 <code>clone</code> 的过程中增加引用计数，在克隆出的实例被丢弃后减少引用计数。但它并没有使用任何并发原语来保证修改计数的过程中不会被另一个线程所打断。这极有可能导致计数错误并产生诡异的 bug。</p><h5 id="原子引用计数-Arc-lt-T-gt"><a href="#原子引用计数-Arc-lt-T-gt" class="headerlink" title="原子引用计数 Arc&lt;T&gt;"></a>原子引用计数 <code>Arc&lt;T&gt;</code></h5><p><code>Arc&lt;T&gt;</code> 类型既拥有类似于 <code>Rc&lt;T&gt;</code> 的行为，又保证自己可以被安全地用于并发场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Result: 10</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>Arc&lt;T&gt;</code> 替换掉代码中的 <code>Rc&lt;T&gt;</code> 后，代码可以编译通过。</p><p>需要注意的是，Rust 并不能使你完全避免使用 <code>Mutex&lt;T&gt;</code> 过程中所有的逻辑错误。使用 <code>Mutex&lt;T&gt;</code> 也会有产生死锁（deadlock）的风险。当某个操作需要同时锁住两个资源，而两个线程分别持有其中一个锁并相互请求另外一个锁时，这两个线程就会陷入无穷尽的等待过程。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;并发编程（concurrent programming）&lt;/strong&gt;允许程序中的不同部分相互独立地运行，而&lt;strong&gt;并行编程（parallel programming）&lt;/strong&gt;则允许程序中的不同部分同时执行。&lt;br&gt;Rust 中的所有权
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Deadlock" scheme="https://rollingstarky.github.io/tags/Deadlock/"/>
    
      <category term="Channel" scheme="https://rollingstarky.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——智能指针</title>
    <link href="https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/"/>
    <id>https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-07-26T15:34:22.264Z</updated>
    
    <content type="html"><![CDATA[<p><strong>指针（pointer）</strong>是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。<br>Rust 中最常见的指针是<strong>引用</strong>，会<strong>借用</strong>它所指向的数据。除此之外，引用没有任何其他功能和额外的开销。<br><strong>智能指针（smart pointer）</strong>是一种数据结构，它的行为类似于指针但<strong>拥有额外的元数据和附加功能</strong>。</p><p>在拥有所有权和借用概念的 Rust 中：<strong>引用只是用来借用数据的指针；而大多数智能指针本身就拥有它们指向的值</strong>。<br>比如 <code>String</code> 和 <code>Vec&lt;T&gt;</code> 类型就都可以被算作智能指针。它们都拥有一片内存区域并允许用户对其进行操作，拥有元数据（如容量等），能提供额外的功能或保障（如 <code>String</code> 会保证其中的数据必是合法的 <code>UTF-8</code> 编码）。</p><p>通常使用结构体来实现智能指针。区别于普通的结构体，智能指针会实现 <code>Deref</code> 与 <code>Drop</code> 这两个 <code>trait</code>。Deref trait 使得智能指针的实例拥有与引用一致的行为；Drop trait 使得用户可以自定义智能指针离开作用域时运行的代码。</p><p>标准库中最为常见的智能指针如下：</p><ul><li><code>Box&lt;T&gt;</code>：可用于在堆上分配数据</li><li><code>Rc&lt;T&gt;</code>：具备多重所有权的<strong>引用计数类型</strong></li><li><code>Ref&lt;T&gt;</code> 和 <code>ReMut&lt;T&gt;</code>：可以通过 <code>RefCell&lt;T&gt;</code> 访问，是一种可以在运行时而不是编译时执行借用规则的类型</li></ul><h4 id="使用-Box-lt-T-gt-在堆上分配数据"><a href="#使用-Box-lt-T-gt-在堆上分配数据" class="headerlink" title="使用 Box&lt;T&gt; 在堆上分配数据"></a>使用 <code>Box&lt;T&gt;</code> 在堆上分配数据</h4><p><strong>装箱（box）</strong>是最简单的一种智能指针，其类型为 <code>Box&lt;T&gt;</code>。它使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针。</p><p>装箱常被用于以下场景：</p><ul><li>拥有一个无法在编译时确定大小的类型，但又想在一个要求固定尺寸的上下文环境中使用这个类型</li><li>需要传递大量数据的所有权，但又不希望产生大量数据的复制行为</li><li>希望拥有一个实现了指定 trait 的类型值，但又不关心具体的类型</li></ul><p>使用装箱在堆上存储一个 <code>i32</code> 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将单一值存放在堆上没有太大用处，大部分情况下都可以将类似的单个 <code>i32</code> 值默认放置在栈上。</p><h5 id="使用装箱定义递归类型"><a href="#使用装箱定义递归类型" class="headerlink" title="使用装箱定义递归类型"></a>使用装箱定义递归类型</h5><p>Rust 必须在编译时知道每一种类型占据的空间大小，但有一种被称为<strong>递归</strong>的类型无法在编译时确定具体大小。<br>递归类型的值可以在自身中存储另一个相同类型的值，这种嵌套理论上可以无穷无尽地进行下去，根本无法计算出具体的空间大小。</p><p>链接列表（cons list）是一种在函数式语言中非常常见的数据类型。<code>cons</code> 函数会将两个参数组成一个二元组，而这个元组通常由一个值和另一个二元组组成，通过这种不断嵌套元组的形式最终组成一个列表。<br>使用枚举来定义一个链接列表：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码在编译时会报出 <code>error[E0072]: recursive type `List` has infinite size</code> 错误。</p><p>Rust 在计算枚举类型需要的空间大小时，会遍历枚举中的每一个成员来找到需要最大空间的那个变体。因为在每个时间点，只会有一个变体存在。<br>对于递归类型大小的计算，以前面的 <code>List</code> 为例，编译器会先检查 <code>Cons</code> 变体，它持有一个 <code>i32</code> 类型的值及另外一个 <code>List</code> 类型；为了确定此处<code>List</code> 的大小，编译器又会从 <code>Cons</code> 开始遍历其下的所有变体，这样的检查将永远进行下去。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-23761fd6dc9ac77d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="包含无穷多 Cons 变体的无穷 List"></p><p>可以使用 <code>Box&lt;T&gt;</code> 将递归类型的大小固定下来。<br><code>Box&lt;T&gt;</code> 是一个指针，其大小总是恒定的，不会因为指向数据的大小而发生变化。我们可以在 <code>Cons</code> 变体中存放一个 <code>Box&lt;T&gt;</code> 指针，<code>Box&lt;T&gt;</code> 指向下一个存储在堆上的 <code>List</code>。即嵌套的 <code>List</code> 并没有直接存放在 <code>Cons</code> 变体中，而是放置在堆上，打破了无限递归的过程。<br>此时任意的 <code>List</code> 值都只需要占用一个 <code>i32</code> 值加上一个装箱指针的大小。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-688437fa1045d8cb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Box in Cons"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装箱除了间接访问内存和堆分配，没有提供任何其他的特殊功能，也没有这些特殊功能附带的性能开销。因此正好能被用在类似于链接列表这类只是需要间接访问的场景中。</p><h4 id="通过-Deref-trait-将智能指针视作常规引用"><a href="#通过-Deref-trait-将智能指针视作常规引用" class="headerlink" title="通过 Deref trait 将智能指针视作常规引用"></a>通过 <code>Deref trait</code> 将智能指针视作常规引用</h4><p>实现 <code>Deref trait</code> 使我们可以自定义解引用运算符 <code>*</code> 的行为，这意味着原本用于处理引用的代码可以不加修改地用于处理智能指针。</p><h5 id="使用解引用跳转到指针指向的值"><a href="#使用解引用跳转到指针指向的值" class="headerlink" title="使用解引用跳转到指针指向的值"></a>使用解引用跳转到指针指向的值</h5><p>指针可以被理解为一种箭头，会指向存储在别处的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数字和引用是两种不同的类型，所以不能直接比较 <code>5</code> 和 <code>y</code>。必须使用 <code>*y</code> 来跳转到引用指向的值。</p><h5 id="把-Box-lt-T-gt-当成引用来操作"><a href="#把-Box-lt-T-gt-当成引用来操作" class="headerlink" title="把 Box&lt;T&gt; 当成引用来操作"></a>把 <code>Box&lt;T&gt;</code> 当成引用来操作</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>MyBox</code> 是一个拥有 <code>T</code> 类型的元组结构体，其关联函数 <code>MyBox::new</code> 接收一个 <code>T</code> 类型的参数，并返回一个存储有传入值的 <code>MyBox</code> 实例作为结果。</p><p>为了为 <code>MyBox&lt;T&gt;</code> 类型实现解引用功能，代码中实现了 <code>Deref trait</code>。<br>标准库中的 Deref trait 要求我们实现一个 <code>deref</code> 方法，该方法会借用 <code>self</code> 并返回一个指向内部数据的引用。<br><code>deref</code> 方法体中的 <code>&amp;self.0</code> 意味着 <code>deref</code> 会返回一个指向值的引用，进而允许调用者通过 <code>*</code> 运算符访问值。<br>代码中的 <code>*y</code> 会被 Rust 隐式地展开为 <code>*(y.deref())</code>。使得我们可以用完全相同的方式编写代码来处理常规引用及实现了 Deref trait 的类型。</p><h4 id="函数和方法的隐式解引用转换"><a href="#函数和方法的隐式解引用转换" class="headerlink" title="函数和方法的隐式解引用转换"></a>函数和方法的隐式解引用转换</h4><p>解引用转换是 Rust 为函数和方法的参数提供的一种编程特性。当某个类型 T 实现了 Deref trait 时，它能够将 T 的引用转换为 T 经过 Deref 操作后生成的引用。<br>当我们将某个类型的值引用作为参数传递给类型或方法，但传入的类型与参数类型不一致时，解引用转换就会自动发生。编译器会插入一系列的 deref 方法来将我们提供的类型转换为参数所需的类型。</p><p>解引用转换使程序员在调用函数或方法时无需多次显式地使用 <code>&amp;</code> 和 <code>*</code> 操作符来进行引用和解引用操作。我们因而可以更多地编写出能够同时作用于常规引用和智能指针的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;m</code> 是一个指向 <code>MyBox&lt;String&gt;</code> 值的引用。因为 <code>MyBox&lt;T&gt;</code> 实现了 Deref trait，Rust 可以通过调用 deref 将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>String</code>；因为标准库为 <code>String</code> 提供的 Deref 实现会返回字符串切片，所以 Rust 可以继续调用 deref 将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，最终与 <code>hello</code> 函数的定义匹配。</p><h5 id="解引用转换与可变性"><a href="#解引用转换与可变性" class="headerlink" title="解引用转换与可变性"></a>解引用转换与可变性</h5><p>使用 <code>Deref trait</code> 能够重载不可变引用的 <code>*</code> 运算符，使用 <code>DerefMut trait</code> 能够重载可变引用的 <code>*</code> 运算符。</p><p>Rust 会在类型与 trait 满足下面 3 种情况时执行解引用转换：</p><ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code></li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code></li></ul><h4 id="借助-Drop-trait-在清理时运行代码"><a href="#借助-Drop-trait-在清理时运行代码" class="headerlink" title="借助 Drop trait 在清理时运行代码"></a>借助 <strong>Drop trait</strong> 在清理时运行代码</h4><p>Drop trait 允许我们在变量离开作用域时执行某些自定义操作。可以为任意类型实现一个 Drop trait，它常常被用来释放诸如文件、网络连接等资源。<br>几乎每一种智能指针的实现都会用到这一 trait，比如 <code>Box&lt;T&gt;</code> 通过自定义 Drop 来释放装箱指针指向的堆内存空间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"my stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> d = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"other stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure><h5 id="使用-std-mem-drop-提前丢弃值"><a href="#使用-std-mem-drop-提前丢弃值" class="headerlink" title="使用 std::mem::drop 提前丢弃值"></a>使用 <code>std::mem::drop</code> 提前丢弃值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="built_in">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer dropped before the end of main</span></span><br></pre></td></tr></table></figure><h4 id="基于引用计数的智能指针-Rc"><a href="#基于引用计数的智能指针-Rc" class="headerlink" title="基于引用计数的智能指针 Rc"></a>基于引用计数的智能指针 <strong>Rc<t></t></strong></h4><p>所有权在大多数情况下都是清晰的，对于一个给定的值，可以准确地判断出哪个变量拥有它。<br>但在某些场景中，单个值也可能同时被多个所有者持有。<br>比如在图数据结构中，多个边可能会指向相同的节点，这个节点同时属于所有指向它的边。一个节点只要在任意指向它的边还存在时就不应该被清理掉。<br>Rust 提供了一种名为 <code>Rc&lt;T&gt;</code> 的类型来支持多重所有权。<code>Rc&lt;T&gt;</code> 类型的实例会在内部维护一个用于记录值引用次数的计数器，从而确认这个值是否仍在使用。若对一个值的引用次数为零，就意味着这个值可以被安全地清理掉。</p><p>当你希望将堆上的一些数据分享给程序的多个部分同时使用，而又无法在编译期确定哪个部分会最后释放这些数据时，就可以使用 <code>Rc&lt;T&gt;</code> 类型。<br>相反地，若我们能够在编译期确定哪一部分最后会释放数据，那么就只需要让这部分代码成为数据的所有者即可。<br><strong><code>Rc&lt;T&gt;</code> 只能被用于单线程场景中</strong>。</p><h5 id="使用-Rc-lt-T-gt-共享数据"><a href="#使用-Rc-lt-T-gt-共享数据" class="headerlink" title="使用 Rc&lt;T&gt; 共享数据"></a>使用 <code>Rc&lt;T&gt;</code> 共享数据</h5><p>创建两个链接列表，并让它们同时持有第三个列表的所有权。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-46c80b946fd197b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cons List"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>, <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译上述代码会报出 <strong>error[E0382]: use of moved value: <code>a</code></strong> 错误。原因是 <code>a</code> 列表会在创建 <code>b</code> 列表时被移动至 <code>b</code> 中。即 <code>b</code> 列表持有了 <code>a</code> 列表的所有权。随后再次尝试使用 <code>a</code> 来创建 <code>c</code> 列表时就会出现编译错误，因为 <code>a</code> 已经被移走了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，每个 <code>Cons</code> 变体都持有一个值及一个指向 List 的 <code>Rc&lt;T&gt;</code>。我们只需要在创建 <code>b</code> 的过程中克隆 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 智能指针即可，无需获取 <code>a</code> 的所有权。<br>这使得 <code>a</code> 和 <code>b</code> 可以共享 <code>Rc&lt;List&gt;</code> 数据的所有权，并使智能指针中的引用计数从 1 增加到 2。随后创建 <code>c</code> 时也会同样克隆 <code>a</code> 并将引用计数从 2 增加到 3。<br>每次调用 <code>Rc::clone</code> 都会使引用计数增加，而 <code>Rc&lt;List&gt;</code> 中的数据只有在引用计数器减少到 0 时才会被真正清理掉。</p><h5 id="克隆-Rc-lt-T-gt-会增加引用计数"><a href="#克隆-Rc-lt-T-gt-会增加引用计数" class="headerlink" title="克隆 Rc&lt;T&gt; 会增加引用计数"></a>克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; count after creating a = 1</span></span><br><span class="line"><span class="comment">// =&gt; count after creating b = 2</span></span><br><span class="line"><span class="comment">// =&gt; count after creating c = 3</span></span><br><span class="line"><span class="comment">// =&gt; count after c goes out of scope = 2</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>a</code> 存储的 <code>Rc&lt;List&gt;</code> 拥有初始引用计数 1，并在随后每次调用 <code>clone</code> 时增加 1。当 <code>c</code> 离开作用域被丢弃时，引用计数减少 1。<code>Rc&lt;T&gt;</code> 的 <code>Drop</code> 实现会在 <code>Rc&lt;T&gt;</code> 离开作用域时自动将引用计数减 1。</p><p>使用 <code>Rc&lt;T&gt;</code> 可以使单个值拥有多个所有者，而引用计数机制则保证了这个值会在其所有者存活时一直有效，并在所有者全部离开作用域时被自动清理。<br><code>Rc&lt;T&gt;</code> 通过不可变引用使你可以在程序的不同部分之间共享只读数据。但如果 <code>Rc&lt;T&gt;</code> 也允许持有多个可变引用的话，就会违反一个借用原则：多个指向同一区域的可变借用会导致数据竞争及数据不一致。<br>但在实际开发中，允许数据可变是非常有用的。实际上可以通过 <code>RefCell&lt;T&gt;</code> 与 <code>Rc&lt;T&gt;</code> 联合使用来绕开不可变的限制。</p><h4 id="RefCell-和内部可变性模式"><a href="#RefCell-和内部可变性模式" class="headerlink" title="RefCell 和内部可变性模式"></a>RefCell<t> 和内部可变性模式</t></h4><p><strong>内部可变性</strong> 是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改。为了能够改变数据，此模式在它的数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则。<br>假如我们能够保证自己的代码在运行时符合借用规则，就可以在即使编译器无法在编译阶段保证符合借用规则的前提下，使用那些采用了内部可变性模式的类型。实现过程中涉及的那些不安全代码会被妥善地封装在安全的 API 内，而类型本身从外部看依然是不可变的。</p><h5 id="使用-RefCell-lt-T-gt-在运行时检查借用规则"><a href="#使用-RefCell-lt-T-gt-在运行时检查借用规则" class="headerlink" title="使用 RefCell&lt;T&gt; 在运行时检查借用规则"></a>使用 <code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h5><p>Rust 中的借用规则如下：</p><ul><li>在任何给定的时间内，只能拥有一个可变引用或者任意数量的不可变引用</li><li>引用总是有效的</li></ul><p>对于一般引用和 <code>Box&lt;T&gt;</code> 的代码，Rust 会在<strong>编译阶段</strong>强制代码遵守这些借用规则。而对于使用 <code>RefCell&lt;T&gt;</code> 的代码，Rust 只会在<strong>运行时</strong>检查这些规则，并在违反的时候触发 panic 来提前终止程序。</p><p>借用规则的检查放在编译阶段不仅会帮助我们在开发阶段尽早暴露问题，并且不会带来任何运行时开销。对于大多数场景都是最佳的选择。<br>在运行时检查借用规则可以使我们实现某些特定的内存安全场景，即便这些场景无法通过编译时检查。因为某些静态分析是根本无法完成的。这类编译器无法理解代码，但开发者可以保证借用规则能够满足的场景，就适用于 <code>RefCell&lt;T&gt;</code>。</p><h5 id="可变地借用一个不可变的值"><a href="#可变地借用一个不可变的值" class="headerlink" title="可变地借用一个不可变的值"></a>可变地借用一个不可变的值</h5><p><strong>内部可变性模式允许用户更改一个不可变值的内部数据</strong>。<br>借用规则限制用户可变地借用一个不可变的值，如下面的代码无法通过编译：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是在某些情况下，我们也需要一个值对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代码仍不能修改这个值。<br>使用 <code>RefCell&lt;T&gt;</code> 可以获得这种内部可变性。<br>这种内部可变性的机制把借用规则的检查从编译期延后到了运行阶段，若违反了借用规则，只会在运行时触发 <strong>panic!</strong>。</p><p><strong>内部可变性的应用场景：模拟对象</strong><br><strong>测试替代</strong>是一种通用的编程概念，代表了那些在测试工作中被用作其他类型替代品的类型。而<strong>模拟对象</strong>则指代了测试替代中某些特定的类型，会承担起记录测试过程的工作。</p><p>Rust 没有和其他语言中类似的对象概念，也没有在标准库中提供模拟对象的测试功能。但是可以自定义一个结构体来实现与模拟对象相同的效果。<br>比如我们希望开发一个库，会基于当前值与最大值之间的接近程度向外传递信息。比如可以记录用户调用不同 API 的次数，并与设置的调用限额作比较。<br>使用这个库的应用程序需要自行实现发送消息的功能，例如在应用程序中打印信息、发送邮件、发送文字短信等。<br>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>Messenger</code> trait 的 <code>send</code> 方法可以接收 <code>self</code> 的不可变引用及一条文本消息作为参数。我们需要在测试中确定的是，当某段程序使用一个实现了 Messenger trait 的模拟对象与一个 max 值来创建 <code>LimitTracker</code> 实例时，传入的不同 value 值能够触发 messenger 发送不同的信息。<br>此处的模拟对象 <code>MockMessenger</code> 在调用 <code>send</code> 时只需要将收到的消息存档记录即可，不需要真的去发送邮件或短信。使用模拟对象创建 <code>LimitTracker</code> 实例后，就可以通过调用 <code>set_value</code> 方法检查模拟对象中是否存储了我们希望见到的消息。</p><p>尝试编译（<code>cargo test</code>）上述代码会报出如下错误：<br><code>error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</code></p><p><code>send</code> 方法接收了 <code>self</code> 的不可变引用，因此我们无法通过修改 <code>MockMessenger</code> 的内容来记录消息。我们也不能将函数签名修改为 <code>&amp;mut self</code>，因为修改后的签名与 Messenger trait 定义的 <code>send</code> 签名不符。<br>此时就是一个非常适合内部可变性的场景。只要在 <code>RefCell&lt;T&gt;</code> 中存入 <code>sent_messages</code>，<code>send</code> 方法就能够修改 <code>sent_messages</code>。</p><p>修改后的代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>sent_messages</code> 字段的类型变为了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>。对于 <code>send</code> 方法的实现，其第一个参数依然是 <code>self</code> 的不可变借用，与 trait 的定义保持一致。后面的代码调用 <code>self.messages.borrow_mut</code> 方法获取 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 内部值（也就是动态数组）的可变引用，再调用其 <code>push</code> 方法存入数据。<br>在断言语句中，调用了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 的 <code>borrow</code> 方法来取得动态数组的不可变引用。</p><p>对于 <code>RefCell&lt;T&gt;</code> 而言，我们可以使用 <code>borrow</code> 与 <code>borrow_mut</code> 分别创建不可变和可变引用。这两个方法会分别返回 <code>Ref&lt;T&gt;</code> 与 <code>RefMut&lt;T&gt;</code> 两种智能指针，可以被当作一般的引用来对待。<br><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，维护和编译器同样的借用规则：任何给定的时间都只允许拥有多个不可变借用或一个可变借用。<br>当借用规则被违背时，<code>RefCell&lt;T&gt;</code> 会在<strong>运行时</strong>触发 panic。</p><h4 id="Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据"><a href="#Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据" class="headerlink" title="Rc&lt;T&gt; 和 RefCell&lt;T&gt; 实现一个拥有多重所有权的可变数据"></a><code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 实现一个拥有多重所有权的可变数据</h4><p><code>Rc&lt;T&gt;</code> 允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。若在 <code>Rc&lt;T&gt;</code> 内存储了 <code>RefCell&lt;T&gt;</code>，就可以定义出拥有多个所有者且能够进行修改的值了。</p><p>在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code> 来实现修改现有列表内数值的功能：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环引用与内存泄漏"><a href="#循环引用与内存泄漏" class="headerlink" title="循环引用与内存泄漏"></a>循环引用与内存泄漏</h4><p>与数据竞争不同，在编译期彻底防止内存泄漏并不是 Rust 做出的保证。这意味着内存泄漏在 Rust 中是一种内存安全行为。<br>可以通过使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 创建出相互引用成环状的实例。由于环中每一个指针的引用计数都不可能减少到 0，对应的值也不会被释放丢弃，最终造成内存泄漏。</p><p>代码中先创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>a</code>，其中的 List 初始值为 <code>5, Nil</code>。<br>之后又创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>b</code>，其中的 List 包含数值 10 及指向列表 <code>a</code> 的指针。<br>接着将 <code>a</code> 指向的下一个元素 <code>Nil</code> 修改为 <code>b</code>，此时即创建出了循环引用。</p><p>在完成 <code>a</code> 指向 <code>b</code> 的操作后，这两个 <code>Rc&lt;List&gt;</code> 实例的引用计数都变为了 2。而在 <code>main</code> 函数结尾处，Rust 会首先释放 <code>b</code>，并使 <code>b</code> 存储的 <code>Rc&lt;List&gt;</code> 实例的引用计数减少 1。<br>但由于 <code>a</code> 仍然有一个指向 <code>b</code> 中 <code>Rc&lt;List&gt;</code> 的引用，这个 <code>Rc&lt;List&gt;</code> 的引用计数仍然是 1 而不是 0。因此该 <code>Rc&lt;List&gt;</code> 在堆上的内存不会被释放，这块内存会永远以引用计数为 1 的状态保留在堆上。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-55a8d6b393cb625e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 和 b 相互指向的循环引用"></p><p>假如去除最后一行 <code>println!</code> 的注释并再次运行程序，Rust 会在尝试将循环引用打印出来的过程中反复地从 <code>a</code> 跳转到 <code>b</code>，再从 <code>b</code> 跳转至 <code>a</code>，直到发生栈溢出为止。</p><p>如果程序中存在 <code>RefCell&lt;T&gt;</code> 包含 <code>Rc&lt;T&gt;</code> 或其他联用了内部可变性与引用计数指针的情形，就需要自行确保不会在代码中创建出循环引用。<br>创建出循环引用意味着代码逻辑有 bug，可以通过自动化测试及其他软件开发手段来尽可能地避免。</p><h4 id="使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用"><a href="#使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用" class="headerlink" title="使用 Weak&lt;T&gt; 替代 Rc&lt;T&gt; 来避免循环引用"></a>使用 <code>Weak&lt;T&gt;</code> 替代 <code>Rc&lt;T&gt;</code> 来避免循环引用</h4><p>调用 <code>Rc::clone</code> 会增加 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code> 引用计数，而 <code>Rc&lt;T&gt;</code> 实例只有在 <code>strong_count</code> 为 0 时才会被清理。<br>除此之外，我们还可以调用 <code>Rc::downgrade</code> 函数来创建 <code>Rc&lt;T&gt;</code> 实例中值的弱引用。使用 <code>Rc&lt;T&gt;</code> 的引用来调用 <code>Rc::downgrade</code> 会返回一个类型为 <code>Weak&lt;T&gt;</code> 的智能指针，这一操作会让 <code>Rc&lt;T&gt;</code> 的 <code>weak_count</code> 计数增加 1。<code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来记录当前存在多少个 <code>Weak&lt;T&gt;</code> 引用，但不会在执行清理操作前要求 <code>weak_count</code> 必须为 0。<br>强引用可以被用来共享一个 <code>Rc&lt;T&gt;</code> 实例的所有权，而弱引用则不会表达所有权关系。一旦强引用计数为 0，任何由弱引用组成的循环就会被打破。<strong>弱引用不会造成循环引用</strong>。<br>我们无法确定 <code>Weak&lt;T&gt;</code> 引用的值是否已经被释放，因此需要在使用 <code>Weak&lt;T&gt;</code> 指向的值之前确保它依然存在。可以调用 <code>Weak&lt;T&gt;</code> 实例的 <code>upgrade</code> 方法来完成这一验证。此函数返回的 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 会在 <code>Rc&lt;T&gt;</code> 值依然存在时表达为 <code>Some</code>，在 <code>Rc&lt;T&gt;</code> 值被释放时表达为 <code>None</code>。Rust 能够保证 <code>Some</code> 和 <code>None</code> 两个分支都得到妥善的处理，不会产生无效指针之类的问题。</p><h5 id="创建树状结构体：带有子节点的-Node"><a href="#创建树状结构体：带有子节点的-Node" class="headerlink" title="创建树状结构体：带有子节点的 Node"></a>创建树状结构体：带有子节点的 Node</h5><p>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们希望 Node 持有自身所有子节点并通过变量来共享它们的所有权，从而可以直接访问树中的每个 Node。因此将 <code>Vec&lt;T&gt;</code> 的元素定义为 <code>Rc&lt;Node&gt;</code> 类型的值。<br>我们还希望在 <code>children</code> 字段中使用 <code>RefCell&lt;T&gt;</code> 包裹 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 来实现内部可变性。<br>我们使用上述结构体定义一个值为 3 且没有子节点的 Node 实例，并将其作为叶子节点存入 <code>leaf</code> 变量。再定义一个值为 5 且将 <code>leaf</code> 作为子节点的 <code>branch</code> 实例。接着克隆 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 实例，并将其存入 <code>branch</code>。<br>此时我们可以使用 <code>branch.children</code> 来从 <code>branch</code> 访问 <code>leaf</code>，但是反之则不行。因为 <code>leaf</code> 并不持有 <code>branch</code> 的引用，它甚至对两个节点之间存在父子关系一无所知。</p><h5 id="增加子节点指向父节点的引用"><a href="#增加子节点指向父节点的引用" class="headerlink" title="增加子节点指向父节点的引用"></a>增加子节点指向父节点的引用</h5><p>为了让子节点意识到父节点的存在，可以为 <code>Node</code> 结构体添加一个 <code>parent</code> 字段。但 <code>parent</code> 的类型不能是 <code>Rc&lt;T&gt;</code>，会创建循环引用。<code>branch.children</code> 指向 <code>leaf</code> 的同时使 <code>leaf.parent</code> 指向 <code>branch</code> 会导致两者的 <code>strong_count</code> 都无法清零。</p><p>父节点自然拥有子节点的所有权，因为父节点被丢弃时，子节点也应该随之被丢弃；但子节点却不应该拥有父节点的所有权，即父节点的存在不会因为丢弃子节点而受到影响。<br>这恰好是使用弱引用的场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; leaf parent = None</span></span><br><span class="line"><span class="comment">// =&gt; leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>branch</code> 创建完毕后，我们通过 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 的 <code>borrow_mut</code> 方法取出 <code>leaf</code> 中 <code>parent</code> 字段的可变借用，再使用 <code>Rc::downgrade</code> 函数获取 <code>branch</code> 中 <code>Rc&lt;Node&gt;</code> 的 <code>Weak&lt;Node&gt;</code> 引用，将其存入 <code>leaf</code> 的 <code>parent</code> 字段中。<br>最后在打印 <code>leaf</code> 的父节点时，便可以看到一个包含了 <code>branch</code> 实际内容的 <code>Some</code> 变体，即表明 <code>leaf</code> 可以访问其父节点。另外，此时打印 <code>leaf</code> 还可以避免之前因循环引用导致的栈溢出故障，因为 <code>Weak&lt;Node&gt;</code> 引用会被直接打印为 <code>(Weak)</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;指针（pointer）&lt;/strong&gt;是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。&lt;br&gt;Rust 中最常见的指针是&lt;strong&gt;引用&lt;/strong&gt;，会&lt;strong&gt;借用&lt;/strong&gt;它所指向的数据。除此之
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="https://rollingstarky.github.io/tags/Ownership/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
      <category term="Heap" scheme="https://rollingstarky.github.io/tags/Heap/"/>
    
      <category term="Stack" scheme="https://rollingstarky.github.io/tags/Stack/"/>
    
      <category term="Borrow" scheme="https://rollingstarky.github.io/tags/Borrow/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——枚举类型</title>
    <link href="https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/"/>
    <id>https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/</id>
    <published>2021-07-12T16:00:00.000Z</published>
    <updated>2021-07-13T13:02:39.454Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类型（<strong>enum</strong>），通常也被简称为<strong>枚举</strong>，它允许我们列举所有可能的值来定义一个类型。<br>枚举搭配 <code>match</code> 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。<br>Rust 中的枚举更类似于 Haskell 这类函数式编程语言中的<strong>代数数据类型（ADT）</strong>。</p><h4 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h4><p>假设我们需要对 IP 地址进行处理。目前只有两种广泛被使用的 IP 地址标准：IPv4 和 IPv6。<br>我们只需要处理这两种情形，且一个地址要么是 IPv4，要么是 IPv6，因此可以使用枚举将所有可能的值（IPv4 和 IPv6）列举出来，作为一种新的数据类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>IpAddrKind</code> 就是一个可以在代码中随处使用的自定义数据类型了。</p><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>可以参照下面的代码使用 <code>IpAddrKind</code> 中的两个变体（<code>V4</code> 和 <code>V6</code>）创建实例：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure></p><p>由于 <code>IpAddrKind:V4</code> 和 <code>IpAddrKind:V6</code> 拥有相同的类型（都是 <code>IpAddrKind</code>），我们可以定义一个接收 <code>IpAddrKind</code> 类型参数的函数来统一处理它们：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_type: IpAddrKind) &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以使用任意一个变体来调用这个函数了：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route(IpAddrKind::V4);</span><br><span class="line">route(IpAddrKind::V6);</span><br></pre></td></tr></table></figure></p><p>当前定义的枚举类型 <code>IpAddrKind</code>，还只能区分 IP 地址的种类，没有办法去存储实际的 IP 地址数据。<br>可以使用结构体来解决这个问题：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际上，我们可以直接将枚举关联的数据嵌入其变体内，而不用像上面那样将枚举集成至结构体中。</p><p>下面的代码直接定义了 <code>IpAddr</code> 枚举，<code>V4</code> 和 <code>V6</code> 两个变体都被关联上了一个 String 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>我们直接将数据附加到枚举的每个变体中，就不需要额外地使用结构体了。</p><p>另外一个枚举替代结构体的优势在于，<strong>每个变体可以拥有不同类型和数量的关联数据，同时所有变体仍属于同一个枚举类型</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>参考下面代码中定义的一个 <code>Message</code> 枚举：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该枚举拥有 4 个内嵌了不同类型数据的变体：</p><ul><li>Quit 没有关联任何数据</li><li>Move 包含了一个匿名结构体</li><li>Write 包含了一个 String</li><li>ChangeColor 包含了 3 个 i32 值</li></ul><p>枚举有些类似于定义多个不同类型的结构体。但枚举除了不会使用 <code>struct</code> 关键字，还将变体们组合到了同一个 <code>Message</code> 类型中。<br>下面代码中的结构体可以存储与这些变体完全一样的数据：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuitMessage</span></span>; <span class="comment">// 空结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MoveMessage</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WriteMessage</span></span>(<span class="built_in">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeColorMessage</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure></p><p>两种实现方式的差别在于，如果使用了不同的结构体，则<strong>每个结构体都会拥有自己的类型</strong>，无法轻易定义一个统一处理这些类型的函数。而前面的 <strong><code>Message</code> 枚举是单独的一个类型</strong>。</p><p>正如我们可以用 <code>impl</code> 关键字定义结构体的方法一样，我们同样可以为 <code>Message</code> 定义自己的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法在这里定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Option-枚举及空值处理"><a href="#Option-枚举及空值处理" class="headerlink" title="Option 枚举及空值处理"></a>Option 枚举及空值处理</h4><p><code>Option</code> 是一种定义于标准库中的枚举类型，它描述了一种值可能不存在的情形。借助类型系统，编译器可以自动检查我们是否妥善地处理了所有应该被处理的情况。</p><p>Rust 没有像其他语言一样支持<strong>空值（Null）</strong>。空值本身是一个值，但它的含义却是没有值。<br>空值的问题在于，当你尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。由于空或非空的属性广泛散布在程序中，因此很难避免引起此类问题。<br>但空值本身所尝试表达的概念仍是有意义的，它代表了因为某种原因而变得无效或缺失的值。</p><p>Rust 中虽然没有空值，但提供了一个拥有类似概念的枚举 <code>Option&lt;T&gt;</code>，它可以用来标识一个值无效或缺失。<br><code>Option&lt;T&gt;</code> 在标准库中的定义如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Option&lt;T&gt;</code> 是一个普通的枚举类型，<code>Some&lt;T&gt;</code> 和 <code>None</code> 是该类型的变体。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></p><p>若使用 <code>None</code> 而不是 <code>Some</code> 变体来进行赋值，则需要明确声明这个 <code>Option&lt;T&gt;</code> 的具体类型，否则编译器无法进行类型推导。</p><p>当我们有了一个 <code>Some</code> 值时，就可以确定值是存在的，并且被 <code>Some</code> 所持有；当我们有了一个 <code>None</code> 值时，就知道当前并不存在一个有效的值。<br><code>Option&lt;T&gt;</code> 的设计相对于空值的优势在于，<strong><code>Option&lt;T&gt;</code> 和 <code>T</code> 是不同的类型，编译器不会允许我们像使用普通值一样直接去使用 <code>Option&lt;T&gt;</code> 的值</strong>。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = x + y;</span><br></pre></td></tr></table></figure></p><p>运行上述代码会导致编译器报错，因为 <code>i8</code> 和 <code>Option&lt;i8&gt;</code> 是不同的类型。<br>当我们持有的类型是 <code>i8</code> 时，编译器可以确保该值是有效的。但是<strong>当我们持有的类型是 <code>Option&lt;i8&gt;</code> 时，我们必须要考虑值不存在的情况，编译器会迫使我们在使用值之前正确地做出处理操作</strong>。</p><p><strong>为了持有一个可能为空的值，我们总是需要将其显式地放入对应类型的 <code>Option&lt;T&gt;</code> 值当中。当我们随后使用这个值时，也必须显式地处理它可能为空的情况</strong>。<br>即在处理 <code>Option&lt;T&gt;</code> 时，必须编写应对每个变体的代码。某些代码只会在持有 <code>Some(T)</code> 值时运行，它们可以使用变体中存储的 <code>T</code>；另外一些代码则只会在持有 <code>None</code> 值时运行，这些代码没有可用的 <code>T</code> 值。</p><p><code>match</code> 表达式就是一种可以用来处理 <code>Option&lt;T&gt;</code> 这类枚举的控制流结构。它允许我们基于枚举拥有的变体来决定运行的代码分支，并允许代码通过模式匹配来获取变体内的数据。</p><h4 id="控制流运算符-match"><a href="#控制流运算符-match" class="headerlink" title="控制流运算符 match"></a>控制流运算符 match</h4><p><code>match</code> 是 Rust 中一个强大的控制流运算符，它允许将一个值与一系列模式相比较，并根据匹配的模式执行相应的代码。这些模式可以由字面量、变量名、通配符及许多其他东西组成。</p><p>下面的代码会接收一个美国的硬币作为输入，确定硬币的类型并返回其分值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Dime;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(coin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 <code>match</code> 分支所关联的代码同时也是一个表达式，这个表达式运行的结果同时也会作为整个 <code>match</code> 表达式的结果返回。</p><h5 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h5><p>匹配分支还可以绑定匹配对象的部分值，这使得我们能够从枚举变体中提取特定的值。</p><p>比如美国的 25 美分硬币 50 个州采用了不同的设计。现在将这些信息添加至枚举中：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 方便打印输出默认不支持打印的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;."</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alaska = UsState::Alaska;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Quarter(alaska);</span><br><span class="line">    value_in_cents(coin);</span><br><span class="line">    <span class="comment">// =&gt; State quarter from Alaska.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们在模式中加入了一个名为 <code>state</code> 的变量用于匹配变体 <code>Coin::Quarter</code> 中的值。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 就会绑定到 25 美分所包含的值上。<br>比如代码中 <code>Coin::Quarter(UsState::Alaska)</code> 作为 <code>coin</code> 的值传入 <code>value_in_cents</code> 函数，最终值 <code>UsState::Alaska</code> 被绑定到变量 <code>state</code> 上。</p><h4 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 Option<t></t></h4><p>可以使用 <code>match</code> 表达式来处理 <code>Option&lt;T&gt;</code>，从 <code>Some</code> 中取出内部的 <code>T</code> 值。<br>比如编写一个接收 <code>Option&lt;i32&gt;</code> 的函数，若其中有值存在，则将这个值加 1；若其中不存在值，则直接返回 <code>None</code>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is None"</span>);</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is &#123;&#125;"</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="literal">Some</span>(i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">    <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<strong>匹配必须穷举所有的可能</strong>。尤其是 <code>Option&lt;T&gt;</code> 这个例子中，Rust 会强迫我们明确地处理值为 <code>None</code> 的情形。</p><h5 id="简单控制流-if-let"><a href="#简单控制流-if-let" class="headerlink" title="简单控制流 if let"></a>简单控制流 <code>if let</code></h5><p><code>if let</code> 能让我们通过一种不那么繁琐的语法结合使用 <code>if</code> 与 <code>let</code>，处理那些只关心某一种匹配而忽略其他匹配的情况。<br>下面的代码会匹配一个 <code>Option&lt;u32&gt;</code> 的值，并只在值为 3 时执行代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">match</span> some_number &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了满足 <code>match</code> 表达式<strong>穷尽性</strong>的要求，我们不得不在处理完 <code>Some(3)</code> 变体后额外加上一句 <code>_ =&gt; ()</code>。<br>可以使用 <code>if let</code> 以一种更简单的方式实现上述代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以在 <code>if let</code> 中搭配使用 <code>else</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"other number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举类型（&lt;strong&gt;enum&lt;/strong&gt;），通常也被简称为&lt;strong&gt;枚举&lt;/strong&gt;，它允许我们列举所有可能的值来定义一个类型。&lt;br&gt;枚举搭配 &lt;code&gt;match&lt;/code&gt; 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。&lt;br&gt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Enum" scheme="https://rollingstarky.github.io/tags/Enum/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——包（package）、单元包（crate）与模块系统</title>
    <link href="https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/"/>
    <id>https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/</id>
    <published>2021-07-08T16:00:00.000Z</published>
    <updated>2021-07-08T16:40:32.519Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实现指定功能的代码片段，确定哪些地方需要修改。</p><p>除了对功能进行分组，对实现的细节进行封装可以使开发者在更高的层次上复用代码：一旦实现了某个功能，其他代码就可以通过公共接口调用这个操作，而无需了解具体的实现细节。</p><p>Rust 提供了一系列的功能来管理代码，包括决定哪些细节是暴露的，那些细节是私有的，以及不同的作用域内存在哪些名称。这些功能被统称为<strong>模块系统</strong>：</p><ul><li><strong>包（package）</strong>：一个用于构建、测试并分享单元包的 Cargo 特性</li><li><strong>单元包（crate）</strong>：一个用于生成库或可执行文件的树形模块结构</li><li><strong>模块（module）</strong>及 <strong>use 关键字</strong>：用于控制文件结构、作用域及路径的私有性</li><li><strong>路径（path）</strong>：一种用于命名条目的方法，这些条目包括结构体、函数和模块等</li></ul><h4 id="包与单元包"><a href="#包与单元包" class="headerlink" title="包与单元包"></a>包与单元包</h4><p>当我们使用 <code>cargo new</code> 命令创建新项目时，如：<br><code>cargo new restaurant</code></p><p>Cargo 会自动创建如下结构的 Rust 项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>Cargo 默认会将自动生成的 <code>src/main.rs</code> 源文件视作一个二进制单元包（crate）的根节点，与包（package）拥有相同的名称（即 <code>restaurant</code>）。<br>假设包的目录中包含文件 <code>src/lib.rs</code>，Cargo 也会自动将其视作与包同名的库单元包的根节点。<br>可以在路径 <code>src/bin</code> 下添加源文件来创建更多的二进制单元包，这些源文件都会被视作独立的二进制单元包。</p><p>自动生成的 <code>src/main.rs</code> 源文件内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以创建一个 <code>src/lib.rs</code> 源文件，把上面的打印输出的操作作为公共函数定义在 <code>lib.rs</code> 中，再在 <code>main.rs</code> 中调用该公共函数，效果与之前是一致的。</p><p><code>src/lib.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>src/main.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::greeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 <code>lib.rs</code> 默认会作为一个与包同名（都叫 <code>restaurant</code>）的库单元包（crate）存在，且其中的 <code>greeting</code> 函数已被声明为公开的（<code>pub</code>），因此可以直接在 <code>main.rs</code> 中使用 <code>restaurant::greeting()</code> 调用 <code>lib.rs</code> 中定义的 <code>greeting</code> 函数。</p><p>使用 <code>cargo run</code> 命令运行项目后，<code>target/debug</code> 路径下除了像之前一样生成 <code>restaurant</code> 可执行文件外，还会额外生成 <code>librestaurant.rlib</code> 库文件。</p><p>单元包可以将相关的功能分组，并放到<strong>同一作用域</strong>下，这样便可以使这些功能轻松地在多个项目中共享。<br>将单元包的功能保留在它们自己的作用域中有助于指明某个特定功能来源于哪个单元包，并避免可能的命名冲突。<br>比如 <code>rand</code> 包提供了一个名为 <code>Rng</code> 的 trait，我们同样也可以在自己的单元包中定义一个名为 <code>Rng</code> 的结构体。正是由于这些功能被放置在了各自的作用域中，我们能够使用 <code>rng::Rng</code> 访问 rand 包中提供的 <code>Rng</code> trait，而 <code>Rng</code> 则指向刚刚创建的 <code>Rng</code> 结构体。</p><h5 id="通过定义模块来控制作用域及私有性"><a href="#通过定义模块来控制作用域及私有性" class="headerlink" title="通过定义模块来控制作用域及私有性"></a>通过定义模块来控制作用域及私有性</h5><p>假设我们需要编写一个提供就餐服务的库单元包。一个现实的店面常常会划分为前厅与后厨两个部分，前厅负责点单和结账等，后厨则负责制作料理。</p><p>为了按照餐厅的实际工作方式来组织单元包，可以将函数放置在嵌套的模块中。修改 <code>src/lib.rs</code> 源代码文件，内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以使用 <code>mod</code> 关键字来定义一个模块（如本例中的 <code>front_of_house</code>），模块内还可以继续定义其他模块（如本例中的 <code>hosting</code> 和 <code>serving</code>）。模块内同样也可以包含其他条目的定义，如结构体、枚举、常量、trait 或函数等。</p><p><code>src/main.rs</code> 与 <code>src/lib.rs</code> 被称作单元包（crate）的根节点，它们的内容各自组成了一个名为 <code>crate</code> 的模块。这个模块的结构也被称为模块树。<br>上面 <code>src/lib.rs</code> 形成的树状模块结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure></p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>类似于在文件系统中使用路径进行导航，在 Rust 的模块树中定位某个条目同样需要使用路径。</p><p>路径有两种形式：</p><ul><li>使用单元包名或字面量 crate 从根节点开始的绝对路径</li><li>使用 <code>self</code>、<code>super</code> 或内部标识符从当前模块开始的相对路径</li></ul><p>绝对路径与相对路径都至少由一个标识符组成，标识符之间使用双冒号（<code>::</code>）分隔。</p><p>现在尝试在模块外部调用模块中定义的函数。在 <code>src/lib.rs</code> 末尾添加一个公共函数 <code>eat_at_restaurant</code>，调用模块 <code>front_of_house</code> 中定义的函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改 <code>src/main.rs</code>，在 <code>main</code> 函数中调用上一步中定义的公共函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::eat_at_restaurant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试编译项目，会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">error[E0603]: module `serving` is private</span><br></pre></td></tr></table></figure></p><p>即模块 <code>hosting</code> 和 <code>serving</code> 是私有的，Rust 不允许我们访问。<br>Rust 中的模块不仅仅用于组织代码，同时也定义了<strong>私有边界</strong>：外部代码无法知晓、调用或依赖那些由私有边界封装了的实现细节。<br><strong>Rust 中的所有条目（函数、方法、结构体、枚举、模块及常量）默认都是私有的，处于父级模块中的条目无法使用子模块中的私有条目，但子模块中的条目可以使用其祖先模块中的条目</strong>。<br>Rust 希望默认隐藏内部的实现细节，这样用户就能明确地知道修改哪些内容不会破坏外部代码。</p><h5 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 pub 关键字暴露路径</h5><p>可以使用 <code>pub</code> 关键字将某些条目标记为公共的，从而使子模块中的这些部分可以被暴露到祖先模块中。<br>接上面的例子，为了使父模块中的 <code>eat_at_restaurant</code> 函数能够正常访问子模块中定义的函数，可以使用 <code>pub</code> 关键字来标记 <code>hosting</code> 和 <code>serving</code> 模块。<br>需要注意的是，模块被 <code>pub</code> 标记，其效果仅限于模块本身，并不会影响到它内部条目的状态，模块中的内容依旧是私有的。为了使前面的代码正常工作，还必须在需要公开的函数前面添加 <code>pub</code> 关键字。</p><p>编辑 <code>src/lib.rs</code> 中，内容改动如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时程序即可以正常运行。</p><h5 id="将结构体声明为公共的"><a href="#将结构体声明为公共的" class="headerlink" title="将结构体声明为公共的"></a>将结构体声明为公共的</h5><p>当我们在结构体定义前使用 <code>pub</code> 关键字时，结构体本身就成为了公共结构体，但是它的字段依旧保持私有状态。<br>我们可以逐一决定是否将某个字段公开。</p><p>下面的代码定义了一个公共的 <code>back_of_house::Breakfast</code> 结构体，并令其 <code>toast</code> 字段公开，而 <code>seasonal_fruit</code> 字段保持私有。使得客户可以自行选择想要的面包，而只有厨师才能根据季节与存货决定配餐水果。</p><p>编辑 <code>src/lib.rs</code> 源文件，添加如下 <code>back_of_house</code> 模块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">"peaches"</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了测试新添加的代码能否正常工作，修改 <code>src/lib.rs</code> 中的 <code>eat_at_restaurant</code> 函数如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 选择黑麦面包作为夏季早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">"Rye"</span>);</span><br><span class="line">    <span class="comment">// 修改我们想要的面包类型</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">"Wheat"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I'd like &#123;&#125; toast please"</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的这一行无法通过编译，我们不能看到或更换附带的季节性水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from("blueberries");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>back_of_house::Breakfast</code> 结构体中的 <code>toast</code> 字段是公共的，我们因此能够在 <code>eat_at_restaurant</code> 中使用点号读写 <code>toast</code> 字段。<br>同样由于 <code>seasonal_fruit</code> 字段是私有的，我们不能在 <code>eat_at_restaurant</code> 中访问它。<br>另外，由于 <code>back_of_house::Breakfast</code> 拥有一个私有字段，这个结构体必须提供一个公共的关联函数来构造 <code>Breakfast</code> 实例（本例中的 <code>summer</code>），否则我们将无法在结构体外部创建任何的 <code>Breakfast</code> 实例。</p><h4 id="用-use-关键字将路径导入作用域"><a href="#用-use-关键字将路径导入作用域" class="headerlink" title="用 use 关键字将路径导入作用域"></a>用 <code>use</code> 关键字将路径导入作用域</h4><p>基于路径来调用函数的写法看上去会有些重复与冗长。无论我们使用绝对路径还是相对路径来指定 <code>seat_at_table</code> 函数，都必须在每次调用时指定路径上的 <code>front_of_house</code> 和 <code>hosting</code> 节点。<br>可以借助 <code>use</code> 关键字将路径引入作用域，简化上述步骤。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在作用域中使用 <code>use</code> 引入路径有点类似于在文件系统中创建符号链接。通过在单元包的根节点下添加上述两条 <code>use</code> 语句，<code>hosting</code> 和 <code>serving</code> 成了该作用域下的一个有效名称，就如同这两个模块被定义在根节点下一样。</p><p>这里使用了 <code>use crate::front_of_house::hosting</code> 并接着调用 <code>hosting::seat_at_table</code>，而没有使用 <code>use crate::front_of_house::hosting::seat_at_table</code> 来直接引入 <code>seat_at_table</code> 函数。<br>相对而言，前者的方式更常用一些。使用 <code>use</code> 将函数的父模块引入作用域，意味着我们必须在调用函数时指定这个父模块，从而更清晰地表明当前函数没有被定义在当前作用域中。</p><p>不同于函数，使用 <code>use</code> 将结构体、枚举或其他条目引入作用域时，我们习惯于通过指定完整路径的方式引入。</p><h5 id="使用-as-提供新的名称"><a href="#使用-as-提供新的名称" class="headerlink" title="使用 as 提供新的名称"></a>使用 <code>as</code> 提供新的名称</h5><p>使用 use 将多个同名类型引入作用域时，还可以在路径后使用 <code>as</code> 关键字为类型指定一个新的本地名称，也就是别名。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure></p><h5 id="使用-pub-use-重导出名称"><a href="#使用-pub-use-重导出名称" class="headerlink" title="使用 pub use 重导出名称"></a>使用 <code>pub use</code> 重导出名称</h5><p>当我们使用 <code>use</code> 关键字将名称引入作用域时，这个名称会以私有的方式在新的作用域中生效。为了让外部代码能够访问到这些名称，可以通过组合使用 <code>pub</code> 和 <code>use</code> 修饰其路径。<br>这项技术也被称作重导出。</p><p>比如使用 <code>pub</code> 修饰前面 <code>src/lib.rs</code> 中的某条 <code>use</code> 语句：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure></p><p>于是在另一个文件 <code>src/main.rs</code> 中也就可以使用 <code>restaurant::hosting::seat_at_table()</code> 形式的代码调用 <code>hosting</code> 模块中的函数了。<br>通过使用 <code>pub use</code>，我们可以在编写代码时使用一种结构，在对外暴露时使用另外一种不同的结构。这一方法可以让我们的代码库对编写者和调用者同时保持良好的组织结构。</p><h4 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h4><p>当模块规模逐渐增大时，我们可以将它们的定义移动到新的文件中。<br>比如我们需要将 <code>src/lib.rs</code> 中定义的 <code>front_of_house</code> 模块移动到它自己的文件 <code>src/front_of_house.rs</code> 中。首先将根节点文件 <code>lib.rs</code> 中的代码改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>mod front_of_house</code> 后使用分号而不是代码块，会让 Rust 前往与当前模块同名的文件中加载模块内容。因此可以将 <code>front_of_house</code> 模块的具体定义转移到 <code>src/front_of_house.rs</code> 文件中，效果是一样的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上还可以更进一步，继续拆解 <code>front_of_house</code> 模块到其他文件中。首先将 <code>src/front_of_house.rs</code> 文件的内容改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure></p><p>接着创建一个 <code>src/front_of_house</code> 目录，以及一个 <code>src/front_of_house/hosting.rs</code> 文件用来存放 <code>hosting</code> 模块的定义，一个 <code>src/front_of_house/serving.rs</code> 文件存放 <code>serving</code> 模块的定义：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/serving.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果与前两种版本也是一致的。<br>此时 <code>restaurant</code> 项目的目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── front_of_house</span><br><span class="line">    │   ├── hosting.rs</span><br><span class="line">    │   └── serving.rs</span><br><span class="line">    ├── front_of_house.rs</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>所有的修改都没有改变原有的模块树结构，尽管这些定义被放置到了不同的文件中，<code>eat_at_restaurant</code> 中的函数调用依旧有效。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;模块系统&quot;&gt;&lt;a href=&quot;#模块系统&quot; class=&quot;headerlink&quot; title=&quot;模块系统&quot;&gt;&lt;/a&gt;模块系统&lt;/h4&gt;&lt;p&gt;在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Package" scheme="https://rollingstarky.github.io/tags/Package/"/>
    
      <category term="Project" scheme="https://rollingstarky.github.io/tags/Project/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Module" scheme="https://rollingstarky.github.io/tags/Module/"/>
    
      <category term="Crate" scheme="https://rollingstarky.github.io/tags/Crate/"/>
    
      <category term="Scope" scheme="https://rollingstarky.github.io/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（五）自定义 Types</title>
    <link href="https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/"/>
    <id>https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-07-06T14:50:37.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ADT-Algebraic-data-types"><a href="#ADT-Algebraic-data-types" class="headerlink" title="ADT (Algebraic data types)"></a>ADT (Algebraic data types)</h4><p>类似 <code>Bool</code>、<code>Int</code>、<code>Char</code> 这些都是内置的数据类型，我们可以使用 <strong><code>data</code></strong> 关键字创建自己的类型。</p><p>标准库中的 <code>Bool</code> 类型实际上是这样定义的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br></pre></td></tr></table></figure></p><p>其中 <code>=</code> 左边部分指定类型的名称，右边部分叫做 <strong>value constructors</strong>，用来指定当前类型能够拥有的不同数值。<br>整个语句可以读作“<code>Bool</code> 类型可以使用 <code>True</code> 或者 <code>False</code> 作为它的值”。</p><p>现在思考下应该用怎样的形式表示一种形状。可以使用元组，比如圆圈可以表示为 <code>(43.1, 55.0, 10.4)</code>。前两项表示圆心的坐标，最后一项表示半径。<br>但这种形式的元组也同样可以表示一个三维向量或者其他对象。更好一点的方法是创建自定义的数据类型。</p><p>假设一个形状对象可以是圆或者矩形，则可以定义如下形式的 <code>Shape</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure></p><p>可以这样理解，<code>Circle</code> value constructor 包含三个 Float 类型的字段，前两个字段是圆心的坐标，最后一个字段表示半径；<code>Rectangle</code> value constructor 包含四个 Float 类型的字段，前两个字段表示左上角顶点的坐标，后两个字段表示右下角的坐标。</p><p>Value constructor 实际上是一种函数，所谓的“字段”是函数的参数，最终返回特定的数据类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Circle</span></span><br><span class="line"><span class="type">Circle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Rectangle</span></span><br><span class="line"><span class="type">Rectangle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br></pre></td></tr></table></figure></p><p>接下来就可以针对 <code>Shape</code> 类型定义一个 <code>surface</code> 函数，用来计算某个 Shape 的面积：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| surface :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">10</span>)</span><br><span class="line"><span class="number">314.15927</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span> <span class="number">100</span>)</span><br><span class="line"><span class="number">10000.0</span></span><br></pre></td></tr></table></figure><p>但是当我们在 <code>ghci</code> 中像调用函数那样直接执行如 <code>Circle 10 20 5</code> 这类命令时，会报出如下错误：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:<span class="number">14</span>:<span class="number">1</span>: error:</span><br><span class="line">    • <span class="type">No</span> <span class="keyword">instance</span> for (<span class="type">Show</span> <span class="type">Shape</span>) arising from a use <span class="keyword">of</span> ‘print’</span><br><span class="line">    • <span class="type">In</span> a stmt <span class="keyword">of</span> an interactive <span class="type">GHCi</span> command: print it</span><br></pre></td></tr></table></figure></p><p>原因是 Haskell 不清楚如何将此处的自定义类型表示为字符串。当在 <code>ghci</code> 中打印一个值时，实际上 Haskell 调用了 <code>show</code> 函数用来获取对应值的字符串形式，并输出到命令行。<br>为了使我们的 <code>Shape</code> 类型支持打印输出，需要令其实现 <code>Show</code> typeclass。语法如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时 <code>Shape</code> 类型即可支持打印输出操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Rectangle</span> <span class="number">50</span> <span class="number">230</span> <span class="number">60</span> <span class="number">90</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="number">50.0</span> <span class="number">230.0</span> <span class="number">60.0</span> <span class="number">90.0</span></span><br></pre></td></tr></table></figure></p><p>Value constructor 实际上就是函数，也因此支持 <code>map</code>、partially apply 等操作。<br>比如可以使用如下代码创建一系列半径不同的同心圆：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span>) [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">4.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure></p><p>让我们再定义一个 <code>Point</code> 类型，并令其成为 <code>Shape</code> 类型的一部分，从而更加容易理解：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时的 <code>Circle</code> 类型拥有两个字段，用 <code>Point</code> 类型表示圆圈的圆心，再加一个 <code>Float</code> 类型表示半径。</p><p>重新实现下之前的 <code>surface</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><p>只需要重新定义模式匹配的部分即可。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> <span class="number">100</span> <span class="number">100</span>))</span><br><span class="line"><span class="number">10000.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) <span class="number">24</span>)</span><br></pre></td></tr></table></figure></p><p>还可以创建一个 <code>nudge</code> 函数用来移动某个形状对象的位置。它接收一个形状及其在 x 轴和 y 轴上的偏移量作为参数，返回一个同样大小、不同位置的形状对象。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nudge</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="title">nudge</span> (<span class="type">Circle</span> (<span class="type">Point</span> x y) r) a b = <span class="type">Circle</span> (<span class="type">Point</span> (x+a) (y+b)) r</span><br><span class="line"><span class="title">nudge</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) a b = <span class="type">Rectangle</span> (<span class="type">Point</span> (x1+a) (y1+b)) (<span class="type">Point</span> (x2+a) (y2+b))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; nudge (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">34</span> <span class="number">34</span>) <span class="number">10</span>) <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="type">Circle</span> (<span class="type">Point</span> <span class="number">39.0</span> <span class="number">44.0</span>) <span class="number">10.0</span></span><br></pre></td></tr></table></figure><h4 id="Record-语法"><a href="#Record-语法" class="headerlink" title="Record 语法"></a>Record 语法</h4><p>假设创建一个名为 <code>Person</code> 的自定义数据类型。它需要包含名字、姓氏、年龄、身高、手机号和最喜欢的冰淇淋种类等字段。<br>可以使用如下代码实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Float</span> <span class="type">String</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> guy = <span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; guy</span><br><span class="line"><span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br></pre></td></tr></table></figure></p><p>上述代码是可以运行的，但可读性却很差。<br>当我们需要创建函数来获取 Person 对象中的某个字段的值时，可能就需要借助如下形式的代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">firstName</span> (<span class="type">Person</span> firstname _ _ _ _ _) = firstname</span><br><span class="line">  </span><br><span class="line"><span class="title">lastName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lastName</span> (<span class="type">Person</span> _ lastname _ _ _ _) = lastname</span><br><span class="line">  </span><br><span class="line"><span class="title">age</span> :: <span class="type">Person</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">age</span> (<span class="type">Person</span> _ _ age _ _ _) = age</span><br><span class="line">  </span><br><span class="line"><span class="title">height</span> :: <span class="type">Person</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">height</span> (<span class="type">Person</span> _ _ _ height _ _) = height</span><br><span class="line">  </span><br><span class="line"><span class="title">phoneNumber</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">phoneNumber</span> (<span class="type">Person</span> _ _ _ _ number _) = number</span><br><span class="line">  </span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">flavor</span> (<span class="type">Person</span> _ _ _ _ _ flavor) = flavor</span><br></pre></td></tr></table></figure></p><p>鉴于上述场景中的代码实现有诸多不方便的地方，Haskell 提供了另外一种创建数据类型的方法，即 Record 语法。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">flavor</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>通过上述语法，Haskell 会自动创建 <code>firstName</code>、<code>lastName</code>、<code>age</code>、<code>height</code>、<code>phoneNumber</code>、<code>flavor</code> 等函数，用于访问该类型对象中的对应字段。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t flavor</span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t firstName</span><br><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure></p><p>Record 语法的另一个好处在于，Value constructor 中涉及到的所有字段都可以拥有一个有意义的名称，方便各字段之间的相互区分。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Car</span> = <span class="type">Car</span> &#123;<span class="title">company</span> :: <span class="type">String</span>, <span class="title">model</span> :: <span class="type">String</span>, <span class="title">year</span> :: <span class="type">Int</span>&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> car = <span class="type">Car</span> &#123;company=<span class="string">"Ford"</span>, model=<span class="string">"Mustang"</span>, year=<span class="number">1967</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; car</span><br><span class="line"><span class="type">Car</span> &#123;company = <span class="string">"Ford"</span>, model = <span class="string">"Mustang"</span>, year = <span class="number">1967</span>&#125;</span><br></pre></td></tr></table></figure></p><p>比如创建一个用于表示三维向量的数据类型，可以使用 <code>data Vector = Vector Int Int Int</code> 语句。但这样的语法对于前面的 <code>Person</code> 和 <code>Car</code> 来讲，其含义就不如使用 Record 语法来得清晰。</p><h4 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h4><p>Value constructor 可以接收特定数量的参数来生成一个特定类型的值。比如前面的 <code>Car</code> 接收 3 个参数生成一个新的 car。<br><strong>Type constructor</strong> 则可以接收 type 作为参数来生成一个新的类型。</p><p>比如内置的 <code>Maybe</code> 的实现：<br><code>data Maybe a = Nothing | Just a</code></p><p>其中 <code>a</code> 表示类型参数，<code>Maybe</code> 即为 type constructor。我们可以向 <code>Maybe</code> 传入一个 <code>Char</code> 作为类型参数，就可以得到一个新的 <code>Maybe Char</code> 类型。比如值 <code>Just &#39;a&#39;</code> 就属于 <code>Maybe Char</code> 类型。<br>同样的方式可以得到类型 <code>Maybe Int</code>、<code>Maybe String</code> 等等。</p><p><code>Maybe</code> 实际上表示一种<strong>可选项</strong>，它可以是任意某种特定类型的值，也可以什么值都不包含（<code>Nothing</code>）。比如 <code>Maybe Int</code> 类型就表示该类型的值可能包含 <code>Int</code>（值 <code>Just 5</code>），也可能不包含任意类型（<code>Nothing</code>）。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="number">84</span></span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">10</span> :: <span class="type">Maybe</span> <span class="type">Double</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure><p>实际上还有一种类型涉及到了类型参数，只不过借助了语法糖，其形式稍有不同。该类型就是 list。<br>list 类型可以接收一个类型参数生成更具体的类型。比如 <code>[Int]</code>、<code>[Char]</code> 甚至 <code>[[String]]</code> 等等。<br>但是没有任何值的类型可以是 <code>[]</code>。空列表实际上可以表现得像任意类型的列表，其类型是 <code>[a]</code>，也因此可以使用如下形式的表达式：<code>[1,2,3] ++ []</code>、<code>[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;] ++ []</code>。</p><p>下面的代码实现了一种三维的向量类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="title">vplus</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vplus` (<span class="type">Vector</span> l m n) = <span class="type">Vector</span> (i+l) (j+m) (k+n)</span><br><span class="line">  </span><br><span class="line"><span class="title">vectMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vectMult` m = <span class="type">Vector</span> (i*m) (j*m) (k*m)</span><br><span class="line">  </span><br><span class="line"><span class="title">scalarMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `scalarMult` (<span class="type">Vector</span> l m n) = i*l + j*m + k*n</span><br></pre></td></tr></table></figure></p><p>上述函数可以作用在 <code>Vector Int</code>、<code>Vector Integer</code>、<code>Vector  Float</code> 类型上，只要类型 <code>Vector a</code> 中的 <code>a</code> 属于 <code>Num</code> typeclass。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> `vplus` <span class="type">Vector</span> <span class="number">9</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">12</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">9</span> <span class="number">7</span> `vectMult` <span class="number">10.0</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">30.0</span> <span class="number">90.0</span> <span class="number">70.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">4</span> <span class="number">9</span> <span class="number">5</span> `scalarMult` <span class="type">Vector</span> <span class="number">9.0</span> <span class="number">2.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="number">74.0</span></span><br></pre></td></tr></table></figure></p><p>类型参数通常用在当 type constructor 中包含的类型对该类型的正常工作并不产生影响时。即我们的自定义类型表现得像某种“盒子”，里面可以放任意的特定类型的值。</p><h4 id="派生实例"><a href="#派生实例" class="headerlink" title="派生实例"></a>派生实例</h4><p><strong>typeclass 是一种定义了某种行为的接口</strong>。若某个类型支持 typeclass 定义的行为，则该类型成为 typeclass 的实例。<br>比如 <code>Eq</code> typeclass 定义了可以被测试是否相等的行为，而整数之间可以比较是否相等，因此 <code>Int</code> 类型是 <code>Eq</code> typeclass 的实例。与此同时，作为 <code>Eq</code> 接口的函数如 <code>==</code> 和 <code>/=</code>，则可以直接调用 <code>Int</code> 类型的值，测试它们是否相等（或不相等）。</p><p>typeclass 经常会与其他语言如 Java 中的类相混淆。实际上在其他语言中，类可以看作创建对象（包含自身状态和行为）的蓝图；而 typeclass 则更像是接口。<br>在 Haskell 中，我们先创建某个数据类型，然后考虑该类型有怎样的行为。若该类型可以被排序，则令其成为 <code>Ord</code> typeclass 的实例。这之后该类型的值就可以被 <code>&gt;</code>、<code>&lt;</code>、<code>compare</code> 等比较大小的函数调用了。</p><p>现在假设两个人可以有相同的姓氏、名字和年龄，则这两个人就是“相等”的。由此创建一个可以比较是否相等的 <code>Person</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>)</span></span><br></pre></td></tr></table></figure></p><p>当我们使用 <code>==</code> 比较两个实现了 <code>Eq</code> typeclass  的类型实例时，Haskell 会先用 <code>==</code> 比较两个类型实例的 value constructor 是否相等，再比较类型实例中包含的所有字段的值是否都相等。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> adRock = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Horovitz"</span>, age = <span class="number">41</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mca = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Yauch"</span>, age = <span class="number">44</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mca == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == mikeD</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>Person</code> 类型现在是 <code>Eq</code> typeclass 的实例，因此我们可以将其传给类型约束是 <code>Eq a</code> 的函数，比如 <code>elem</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> beastieBoys = [mca, adRock, mikeD]</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD `elem` beastieBoys</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p><code>Show</code> 和 <code>Read</code> typeclass 与类型值的字符串转换有关。<code>Show</code> 表示将类型值转换为 String，<code>Read</code> 则表示将 String 转换为特定类型的值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Read</span>)</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD</span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="string">"mikeD is: "</span> ++ show mikeD</span><br><span class="line"><span class="string">"mikeD is: Person &#123;firstName = \"Michael\", lastName = \"Diamond\", age = 43&#125;"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Person &#123;firstName =\"Michael\", lastName =\"Diamond\", age = 43&#125;"</span> :: <span class="type">Person</span></span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br></pre></td></tr></table></figure></p><p>对于实现了 <code>Ord</code> typeclass 的类型，我们可以根据 value constructor 中值出现的顺序比较同一类型不同值的大小。value constructor 中左侧的值总小于右侧的值。内置的 Bool 类型可以大概视作有如下实现：<br><code>data Bool = False | True deriving (Ord)</code><br>则在比较 <code>False</code> 和 <code>True</code> 时，<code>False</code> 总小于 <code>True</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">False</span> &lt; <span class="type">True</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>借助 <code>Enum</code> 和 <code>Bounded</code> typeclass，可以很轻松地实现枚举类型的 ADT。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br></pre></td></tr></table></figure></p><p>由于 <code>Day</code> 类型实现了 <code>Show</code> 和 <code>Read</code> typeclass，则可以在此类型与字符串之间进行转换：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Wednesday</span></span><br><span class="line"><span class="type">Wednesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; show <span class="type">Wednesday</span></span><br><span class="line"><span class="string">"Wednesday"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Saturday"</span> :: <span class="type">Day</span></span><br><span class="line"><span class="type">Saturday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Eq</code> 和 <code>Ord</code> typeclass，则可以在 <code>Day</code> 类型的值之间进行比较：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Sunday</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Saturday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> &gt; <span class="type">Friday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Monday</span> `compare` <span class="type">Wednesday</span></span><br><span class="line"><span class="type">LT</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Bounded</code> typeclass，我们可以获取“最低”和最高的 <code>Day</code> 类型值：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Monday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Sunday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Enum</code>，因此我们可以对其进行序列类型的操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; succ <span class="type">Monday</span></span><br><span class="line"><span class="type">Tuesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; pred <span class="type">Saturday</span></span><br><span class="line"><span class="type">Friday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="type">Thursday</span> .. <span class="type">Sunday</span>]</span><br><span class="line">[<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [minBound .. maxBound] :: [<span class="type">Day</span>]</span><br><span class="line">[<span class="type">Monday</span>,<span class="type">Tuesday</span>,<span class="type">Wednesday</span>,<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ADT-Algebraic-data-types&quot;&gt;&lt;a href=&quot;#ADT-Algebraic-data-types&quot; class=&quot;headerlink&quot; title=&quot;ADT (Algebraic data types)&quot;&gt;&lt;/a&gt;ADT (Algebra
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Typeclass" scheme="https://rollingstarky.github.io/tags/Typeclass/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（四）高阶函数</title>
    <link href="https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/"/>
    <id>https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-06-30T12:33:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做<strong>高阶函数（high order functions）</strong>。<br>想要通过<strong>定义是什么</strong>而不是<strong>定义一系列可以改变程序状态的步骤</strong>来完成计算过程，高阶函数是必不可少的。</p><h4 id="Curried-functions"><a href="#Curried-functions" class="headerlink" title="Curried functions"></a>Curried functions</h4><p><strong>Haskell 中的函数实际上都只接收一个参数</strong>。前面遇到的接收多个参数的函数是一种 <strong>Curried functions</strong>，可以看作某种特殊形式。<br>比如 <code>max 4 5</code>，看上去是向函数 <code>max</code> 传入两个参数 <code>4</code> 和 <code>5</code>，返回数值较大的 <code>5</code>。实际的计算过程是 <code>(max 4) 5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>首先将参数 <code>4</code> 传递给函数 <code>max</code>，<strong>会返回另一个函数，该函数接收任意一个参数，将该参数与数字 4 比较，返回较大的数</strong>。所以后面将 <code>5</code> 传给函数 <code>(max 4)</code> 后，得到最终的结果 <code>5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> maxWithFour = max <span class="number">4</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxWithFour <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>那么这种形式的函数究竟有什么好处呢？</p><p>当我们使用部分参数调用某个函数的时候，并不会直接得到结果，而是返回一个<strong>部分应用（partially applied）</strong>的函数。这个部分应用的函数可以继续接收剩余的参数，最终得到计算结果。</p><p>partially applied 机制可以方便我们简单地实现动态地创建函数、将函数作为参数传入、用特定数据初始化函数等需求。</p><p>对于函数 <code>multThree</code>：<br><code>let multThree x y z = x * y * z</code><br>它可以接收三个数字作为参数，并计算这三个参数的乘积作为返回值。</p><p>如 <code>multThree 3 5 9</code>，实际上的执行流程为 <code>((multThree 3) 5) 9</code>。</p><ul><li>将数字 3 传递给 <code>multThree</code>，它会返回一个函数 <code>(multThree 3)</code>。该函数接收任意两个数字，并计算它们和 3 的乘积</li><li>将数字 5 传递给 <code>(multThree 3)</code>，返回另一个函数 <code>((multThree 3) 5)</code>。该函数接收任意一个数字，并计算它和 15 的乘积</li><li>将数字 9 传递给 <code>((multThree 3) 5)</code>，返回 9 和 15 的乘积作为结果</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multThreeNums x y z = x * y * z</span><br><span class="line"><span class="type">Prelude</span>&gt; multThreeNums <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multTwoNumsWithNine = multThreeNums <span class="number">9</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multTwoNumsWithNine <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multOneNumWithEighteen = multTwoNumsWithNine <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multOneNumWithEighteen <span class="number">10</span></span><br><span class="line"><span class="number">180</span></span><br></pre></td></tr></table></figure><p>中缀函数如 <code>+ - * /</code> 等也可以 partially applied。</p><p>比如可以将数字 5 传递给中缀函数 <code>+</code> 生成一个新的函数 <code>(5+)</code>，而新函数 <code>(5+)</code> 可以接收一个数字作为参数，返回该参数与 5 的和。<br>即函数 <code>(5+)</code> 其实是中缀函数 <code>+</code> 固定一个参数 5 之后生成的新函数，这个新函数接收任何一个数字作为另一个加数并求和。</p><p>使用 <code>/</code> 固定除数生成新函数 <code>divideByTen</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideByTen = (/<span class="number">10</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideByTen <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (/<span class="number">10</span>) <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">200</span> / <span class="number">10</span></span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure></p><p><code>divideByTen 200</code> 等同于 <code>(/10) 200</code> 等同于 <code>200 / 10</code>。</p><p>同样的方式还可以定义 <code>divideTen</code> 固定被除数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideTen = (<span class="number">10</span>/)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideTen <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (<span class="number">10</span>/) <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">10</span> / <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure></p><p>检查输入的字符是否是大写字母：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> isUpperAlphanum = (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>])</span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum '<span class="type">D'</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum 'a'</span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure></p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> applyTwice f x = f (f x)</span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (+<span class="number">3</span>) <span class="number">10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (++ <span class="string">" HAHA"</span>) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HEY HAHA HAHA"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="string">"HAHA "</span> ++) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HAHA HAHA HEY"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="number">3</span>:) [<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="zipWith-的自定义实现"><a href="#zipWith-的自定义实现" class="headerlink" title="zipWith 的自定义实现"></a>zipWith 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">ith'</span> f <span class="type">Prelude</span>| zipWith' _ [] _ = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' _ _ [] = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (++) [<span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span>] [<span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span>]</span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h5 id="flip-的自定义实现"><a href="#flip-的自定义实现" class="headerlink" title="flip 的自定义实现"></a>flip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">flip'</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="title">flip'</span> f y x = f x y</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="type">Prelude</span>| flip' f y x = f x y</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; flip' zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">"hello"</span></span><br><span class="line">[('h',<span class="number">1</span>),('e',<span class="number">2</span>),('l',<span class="number">3</span>),('l',<span class="number">4</span>),('o',<span class="number">5</span>)]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith (flip' div) [<span class="number">2</span>,<span class="number">2.</span>.] [<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="Maps-amp-Filters"><a href="#Maps-amp-Filters" class="headerlink" title="Maps &amp; Filters"></a>Maps &amp; Filters</h4><p><code>map</code> 接收一个函数和一个列表作为参数，可以将函数应用到列表的每一项元素上。</p><p><code>map</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  </span><br><span class="line"><span class="title">map</span> _ [] = []  </span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (++ <span class="string">"!"</span>) [<span class="string">"BIFF"</span>, <span class="string">"BANG"</span>, <span class="string">"POW"</span>]</span><br><span class="line">[<span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (replicate <span class="number">3</span>) [<span class="number">3.</span><span class="number">.6</span>]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (map (^<span class="number">2</span>)) [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>],[<span class="number">49</span>,<span class="number">64</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map fst [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><code>filter</code> 接收一个判断函数和一个列表作为参数，返回列表中所有使判断函数为真的元素。</p><p><code>filter</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> p (x:xs)</span><br><span class="line">    | p x       = x : filter p xs</span><br><span class="line">    | otherwise = filter p xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; filter (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (==<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> notNull x = not (null x) <span class="keyword">in</span> filter notNull [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[],[],[]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['a'..'z']) <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span></span><br><span class="line"><span class="string">"uagameasadifeent"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"i lauGh At You BecAuse u r aLL the Same"</span></span><br><span class="line"><span class="string">"GAYBALLS"</span></span><br></pre></td></tr></table></figure><p>借助 filter 实现 quicksort：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort (filter (&lt;=x) xs)</span><br><span class="line">        biggerSorted = quicksort (filter (&gt;x) xs)</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure></p><p>找出 100000 以内能够被 3829 整除的最大的数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largestDivisible</span> :: (<span class="type">Integral</span> a) =&gt; a</span><br><span class="line"><span class="title">largestDivisible</span> = head (filter p [<span class="number">100000</span>,<span class="number">99999.</span>.])</span><br><span class="line">    <span class="keyword">where</span> p x = x `mod` <span class="number">3829</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>p x = x `mod` 3829 == 0</code> 定义了函数 <code>p</code> 作为 <code>filter</code> 的判断函数，而列表 <code>[100000, 99999..]</code> 实际上是一个逆序的无穷列表。<br>借助 Haskell 的<strong>惰性计算</strong>机制，函数获取的是最大的可被整除的数，获得该值后就不会再继续计算下去。</p><p>实际上还可以这样使用 <code>map</code> 函数：<br><code>map (*) [0..]</code><br>将函数 <code>*</code> 映射到列表 <code>[0..]</code>，会返回一个包含一系列函数的新列表。新列表的形式类似 <code>[(0*),(1*),(2*),(3*),(4*),(5*)..]</code>。<br>其中的任何一个函数如 <code>(4*)</code>，都是接收两个参数的函数 <code>*</code> 固定了一个参数后的形式，再向其传入一个参数即可完成乘法运算。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> listOfFuns = map (*) [<span class="number">0.</span>.]</span><br><span class="line"><span class="type">Prelude</span>&gt; (listOfFuns !! <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><code>!!</code> 函数可以从指定列表中根据索引值获取特定的元素。<code>(listOfFuns !! 4)</code> 即为 <code>(4*)</code>。</p><h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>Lambda 基本上是代码中只使用一次的匿名函数。<br>由 <code>\</code> 反斜杠符号指定参数，<code>-&gt;</code> 符号指定函数体。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; zipWith (\a b -&gt; a * b - <span class="number">1</span>) [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>和通常的函数类似，lambda 中也可以应用模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (\(a,b) -&gt; a + b) [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>不同的是，lambda 不支持对同一个参数定义多个模式。</p><h4 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h4><p>Fold 有点类似于 <code>map</code> 函数，只不过 fold 操作最终会将列表中的元素归并（<strong>reduce</strong>）到单个值。</p><p>Fold 函数接收三个参数：</p><ul><li>binary function：接收两个参数的函数</li><li>初始值：称作累加器（accumulator）</li><li>需要被折叠的列表</li></ul><p>首先是 binary function 接收 accumulator 和列表的第一个元素作为参数，执行特定的计算后返回一个新的 accumulator；<br>binary function 继续接收刚返回的新 accumulator 和列表中剩余元素中的第一个作为参数，执行计算并返回新的 accumulator；<br>若干次循环过后，列表中的最后一个元素被传入 binary function，返回的 accumulator 即为整个列表归并（折叠）后的最终结果。</p><h5 id="左折叠-foldl"><a href="#左折叠-foldl" class="headerlink" title="左折叠 foldl"></a>左折叠 <code>foldl</code></h5><p>运用左折叠（从左侧开始折叠）实现自定义的 <code>sum</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> sum' xs = foldl (\acc x -&gt; acc + x) <span class="number">0</span> xs</span><br><span class="line"><span class="type">Prelude</span>&gt; sum' [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>对应到前面提到的概念，lambda 函数 <code>(\acc x -&gt; acc + x)</code> 即为 binary function，<code>0</code> 是初始值（accumulator），<code>xs</code> 为传入的待折叠列表。</p><p>借助 curried function，甚至可以写出更简单的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> sum' = foldl (+) <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>lambda 函数 <code>(\acc x -&gt; acc + x)</code> 实际上等效于 <code>(+)</code>。<br>对于 <code>xs</code> 参数的化简，原因是通常情况下，若函数具有 <code>foo a = bar b a</code> 这样的形式，则该函数可以简化为 <code>foo = bar b</code>。</p><p>运用左折叠实现自定义的 <code>elem</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> elem' y ys = foldl (\acc x -&gt; <span class="keyword">if</span> x == y <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> ys</span><br><span class="line"><span class="type">Prelude</span>&gt; elem' <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><h5 id="右折叠-foldr"><a href="#右折叠-foldr" class="headerlink" title="右折叠 foldr"></a>右折叠 <code>foldr</code></h5><p>运用右折叠（从右侧开始折叠）实现自定义的 <code>map</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> map' f xs = foldr (\x acc -&gt; f x : acc) [] xs</span><br><span class="line"><span class="type">Prelude</span>&gt; map' (+<span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>此外还有两个折叠函数 <code>foldl1</code> 和 <code>foldr1</code>。它们与 <code>foldl</code> 和 <code>foldr</code> 的功能基本相同，只不过不需要显式地提供初始值。而是会自动地将列表的第一个值（不管从左起还是从右起）作为初始值。</p><p>以下是几个通过 fold 操作实现的标准库函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> = foldr1 (\x acc -&gt; <span class="keyword">if</span> x &gt; acc <span class="keyword">then</span> x <span class="keyword">else</span> acc)</span><br><span class="line">  </span><br><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> = foldl (\acc x -&gt; x : acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">product'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">product'</span> = foldr1 (*)</span><br><span class="line">  </span><br><span class="line"><span class="title">filter'</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter'</span> p = foldr (\x acc -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : acc <span class="keyword">else</span> acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">head'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head'</span> = foldr1 (\x _ -&gt; x)</span><br><span class="line">  </span><br><span class="line"><span class="title">last'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">last'</span> = foldl1 (\_ x -&gt; x)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做&lt;strong&gt;高阶函数（high order functions）&lt;/strong&gt;。&lt;br&gt;想要通过&lt;strong&gt;定义是什么&lt;/strong&gt;而不是&lt;strong&gt;定义一系列可以改变程序状态的步骤&lt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Map" scheme="https://rollingstarky.github.io/tags/Map/"/>
    
      <category term="Reduce" scheme="https://rollingstarky.github.io/tags/Reduce/"/>
    
      <category term="Filter" scheme="https://rollingstarky.github.io/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（三）递归</title>
    <link href="https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/"/>
    <id>https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-06-29T12:12:17.348Z</updated>
    
    <content type="html"><![CDATA[<p>递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。</p><p>数学中的定义很多时候都会用到递归，比如 fibonacci 数列：</p><ul><li><code>F(0) = 1</code></li><li><code>F(1) = 1</code></li><li><code>F(n) = F(n - 1) + F(n - 2)</code></li></ul><p>于是有 <code>F(3) = F(2) + F(1) = (F(1) + F(0)) + F(1) = 2</code>。</p><p>递归函数的定义中，并不只是包含调用自身的代码，常常还需要非递归形式的定义，如上面的 <code>F(0) = 1</code> 和 <code>F(1) = 1</code>。这样的代码称作<strong>边缘条件（edge condition）</strong>。<br>边缘条件对于递归函数的终止至关重要。假如上面的 <code>F(0)</code> 和 <code>F(1)</code> 未定义，则任何一个输入都会导致函数无限调用自身，永远不会终止。</p><p>递归是 Haskell 中很重要的概念。不同于命令式的语言，在 Haskell 中需要<strong>定义计算本身是什么</strong>，而不是<strong>定义怎样一步步得出结果</strong>。</p><h5 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs)</span><br><span class="line">    | x &gt; maxTail = x</span><br><span class="line">    | otherwise = maxTail</span><br><span class="line">    <span class="keyword">where</span> maxTail = maximum' xs</span><br></pre></td></tr></table></figure><p>使用 <code>max</code> 函数（返回两个输入值中较大的那个）编写更短的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs) = max x (maximum' xs)</span><br></pre></td></tr></table></figure></p><p>当输入为 <code>[2, 5, 1]</code> 时，计算过程如下：<br><code>maximum&#39; [2, 5, 1]</code> -&gt; <code>max 2 (maximum&#39; [5, 1])</code> -&gt; <code>max 2 (max 5 (maximum&#39; [1]))</code> -&gt; <code>max 2 (max 5 1)</code> -&gt; <code>max 2 5</code> -&gt; <code>5</code>。</p><h5 id="生成由固定数量的同一元素构成的列表"><a href="#生成由固定数量的同一元素构成的列表" class="headerlink" title="生成由固定数量的同一元素构成的列表"></a>生成由固定数量的同一元素构成的列表</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicate'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">replicate'</span> n x</span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []</span><br><span class="line">    | otherwise = x:replicate' (n<span class="number">-1</span>) x</span><br></pre></td></tr></table></figure><p>如 <code>replicate&#39; 3 5</code> -&gt; <code>5:(replicate&#39; 2 5)</code> -&gt; <code>5:(5:(replicate&#39; 1 5))</code> -&gt; <code>5:(5:(5:(replicate&#39; 0 5)))</code> -&gt; <code>5:(5:(5:[]))</code> -&gt; <code>[5, 5, 5]</code>。</p><h5 id="取出列表中的前几个元素"><a href="#取出列表中的前几个元素" class="headerlink" title="取出列表中的前几个元素"></a>取出列表中的前几个元素</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">take'</span> n _</span><br><span class="line">    | n &lt;= <span class="number">0</span>   = []</span><br><span class="line"><span class="title">take'</span> _ []     = []</span><br><span class="line"><span class="title">take'</span> n (x:xs) = x : take' (n<span class="number">-1</span>) xs</span><br></pre></td></tr></table></figure><p>其中 <code>take&#39; n _</code> 和 <code>take&#39; _ []</code> 分别作为两种不同情况下的终止条件。<br>第一个模式 <code>take&#39; n _</code> 表示当 <code>n</code> 小于等于 0 时，不管输入的是什么样的列表都返回空列表 <code>[]</code>。<br>可以作为如 <code>take&#39; 2 [1, 2, 3]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后 <code>n</code> 等于 0，满足第一个模式，递归终止。<br>第二个模式 <code>take _ []</code> 表示当输入的列表是空列表时，不管 <code>n</code> 是多少都返回空列表。<br>可以作为如 <code>take&#39; 3 [1, 2]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后，n 为 1，但列表成为空列表，满足第二个模式，递归终止。<br>第三个模式 <code>take&#39; n (x:xs)</code> 则用来定义从输入的列表头部逐个取出 n 个元素并拼接成新列表的递归逻辑。</p><h5 id="reverse-的自定义实现"><a href="#reverse-的自定义实现" class="headerlink" title="reverse 的自定义实现"></a>reverse 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> [] = []</span><br><span class="line"><span class="title">reverse'</span> (x:xs) = reverse' xs ++ [x]</span><br></pre></td></tr></table></figure><h5 id="zip-的自定义实现"><a href="#zip-的自定义实现" class="headerlink" title="zip 的自定义实现"></a>zip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip'</span> :: [a] -&gt; [b] -&gt; [(a,b)]</span><br><span class="line"><span class="title">zip'</span> _ [] = []</span><br><span class="line"><span class="title">zip'</span> [] _ = []</span><br><span class="line"><span class="title">zip'</span> (x:xs) (y:ys) = (x,y):zip' xs ys</span><br></pre></td></tr></table></figure><h5 id="elem-的自定义实现（判断某个元素是否属于某个列表）"><a href="#elem-的自定义实现（判断某个元素是否属于某个列表）" class="headerlink" title="elem 的自定义实现（判断某个元素是否属于某个列表）"></a>elem 的自定义实现（判断某个元素是否属于某个列表）</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">elem'</span> a [] = <span class="type">False</span></span><br><span class="line"><span class="title">elem'</span> a (x:xs)</span><br><span class="line">    | a == x    = <span class="type">True</span></span><br><span class="line">    | otherwise = a `elem'` xs</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]</span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure><h5 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h5><p>递归函数的定义通常遵循如下模式：</p><ul><li>定义边缘条件（edge conditon）用于在特定条件下终止递归的执行</li><li>取出部分元素执行特定操作，再调用递归函数本身处理剩余的元素</li></ul><p>某个列表中所有元素之和等于该列表的第一个元素加上剩余的所有元素之和；某个列表的长度等于尾部（去除头部第一个元素）所有元素的长度加 1。</p><p>通常情况下，edge condition 就是令递归函数无实际意义的条件。对于列表来说，最常见的 edge condition 就是空列表。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。&lt;/p&gt;
&lt;p&gt;数学中的定义很多时候都会用到递归，比如 fibonacci 数列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F(0) = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F(
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Recursion" scheme="https://rollingstarky.github.io/tags/Recursion/"/>
    
      <category term="Computation" scheme="https://rollingstarky.github.io/tags/Computation/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（二）模式匹配</title>
    <link href="https://rollingstarky.github.io/2021/06/25/basic-haskell-pattern-match/"/>
    <id>https://rollingstarky.github.io/2021/06/25/basic-haskell-pattern-match/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-25T14:53:30.547Z</updated>
    
    <content type="html"><![CDATA[<p>式匹配包含一系列特定的模式，用来判断数据是否符合规则，且能够通过这些模式把符合要求的数据<strong>解构</strong>出来。<br>Haskell 中的模式匹配可以应用到任意的数据类型上（数字、字符、列表、元组等等）。</p><h4 id="函数中的模式匹配"><a href="#函数中的模式匹配" class="headerlink" title="函数中的模式匹配"></a>函数中的模式匹配</h4><p>可以在函数体的定义中，用不同的代码行分别指定不同的模式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| lucky :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>| lucky <span class="number">7</span> = <span class="string">"LUCKY NUMBER SEVEN!"</span></span><br><span class="line"><span class="type">Prelude</span>| lucky x = <span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">1</span></span><br><span class="line"><span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">10</span></span><br><span class="line"><span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">7</span></span><br><span class="line"><span class="string">"LUCKY NUMBER SEVEN!"</span></span><br></pre></td></tr></table></figure></p><p><strong>PS</strong>：上述代码是在 Haskell 的交互式解释器（REPL) <code>ghci</code> 中定义和执行函数的效果。<br>像 <code>lucky</code> 这种包含多行代码的函数，在 ghci 解释器中直接定义时，需要把整个函数体用 <code>:{</code> 和 <code>:}</code> 括起来（否则解释器会报错）。实际的 <code>lucky</code> 函数代码应为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">"LUCKY NUMBER SEVEN!"</span>  </span><br><span class="line"><span class="title">lucky</span> x = <span class="string">"Sorry, you're out of luck, pal!"</span></span><br></pre></td></tr></table></figure></p><p>即 <code>:{</code> 和 <code>:}</code> 从代码的角度讲是多余的，只是 <code>ghci</code> 解释器的缘故，导致必须加上这两个分隔符。若在文件中编写代码，则应该使用第二种形式。</p><p>代码的第一行 <code>lucky :: (Integral a) =&gt; a -&gt; String</code> 是函数的类型签名，也可以省略，解释器会自行推导。<br><code>lucky 7</code> 和 <code>lucky x</code> 两行代码则指定了具体的两个模式：<br>当函数输入为数字 7 时匹配第一个模式，任何其他的数字输入则匹配第二个模式并将该输入值绑定给变量 <code>x</code>。</p><p>一个包含更多个模式的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">"One!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">"Two!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">"Three!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">"Four!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">"Five!"</span>  </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">"Not between 1 and 5"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，最后一行代码 <code>sayMe x</code> 必须作为最后一个模式。<br>函数体中的模式会按照<strong>自顶而下</strong>的顺序检查是否匹配，若当前的模式已完成匹配，则忽略后面的检查；若当前模式不匹配，则继续向下逐个进行检查。<br>若 <code>sayMe x</code> 作为顶部的第一个模式（它实际上会匹配所有合法值），则任何输入值都会在第一步就完成匹配，进而忽略后面的 <code>sayMe 1</code>、<code>sayMe 2</code> 等模式，不再进行判断。即输入任何数字都会先匹配 <code>x</code> 并输出 Not between 1 and 5。</p><p>使用模式匹配和递归实现阶乘函数<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>比如当输入为 3 时，<code>factorial</code> 函数会匹配第二个模式，结果为 <code>3 * (factorial 2)</code>。继续迭代，进一步计算结果中的 <code>factorial 2</code>，得到 <code>3 * (2 * (factorial 1))</code>、<code>3 * (2 * (1 * (factorial 0)))</code>。<br>而 <code>factorial 0</code> 会匹配第一个模式得到结果 1，迭代终止，再和前面的数字相乘后得到最终结果。</p><p>假如将 <code>factorial n = n * factorial (n - 1)</code> 作为第一个模式，则 <code>factorial n</code> 会匹配包含数字 0 在内的所有数字，另一个模式 <code>factorial 0 = 1</code> 就永远不会触发。从而导致迭代没有终止条件，一直进行下去。<br>因此，<strong>在模式匹配中，更精确更有指向性的模式总是放在相对通用和宽泛的模式前面</strong>。</p><p>在使用模式匹配时，应该总是包含一个 catch-all 模式，这样就不会出现所有模式都不匹配的情况。若程序的输入与所有模式都不匹配，程序会崩溃掉。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| charName :: <span class="type">Char</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'a' = <span class="string">"Albert"</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'b' = <span class="string">"Broseph"</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'c' = <span class="string">"Cecil"</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'a'</span><br><span class="line"><span class="string">"Albert"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'b'</span><br><span class="line"><span class="string">"Broseph"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'h'</span><br><span class="line">*** <span class="type">Exception</span>: &lt;interactive&gt;:(<span class="number">3</span>,<span class="number">1</span>)-(<span class="number">5</span>,<span class="number">22</span>): <span class="type">Non</span>-exhaustive patterns <span class="keyword">in</span> function charName</span><br></pre></td></tr></table></figure></p><h4 id="元组中的模式匹配"><a href="#元组中的模式匹配" class="headerlink" title="元组中的模式匹配"></a>元组中的模式匹配</h4><p>在不使用模式匹配的情况下，实现一个计算两个向量之和的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)</span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b)</span><br></pre></td></tr></table></figure></p><p>通过模式匹配实现上述功能：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| addVectors :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)</span><br><span class="line"><span class="type">Prelude</span>| addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; addVectors (<span class="number">1</span>, <span class="number">2</span>) (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p><code>fst</code> 和 <code>snd</code> 函数可以分别用来获取元组中的第一个和第二个元素（但是只针对包含两个元素的元组）。<br>对于有 3 个元素的元组，实际上可以借助模式匹配自己实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a</span><br><span class="line"><span class="title">first</span> (x, _, _) = x</span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b</span><br><span class="line"><span class="title">second</span> (_, y, _) = y</span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c</span><br><span class="line"><span class="title">third</span> (_, _, z) = z</span><br></pre></td></tr></table></figure></p><p>可以在<strong>列表推导</strong>中使用模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="type">Prelude</span>&gt; [a+b | (a,b) &lt;- xs]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>甚至列表本身也可以用于模式匹配。<br>如模式 <code>x:xs</code> 会将列表的第一个元素绑定给变量 <code>x</code>，把其余元素绑定给 <code>xs</code>。此模式的应用非常普遍，尤其是在递归函数中。<br>如果想提取列表的前 3 个元素并将它们绑定给指定变量，可以使用 <code>x:y:z:zs</code> 形式的模式。</p><p>利用对列表的模式匹配实现自定义的 <code>head</code> 函数（获取列表中的第一个元素）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| head' :: [a] -&gt; a</span><br><span class="line"><span class="type">Prelude</span>| head' [] = error <span class="string">"Can't call head on an empty list!"</span></span><br><span class="line"><span class="type">Prelude</span>| head' (x:_) = x</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; head' [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="type">Prelude</span>&gt; head' <span class="string">"Hello"</span></span><br><span class="line">'<span class="type">H'</span></span><br></pre></td></tr></table></figure></p><p>借助递归和模式匹配实现自定义的 <code>length</code> 函数（获取列表的长度）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length'</span> :: (<span class="type">Num</span> b) =&gt; [a] -&gt; b</span><br><span class="line"><span class="title">length'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">length'</span> (_:xs) = <span class="number">1</span> + length' xs</span><br></pre></td></tr></table></figure></p><p>对于任何一个合法的输入如 <code>&quot;ham&quot;</code>，<code>length&#39;</code> 函数的计算过程如下：<br><code>length&#39; &quot;ham&quot;</code> =&gt; <code>1 + length&#39; &quot;am&quot;</code> =&gt; <code>1 + (1 + length&#39; &quot;m&quot;)</code> =&gt; <code>1 + (1 + (1 + length&#39; []))</code> =&gt; <code>1 + (1 + (1 + 0))</code></p><p>实现自定义的 <code>sum</code> 函数（求列表中各元素之和）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum' xs</span><br></pre></td></tr></table></figure></p><h4 id="守卫（guards）"><a href="#守卫（guards）" class="headerlink" title="守卫（guards）"></a>守卫（guards）</h4><p>守卫一般用来测试某个（些）值的特定属性是否为真，很像 if 语句。守卫和模式整合得非常好。</p><p>以下是一个求 BMI（体重指数）的函数定义：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> bmi</span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise   = <span class="string">"You're a whale, congratulations!"</span></span><br></pre></td></tr></table></figure></p><p>管道符（<code>|</code>）后面的布尔表达式即为守卫的定义。若该表达式计算结果为 True，则对应的代码被执行。<br>若该表达式计算结果为 False，则继续测试下一个守卫。</p><p>通常情况下，最后一个守卫是 <code>otherwise</code>。它其实是 <code>otherwise = True</code> 的简写形式，会捕获所有剩余的情况。</p><p>守卫可以配合有多个参数的函数使用：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise                 = <span class="string">"You're a whale, congratulations!"</span></span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; bmiTell <span class="number">65</span> <span class="number">1.75</span></span><br><span class="line"><span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br></pre></td></tr></table></figure><p>通过守卫自定义 <code>max</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">max'</span> a b</span><br><span class="line">    | a &gt; b     = a</span><br><span class="line">    | otherwise = b</span><br></pre></td></tr></table></figure></p><p><strong>where</strong><br>可以通过 <code>where</code> 关键字优化上面的 <code>bmiTell</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise   = <span class="string">"You're a whale, congratulations!"</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>变量 <code>bmi</code> 在这里只计算了一次，不同于之前的 <code>weight / height ^ 2</code> 有可能会被重复计算 3 次。</p><p>更进一步，<code>bmiTell</code> 函数还可以改为如下形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= skinny = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= normal = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= fat    = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise     = <span class="string">"You're a whale, congratulations!"</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br><span class="line">          skinny = <span class="number">18.5</span></span><br><span class="line">          normal = <span class="number">25.0</span></span><br><span class="line">          fat = <span class="number">30.0</span></span><br></pre></td></tr></table></figure></p><p><code>where</code> 语句中也可以定义函数，比如通过由多个包含身高体重的元组组成的列表，计算一系列 BMI 值：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]</span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs]</span><br><span class="line">    <span class="keyword">where</span> bmi weight height = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;式匹配包含一系列特定的模式，用来判断数据是否符合规则，且能够通过这些模式把符合要求的数据&lt;strong&gt;解构&lt;/strong&gt;出来。&lt;br&gt;Haskell 中的模式匹配可以应用到任意的数据类型上（数字、字符、列表、元组等等）。&lt;/p&gt;
&lt;h4 id=&quot;函数中的模式匹配&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="GHC" scheme="https://rollingstarky.github.io/tags/GHC/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Recursion" scheme="https://rollingstarky.github.io/tags/Recursion/"/>
    
      <category term="Deconstruction" scheme="https://rollingstarky.github.io/tags/Deconstruction/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——模式匹配</title>
    <link href="https://rollingstarky.github.io/2021/06/23/the-rust-programming-language-reading-notes-pattern-match/"/>
    <id>https://rollingstarky.github.io/2021/06/23/the-rust-programming-language-reading-notes-pattern-match/</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-23T12:15:54.396Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模式</strong>是 Rust 中一种用来匹配类型结构的特殊语法，将其与 match 表达式或其他工具配合使用可以更好地控制程序流程。<br>模式被用来与某个特定的值进行匹配，若匹配成功，则可以继续使用这个值的某些部分；若匹配失败，模式对应的代码就被简单地略过。</p><h4 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><h5 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a>match 分支</h5><p>模式可以被应用在 match 表达式的分支中。<br>match 表达式由 match 关键字、待匹配的值以及至少一个匹配分支组成。匹配分支则由某个模式及模式匹配成功后应当执行的表达式组成。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> 值 &#123; </span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>match 表达式必须穷尽匹配值的所有可能性</strong>。为了确保代码满足要求，可以在最后的分支处使用<strong>全匹配模式</strong>。例如变量名可以被用来覆盖所有剩余的可能性。<br>还有一个特殊的 <code>_</code> 模式可以被用来匹配所有可能的值，且不将它们绑定到任何一个变量上。即忽略所有未被指定的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">match</span> some_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="if-let-表达式"><a href="#if-let-表达式" class="headerlink" title="if let 表达式"></a>if let 表达式</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> favorite_color: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> age: <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, _&gt; = <span class="string">"34"</span>.parse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(color) = favorite_color &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Using your favorite color &#123;&#125; as the background"</span>, color);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(age) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Using purple as the background color"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Using orange as the background color"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Using blue as the background color"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过执行一系列的条件检查来确定使用的背景颜色。其中的变量已经被赋予了硬编码值，但现实中应当通过用户输入来获取这些值。</p><p>和 match 分支类似，if let 分支能够以同样的方式对变量进行覆盖。<code>if let Ok(age) = age</code> 这句代码中引入了新的变量 <code>age</code> 来存储 Ok 变体中的值，并覆盖了右侧的同名变量。</p><h5 id="while-let-循环"><a href="#while-let-循环" class="headerlink" title="while let 循环"></a>while let 循环</h5><p>while let 会反复执行同一个模式匹配直到出现失败的情形。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">2</span>);</span><br><span class="line">    stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(top) = stack.pop() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码会依次打印 3、2、1。其中的 <code>pop</code> 方法会尝试取出动态数组的最后一个元素并将它包裹在 <code>Some(value)</code> 中返回。若动态数组为空，则 pop 返回 None。<code>while</code> 循环会在 pop 返回 Some 时执行循环体中的代码，pop 返回 None 时结束循环。</p><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p><strong>for 语句中紧随关键字 <code>for</code> 之后的值就是一个模式。</strong>比如 <code>for x in y</code> 中的 <code>x</code> 就是一个模式。</p><p>在 for 循环中使用模式来解构元组：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125; is at index &#123;&#125;"</span>, value, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码使用 <code>enumerate</code> 方法作为迭代器的适配器，会在每次迭代过程中生成一个包含值本身及其索引的元组。如首次调用 <code>enumerate</code> 会产生元组 <code>(0, &#39;a&#39;)</code>。当这个值与模式 <code>(index, value)</code> 进行匹配时，index 就会被赋值为 0，value 就会被赋值为 ‘a’。</p><h5 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h5><p>最基本的 <code>let</code> 赋值语句中也同样用到了模式。更正式的 let 语句的定义如下：<br><code>let PATTERN = EXPRESSION;</code></p><p>在类似于 <code>let x = 5;</code> 这样的语句中，单独的变量名成为最朴素的模式。其中 <code>x</code> 作为模式表达的含义是，将此处匹配到的所有内容绑定至变量 x，因为 x 就是整个模式本身。</p><p>用 let 模式匹配来解构元组：<br><code>let (x, y, z) = (1, 2, 3);</code></p><p>如果模式中元素的数量与元组中元素的数量不同，则整个类型会匹配失败，导致编译错误。</p><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><p>函数的参数同样也是模式。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_coordinates</span></span>(&amp;(x, y): &amp;(<span class="built_in">i32</span>, <span class="built_in">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Current location: (&#123;&#125;, &#123;&#125;)"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> point = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    print_coordinates(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模式 <code>&amp;(x, y)</code> 能够和值 <code>&amp;(3, 5)</code> 匹配，因此 x 的值为 3，y 的值为 5。</p><h4 id="可失败性"><a href="#可失败性" class="headerlink" title="可失败性"></a>可失败性</h4><p><strong>模式可以被分为不可失败（irrefutable）和可失败（refutable）两种类型</strong>。<br>不可失败的模式能够匹配任何传入的值。如语句 <code>let x = 5;</code> 中的 x，因为 x 能够匹配右侧表达式所有可能的返回值。<br>可失败模式则可能因为某些特定的值而匹配失败。如表达式 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code>。若 <code>a_value</code> 变量的值是 None 而不是 Some，则左边的 <code>Some(x)</code> 模式就会出现不匹配的情况。</p><p><strong>函数参数、let 语句及 for 循环只接收不可失败模式</strong>。因为这些场合下，程序无法在值不匹配时执行任何有意义的行为。<br><strong>if let 和 while let 表达式则只接收可失败模式</strong>。因为它们在被设计时就将匹配失败的情形考虑在内了，条件表达式的功能就是根据条件的成功与否执行不同的操作。</p><h4 id="模式语法"><a href="#模式语法" class="headerlink" title="模式语法"></a>模式语法</h4><h5 id="匹配字面量"><a href="#匹配字面量" class="headerlink" title="匹配字面量"></a>匹配字面量</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"two"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h5><p>命名变量是一种可以匹配任何值的不可失败模式。需要注意的是，当我们在 match 表达式中使用命名变量时，由于 match 开启了一个新的作用域，所以被定义在 match 表达式内作为模式一部分的变量会覆盖掉 match 结构外的同名变量。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"Got 50"</span>),</span><br><span class="line">        <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">"Matched, y = &#123;:?&#125;"</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"Default case, x = &#123;:?&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =&gt; Matched, y = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"at the end: x = &#123;:?&#125;, y = &#123;:?&#125;"</span>, x, y);</span><br><span class="line">    <span class="comment">// =&gt; at the end: x = Some(5), y = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，第二个匹配分支的模式引入了新的变量 y，它会匹配 Some 变体中携带的任何值。因为处在 match 表达式创建的新作用域中，这里的 y 是一个新的变量，而不是程序起始处声明的那个存储了 10 的 y。<br>新的 y 绑定能够匹配 Some 中的任意值，即匹配 x 变量中 Some 内部的值 5。</p><p>match 表达式创建的作用域会随着当前表达式的结束而结束，其内部的 y 也无法幸免。因此代码最后的 <code>println!</code> 会输出 <code>at the end: x = Some(5), y = 10</code>。</p><h5 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h5><p>可以在 match 表达式的分支匹配中使用 <code>|</code> 来表示或的意思，从而一次性地匹配多个模式。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one or two"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-来匹配区间"><a href="#使用-来匹配区间" class="headerlink" title="使用 ..= 来匹配区间"></a>使用 <code>..=</code> 来匹配区间</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one through five"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"something else"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用解构来分解值"><a href="#使用解构来分解值" class="headerlink" title="使用解构来分解值"></a>使用解构来分解值</h5><p>可以使用模式来分解结构体、枚举、元组或引用，从而使用这些值中的不同部分。</p><p><strong>解构结构体</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码创建了 a 和 b 两个变量，分别匹配了 p 结构体中字段 x 和 y 的值。<br>采用与字段名相同的变量名在实践中非常常见，为了避免写出类似于 <code>let Point { x: x, y: y } = p</code> 这样冗余的代码，Rust 允许采用如下形式的代码解构结构体：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x, y &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了为所有字段创建变量，还可以在结构体模式中使用字面量来进行解构。这一技术使我们可以在某些特定字段符合要求的前提下再对其他字段进行解构。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On the x axis at &#123;&#125;"</span>, x),</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On the y axis at &#123;&#125;"</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On neither axis: (&#123;&#125;, &#123;&#125;)"</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在第一个分支中要求 y 字段匹配字面量 0，从而匹配到所有位于 x 轴上的点，同时创建了一个可以在随后代码块中使用的 x 变量。<br>类似的第二个分支匹配 y 轴上的点，第三个分支匹配所有剩余的点。</p><p>甚至可以按照某种更为复杂的方式来将模式混合、匹配或嵌套在一起。<br><code>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });</code></p><h5 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h5><p><strong>使用 _ 忽略整个值</strong><br>可以使用下划线 <code>_</code> 作为通配符来匹配任意可能的值而不绑定值本身。虽然 <code>_</code> 模式最常被用在 match 表达式的最后一个分支中，实际上我们可以把它用于包括函数参数在内的一切模式中。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(_: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"This code only uses the y parameter: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码会忽略传给第一个参数的值 3。忽略函数参数在某些情况下会变得有用。比如正在实现一个 trait，而这个 trait 的方法包含了你不需要的某些参数。此时就可以借助忽略模式避免编译器产生未使用变量的警告。</p><p><strong>使用 <code>..</code> 忽略值的剩余部分</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">    z: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>..</code> 语法会自动展开并填充任意多个所需的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Some numbers: &#123;&#125;, &#123;&#125;"</span>, first, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码使用 <code>first</code> 和 <code>last</code> 分别匹配了元组中的第一个值和最后一个值，而它们之间的 <code>..</code> 模式则会匹配并忽略中间的值。</p><h5 id="使用匹配守卫添加额外条件"><a href="#使用匹配守卫添加额外条件" class="headerlink" title="使用匹配守卫添加额外条件"></a>使用匹配守卫添加额外条件</h5><p>匹配守卫（match guard）是附加在 match 分支模式后的 if 条件语句，分支中的模式只有在该条件被同时满足时才能匹配成功。<br>匹配守卫的条件可以使用模式中创建的变量。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"less than five: &#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中，<code>num</code> 能够与第一个分支中的模式匹配成功，随后的匹配守卫则会检查模式中创建的变量 x 是否小于 5。由于 num 同样满足这一条件，最终执行了第一个分支中的代码。<br>假设 num 的值是 <code>Some(10)</code>，则第一个匹配分支中的匹配守卫无法成立，Rust 会进入第二个分支继续比较最终匹配成功。</p><p>我们无法通过模式表达类似于 <code>if x &lt; 5</code> 这样的条件，匹配守卫增强了语句中表达相关逻辑的能力。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;是 Rust 中一种用来匹配类型结构的特殊语法，将其与 match 表达式或其他工具配合使用可以更好地控制程序流程。&lt;br&gt;模式被用来与某个特定的值进行匹配，若匹配成功，则可以继续使用这个值的某些部分；若匹配失败，模式对应的代码就被简单
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——泛型与 trait（特征）</title>
    <link href="https://rollingstarky.github.io/2021/06/20/the-rust-programming-language-reading-notes-generics-and-trait/"/>
    <id>https://rollingstarky.github.io/2021/06/20/the-rust-programming-language-reading-notes-generics-and-trait/</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2021-06-20T13:18:29.320Z</updated>
    
    <content type="html"><![CDATA[<p>所有的编程语言都会致力于高效地处理重复概念，Rust 中的泛型（generics）就是这样一种工具。<strong>泛型是具体类型或其他属性的抽象替代</strong>。比如 <code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Hash&lt;K, V&gt;</code> 等。</p><h4 id="将代码提取为函数以减少重复工作"><a href="#将代码提取为函数以减少重复工作" class="headerlink" title="将代码提取为函数以减少重复工作"></a>将代码提取为函数以减少重复工作</h4><p>下面的代码可以用来在数字列表中找到最大值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = number_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了消除重复代码，可以通过定义函数来创建抽象，令该函数可以接收任意整数列表作为参数并进行求值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(list: &amp;[<span class="built_in">i32</span>]) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们拥有两个不同的函数：一个用于在 i32 切片中搜索最大值；另一个用于在 char 切片中搜索最大值。代码可能是下面这个样子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest_i32</span></span>(list: &amp;[<span class="built_in">i32</span>]) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest_char</span></span>(list: &amp;[<span class="built_in">char</span>]) -&gt; <span class="built_in">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest_i32(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest_char(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="泛型数据类型"><a href="#泛型数据类型" class="headerlink" title="泛型数据类型"></a>泛型数据类型</h5><p><strong>在函数定义中使用</strong><br>当使用泛型来定义一个函数时，我们需要将泛型放置在函数签名中用于指定参数和返回值类型的地方。<br>以这种方式编写的代码更加灵活，可以在不引入重复代码的同时向函数调用者提供更多的功能。</p><p>上面代码中的 <code>largest_i32</code> 和 <code>largest_char</code> 是两个只在名称和签名上有所区别的函数。<code>largest_i32</code> 作用于 i32 类型的切片，而 <code>largest_char</code> 作用于 char 类型的切片。<br>这两个函数拥有完全相同的代码，因此可以通过在一个函数中使用泛型来消除重复代码。</p><p>在函数签名中使用泛型合并不同的 largest 函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>largest&lt;T: PartialOrd + Copy&gt;</code> 部分的 <code>PartialOrd</code> 和 <code>Copy</code> 是为类型 T 指定的两个 <strong>trait 约束</strong>（后面会提到）。</p><p><strong>在结构体定义中使用</strong><br>同样地，也可以使用 <code>&lt;&gt;</code> 语法来定义在一个或多个字段中使用泛型的结构体。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码，在结构名后的一对尖括号中声明泛型参数后，就可以在结构体定义中用于指定具体数据类型的位置使用泛型了。</p><p>在定义 <code>Point&lt;T&gt;</code> 结构体时仅使用了一个泛型参数，表明该结构体对某个类型 <code>T</code> 是通用的。但无论 <code>T</code> 具体的类型是什么，字段 <code>x</code> 和 <code>y</code> 都同时属于这个类型。即 <code>x</code> 和 <code>y</code> 只能是同一类型。</p><p>为了使结构体 Point 中的 x 和 y 能够被实例化为不同的类型，可以使用多个泛型参数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> both_integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> both_float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> integer_and_float = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在方法定义中使用</strong><br>方法也可以在自己的定义中使用泛型：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码为结构体  <code>Point&lt;T&gt;</code> 实现了名为 <code>x</code> 的方法，返回一个指向 x 字段中 T 类型值的引用。</p><p>紧跟着 impl 关键字声明 T 是必须的。通过在 impl 之后将 T 声明为泛型，Rust 能够识别出 <code>Point&lt;T&gt;</code> 中尖括号内的类型是泛型而不是具体的类型。</p><p>实际上，可以单独为 <code>Point&lt;f32&gt;</code> 实例而不是所有的 <code>Point&lt;T&gt;</code> 泛型实例来实现特定的方法。<br>当在 <code>Point&lt;32&gt;</code> 声明中使用了明确的类型 f32，也意味着无需在 impl 之后附带任何类型声明了。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">distance_from_origin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.powi(<span class="number">2</span>) + <span class="keyword">self</span>.y.powi(<span class="number">2</span>)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码意味着，类型 <code>Point&lt;f32&gt;</code> 将会拥有一个名为 <code>distance_from_origin</code> 的方法，而其他的 <code>Point&lt;T&gt;</code> 实例则没有该方法的定义。</p><p>结构体定义中的泛型参数并不总是与方法签名中使用的类型参数一致。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p2 = Point &#123; x: <span class="string">"Hello"</span>, y: <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p3 = p1.mixup(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p3.x = &#123;&#125;, p3.y = &#123;&#125;"</span>, p3.x, p3.y);</span><br><span class="line">    <span class="comment">// =&gt; p3.x = 5, p3.y = c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="trait：定义共享行为"><a href="#trait：定义共享行为" class="headerlink" title="trait：定义共享行为"></a>trait：定义共享行为</h4><p><strong>trait</strong> 用来向 Rust 编译器描述某些特定类型拥有的且能够被其他类型共享的功能，使我们可以以一种抽象的方式来定义共享行为。</p><p>trait 与其他语言中的接口（interface）功能类似，但也不尽相同。<br><strong>类型的行为由该类型本身可供调用的方法组成</strong>。当我们可以在不同的类型上调用相同的方法时，就称这些类型共享了相同的行为。<br><strong>trait 提供了一种将特定方法组合起来的途径，定义了为达成某种目的所必须的方法（行为）集合</strong>。</p><h5 id="定义-trait"><a href="#定义-trait" class="headerlink" title="定义 trait"></a>定义 trait</h5><p>假如我们拥有多个结构体（struct），分别持有不同类型、不同数量的文本字段。其中 NewsArticle 结构体存放新闻故事，Tweet 结构体存放推文。<br>我们还想要方便地获取存储在 NewsArticle 和 Tweet 实例中的数据摘要。因此需要为每个结构体类型都实现摘要行为，从而可以在这些实例上统一地调用 <code>summarize</code> 方法来请求摘要内容。</p><p>可以定义如下形式的 Summary trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在大括号中声明了用于定义类型行为的方法签名，即 <code>fn summarize(&amp;self) -&gt; String;</code>。<br>方法签名后省略了大括号及方法的具体实现。<strong>任何想要实现这个 trait 的类型都需要为上述方法提供自定义行为。编译器会确保每一个实现了 Summary trait 的类型都定义了与这个签名完全一致的 summarize 方法</strong>。<br>一个 trait 可以包含多个方法，每个方法签名占据单独一行并以分号结尾。</p><p><strong>为类型实现 trait</strong></p><p>完整代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>,</span><br><span class="line">    location: <span class="built_in">String</span>,</span><br><span class="line">    author: <span class="built_in">String</span>,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">    reply: <span class="built_in">bool</span>,</span><br><span class="line">    retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">    <span class="comment">// =&gt; 1 new tweet: horse_ebooks: of course, as you probably already know, people</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>impl Summary for NewsArticle</code> 和 <code>impl Summary for Tweet</code> 部分负责为 NewsArticle 和 Tweet 两个结构体类型定义 Summary trait 中指定的 <code>summarize</code> 方法，并为该方法实现具体的行为。</p><h5 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h5><p>某些时候，为 trait 中的某些或所有方法都提供默认行为非常有用，使我们无需为每一个类型的 trait 实现都提供自定义行为。<br>当我们为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p><p>如为 Summary trait 中的 <code>summarize</code> 方法指定一个默认的字符串返回值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"(Read More...)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如需要在 NewsArticle 的实例中使用上述默认实现，而不是自定义实现，可以指定一个空的 impl 代码块：<br><code>impl Summary for NewsArticle {}</code></p><p>此时虽然没有直接为 NewsArticle 定义 <code>summarize</code> 方法，依然可以在 NewsArticle 实例上调用 <code>summarize</code> 方法。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> article = NewsArticle &#123;</span><br><span class="line">        headline: <span class="built_in">String</span>::from(<span class="string">"Penguins win the Stanley Cup Championship!"</span>),</span><br><span class="line">        location: <span class="built_in">String</span>::from(<span class="string">"Pittsburgh, PA, USA"</span>),</span><br><span class="line">        author: <span class="built_in">String</span>::from(<span class="string">"Iceburgh"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(</span><br><span class="line">            <span class="string">"The Pittsburgh Penguins once again are the best</span></span><br><span class="line"><span class="string">    hockey team in the NHL."</span>,</span><br><span class="line">        ),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"New article available! &#123;&#125;"</span>, article.summarize());</span><br><span class="line">    <span class="comment">// =&gt; New article available! (Read More...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以在默认实现中调用同一 trait 中的其他方法，哪怕这些被调用的方法没有默认实现</strong>。例如，可以为 Summary trait 定义一个<strong>需要被实现</strong>的方法 <code>summarize_author</code>（即 trait 中没有该方法的默认实现，需要在后续的类型中实现），再通过调用 <code>summarize_author</code> 为 <code>summarize</code> 方法提供一个默认实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使用这个版本的 Summary，只需要在后续类型实现这一 trait 时定义 <code>summarize_author</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"@&#123;&#125;"</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了 <code>summarize_author</code> 之后，就可以在 Tweet 实例上调用 <code>summarize</code> 了。<code>summarize</code> 的默认实现会进一步调用我们提供的 <code>summarize_author</code> 的定义。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">    <span class="comment">// =&gt; 1 new tweet: (Read more from @horse_ebooks...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h5><p>前面的代码中为 NewsArticle 和 Tweet 类型实现了 Summary trait，我们还可以定义一个 notify 函数来调用这些类型的 <code>summarize</code> 方法。语法如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码没有为 <code>item</code> 参数指定具体的类型，而是使用了 <code>impl</code> 关键字及对应的 trait 名称。<br>这意味着 <code>item</code> 参数可以接收任何实现了指定 trait 的类型。在 <code>notify</code> 函数体内，则可以调用来自 Summary trait 的任何方法。<br>尝试使用其他类型（如 <code>String</code> 或 <code>i32</code>）来调用 <code>notify</code> 函数则无法通过编译，因为这些类型没有实现 Summary trait。</p><p>上述代码其实只是 <strong>trait 约束</strong>的一种语法糖，完整形式如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br></pre></td></tr></table></figure></p><p><strong>通过 + 语法来指定多个 trait 约束</strong><br>如果 notify 函数需要在调用 summarize 方法的同时显示格式化后的 item，则此处的 item 就必须实现两个不同的 trait：Summary 和 Display。<br><code>fn notify(item: impl Summary + Display) {</code></p><p>这一语法在泛型的 trait 约束中同样有效：<br><code>fn notify&lt;T: Summary + Display&gt;(item: T) {</code></p><p><strong>where 从句简化 trait 约束</strong><br>因为每个泛型都拥有自己的 trait 约束，定义多个类型参数的函数可能会有大量的 trait 约束信息需要被填写在函数名与参数列表之间。Rust 提供了一种替代语法。</p><p>如 <code>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {</code></p><p>可以改写成如下形式：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></p><h5 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h5><p>同样可以在返回值中使用 impl Trait 语法，用于返回某种实现了特定 trait 的类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前在介绍泛型时编写的 <code>largest</code> 函数就通过 trait 约束来限定泛型参数的具体类型。<br>在 <code>largest</code> 函数中，我们想要使用大于号运算符来比较两个 T 类型的值。这一运算符被定义为标准库 <code>std::cmp::PartialOrd</code> 的一个默认方法，因此需要在 T 的 trait  约束中指定 <code>PartialOrd</code>，才能够使 <code>largest</code> 函数用于任何可比较类型的切片上。</p><p>我们在编写 <code>largest</code> 函数的非泛型版本时，只尝试过搜索 <code>i32</code> 和 <code>char</code> 类型的最大值。这两种都是拥有确定大小并存储在栈上的类型，实现了 Copy trait。<br>但当我们尝试将 <code>largest</code> 函数泛型化时，list 参数中的类型有可能是没有实现 Copy trait 的。为了确保这个函数只会被那些实现了 Copy trait 的类型所调用，还需要把 Copy 加入到 T 的 trait 约束中。</p><p>所以最终的 <code>largest</code> 函数采用如下声明：<br><code>fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {</code></p><h5 id="使用-trait-约束有条件地实现方法"><a href="#使用-trait-约束有条件地实现方法" class="headerlink" title="使用 trait 约束有条件地实现方法"></a>使用 trait 约束有条件地实现方法</h5><p>通过在带有泛型参数的 impl 代码块中使用 trait 约束，我们可以单独为实现了指定 trait 的类型编写方法。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Pair::new(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    pair.cmp_display()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，所有的 <code>Pair&lt;T&gt;</code> 类型都会实现 <code>new</code> 方法，但只有在内部类型 <code>T</code> 实现了 <code>PartialOrd</code>（用于比较）和  <code>Display</code>（用于打印）这两个 trait 的前提下，才会实现 <code>cmd_display</code> 方法。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>借助于 trait 和 trait 约束，我们可以在使用泛型参数消除重复代码的同时，向编译器指明自己希望泛型拥有的功能。而编译器则可以利用这些 trait 约束信息来确保代码中使用的具体类型提供了正确的行为</strong>。<br>在动态语言中，尝试调用类型没有实现的方法会导致在运行时出现错误。Rust 将这些错误出现的时机转移到了编译期，我们无需编写那些用于在运行时检查类型的代码，这一机制在保留泛型灵活性的同时提升了代码性能。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有的编程语言都会致力于高效地处理重复概念，Rust 中的泛型（generics）就是这样一种工具。&lt;strong&gt;泛型是具体类型或其他属性的抽象替代&lt;/strong&gt;。比如 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Generics" scheme="https://rollingstarky.github.io/tags/Generics/"/>
    
      <category term="Interface" scheme="https://rollingstarky.github.io/tags/Interface/"/>
    
      <category term="Trait" scheme="https://rollingstarky.github.io/tags/Trait/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——通用集合类型</title>
    <link href="https://rollingstarky.github.io/2021/06/14/the-rust-programming-language-reading-notes-collections/"/>
    <id>https://rollingstarky.github.io/2021/06/14/the-rust-programming-language-reading-notes-collections/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2021-06-14T14:54:05.591Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 标准库包含了一系列被称为集合的数据结构。<strong>与内置的数组和元组不同，集合将自己持有的数据存储在堆上。这使得数据的大小不需要在编译时确定，且可以随着程序的运行按需扩大或缩小数据占用的空间</strong>。</p><p>Rust 中有 3 种最常用的集合类型：</p><ul><li>动态数组（vector）</li><li>字符串（string）</li><li>哈希映射（hash map）</li></ul><h4 id="使用动态数组存储多个值"><a href="#使用动态数组存储多个值" class="headerlink" title="使用动态数组存储多个值"></a>使用动态数组存储多个值</h4><p>动态数组（<code>Vec&lt;T&gt;</code>）支持在单个数据结构中存储多个<strong>相同类型</strong>的值，这些值会彼此相邻地排布在内存中。</p><p>可以调用函数 <code>Vec::new</code> 来创建一个空的动态数组：<br><code>let v: Vec&lt;i32&gt; = Vec::new();</code></p><p>上述代码会创建一个用来存储 <code>i32</code> 数据地的空的动态数组。由于并未在这个动态数组中插入任何值，因此需要显式地添加类型标记（<code>Vec&lt;i32&gt;</code>）。</p><p>用初始值去创建动态数组的场景也十分常见，因此 Rust 特意提供了一个用于简化代码的 <code>vec!</code> 宏。<br><code>let v = vec![1, 2, 3]</code></p><p>更新动态数组：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line">v.push(<span class="number">7</span>);</span><br><span class="line">v.push(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></p><p><strong>销毁动态数组时也会销毁其中的元素</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  执行与 v 相关的操作</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//  &lt;- v 在这里离开作用域并随之被销毁</span></span><br></pre></td></tr></table></figure></p><p>可以使用索引和 <code>get</code> 两种方法读取动态数组中的元素。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third number is &#123;&#125;"</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ul><li>动态数组使用数字进行索引，索引值从 0 开始</li><li>使用 <code>&amp;</code> 与 <code>[]</code> 会直接返回元素的引用</li><li>接收索引作为参数的 get 方法会返回一个 <code>Option&lt;T&gt;</code> 类型</li></ul><p>当尝试使用不存在的索引值去访问动态数组时，上述两种引用方法会导致程序触发不同的响应方式。比如对于某个持有 5 个元素的动态数组，尝试访问其索引为 100 的元素。</p><p><code>[]</code> 方法会因为索引指向了不存在的元素而触发 panic，假如希望在尝试越界访问元素时令程序直接崩溃，此方法就很适用。<br><code>get</code> 方法会在检测到索引越界时直接返回 <code>None</code>，而不会导致程序崩溃。当偶尔越界访问动态数组的元素是一种正常行为时，可以使用此方法。此外，<strong>代码应该合乎逻辑地处理 <code>Some(&amp;element)</code> 与 <code>None</code> 两种不同的情形</strong>。</p><p><strong>在存在指向动态数组元素的引用时，尝试向动态数组中添加元素会导致编译器报错</strong>。比如下面的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The first element is &#123;&#125;"</span>, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对第一个元素的引用需要关心动态数组结尾处的变化，这与动态数组的机制有关。<br>动态数组中的元素是连续地存储在堆中的，插入新的元素也许会没有足够多的空间将所有元素依次相邻地放下。这就需要分配新的内存空间，再将旧的元素移动到新的空间上，旧的空间被释放。<br>也就是说，动态数组末尾插入数据有可能导致上面代码中第一个元素的引用指向了被释放的内存。</p><h5 id="遍历动态数组"><a href="#遍历动态数组" class="headerlink" title="遍历动态数组"></a>遍历动态数组</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以遍历可变的动态数组，获得元素的可变引用，并修改其中的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使 <code>+=</code> 运算符修改可变引用的值，需要使用解引用运算符 <code>*</code> 来获取 <code>i</code> 绑定的值。</p><h4 id="使用字符串存储-UTF-8-文本"><a href="#使用字符串存储-UTF-8-文本" class="headerlink" title="使用字符串存储 UTF-8 文本"></a>使用字符串存储 UTF-8 文本</h4><p>Rust 在语言核心部分只有一种字符串类型，即<strong>字符串切片 str</strong>，通常以借用的形式（<code>&amp;str</code>）出现。<strong>字符串切片是一些指向存储在别处的 UTF-8 编码的字符串的引用</strong>。</p><p>String 类型被定义在 Rust 标准库中，没有内置在语言的核心部分。它也采用了 UTF-8 编码。</p><h5 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h5><p>许多对于 <code>Vec&lt;T&gt;</code> 的操作同样可用于 String，比如可以从 <code>new</code> 函数创建一个新的空字符串：<br><code>let mut s = String::new();</code></p><p>可以对那些实现了 Display trait 的类型调用 <code>to_string</code> 方法，创建有初始数据的字符串：<br><code>let s = &quot;initial contents&quot;.to_string();</code></p><p>也可以使用 <code>String::from</code> 函数基于字符串字面量生成 String：<br><code>let s = String::from(&quot;initial contents&quot;);</code></p><p>字符串是基于 UTF-8 编码的，因此可以将任何合法的数据编码进字符串：<br><code>let hello = String::from(&quot;你好&quot;);</code></p><h5 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a>更新字符串</h5><p>可以使用 <code>push_str</code> 方法来向 String 中添加一段字符串切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">s.push_str(<span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure></p><p><code>push</code> 方法接收单个字符作为参数，并将它添加到 String 中。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"lo"</span>);</span><br><span class="line">s.push(<span class="string">'l'</span>);</span><br></pre></td></tr></table></figure></p><p>使用 <code>+</code> 运算符将两个 String 合并到一个新的 String 中：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Hello, "</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> s3 = s1 + &amp;s2;  <span class="comment">// 这里的 s1 已经被移动且再也不能被使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面的加法操作中只对变量 s2 采用了引用，而 s1 由于所有权的移动在加法操作之后不再有效。<br>这里的 <code>+</code> 运算符会调用一个 <code>add</code> 方法，其签名类似于：<br><code>fn add(self, s: &amp;str) -&gt; String {</code></p><p>由于函数签名中的 <code>self</code> 并没有使用 <code>&amp;</code> 标记，因此 add 函数会取得 self 的所有权，导致 s1 被移动至 add 函数调用中，在调用后失效。<br>这种实现要比单纯的复制更加高效。</p><p>对于复杂一些的比如多个字符串的合并，可以使用 <code>format!</code> 宏：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"tic"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"tac"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure></p><p><code>format!</code> 宏与 <code>println!</code> 宏的工作原理完全相同，只不过 <code>format!</code> 会将结果包含在一个 String 中返回。这使得用 <code>format!</code> 的代码更加易读，且不会夺取任何参数的所有权。</p><h5 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h5><p><strong>Rust 中的字符串不支持索引</strong>。比如下面的代码会导致编译器报错：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> h = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>String 实际上是一个基于 <code>Vec&lt;u8&gt;</code> 的封装类型。<br><code>let len = String::from(&quot;Hola&quot;).len();</code> 中，变量 <code>len</code> 的值为 4，意味着动态数组所存储的字符串 Hola 占用了 4 个字节。<br>而 <code>let len = String::from(&quot;你好&quot;).len();</code> 中，Rust 返回的结果却并不是 2，而是 6。这就是使用 UTF-8 编码来存储“你好”所需要的字节数。<br>因此<strong>对于字符串中字节的索引并不总是能对应到一个有效的 Unicode 标量值</strong>。</p><p>还有一个原因，索引操作的复杂度往往会被预期为常数时间 O(1)，但在 String 中，Rust 必须要从头遍历至索引位置来确定究竟有多少合法字符存在，这无法保障常数时间的性能。</p><h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><p>字符串切片是指向 String 对象中某个连续部分的<strong>引用</strong>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure></p><p>向函数传入字符串切片并不会导致切片指向的原始 String 因为所有权的移动而失效。</p><p>字符串字面量就是切片。<br><code>let s = &quot;Hello, world!&quot;;</code><br>变量 s 的类型其实是 <code>&amp;str</code>，是一个指向二进制程序特定位置的切片。正是由于 <code>&amp;str</code> 是一个不可变引用，字符串字面量才是不可变的。</p><p>尝试通过索引引用字符串通常是一个坏主意，因为该操作应当返回的类型是不明确的：究竟应该是字节、字符、字形簇还是切片呢？<br>Rust 要求程序员做出更加明确的标记，在索引的 <code>[]</code> 中填写范围来指定所需的<strong>字节内容</strong>，即明确其类型为字符串切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">    <span class="comment">// =&gt; 你</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>s</code> 将会是一个包含了字符串前 3 个字节的 <code>&amp;str</code>，即 <code>你</code>。若尝试在代码中使用 <code>&amp;hello[0..2]</code>，则程序运行时会发生 panic：<br><code>thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;你&#39; (bytes 0..3) of `你好`&#39;</code></p><p><strong>切记要小心谨慎地使用范围语法创建字符串切片</strong>。</p><p>假如确实需要对每一个 Unicode 标量值都进行处理，最好的办法是使用 <code>chars</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> hello.chars() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">        <span class="comment">// =&gt; 你</span></span><br><span class="line">        <span class="comment">// =&gt; 好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="在映射中存储键值对"><a href="#在映射中存储键值对" class="headerlink" title="在映射中存储键值对"></a>在映射中存储键值对</h4><p>哈希映射 <code>HashMap&lt;K, V&gt;</code> 存储了从 K 类型键关联到 V 类型值之间的映射关系。</p><h5 id="创建哈希映射"><a href="#创建哈希映射" class="headerlink" title="创建哈希映射"></a>创建哈希映射</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>和动态数组一样，哈希映射也将其数据存储在堆上。它同样也是同质的，即所有键必须拥有相同的类型，所有的值也必须拥有相同的类型。</p><p>另一种构建哈希映射的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure></p><h5 id="哈希映射与所有权"><a href="#哈希映射与所有权" class="headerlink" title="哈希映射与所有权"></a>哈希映射与所有权</h5><p>对于那些实现了 Copy trait 的类型如 i32，它们的值会被简单地复制到哈希映射中。而对于 String 这种持有所有权的值，其所有权会转移给哈希映射：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">map.insert(field_name, field_value);</span><br><span class="line"><span class="comment">// filed_name 和 field_value 从这一刻开始失效，若尝试使用它们则会导致编译错误！</span></span><br></pre></td></tr></table></figure></p><p>在调用 <code>insert</code> 方法后，field_name 和 field_value 变量会被移动到哈希映射中，之后就无法再使用这两个变量了。</p><h5 id="访问哈希映射中的值"><a href="#访问哈希映射中的值" class="headerlink" title="访问哈希映射中的值"></a>访问哈希映射中的值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><p><code>get</code> 返回的是一个 <code>Option&lt;&amp;V&gt;</code> 类型。因此上面代码中的 <code>score</code> 将会是与蓝队相关联的值，即 <code>Some(&amp;10)</code>。<br>若哈希映射中没有指定键所对应的值，<code>get</code> 方法就会返回 <code>None</code>。</p><p>可以使用 <code>for</code> 循环遍历哈希映射：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="更新哈希映射"><a href="#更新哈希映射" class="headerlink" title="更新哈希映射"></a>更新哈希映射</h5><p><strong>替换旧值</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure></p><p>原来的值 10 会被新值 25 替换掉。</p><p><strong>只在某个键没有对应值时才插入数据</strong><br>即若某个键对应的值存在，保持原状；若该值不存在，将参数作为新值插入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br><span class="line">    <span class="comment">// =&gt; &#123;"Blue": 10, "Yellow": 50&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于旧值更新值</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br><span class="line">    <span class="comment">// =&gt; &#123;"hello": 1, "world": 2, "wonderful": 1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 标准库包含了一系列被称为集合的数据结构。&lt;strong&gt;与内置的数组和元组不同，集合将自己持有的数据存储在堆上。这使得数据的大小不需要在编译时确定，且可以随着程序的运行按需扩大或缩小数据占用的空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Rust 中有 3 种最常用的集
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="List" scheme="https://rollingstarky.github.io/tags/List/"/>
    
      <category term="String" scheme="https://rollingstarky.github.io/tags/String/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Collection" scheme="https://rollingstarky.github.io/tags/Collection/"/>
    
      <category term="Vector" scheme="https://rollingstarky.github.io/tags/Vector/"/>
    
      <category term="HashMap" scheme="https://rollingstarky.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——结构体（Struct）</title>
    <link href="https://rollingstarky.github.io/2021/06/09/the-rust-programming-language-reading-notes-struct/"/>
    <id>https://rollingstarky.github.io/2021/06/09/the-rust-programming-language-reading-notes-struct/</id>
    <published>2021-06-08T16:00:00.000Z</published>
    <updated>2021-06-09T15:29:10.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>结构（Struct）是一种自定义数据类型</strong>。允许我们命名多个相关的值并将它们组成一个有机的结合体。</p><h4 id="定义与实例化"><a href="#定义与实例化" class="headerlink" title="定义与实例化"></a>定义与实例化</h4><p>关键字 <code>struct</code> 被用来定义并命名结构体，一个良好的结构体名称需反映出自身数据组合的意义。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构体就像是类型的通用模板，将具体的数据填入模板时就创建了新的实例</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在创建了结构体实例后，可以通过点号来访问实例中的特定字段。假如这个实例是可变的，还可以通过点号来修改字段的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">"anotheremail@example.com"</span>);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<strong>一旦结构体实例定义为可变，那么实例中的所有字段都将是可变的</strong>。</p><p>可以在函数体的最后一个表达式中构建结构体实例，来隐式的将这个实例作为结果返回。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在变量名与字段名相同时，可以使用简化版的字段初始化方法重构上面的 <code>build_user</code> 函数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在许多情况下，新创建的实例中，除了需要修改的小部分字段以外，其余字段的值与旧实例完全相同。可以使用<strong>结构体更新语法</strong>快速实现此类新实例的创建。</p><p>使用结构体更新语法来为一个 User 实例设置新的 email 和 username 字段的值，并从 user1 实例中获取剩余字段的值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>..</code> 表示剩下的那些还未被显式赋值的字段都与给定实例拥有相同的值。</p><h5 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h5><p>可以使用一种类似元组的方式定义结构体，这种结构体也被称作元组结构体。元组结构体同样拥有表明自身含义的名称，但无需在声明时对其字段进行命名，只标注类型即可。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这里的 black 和 origin 是不同的类型，因为它们两个分别是不同元组结构体的实例。<br><strong>每一个结构体都拥有自己的类型</strong>。</p><h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>使用 cargo 命令创建一个名为 rectangles 的项目：<br><code>cargo new rectangles</code><br>这个程序会接收以像素为单位的宽度和高度作为输入，并计算出对应的长方形面积。</p><p>编辑项目中的 <code>src/main.rs</code> 源代码文件：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> width1 = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> height1 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(width1, height1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行 <code>cargo run</code> 命令查看输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 2.53s</span><br><span class="line">     Running `target/debug/rectangle`</span><br><span class="line">The area of the rectangle is 1500</span><br></pre></td></tr></table></figure></p><p><code>area</code> 函数用来计算长方形的面积，接收宽和高两个参数。这两个参数是相互关联的，但程序中没有任何地方可以体现这一点。将宽和高放在一起能够使代码更加易懂和易于维护。</p><p><strong>使用元组关联长方形的宽和高</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = (<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(rect1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(dimensions: (<span class="built_in">u32</span>, <span class="built_in">u32</span>)) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    dimensions.<span class="number">0</span> * dimensions.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，元组使输入的参数结构化了，现在只需要传递一个参数就可以调用函数 <code>area</code>。<br>但元组不会给出自身元素的名称，只能通过索引访问。这使得程序变得难以阅读。<br>比如当需要将该长方形绘制到屏幕上时，混淆宽度和高度就容易出现问题。</p><p><strong>使用结构体增加有意义的描述信息</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(&amp;rect1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Rectangle 结构体表明了宽度和高度是相互关联的两个值，并为这些值提供了描述性的名字。因此代码看起来会更加清晰。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法与函数十分相似，它们都使用 <code>fn</code> 关键字及一个名称进行声明；它们都可以拥有参数和返回值；它们都包含了一段在调用时执行的代码。<br>但<strong>方法总是被定义在某个结构体（或者枚举类型、trait 对象）的上下文中，且它们的第一个参数都是 <code>self</code>，用于指代调用该方法的结构体实例</strong>。</p><p>将 <code>area</code> 函数定义为 Rectangle 结构体中的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, rect1.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于方法的声明被放置在 <code>impl Rectangle</code> 块中，因此 Rust 能够将 <code>self</code> 的类型推导为 Rectangle，我们才可以在 <code>area</code> 的签名中使用 <code>&amp;self</code> 来替代 <code>&amp;Rectangle</code>。<br>使用方法替代函数不仅能够避免在每个方法的签名中重复编写 self 的类型，还有助于程序员组织代码的结构。可以将某个类型的实例需要的功能放置在同一个 impl 块中，避免用户在代码库中盲目地搜索它们。</p><p>添加 <code>can_hold</code> 方法检测当前的 Rectangle 实例能否完整地包含传入的另一个 Rectangle 实例：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect2 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect3 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"Can rect1 hold rect2? &#123;&#125;"</span>, rect1.can_hold(&amp;rect2));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"Can rect1 hold rect3? &#123;&#125;"</span>, rect1.can_hold(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h5><p>除了方法，impl 块还允许我们定义不用接收 self 作为参数的函数。这类函数与结构体（而不是实例）相互关联，因此也被称为关联函数。<br>它们不会作用于某个具体的结构体实例。<br>之前用到的 <code>String::from</code> 就是关联函数的一种。</p><p>关联函数常被用作构造器来返回一个结构体的新实例。例如可以编写一个 <code>square</code> 关联函数，只接收一个参数，该参数同时用作宽度与高度来构造正方形实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用 <code>let sq = Rectangle::square(3);</code> 类似的语法来创建正方形实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>结构体可以让我们基于特定领域的规则创建有意义的自定义类型</strong>。<br>通过使用结构体，可以将相互关联的数据组合起来，并为每条数据赋予有含义的名称，从而使代码更加清晰。<br>方法可以让我们为结构体实例指定特殊的行为，而关联函数则可以将那些不需要实例的特定功能放置到结构体的命名空间中。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;结构（Struct）是一种自定义数据类型&lt;/strong&gt;。允许我们命名多个相关的值并将它们组成一个有机的结合体。&lt;/p&gt;
&lt;h4 id=&quot;定义与实例化&quot;&gt;&lt;a href=&quot;#定义与实例化&quot; class=&quot;headerlink&quot; title=&quot;定义与实例化&quot;
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Struct" scheme="https://rollingstarky.github.io/tags/Struct/"/>
    
      <category term="Method" scheme="https://rollingstarky.github.io/tags/Method/"/>
    
  </entry>
  
</feed>
