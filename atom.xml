<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2023-09-08T19:33:40.599Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Init Container</title>
    <link href="https://rollingstarky.github.io/2023/09/09/kubernetes-patterns-reading-notes-init-container/"/>
    <id>https://rollingstarky.github.io/2023/09/09/kubernetes-patterns-reading-notes-init-container/</id>
    <published>2023-09-08T16:00:00.000Z</published>
    <updated>2023-09-08T19:33:40.599Z</updated>
    
    <content type="html"><![CDATA[<p>Init Container 为初始化相关的任务提供了区别于主应用程序的独立的生命周期，从而实现关注点分离。</p><p>初始化在很多编程语言中都备受关注。比如在 Java 中，为了初始化某个需要配置的对象，我们使用 constructor。<br>Constructor 会保证在对象中是第一个运行的，且只被 runtime 运行一次。此外，还可以使用构造函数验证强制参数之类的先决条件，传入参数或默认值以初始化实例字段。</p><p>Init Container 与构造函数是类似的，只不过是在 Pod 级别而不是类级别。<br>假如 Pod 中有一个或多个容器代表主应用程序，这些容器可能需要一些启动前的先决条件。比如为文件系统设置特殊的权限，设置数据库 schema，应用程序种子数据的安装等。同时，这些初始化逻辑可能需要主容器镜像中不包含的工具和库。<br>又或者，用户想要延迟应用的启动，直到可以确认某个外部的依赖满足条件。<br>所有上述需求都可以通过 Kubernetes 提供的 Init Container 实现。</p><p>Kubernetes 中的 Init Container 属于 Pod 定义的一部分，可以将容器划分成两组：init containers 和 application containers。<br>所有的 init container 会以串行的顺序一个接一个地执行，在应用容器开始启动之前，所有 init container 的执行必须成功完成。<br>而应用容器是可以并行运行的，启动顺序也是任意的。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d33171274696c714.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Init and application containers"></p><p>通常情况下，init container 应该是小型快速且能成功完成的，除非它是用来延迟 Pod 的启动以等待某个依赖符合要求。<br>当 init container 失败时，整个 Pod 会重新启动（除非配置了 <code>RestartNever</code>），导致所有 init container 重新执行一遍。因而令它们符合幂等原则可以避免副作用。<br>一方面，init container 有着和应用容器一样的能力：位于同一个 Pod 中，共享资源限制、存储卷和安全设置。另一方面，它们的健康检查和资源处理在语义上有些许不同。它们不存在 rediness check，因为只有当所有的 init container 成功结束之后应用容器才会继续启动。</p><p>在容器调度、自动伸缩、配额管理方面，Init container 会影响 Pod 请求和计算资源的方式。由于所有的 init container 会先串行执行到终止，接着应用容器并行运行。因而高效的 Pod 级别的资源分配取决于以下两组值中较大的那个：</p><ul><li>所有 init container 中资源请求或限制值最大的那个</li><li>所有应用容器资源请求或限制的总和</li></ul><p>上述行为的限制在于，当 init container 的资源需求非常高而应用容器相对很低时，这种配置对于资源的利用就很低效。因为 init container 一般只运行很短的一段时间，其他 Pod 无法使用 init container 运行结束后空闲下来的资源。</p><p>Init container 能够实现关注点分离，从而使容器保持 single-purposed。应用容器可以由只关注应用逻辑的开发工程师创建，而部署工程师可以为其添加 init container 并只关注配置和初始化任务。比如下面的例子。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">  labels:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">www</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  initContainers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">download</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">axeclbr/git</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">git</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">clone</span></span><br><span class="line"><span class="attr">    - https:</span><span class="string">//github.com/mdn/beginner-html-site-scripted</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/var/lib/data</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/lib/data</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">run</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">docker.io/centos/httpd</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - mountPath:</span> <span class="string">/var/www/html</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">source</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">source</span></span><br></pre></td></tr></table></figure></p><p>Init container 克隆外部 Git repo 到挂载的路径，该路径通过 <code>emptyDir</code> 挂载卷实现 init 容器和应用容器间的数据共享。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Init container 将 Pod 中的容器分成两组，拥有不同的生命周期、目的甚至作者。<br>Init 容器分阶段地执行，且只有当前容器成功完成后才继续进行下一阶段，意味着我们可以确保应用初始化的每一个阶段都是有保障的。<br>应用容器则可以并行运行，没有提供 init 容器那样的保证。我们可以根据目的在 Pod 中合理地组织关注初始化的 init 容器和关注应用本身的应用容器。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Init Container 为初始化相关的任务提供了区别于主应用程序的独立的生命周期，从而实现关注点分离。&lt;/p&gt;
&lt;p&gt;初始化在很多编程语言中都备受关注。比如在 Java 中，为了初始化某个需要配置的对象，我们使用 constructor。&lt;br&gt;Constructor
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Init" scheme="https://rollingstarky.github.io/tags/Init/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Self Awareness</title>
    <link href="https://rollingstarky.github.io/2023/09/09/kubernetes-patterns-reading-notes-self-awareness/"/>
    <id>https://rollingstarky.github.io/2023/09/09/kubernetes-patterns-reading-notes-self-awareness/</id>
    <published>2023-09-08T16:00:00.000Z</published>
    <updated>2023-09-08T19:30:52.948Z</updated>
    
    <content type="html"><![CDATA[<p>一些应用需要具备 self-aware 能力，获取关于自身的一些信息。Kubernetes 的 Downward API 就提供了一种简单的将元数据注入到应用中的机制。<br>大多数云原生应用都是无状态的，没有与其他应用相关的标识。然而，即便是这些应用，有时候也需要使用应用自身及其运行环境的信息。包括一些只有在运行时才能知道的数据，比如 Pod 名称（有随机后缀）、Pod IP（重启会变化）和应用程序所在的主机名等；或者在 Pod 级别定义的静态信息比如对特定资源的需求和限制；又或者一些动态信息如注释和标签，可以由用户在运行时更改。<br>这些元数据适用于多种不同的场景，比如基于容器可用的资源，我们可能需要优化应用的 thread-pool 大小，或更改垃圾收集算法、内存分配等。在记录日志或发送 metrics 到监控服务器时需要 Pod 名称、hostname。</p><p>上述需求并不只存在于容器中，对于资源元数据会发生变化的任何动态环境都是成立的。比如 AWS 就提供了 Instance Metadata 和 User Data 服务，可以在任意 EC2 实例上访问从而获取关于自身的元数据。<br>Kubernetes 的思路则更加优雅和易于使用。Downward API 允许通过环境变量和文件将 Pod 的元数据传递给容器。同使用 ConfigMap 和 Secrets 传递应用相关的数据是相同的原理，只不过这些数据都不是用户创建的。<br>我们只需要指定我们想要获取的信息的 key，Kubernetes 就会动态地填充这些值。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-83d322cae3ccd22b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Application introspection mechanisms"></p><p>重点在于通过 Downward API，元数据注入到 Pod 中并且本地可用，应用并不需要一个类似客户端的东西与 Kubernetes API 交互。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">MEMORY_LIMIT</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          resourceFieldRef:</span></span><br><span class="line"><span class="attr">            container:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  resource:</span> <span class="string">limits.memory</span></span><br></pre></td></tr></table></figure></p><p>上述配置使用 <code>fieldRef</code> 访问 Pod 级别的元数据。<code>fieldRef.fieldPath</code> 支持的键值如下表：</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>spec.nodeName</td><td>Name of node hosting the Pod</td></tr><tr><td>status.hostIP</td><td>IP address of node hosting the Pod</td></tr><tr><td>metadata.name</td><td>Pod name</td></tr><tr><td>metadata.namespace</td><td>Namespace in which the Pod is running</td></tr><tr><td>status.podIP</td><td>Pod IP address</td></tr><tr><td>spec.serviceAccountName</td><td>ServiceAccount that is used for the Pod</td></tr><tr><td>metadata.uid</td><td>Unique ID of the Pod</td></tr><tr><td>metadata.labels[‘key’]</td><td>Value of the Pod’s label key</td></tr><tr><td>metadata.annotations[‘key’]</td><td>Value of the Pod’s annotation key</td></tr></tbody></table><p><code>resourceFieldRef.resource</code> 支持的键值如下表：</p><table><thead><tr><th>Name</th><th>Description</th></tr></thead><tbody><tr><td>requests.cpu</td><td>A container’s CPU request</td></tr><tr><td>limits.cpu</td><td>A container’s CPU limit</td></tr><tr><td>limits.memory</td><td>A container’s memory request</td></tr><tr><td>requests.memory</td><td>A container’s memory limit</td></tr></tbody></table><p>用户可以在 Pod 运行时修改特定的元数据比如 lable 和 annotation。除非 Pod 重启，环境变量不会反映这些改动。<br>但是 <code>downwardAPI</code> 卷能够反映 label 和 annotation 的改动，通过 <code>metadata.labels</code> 和 <code>metadata.annotations</code> 捕获所有的 label 和 annotation 信息。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">pod-info</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/pod-info</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">pod-info</span></span><br><span class="line"><span class="attr">    downwardAPI:</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">labels</span></span><br><span class="line"><span class="attr">        fieldRef:</span></span><br><span class="line"><span class="attr">          fieldPath:</span> <span class="string">metadata.labels</span></span><br><span class="line"><span class="attr">      - path:</span> <span class="string">annotations</span></span><br><span class="line"><span class="attr">        fieldRef:</span></span><br><span class="line"><span class="attr">          fieldPath:</span> <span class="string">metadata.annotations</span></span><br></pre></td></tr></table></figure></p><p>Downward API 上的值能够作为文件 mount 到 Pod 中，<code>labels</code> 文件包含所有的 label，以 <code>name=value</code> 的格式逐行保存。当 label 变动时，此文件的内容也会跟着变化。<br>通过 <code>downwardAPI</code> 卷，元数据在 Pod 运行时的变化会反映到挂载的文件中。当然应用同时需要具备检测到此文件改动的功能，若此功能不具备，则重启 Pod 仍旧是必须的操作。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>在很多场景下，应用都需要是 self-aware 的，能够获取关于自身及运行环境的信息。Kubernetes 的 Downward API 为自省和元数据注入提供了一种非侵入的方式。它的一个缺点在于只提供了固定数量的 key，如果应用需要更多数据，尤其是关于其他资源或集群的元数据，则必须从 API Server 处查询。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一些应用需要具备 self-aware 能力，获取关于自身的一些信息。Kubernetes 的 Downward API 就提供了一种简单的将元数据注入到应用中的机制。&lt;br&gt;大多数云原生应用都是无状态的，没有与其他应用相关的标识。然而，即便是这些应用，有时候也需要使用应用
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Label" scheme="https://rollingstarky.github.io/tags/Label/"/>
    
      <category term="Metadata" scheme="https://rollingstarky.github.io/tags/Metadata/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Stateful Services</title>
    <link href="https://rollingstarky.github.io/2023/08/26/kubernetes-patterns-reading-notes-stateful-services/"/>
    <id>https://rollingstarky.github.io/2023/08/26/kubernetes-patterns-reading-notes-stateful-services/</id>
    <published>2023-08-25T16:00:00.000Z</published>
    <updated>2023-08-25T18:46:00.002Z</updated>
    
    <content type="html"><![CDATA[<p>有状态的分布式应用通常需要一些特性作为支撑，比如持久化的身份标识、网络、存储和有序性等。Kubernetes 中的 StatefulSet 原语就提供了一系列基础构件，方便管理有状态的应用。</p><p>现实世界中，在每一个高扩展性的无状态的服务背后，都会存在一个有状态的服务，通常作为某种形式的数据仓库。<br>在早期的 Kubernetes 中，由于缺乏对有状态负载的支持，解决方案通常是将无状态的部分放置到 Kubernetes 集群，有状态的部分则保留在集群外部。不管是借助公有云抑或是 on-premises 硬件，都以传统的非云原生的方式进行管理。</p><h4 id="有状态应用的挑战"><a href="#有状态应用的挑战" class="headerlink" title="有状态应用的挑战"></a>有状态应用的挑战</h4><h5 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h5><p>我们可以很轻松地增加 ReplicaSet 中副本的数量，以期得到一个分布式的有状态应用。但是该如何定义对存储的需求呢？<br>通常一个有状态的分布式应用中的每一个实例都需要<strong>专用</strong>的持久化存储。ReplicaSet 和 PersistentVolumeClaim 会导致所有的 Pod 都关联到同一个 PersistentVolume。其存储并不是专用的，而是在所有 Pod 间共享的。</p><p>我们能想到的一种方式是令应用实例共享同一个存储的同时，通过某种应用内部的设计，将共享的存储划分成多个子文件夹，每个实例都只占用属于自己的 subfolder，从而不会产生任何冲突。<br>上述方式是可行的，但同时也引入了<strong>单点故障</strong>，因为存储实际上只绑定了一个。此外，当应用需要扩展，Pod 的数量改变，也可能会存在数据损坏或丢失的风险。</p><p>另一种方式是为每一个有状态的应用实例都分别创建一个 ReplicaSet（<code>replicas=1</code>），最终每个实例都能拥有独占的 PVC 和存储。缺点是会耗费更多的人力操作，扩展应用时需要创建一批的新的 ReplicaSet、PVC 等。同时缺少一个能管理所有应用实例的统一抽象。</p><h5 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h5><p>同存储上的需求类似，有状态的分布式应用需要一个稳定的网络标识。除了要保存特定于应用的数据到存储设备外，有状态的应用还需要存储一些配置细节，比如主机名和对端的连接细节等。这意味着每个实例都必须能够通过一个可预测的地址访问，而不能像 ReplicaSet 中的 Pod 那样，IP 地址会动态地发生变化。主机名也不是稳定的，会在每次重启时改变。</p><h5 id="Identity"><a href="#Identity" class="headerlink" title="Identity"></a>Identity</h5><p>在有状态的应用中，每一个实例都是<strong>唯一</strong>的，且知晓其自身的标识。这个身份标识的主要组成部分就是长期存在的专用存储和网络坐标，我们可以把实例的 identity/name 也加入进去，有些应用需要唯一的持久的名称。在 Kubernetes 中，就是 Pod 名称。<br>对于由 ReplicaSet 创建的 Pod，其名称是随机的且并不会在重启后保留。</p><h5 id="Ordinality"><a href="#Ordinality" class="headerlink" title="Ordinality"></a>Ordinality</h5><p>除了拥有一个唯一的、长久存活的身份标识外，对于有状态的应用，其实例还必须各自拥有一个固定的位置，即各实例之间是有序的。这种有序性会影响到应用扩展和收缩时的顺序，同时也会影响数据的分布和访问，以及集群内部与位置相关的行为，比如锁、单例或主从等。</p><h5 id="其他需求"><a href="#其他需求" class="headerlink" title="其他需求"></a>其他需求</h5><p>稳定且长久存活的存储、网络、身份标识以及有序性是有状态的分布式应用的共同需求。此外由于个例具体的应用场景不同，管理有状态应用还需要满足一些特定的需求。比如一些应用具有仲裁的概念，要求可用的实例数量必须大于某个最小值；有些应用对于实例的顺序很敏感，另外一些则允许并行化的部署，不要求遵循特定的顺序；有些应用容忍重复的实例存在，有些则不能。<br>对于所有这些一次性的案例，统一进行规划并提供一个通用的机制是不现实的。因此 Kubernetes 还允许用户自己创建 CustomResourceDefinitions 和 Operators 来管理有状态的应用。</p><h4 id="StatefulSet"><a href="#StatefulSet" class="headerlink" title="StatefulSet"></a>StatefulSet</h4><p>从很多方面来看，StatefulSet 用来管理“宠物”，而 ReplicaSet 则用来管理“家畜”。<br>宠物 vs 家畜是 DevOps 里一个很有名的类比。家畜用来指代完全相同的、可自由替换的服务；而宠物则用来指代独特的、不可替代的、需要区别对待的服务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">rg</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - name:</span> <span class="string">logs</span></span><br><span class="line"><span class="attr">          mountPath:</span> <span class="string">/logs</span></span><br><span class="line"><span class="attr">      volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">      - metadata:</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">logs</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          accessModes:</span> <span class="string">[</span> <span class="string">"ReadWriteOnce"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">          resources:</span></span><br><span class="line"><span class="attr">            requests:</span></span><br><span class="line"><span class="attr">            storage:</span> <span class="number">10</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure><h5 id="存储-1"><a href="#存储-1" class="headerlink" title="存储"></a>存储</h5><p>绝大多数有状态的应用需要对其“状态”进行保存，因而需要专属于实例的持久化存储。<br>不同于 ReplicaSet 使用 <code>persistentVolumeClaim</code> 指向一个预定义的 PVC，StatefulSet 则是通过 <code>volumeClaimTemplates</code> 在 Pod 创建时动态地创建 PVC。这种机制能够保证不管是在初始创建还是在扩展时，每个 Pod 都能够获得专用的 PVC。</p><p>扩展一个 StatefulSet（增加 <code>replicas</code> 的数值）会创建新的 Pod 和关联的 PVC，但其收缩时只会删除 Pod，并不会删除任何关联的 PVC 或 PV。即 PV 并不会被回收，其占用的空间没有被释放。<br>上述行为是故意这样设计的，其基础在于，通常有状态应用的数据存储是至关重要的，意外的收缩不应该导致数据丢失。</p><h5 id="网络-1"><a href="#网络-1" class="headerlink" title="网络"></a>网络</h5><p>StatefulSet 创建的每一个 Pod 都拥有一个稳定的名称标识，由 StatefulSet 的 <code>name</code> 字段和索引数字（从 0 开始）组成。ReplicaSet 创建的 Pod 的名称后缀则是随机的。<br>由 ReplicaSet 创建的无状态的 Pod 应该是完全相同的，因此客户端请求无论转发到哪个 Pod 都没有任何区别。但是有状态的 Pod 彼此之间是不相同的，我们有可能希望某些请求只转发给特定的 Pod。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>上述配置定义了一个 <em>headless</em> 服务。在 headless 服务中，<code>clusterIP: None</code>，表明我们不想让 kube-proxy 去处理请求，也不需要 cluster IP 或 负载均衡。<br>带有 selector 的 headless 服务会在 API Server 上创建 Endpoint 纪录，DNS 返回的 A 记录（地址）直接指向 Pod。即每个 Pod 都会获得一个 DNS 记录，能够被客户端直接访问。<br>假如我们的 <code>random-generator</code> 服务属于 <code>default</code> 命名空间，若需要访问 Pod <code>rg-0</code>，就可以使用域名 <code>rg-0.random-generator.default.svc.cluster.local</code>。</p><p>对于 StatefulSet 来说，通过 <code>volumeClaimTemplates</code> 定义专用存储不是必须的，通过 <code>serviceNmae</code> 字段指向服务则是一定要做的步骤。Governing Service 必须在 StatefulSet 创建之前就存在，作为网络标识。<img src="https://upload-images.jianshu.io/upload_images/6875152-880d78204840a3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="分布式有状态应用"></p><h5 id="Identity-1"><a href="#Identity-1" class="headerlink" title="Identity"></a>Identity</h5><p><em>Identity</em> 是 StatefulSet 保证的所有特性的最基础构件。基于 StatefulSet 的 name，我们可以预测其创建的 Pod 的名称和标识。再利用 Pod 的标识命名 PVC，通过 headless 服务访问特定的 Pod 等等。<br>每一个 Pod 在创建前，其标识是可以预先确定的，从而必要的时候可以在应用内部直接使用此标识。</p><h5 id="Ordinality-1"><a href="#Ordinality-1" class="headerlink" title="Ordinality"></a>Ordinality</h5><p>从定义来看，一个分布式的有状态应用包含多个独特的、不可相互替代的实例。除了独特性以外，各实例之间还可能会有基于顺序/位置的关系。<br>从 StatefulSet 的视角看，顺序性出现在应用需要扩展时。Pod 扩展时的顺序同创建时的顺序一致，收缩时则相反（从 <code>n - 1</code> 到 <code>0</code>）。<br>当我们创建一个带有多个副本的 ReplicaSet，Pod 是同时被调度和启动的，不需要等待第一个 Pod 启动成功，Pod 之间的启动顺序是没有保证的。应用收缩时也是这样。属于同一个 ReplicaSet 的 Pod 同时被关闭，不关注任何顺序或依赖性。<br>上述行为在执行时可能更加迅速，但并不是 StatefulSet 所需要的，尤其是涉及到数据分片的时候。</p><p>为了保证应用扩展和收缩时数据能够正确地同步，默认情况下 StatefulSet 会执行顺序（串行）的启动和终止。这表示第一个 Pod（索引 0）会先启动，在其启动成功以后，下一个 Pod（索引 1）才会被调度。在应用收缩时，顺序则相反。</p><h5 id="其他特性"><a href="#其他特性" class="headerlink" title="其他特性"></a>其他特性</h5><p><strong>Partitioned Updates</strong><br>StatefulSet 在扩展时会保证串行执行和顺序性。对于正在运行的应用的升级操作（修改 <code>.spec.template</code>），则允许阶段性更新（比如 canary release），保证在对一部分实例进行更新的同时，剩余部分中特定数量的实例保持正常。<br>对于默认的 rolling update 策略，可以指定一个 <code>.spec.updateStrategy.rollingUpdate.partition</code> 数字来对实例进行分片。所有索引值大于或等于 <code>partition</code> 的 Pod 会被更新，剩余的 Pod 则保持不变。若需要继续更新集群中剩余的实例，可以将 <code>partition</code> 值改为 0。</p><p><strong>Parallel Deployments</strong><br>当我们指定 <code>.spec.podManagementPolicy</code> 为 <code>Parallel</code> 时，StatefulSet 会并行地同时加载或关闭所有的 Pod，不需要等待前一个 Pod 完毕。<br>若串行处理不是必须的条件，则可以设置此选项来加速部署流程。</p><p><strong>At-Most-One 保证</strong><br>唯一性是有状态应用实例的基础属性，Kubernetes 会确保属于同一个 StatefulSet 的两个 Pod 不会具有相同的标识，不会绑定给同一个 PV。<br>另一方面，ReplicaSet 则为其实例提供了 <em>At-Least-X-Guarantee</em>。比如一个配置了两个副本的 ReplicaSet 会始终确保最少有两个实例处于运行状态，即便在某些场景下，Pod 的数量有可能超过两个。<br>StatefulSet 控制器则会进行任何可能的检查来确保不会出现重复的 Pod。即 <em>At-Most-One Guarantee</em>。在需要替换 Pod 时，只有在确定旧 Pod 已经被完全关闭之后，新 Pod 才会开始启动；当节点故障时，除非 Kubernetes 能够确定 Pod 已经停止运行，否则不会在其他节点上部署新的 Pod。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有状态的分布式应用通常需要一些特性作为支撑，比如持久化的身份标识、网络、存储和有序性等。Kubernetes 中的 StatefulSet 原语就提供了一系列基础构件，方便管理有状态的应用。&lt;/p&gt;
&lt;p&gt;现实世界中，在每一个高扩展性的无状态的服务背后，都会存在一个有状态的
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Cluster" scheme="https://rollingstarky.github.io/tags/Cluster/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="StatefulSet" scheme="https://rollingstarky.github.io/tags/StatefulSet/"/>
    
      <category term="Stateful" scheme="https://rollingstarky.github.io/tags/Stateful/"/>
    
      <category term="Distributed" scheme="https://rollingstarky.github.io/tags/Distributed/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Service Discovery</title>
    <link href="https://rollingstarky.github.io/2023/08/26/kubernetes-patterns-reading-notes-service-discovery/"/>
    <id>https://rollingstarky.github.io/2023/08/26/kubernetes-patterns-reading-notes-service-discovery/</id>
    <published>2023-08-25T16:00:00.000Z</published>
    <updated>2023-08-25T18:56:29.030Z</updated>
    
    <content type="html"><![CDATA[<p><em>Service Discovery</em> 主要负责提供一类稳定的入口，利用这些入口服务的客户端能够访问到提供服务的后台实例。</p><p>部署到 Kubernetes 的应用很少是单独存在的，它们往往需要与集群内部的其他服务甚至集群外部的系统产生交互。<br>比如 DaemonSet 或者 ReplicaSet 中的 long-running Pod，通常需要处理来自外部的比如 HTTP 连接请求。这些时候，服务的消费者就需要某种机制发现 Pod 的位置，因为 Pod 会动态地由 scheduler 分配给节点，其位置在应用扩展和收缩时也会发生变化。</p><p>在 Kubernetes 之前，最常用的机制是 client-side discovery。当一个消费者需要访问另一个有可能扩展到多个实例上的服务时，消费者本身会有一个 agent 负责查询记录有实例信息的注册表，选择其中一个实例进行访问。这个 agent 有可能嵌入到消费者中（比如 Zookeeper client、Consul client 或 Ribbon），也有可能作为并置进程存在（比如 Prana）。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-5d3a2cf6544cb6d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Client-side service discovery"></p><p>在后 Kubernetes 时代，分布式系统的很多非功能性职责比如资源调度、健康检查、自恢复、资源隔离等都交由平台负责。服务发现和负载均衡也属于这部分职责。<br>在 Kubernetes 里，所有服务实例注册以及注册信息的访问这类工作，都在后台完成。服务的消费者访问一个固定的虚拟服务端点，这个端点能够动态地发现提供服务的 Pod。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-03956038178fe444.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Server-side service discovery"></p><h4 id="Internal-Service-Discovery"><a href="#Internal-Service-Discovery" class="headerlink" title="Internal Service Discovery"></a>Internal Service Discovery</h4><p>当我们创建一个包含多个副本的 Deployment，scheduler 会将 Pod 调度到合适的节点，每个 Pod 在启动之前都会获得一个集群 IP。<br>如果另一个客户端服务想要访问 Deployment 部署的服务，想要获悉集群 IP 的具体地址并没有简单直接的方式。<br>因而 Kubernetes 提供了 Service 组件。Service 可以为一组相同功能的 Pod 提供一个不变的稳定入口。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure></p><p>上述配置会创建一个名为 <code>random-generator</code> 的 Service，其类型为 <code>ClusterIP</code>（默认值），会在 80 端口上监听 TCP 连接，并转发到所有匹配的 Pod。<br>匹配条件 <code>app: random-generator</code> 由 selector 指定。<br>不管 Pod 是何时或者怎样创建的，任何带有 <code>app: random-generator</code> 标签的 Pod 都会作为转发的目标。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-22a7f40179e67aea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Internal service discovery"></p><p>需要注意的一点是，当 Service 创建完成时，它获取到的 ClusterIP 只允许 Kubernetes 集群内部访问。只要 Service 定义一直存在，IP 就保持不变。<br>关于集群内部的其他应用如何知晓这个动态的 ClusterIP 具体是多少，有两种方式：</p><ul><li>环境变量：此方式的主要问题是依赖于 Service 创建的时间，即 Service 必须在环境变量注入之前创建。因为环境变量无法注入到已经在运行的 Pod 中</li><li>DNS lookup：Kubernetes 包含一个内置的 DNS 服务，被所有的 Pod 默认配置使用。当一个新的 Service 创建后，它会自动获得一条新的 DNS 记录，能够被所有 Pod 使用。比如 <code>random-generator.default.svc.cluster.local</code>，其中 <code>random-generator</code> 表示 Service 的名称，<code>default</code> 表示命名空间，<code>svc</code> 表示这是一个 Service，<code>cluster.local</code> 是集群前缀，可以省略</li></ul><h5 id="Service-的高级特性"><a href="#Service-的高级特性" class="headerlink" title="Service 的高级特性"></a>Service 的高级特性</h5><p><strong>Multiple ports</strong><br>一个 Service 定义可以支持多个源端口和目标端口。</p><p><strong>Session affinity</strong><br>当新的请求出现时，Service 默认会随机挑选一个 Pod 作为转发的目标。可以配置 <code>sessionAffinity: ClientIP</code>，从而来自同一个客户端 IP 的请求都会转发给同一个 Pod。</p><p><strong>Readiness Probes</strong><br>如果 Pod 定义了 readiness 检查，当它失效时，即便标签匹配，该 Pod 也会从 Service 端点中移除。</p><p><strong>Virtual IP</strong><br>ClusterIP 类型的 Service 在创建时会获得一个稳定的虚拟 IP，这个 IP 与任何网络接口都不相关，在现实中并不真实存在。<br>是每个节点上都有的 kube-proxy 意识到 Service 的存在后，更新节点上的 iptables，设置规则捕获目标是这个虚拟 IP 的网络包，将目标地址替换为选定的 Pod IP 地址。<br>iptables 中添加的规则并不包含 ICMP 协议，因此 Service 的 IP 地址无法被 ping。</p><p><strong>Choosing ClusterIP</strong><br>在 Service 创建过程中，可以通过 <code>.spec.clusterIP</code> 指定其使用的 IP 地址。</p><h4 id="Manual-Service-Discovery"><a href="#Manual-Service-Discovery" class="headerlink" title="Manual Service Discovery"></a>Manual Service Discovery</h4><p>当我们创建一个带有 <code>selector</code> 的 Service 时，Kubernetes 会负责在 endpoint 资源列表里记录所有可提供服务的 Pod。可以使用类似 <code>kubectl get endpoints random-generator</code> 的命令查看 endpoint 列表。<br>除了将请求转发给集群内部的 Pod，还可以将连接转发给外部的 IP 和端口，比如像下面这样创建一个不带 <code>selector</code> 的 Service 并手动创建 endpoint 资源：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ClusterIP</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Endpoints</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">external-service</span></span><br><span class="line"><span class="attr">subsets:</span></span><br><span class="line"><span class="attr">  - addresses:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">1.1</span><span class="number">.1</span><span class="number">.1</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">2.2</span><span class="number">.2</span><span class="number">.2</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>上面创建的 Service 和之前的一样，都只能在集群内部访问。区别在于其 endpoint 是手动维护的，并且指向了集群外部的 IP 地址。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-3cdceb95fdbc1d50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Manual service discovery"></p><p>上述机制主要应用在需要访问外部资源的时候。Endpoint 还可以绑定 Pod 的 IP 地址，但是不支持其他 Service 的虚拟 IP。</p><p>Service 的一个优势在于它允许添加或者删除 <code>selector</code>，随意指向外部或内部的服务提供者，而不需要删除自身的资源定义。从而 Service 的 IP 地址保持不变。因此 Service 的客户端可以继续使用原来的访问地址，而 Service 本身指向的服务提供者可能已经从 on-premise 转到了 Kubernetes，客户端不受任何影响。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">database-service</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">ExternalName</span></span><br><span class="line"><span class="attr">  externalName:</span> <span class="string">my.database.example.com</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p><code>ExternalName</code> 是另外一种方式，通过 DNS CNAME 为外部的 endpoint 创建别名，而不是借助 IP 地址和代理。</p><h4 id="面向集群外部的服务发现"><a href="#面向集群外部的服务发现" class="headerlink" title="面向集群外部的服务发现"></a>面向集群外部的服务发现</h4><p>前面提到的服务发现机制都使用了虚拟 IP，而这个虚拟 IP 本身只支持从集群内部访问。但是 Kubernetes 集群并不是与外部世界完全隔离的，除了 Pod 有时候需要访问外部资源以外，相反方向的访问也是经常发生的，即外部应用需要访问 Pod 提供的 endpoint。</p><h5 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h5><p>第一种创建 Service 并将其暴露给外部世界的方式是 <code>NodePort</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">NodePort</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    nodePort:</span> <span class="number">30036</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br></pre></td></tr></table></figure></p><p>上述配置会创建一个 Service，在虚拟 IP 的 80 端口接收客户端连接，并有选择地转发给匹配 selector <code>app: random-generator</code> 的 后端 Pod 上的 8080 端口。<br>除此之外，上面的配置还会保留所有节点上的 30036 端口，并将所有访问此端口的连接转发给 Service。从而不仅可以在集群内部通过虚拟 IP 连接 Service，还可以借助每个节点上的保留端口从集群外部访问 Service。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-8429933235e273b0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Node port Service Discovery"></p><p><code>NodePort</code> 的特点和问题：</p><ul><li>Port number：除了可以指定端口号以外（<code>nodePort: 30036</code>），还可以让 Kubernetes 自己选择可用的端口</li><li>Firewall rules：<code>NodePort</code> 会使用每一个节点上的指定端口，因此可能需要配置防火墙允许外部客户端连接指定端口</li><li>Node selection：客户端可以连接集群中的任意一个节点，潜在的问题是，当该节点不可用时，客户端应用负责实现访问另一个健康节点的功能。因此，在节点前部署一个负载均衡器会是一个好的措施</li><li>Pod selection：当客户端尝试通过节点端口连接服务时，其请求会被路由到随机选择的 Pod，该 Pod 可能位于同一个节点上，也可能位于另外的节点上。可以在 Service 的定义中使用 <code>externalTrafficPolicy: Local</code> 选项强制将请求只转发给当前节点上的 Pod。这同时会引发另一个问题，即必须确保每个节点上都有 Pod 部署（比如 <em>daemon service</em>），或者客户端知道哪个节点上有健康的 Pod 在运行</li><li>Source address：当 Service 类型为 <code>NodePort</code> 时，网络包中的源 IP 地址（即客户端 IP）会被替换成节点的内部 IP。比如客户端发送网络包给 node1，假如说 Pod 位于 node2 上，网络包从 node1 转发到 node2，网络包中的源 IP 地址会被替换成 node1 的 IP，目标地址替换成 Pod 的地址。当 Pod 最终接收到请求，源 IP 地址已经被替换成 node1 的地址。这类行为同样可以通过 <code>externalTrafficPolicy: Local</code> 避免</li></ul><h5 id="LoadBalancer"><a href="#LoadBalancer" class="headerlink" title="LoadBalancer"></a>LoadBalancer</h5><p>另一种针对外部客户端的服务发现方式是通过负载均衡器。<code>NodePort</code> 类型的 Service 构建在默认的 Service（<code>type: ClusterIP</code>）之上，额外在每个节点上开放了一个端口。<br>该方式的缺点就是，我们仍需要一个负载均衡器来为客户端应用选择健康的节点。而 <code>LoadBalancer</code> 类型的 Service 则解决了这个问题。</p><p>除了 <code>NodePort</code> 类型所做的操作以外，<code>LoadBalancer</code> 类型的 Service 还会借助云服务提供商的负载均衡器将服务暴露给外部使用。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-7f35db0076950a7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Load balancer service discovery"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  type:</span> <span class="string">LoadBalancer</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="number">10.0</span><span class="number">.171</span><span class="number">.239</span></span><br><span class="line"><span class="attr">  loadBalancerIP:</span> <span class="number">78.11</span><span class="number">.24</span><span class="number">.19</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - port:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">    targetPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">status:</span></span><br><span class="line"><span class="attr">  loadBalancer:</span></span><br><span class="line"><span class="attr">    ingress:</span></span><br><span class="line"><span class="attr">    - ip:</span> <span class="number">146.148</span><span class="number">.47</span><span class="number">.155</span></span><br></pre></td></tr></table></figure><h4 id="应用层服务发现（Ingress）"><a href="#应用层服务发现（Ingress）" class="headerlink" title="应用层服务发现（Ingress）"></a>应用层服务发现（Ingress）</h4><p>不同于之前的服务发现机制，Ingress 并不是一种 Service 类型，而是一个独立的 Kubernetes 资源，部署在 Service 前端作为 smart router 和集群的入口。<br>Ingress 通常会提供基于 HTTP 协议的对 Service 的访问， 通过外部可见的 URL、负载均衡、SSL termination、基于名称的 virtual hosting 等。<br>为了 Ingress 能生效，集群本身必须要有一个或者多个 Ingress controller 在运行。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  backend:</span></span><br><span class="line"><span class="attr">    serviceName:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    servicePort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><p>上述配置会分配一个可供外部访问的 IP 地址并在 80 端口对外暴露 Service。看上去与 <code>type: LoadBalancer</code> 并没有什么区别。实际上 Ingress 能够重复使用同一个外部负载均衡器和 IP 指向多个 Service。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Ingress</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  annotations:</span></span><br><span class="line">    <span class="string">nginx.ingress.kubernetes.io/rewrite-target:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  rules:</span></span><br><span class="line"><span class="attr">  - http:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="attr">    - path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      backend:</span></span><br><span class="line"><span class="attr">        serviceName:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">        servicePort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    - path:</span> <span class="string">/cluster-status</span></span><br><span class="line"><span class="attr">      backend:</span></span><br><span class="line"><span class="attr">        serviceName:</span> <span class="string">cluster-status</span></span><br><span class="line"><span class="attr">        servicePort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-11acaf78b2c8caef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Application layer service discovery"></p><p>Ingress 是 Kubernetes 上最强大同时也最复杂的服务发现机制，其最常用的场景是当多个服务需要在同一个 IP 地址下，同时这些服务又都使用同样的第七层协议（通常是 HTTP）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-02f70a1ad720f9d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service Discovery mechanisms"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Service Discovery&lt;/em&gt; 主要负责提供一类稳定的入口，利用这些入口服务的客户端能够访问到提供服务的后台实例。&lt;/p&gt;
&lt;p&gt;部署到 Kubernetes 的应用很少是单独存在的，它们往往需要与集群内部的其他服务甚至集群外部的系统产生交互。&lt;br&gt;
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="LoadBalancer" scheme="https://rollingstarky.github.io/tags/LoadBalancer/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="DNS" scheme="https://rollingstarky.github.io/tags/DNS/"/>
    
      <category term="Entrypoint" scheme="https://rollingstarky.github.io/tags/Entrypoint/"/>
    
      <category term="Proxy" scheme="https://rollingstarky.github.io/tags/Proxy/"/>
    
      <category term="Ingress" scheme="https://rollingstarky.github.io/tags/Ingress/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Daemon Service</title>
    <link href="https://rollingstarky.github.io/2023/08/15/kubernetes-patterns-reading-notes-daemon-service/"/>
    <id>https://rollingstarky.github.io/2023/08/15/kubernetes-patterns-reading-notes-daemon-service/</id>
    <published>2023-08-14T16:00:00.000Z</published>
    <updated>2023-08-15T14:20:43.963Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Daemon Service</strong> 能够向目标节点放置和运行有优先级的、面向基础设施的 Pod，通常被管理员用来部署与节点相关联的 Pod 以增强 Kubernetes 平台的功能。</p><p>从操作系统层面来看，<strong>daemon</strong> 是一类长时间运行、能够自行恢复的后台进程，通常在计算机启动时即自动加载，不会与前台进行任何交互。<br>这类概念也存在于应用层面。比如运行在后台的 JVM deamon 线程为用户线程提供支持服务，有着较低的优先级，执行诸如 GC 等任务。</p><p>与上述场景类似，Kubernetes 也提供了 DaemonSet 功能。<br>DaemonSet 与 ReplicaSet 有一个相同点，都是负责确保特定数量的 Pod 是一直运行着的。不同点在于，ReplicaSet 的具体配置通常取决于应用对于高可用和工作负载的需求，与节点数量无关；DaemonSet 则并不关注负载方面的因素，它的主要目的是<strong>在每一个节点（或部分特定的节点）上保持运行一个 Pod。</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">extensions/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">DaemonSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-refresher</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">      app:</span> <span class="string">random-refresher</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">random-refresher</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      nodeSelector:</span></span><br><span class="line"><span class="attr">        feature:</span> <span class="string">hw-rng</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">        command:</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">        -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">        -</span> <span class="string">&gt;-</span></span><br><span class="line">          <span class="string">"while true; do</span></span><br><span class="line"><span class="string">          java -cp / RandomRunner /host_dev/random 100000;</span></span><br><span class="line"><span class="string">          sleep 30; done"</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/host_dev</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">devices</span></span><br><span class="line"><span class="attr">      volumes:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">devices</span></span><br><span class="line"><span class="attr">        hostPath:</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/dev</span></span><br></pre></td></tr></table></figure><p>DaemonSet 的适用场景比如日志收集、监控数据导出甚至 kube-proxy 等。其与 ReplicaSet 的主要区别如下：</p><ul><li>默认情况下，DaemonSet 会向每一个节点都部署一个 Pod 实例，可以通过 <code>nodeSelector</code> 字段只选取部分节点</li><li>DaemonSet 创建的 Pod 能够在 Scheduler 启动之前运行，因此，节点上还没有任何其他 Pod 被部署时，DaemonSet 创建的 Pod 就已经可以运行</li><li>由于 Scheduler 并没有参与 DaemonSet 的部署，节点上的 <code>unschedulable</code> 字段对 DaemonSet 控制器不起作用</li><li>DaemonSet 管理的 Pod 通常只运行在特定的节点上，因而很多控制器会对这些 Pod 区别对待，给与更高的优先级。比如 descheduler  会避免销毁这类 Pod，cluster autoscaler 会对它们独立地进行管理</li></ul><p>DaemonSet 和 CronJob 是两个非常优秀的例子，Kubernetes 将单节点的概念比如 Crontab 和 daemon 脚本，转换成多节点的、集群化的原语，应用到分布式系统的管理中。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Daemon Service&lt;/strong&gt; 能够向目标节点放置和运行有优先级的、面向基础设施的 Pod，通常被管理员用来部署与节点相关联的 Pod 以增强 Kubernetes 平台的功能。&lt;/p&gt;
&lt;p&gt;从操作系统层面来看，&lt;strong&gt;daemon
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Daemon" scheme="https://rollingstarky.github.io/tags/Daemon/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Singleton Service</title>
    <link href="https://rollingstarky.github.io/2023/08/15/kubernetes-patterns-reading-notes-singleton-service/"/>
    <id>https://rollingstarky.github.io/2023/08/15/kubernetes-patterns-reading-notes-singleton-service/</id>
    <published>2023-08-14T16:00:00.000Z</published>
    <updated>2023-08-15T14:32:46.873Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Singleton Service</strong> 模式会保证在某个特定的时间点，有且只有一个应用实例是活跃的。这个模式可以在应用内部实现，也可以完全交给 Kubernetes 去处理。</p><p>Kubernetes 最大的优势之一就是能够轻松、透明地扩展应用，只需要一条命令式的语句 <code>kubectl scale</code> 就能伸缩 Pod，或者通过声明式的方式修改 controller（比如 ReplicaSet）定义来实现，甚至基于应用负载动态地完成应用扩展。<br>在 Kubernetes 中，多实例指的就是 Pod 的多个副本，能够提升应用的吞吐量和可用性，Service 则负责分配请求。</p><p>但是在一些特殊的场景中，同一时间只允许唯一一个应用实例运行。比如某个周期性执行的定时任务，若存在该任务的多个实例同时运行，则其中每一个实例都会在规定的时间间隔后触发一次该任务，导致预期之外的重复执行。<br>另一个例子比如，某个应用服务需要轮询特定的系统资源（文件系统或数据库等），我们想要确保只有一个应用实例甚至只有一个线程在执行这类操作。<br>还比如，我们必须按照特定的顺序消费来自消息代理的消息时，这里的单线程消费者也是一种单例。</p><p>运行同一个 Pod 实例的多个副本并令它们同时处于活跃状态，属于 <strong>active-active</strong> 拓扑结构，单例模式需要的是 <strong>active-possive</strong>（或者叫做 <strong>master-slave</strong>）结构。即只有一个实例是活跃的，其他所有的实例都是被动的，等待需要的时候被唤醒。</p><h4 id="Out-of-Application-Locking"><a href="#Out-of-Application-Locking" class="headerlink" title="Out-of-Application Locking"></a>Out-of-Application Locking</h4><p>顾名思义，通过外部的管理程序确保应用只有唯一一个实例在运行，应用本身并不知晓自己是否是单例。<img src="https://upload-images.jianshu.io/upload_images/6875152-fd7cd0a7aecf40c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Out-of-application locking mechanism"></p><p>Kubernetes 实现单例模式的方式是，启动一个副本唯一的 Pod，但这并不能确保 Pod 是高可用的。因此还必须通过控制器（比如 ReplicaSet）来管理单例，令其具备高可用的能力。<br>这种结构严格来说并不是 active-passive （没有配置 passive 实例）的，但是具有同样的效果。Kubernetes 会确保任何时候都会有一个 Pod 实例在运行，控制器会持续进行健康检查，修复失败的 Pod。</p><p>最需要额外注意的是副本数量，避免意外地被修改成大于 1 的值。事实上任何时候都只有唯一的应用实例在运行的说法不是完全准确的。Kubernetes 中的组件比如 ReplicaSet，会<strong>优先考虑可用性而非一致性</strong>。这意味着对于副本数量来说，ReplicaSet 会实行<strong>至少一个</strong>而不是<strong>最多一个</strong>的策略。在某些特殊的情况下，即便有 <code>replicas: 1</code> 的配置，也会出现多个实例同时在运行的情况。<br>最常见的情形比如当某个节点失效时，与整个 Kubernetes 集群的连接丢失，ReplicaSet 控制器就会在另一个健康的节点上创建一个新的 Pod 实例，并且不会提前确认断连的节点上的原 Pod 是否已经关闭。类似的情况也会在修改副本数量或者将 Pod 重新分配给另一个节点时出现。</p><p>单例模式可以具有弹性和恢复能力，但是从定义来看，并不具备高可用性。<strong>它通常更倾向于一致性而非可用性</strong>。同样更倾向于一致性的 Kubernetes 资源是 <strong>StatefulSet</strong>。如果需要严格意义上的单例模式，StatefulSet 是更好的选择，但是它同样会增加系统的复杂度。</p><h4 id="In-Application-Locking"><a href="#In-Application-Locking" class="headerlink" title="In-Application Locking"></a>In-Application Locking</h4><p>在分布式环境中，控制服务实例数量的一种方式就是分布式锁。当实例中的服务组件被激活时，它会尝试获取一个锁，成功获取到锁则服务处于活跃状态。此时任何其他未获取到锁的服务实例则等待并不断地尝试获取锁，直到占用的锁被释放。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-751e79c46259d288.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="In-application locking mechanism"></p><p>在面向对象的概念中，单例就是一个保存在类的静态变量中的对象实例。类本身知晓该实例是单例，并且在定义中不允许为同一个进程实例化多个实例。<br>在分布式系统中，就意味着容器化应用本身在设计上，就不允许同一时间下有多于一个的实例处于活跃状态，不管实际上启动了多少个 Pod。上述实现需要借助分布式锁，比如 ZooKeeper，Consul，Redis 或 Etcd 等。</p><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>如果使用场景需要强 singleton 保证，就不能借助 ReplicaSet 实现的应用外部的锁机制。ReplicaSet 的设计目标在于保证 Pod 的可用性而不是满足 at-most-one 语义。会有很多错误场景，同一个 Pod 的两个副本短时间内并发地运行。<br>若上述情况是不可接受的，则可以使用 StatefulSet 或者引入应用内的锁机制。<br>在另外一些场景中，只有容器化应用的一部分是需要作为 singleton 运行的。比如一个容器化应用提供 HTTP 服务（能够安全地扩展），同时还包含必须是 singleton 的轮询组件。这时候使用应用外部的锁机制，会阻止整个应用被扩展。我们因此必须将 singleton 组件从原本的部署中分离出来。<br>或者借助应用内的锁机制，只对 singleton 组件加锁。此时就可以透明地扩展整个应用，多个 HTTP 服务副本提供访问，singleton 组件则以 active-passive 模式运行。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Singleton Service&lt;/strong&gt; 模式会保证在某个特定的时间点，有且只有一个应用实例是活跃的。这个模式可以在应用内部实现，也可以完全交给 Kubernetes 去处理。&lt;/p&gt;
&lt;p&gt;Kubernetes 最大的优势之一就是能够轻松、透明
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Cluster" scheme="https://rollingstarky.github.io/tags/Cluster/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Singleton" scheme="https://rollingstarky.github.io/tags/Singleton/"/>
    
      <category term="Scale" scheme="https://rollingstarky.github.io/tags/Scale/"/>
    
      <category term="StatefulSet" scheme="https://rollingstarky.github.io/tags/StatefulSet/"/>
    
      <category term="Consistency" scheme="https://rollingstarky.github.io/tags/Consistency/"/>
    
      <category term="Locking" scheme="https://rollingstarky.github.io/tags/Locking/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Job &amp; CronJob</title>
    <link href="https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-job-and-cronjob/"/>
    <id>https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-job-and-cronjob/</id>
    <published>2023-06-18T16:00:00.000Z</published>
    <updated>2023-06-19T12:42:26.965Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Batch-Job"><a href="#Batch-Job" class="headerlink" title="Batch Job"></a>Batch Job</h4><p>Batch Job 模式适合处理<strong>隔离的</strong>、<strong>原子化的</strong>工作任务，能够在分布式的环境中，可靠地运行 short-lived Pods，直到工作任务成功地结束。</p><p>在 Kubernetes 中，可以通过不同的方式创建 Pod：</p><ul><li>Bare Pod：可以手动创建 Pod 来运行容器应用，但是当此类 Pod 所在的节点失效时，Pod 不会自动重启。除非用于开发或测试目的，此类方式并不推荐</li><li>ReplicaSet：当 Pod 应该长时间持续运行时（比如 web server），就适合用此方式来创建 Pod 和管理其生命周期。它会确保在任意时刻，运行着的 Pod 副本数量都是稳定的</li><li>DaemonSet：负责在每一个节点上都部署一个 Pod。通常情况下用于平台管理工作，比如监控、日志聚合、存储等</li></ul><p>上述 Pod 有一个共同点，它们都代表着长时间运行的进程，并不是在一段时间后就需要被关掉。但是在某些场景下，仍需要执行一类预先定义好的、有限的工作流，当该工作流程可靠地完成后，再关闭对应的容器。</p><p>Kubernetes Job 类似于 ReplicaSet，它也会创建 1 个或者多个 Pods 并确保它们成功运行。区别在于，当特定数量的 Pods 成功终止后，Job 就变为完成状态，不会再有额外的 Pod 被启动。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  completions:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[</span> <span class="string">"java"</span><span class="string">,</span> <span class="string">"-cp"</span><span class="string">,</span> <span class="string">"/"</span><span class="string">,</span> <span class="string">"RandomRunner"</span><span class="string">,</span> <span class="string">"/numbers.txt"</span><span class="string">,</span> <span class="string">"10000"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>比如上面配置的 Job，会确保有 5 个 Pod 成功执行完毕，可以有两个 Pod 同时运行。此外，Job 配置文件中的 <code>restartPolicy</code> 是必需的，且其值只能是 <code>OnFailure</code> 或 <code>Never</code>，不能是 <code>Always</code>。</p><p>为什么不通过 bare Pods 来执行 Job 对应的任务呢？因为 Job 相比于 bare Pods，能够提供更多可靠性和扩展性方面的好处。</p><ul><li>Job 并不是临时的 in-memory 任务，而是一个持久化的能够在集群重启后幸存的任务</li><li>Job 完成后并不会被删除，而是继续保留，方便以后追踪问题。只有当 bare Pods 是 <code>restartPolicy: OnFailure</code> 时，其才会拥有同样的特性</li><li>Job 可能需要执行多次，可以通过 <code>.spec.completions</code> 指定</li><li>当任务确实需要完成多次时，Job 还支持扩展，即同一时间开启多个 Pods。可以通过 <code>.spec.parallelism</code> 指定</li><li>若节点失效，或者 Pod 正在运行时因为某些原因被移除，由 Job 创建的 Pods 会被 scheduler 重新分配给健康的节点</li></ul><p>两个字段对控制 Job 的行为发挥着关键作用：</p><ul><li><code>.spec.completions</code>：指定 Pod 的数量。当特定数量的 Pod 执行完毕后，当前 Job 才算完成</li><li><code>.spec.parallelism</code>：指定可以并行执行的 Pod 副本数量</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5fc1677a539a8d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Parallel Batch Job with a fixed completion count"></p><p>基于上述两个参数，Job 可以分为如下几种类型：</p><ul><li>Single Pod Job：不设置 <code>.spec.completions</code> 和 <code>.spec.parallelism</code> 的值，或者将它们设置为默认值 1。此类 Job 只会启动一个 Pod，当 Pod 成功退出后，Job 完成</li><li>Fixed completions count Jobs：<code>.spec.completions</code> 的值大于 1。当特定数量（<code>.spec.completions</code>）的 Pod 执行完毕后，Job 完成</li><li>Work queue Job：<code>.spec.completions</code> 不设置或者设为默认值，<code>.spec.parallelism</code> 大于 1。适用于工作队列中的 Job。当至少有一个 Pod 成功终止时，所有其他 Pod 也会自行终止。比如，一堆固定数量的待处理项目保存在某个队列中，并行的 Pod 可以按顺序获取并处理它们，当某个 Pod 检测到队列为空并成功退出后，Job controller 等待其他 Pod 终止运行</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Job 帮助我们将隔离的工作单元变成一个可靠的、可扩展的执行单元。并不是所有的服务都需要一直运行，比如某些服务可能需要按需运行，某些必须在特定的时间窗口运行，某些必须按照计划重复执行。<br>通过 Job 可以只在需要的时候运行 Pod，且任务完成后就退出。使用 Job 处理 short-lived 任务可以节约系统资源。</p><h4 id="Periodic-Job"><a href="#Periodic-Job" class="headerlink" title="Periodic Job"></a>Periodic Job</h4><p>Periodic Job 是对 Batch Job 的扩展，为其添加了时间维度，同时允许临时的事件触发工作流的执行。<br>在分布式系统的世界里，有一种比较清晰的倾向，借助 HTTP 和轻量的消息系统实现实时、事件驱动的应用。不考虑软件开发中的此类倾向，计划任务仍然是一种历史悠久且至今常用的手段。<br>它们通常用于自动化的系统维护工作或者管理员任务，在商业应用方面的场景比如文件同步、发送邮件、清理和归档旧文件等。</p><p>传统的处理 Periodic Job 的方式是借助专门的计划任务软件比如 Cron。但是 Cron jobs 运行在单一的服务器上，难以维护且有发生单点故障的风险。<br>这也是为什么很多开发者会尝试实现自己的方案，比如 Java 中的 Quartz、Spring Batch 等。但是类似于 Cron，它们也会遇到弹性和高可用性方面的挑战，导致较高的资源使消耗。此外在这类方案里，Job 调度器是应用的一部分，为了获得高可用，通常就需要运行多个应用实例，同时还需要确保同一时刻下只有一个实例是活跃的。从而引入 leader election 等分布式系统问题。</p><p>面对以上的一些问题，Kubernetes 实现了 CronJob，允许开发者以广为熟知的 Cron 格式将 Job 设置为计划任务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># Every three minutes</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"*/3 * * * *"</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          containers:</span></span><br><span class="line"><span class="attr">          - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">            command:</span> <span class="string">[</span> <span class="string">"java"</span><span class="string">,</span> <span class="string">"-cp"</span><span class="string">,</span> <span class="string">"/"</span><span class="string">,</span> <span class="string">"RandomRunner"</span><span class="string">,</span> <span class="string">"/numbers.txt"</span><span class="string">,</span> <span class="string">"10000"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><p>与 Job 相比，CronJob 有一些额外的字段：</p><ul><li><code>.spec.schedule</code>：指定 Job 的 schedule 模式（如 <code>0 * * * *</code> 表示每个小时触发一次）</li><li><code>.spec.startingDeadlineSeconds</code>：Job 启动时的截止时间。有些时候由于资源不够或者缺少其他依赖，Job 错过了预定的触发时间。此字段用于指定错过多少秒后就直接跳过此次执行</li><li><code>.spec.concurrencyPolicy</code>：用于控制同一个 CronJob 的并发执行。默认值为 <code>Allow</code>，即使前一个 Job 并未结束，也允许新的 Job 实例被创建；可以指定为 <code>Forbid</code>，若当前 Job 并未结束，则跳过下一次执行；或者改为 <code>Replace</code>，取消当前还未结束的 Job 并启动一个新的 Job 实例</li><li><code>.spec.suspend</code>：暂停所有后续执行，但不影响已经开始的执行</li><li><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>：应保留多少已完成和失败的 Job 作为审计数据</li></ul><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>CronJob 其实是一个非常简单的原语，在现有的 Job 定义中添加类似 Cron 的行为。但是当它与 Kubernetes 提供的其他原语比如 Pods、资源隔离结合起来时，就成为一个非常强大的任务调度系统。<br>它的调度行为是平台的一部分，实现在应用的外部，使得开发者能够专注于应用的业务逻辑，无需在应用内部额外设计一套调度逻辑。同时提供了高可用、高弹性、高容积以及由策略驱动的 Pod 部署等特性。<br>当然，和 Job 一样，CronJob 容器在部署时，也需要考虑所有的特殊情况，比如重复执行、未触发、并发执行和任务取消等。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Batch-Job&quot;&gt;&lt;a href=&quot;#Batch-Job&quot; class=&quot;headerlink&quot; title=&quot;Batch Job&quot;&gt;&lt;/a&gt;Batch Job&lt;/h4&gt;&lt;p&gt;Batch Job 模式适合处理&lt;strong&gt;隔离的&lt;/strong&gt;、&lt;stro
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Job" scheme="https://rollingstarky.github.io/tags/Job/"/>
    
      <category term="CronJob" scheme="https://rollingstarky.github.io/tags/CronJob/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Automated Placement</title>
    <link href="https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-automated-placement/"/>
    <id>https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-automated-placement/</id>
    <published>2023-06-18T16:00:00.000Z</published>
    <updated>2023-06-19T12:30:35.207Z</updated>
    
    <content type="html"><![CDATA[<p><em>Automated Placement</em> 是 Kubernetes 中 scheduler 的核心功能，负责将新的 Pod 分配给合适的节点，满足容器的资源需求，同时遵守设定好的调度策略。</p><p>基于微服务的系统通常会包含数十个甚至数百个隔离的进程，容器和 Pod 为它们提供了很好的打包和部署机制，但并没有解决将众多的进程分配给适当的节点这项工作。<br>容器之间存在依赖关系，有些还需要关联到特定的节点，容器自身也有一定的资源需求。这些都会随着时间发生变化。同时集群本身的资源也不是恒定的，它会执行缩容或者扩容，其特定时刻下的容量也取决于已经放置的容器数量。<br>这些因素都会左右容器的调度。</p><h4 id="Available-Node-Resources"><a href="#Available-Node-Resources" class="headerlink" title="Available Node Resources"></a>Available Node Resources</h4><p>首先需要考虑的就是节点上是否有足够的可用资源。Scheduler 会确保 Pod 申请的资源总和小于可分配节点上的可用容量。节点可用容量的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocatable [capacity for application pods] =</span><br><span class="line">    Node Capacity [available capacity on a node]</span><br><span class="line">        - Kube-Reserved [Kubernetes daemons like kubelet, container runtime]</span><br><span class="line">        - System-Reserved [OS system daemons like sshd, udev]</span><br></pre></td></tr></table></figure></p><h4 id="Container-Resource-Demands"><a href="#Container-Resource-Demands" class="headerlink" title="Container Resource Demands"></a>Container Resource Demands</h4><p>Pod 在调度时，另一个重要的考虑因素就是容器有着自己的运行时依赖和资源需求。<br>比如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure></p><h4 id="Placement-Policies"><a href="#Placement-Policies" class="headerlink" title="Placement Policies"></a>Placement Policies</h4><p>Scheduler 配置了一组默认的优先级策略，适用于绝大多数场景。这个策略可以在 scheduler 启动时被替换掉。</p><p>scheduler 策略示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    <span class="attr">"predicates"</span> : [</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"PodFitsHostPorts"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"PodFitsResources"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"NoDiskConflict"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"NoVolumeZoneConflict"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"MatchNodeSelector"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"HostName"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"priorities"</span> : [</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"LeastRequestedPriority"</span>, <span class="attr">"weight"</span> : <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"BalancedResourceAllocation"</span>, <span class="attr">"weight"</span> : <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"ServiceSpreadingPriority"</span>, <span class="attr">"weight"</span> : <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"EqualPriority"</span>, <span class="attr">"weight"</span> : <span class="number">1</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 Predicate 规则用于过滤掉不合格的节点。比如 <code>PodFitsHostsPorts</code> 关注特定的固定主机端口，只有在这些端口可用时对应的节点才会作为候选。<br>Priorities 用于根据一些偏好设置来对候选的节点进行排序。比如 <code>LeastRequestedPriority</code> 会赋予请求了较少资源的节点更高的优先级。</p><p>可以同时运行多个 scheduler，让 Pod 自己去指定使用哪一个。只需要在 Pod 的配置中添加一条 <code>.spec.schedulerName</code>，其值为自定义 scheduler 的名字。</p><h4 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-92760d77eed2a546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A Pod-to-node assignment"></p><p>只要 Pod 创建完成且还没有被分配给任何节点，scheduler 就会挑选出该 Pod，连同所有可用的节点及优先级策略。第一阶段借助过滤策略移除所有不满足要求的节点，剩余的节点在第二阶段有权重地排序。最后一个阶段得到最终的胜出节点。</p><p>在绝大多数情况下，最好都只让 scheduler 去做 Pod-to-Node 的分配工作，不要去尝试“微操”调度逻辑。<br>在某些特殊场景下，如果需要强制某个 Pod 只能分配给特定的一个或一组节点，可以借助 Pod 的 <code>.spec.nodeSelector</code> 字段。<br>该字段可以指定一些键值对，对应节点身上的标签。比如想要 Pod 运行在拥有 SSD 磁盘的硬件上：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line"><span class="attr">    disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure></p><p>除了通过自定义标签指定节点，还可以通过每个节点上都有的默认标签来筛选，比如 <code>kubernetes.io/hostname</code>。</p><h4 id="Node-Affinity"><a href="#Node-Affinity" class="headerlink" title="Node Affinity"></a>Node Affinity</h4><p>Kubernetes 还支持更为灵活的配置调度流程的方式，比如 node affinity。其实它相当于 nodeSelector 机制的泛化，其规则可以被指定为“必需”或者“优先”。<br>“必需”表示相应的规则必须被满足，否则节点无法作为候选；“优先”则并不强制，只是提高匹配节点的权重。<br>此外，node affinity 支持多种操作符，如 <code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExist</code>、<code>Gt</code>、<code>Lt</code> 等，从而获得更强的表达能力。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  affinity:</span></span><br><span class="line"><span class="attr">    nodeAffinity:</span></span><br><span class="line"><span class="attr">      requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">        nodeSelectorTerms:</span></span><br><span class="line"><span class="attr">        - matchExpressions:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">numberCores</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">Gt</span></span><br><span class="line"><span class="attr">            values:</span> <span class="string">[</span> <span class="string">"3"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - weight:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">        preference:</span></span><br><span class="line"><span class="attr">          matchFields:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">NotIn</span></span><br><span class="line"><span class="attr">            values:</span> <span class="string">[</span> <span class="string">"master"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br></pre></td></tr></table></figure><p>其中 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 用来指定节点必须具备的条件，此规则不会在执行过程中重新计算。结合后面的 <code>nodeSelectorTerms</code> 配置，筛选出核心数大于 3 的节点。<br><code>preferredDuringSchedulingIgnoredDuringExecution</code> 用于指定非必须的条件，表现为一个带有权重的 selector 列表。对于每一个节点，计算出所有匹配项的权重总和，结果最高的节点被选中，只要该节点已经满足了前面的“必需”条件。</p><p>PS：<code>matchFields</code> 只支持 <code>In</code> 和 <code>NotIn</code> 操作符，<code>values</code> 指定的列表中也只允许有一个值。</p><p>诚然，node affinity 相比于 <code>nodeSelector</code> 功能更为强大。它允许通过标签或者字段为 Pod 选择合适的节点，但不能够用来表达 Pod 之间的依赖关系，比如无法根据某个节点上已经部署的 Pod 判断某个新 Pod 是否也应该部署到该节点。这类需求可以通过 Pod affinity 实现。</p><h4 id="Pod-Affinity"><a href="#Pod-Affinity" class="headerlink" title="Pod Affinity"></a>Pod Affinity</h4><p>Node affinity 工作在节点层级上，Pod affinity 则可以在多个拓扑层级上表达规则，达到粒度更细的控制。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  affinity:</span></span><br><span class="line"><span class="attr">    podAffinity:</span></span><br><span class="line"><span class="attr">      requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - labelSelector:</span></span><br><span class="line"><span class="attr">          matchLabels:</span></span><br><span class="line"><span class="attr">            confidential:</span> <span class="string">high</span></span><br><span class="line"><span class="attr">        topologyKey:</span> <span class="string">security-zone</span></span><br><span class="line"><span class="attr">    podAntiAffinity:</span></span><br><span class="line"><span class="attr">      preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - weight:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">        podAffinityTerm:</span></span><br><span class="line"><span class="attr">          labelSelector:</span></span><br><span class="line"><span class="attr">            matchLabels:</span></span><br><span class="line"><span class="attr">              confidential:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">          topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>podAffinity</code> 部分的配置表示，符合条件的节点上必须有带有 <code>confidential=high</code> 标签的 Pod 在运行，且该节点有 <code>security-zone</code> 标签。<br><code>podAntiAffinity</code> 定义的规则用于过滤掉匹配的节点。结合其配置，即节点上有带 <code>confidential=none</code> 标签的 Pod 在运行时，该节点不会用来部署当前 Pod。</p><h4 id="Taints-and-Tolerations"><a href="#Taints-and-Tolerations" class="headerlink" title="Taints and Tolerations"></a>Taints and Tolerations</h4><p>Taints 和 Tolerations 是一类更高级的用于控制调度策略的特性。简单来说，node affinity 允许 Pod 根据规则选择合适的节点，taints 和 tolerations 则正相反，它允许节点自身去控制 Pod 是否应该分配给自己。<br>Taint 是节点自身的一种属性，当它存在时，会阻止 Pod 分配给自己，除非该 Pod 拥有针对 taint 的 tolerations。</p><p>Taint 可以使用 <code>kubectl</code> 命令添加。如 <code>kubectl taint nodes master noderole.kubernetes.io/master=&quot;true&quot;:NoSchedule</code>，等效于下面的配置。</p><p>Tainted 节点：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  taints:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br></pre></td></tr></table></figure></p><p>拥有此 taint 的节点不会被分配任何 Pod，除非有 Pod 指定了对应的 toleration。比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure><p>在生产级别的集群中，带有 <code>noderole.kubernetes.io/master</code> 配置的 taint 一般会指定给 master 节点，阻止 Pod 部署到 master 上。<br>这里给 Pod 添加的 toleration 会覆盖 taint 的 <code>NoSchedule</code> 效果，即无论如何都允许此 Pod 分配给 master 节点。</p><p>Taint 可以是硬性的，阻止节点作为候选（<code>effect=NoSchedule</code>），也可以是软性的，尝试避免节点作为候选（<code>effect=PreferNoSchedule</code>），还可以强制移除节点上已经在运行的 Pod（<code>effect=NoExecute</code>）。</p><p>当 Pod 已经分配给某个节点，scheduler 的工作就已经算完成了，它不会再对完成的分配进行调整。除非该 Pod 被删除或者重建。随着时间的推移，这一定会导致资源的碎片化，集群利用率降低。<br>另一个潜在的问题是，Pod 被创建后具体分配给哪一个节点，依赖于当时集群的状态。而集群本身是动态的，节点的资源配置会更改，或者有新的节点加入进来，scheduler 并不会纠正已经存在的部署。此外，节点上的标签也有可能会变动，影响到之后的调度，但之前已经完成的调度依旧保持不变。</p><p>以上所有的场景都可以通过 descheduler 去解决。Kubernetes 的 descheduler 是一个可选的特性，通常作为 Job 执行，当管理员觉得是时候通过重新调度 Pod 来整理集群的碎片。<br>Descheduler 有一些预先定义的策略，可以被启用或者禁用：</p><ul><li>RemoveDuplicates：该策略会确保 ReplicaSet 或 Deployment 关联的单一 Pod 只运行在唯一一个节点上。当某个节点不健康时，controller 会在其他健康的节点上启动新的 Pod。此时若之前不健康的节点恢复正常重新加入集群，正在运行的 Pod 就会大于需要的数量。此策略就可以应用于这类的场景。同时 RemoveDuplicates 还可以在策略或集群架构发生变化后，将 Pod 更均匀地分散在更多的节点上</li><li>LowNodeUtilization：该策略会找到使用率低的节点，并将高使用率节点上的 Pod 移除掉，希望这些移除的 Pod 可以重新分配到未充分利用的节点上。使用率低指 CPU、内存或 Pod 数量小于 <code>thresholds</code> 配置；使用率高指的是 CPU、内存或 Pod 数量大于 <code>targetThresholds</code> 配置</li><li>RemovePodsViolatingInterPodAntiAffinity：该策略会移除违反了 pod antiaffinity 规则的 Pod。这种情况可能发生在，添加规则时一些不符合规则的 Pod 就已经存在了</li><li>RemovePodsViolatingNodeAffinity：移除违反了 node affinity 规则的 Pod</li></ul><p>不管使用何种配置的策略，descheduler 会避免移除如下类型的 Pod：</p><ul><li>在 annotation 中标记为 <code>scheduler.alpha.kubernetes.io/criticalpod</code> 的关键 Pod</li><li>不由 ReplicaSet、Deployment 或 Job 管理的 Pod</li><li>由 DaemonSet 管理的 Pod</li><li>拥有本地存储的 Pod</li><li>配置了 <code>PodDisruptionBudget</code> 的 Pod，且移除时会违反此规则</li><li>Descheduler Pod 本身</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>容器调度是一个我们希望尽可能少干预的领域。从简单到复杂，以下方法控制着调度的具体策略：</p><ul><li>nodeName：最简单的分配方式，将 Pod 到节点的关系硬编码到配置中。理想的情况下，此字段应该由 scheduler 填充，策略去驱动，而不是手动指定</li><li>nodeSelector：键值对映射。符合条件的节点必须包含此键值对指向的标签。在控制调度策略的可接受的方式中，最简单的一种</li><li>Default scheduling alteration：必要的情况下，可以修改 default scheduler 的过滤规则和优先级策略、顺序、权重等</li><li>Pod affinity 和 antiaffinity：此机制允许 Pod 表达自身对其他 Pod 的依赖关系</li><li>Node affinity：允许 Pod 表达自身对节点的依赖关系，比如节点的硬件配置、地理位置等</li><li>Taints 和 tolerations：允许节点去控制哪些 Pod 允许哪些不允许分配给自己。比如为一组 Pod 分配一个专用节点，甚至在运行时移除 Pod</li><li>Custom scheduler：若上述方案都不能符合需求，还可以编写自定义的 scheduler。自定义 scheduler 可以替换掉标准的 Kubernetes scheduler，也可以两者一起运行</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Automated Placement&lt;/em&gt; 是 Kubernetes 中 scheduler 的核心功能，负责将新的 Pod 分配给合适的节点，满足容器的资源需求，同时遵守设定好的调度策略。&lt;/p&gt;
&lt;p&gt;基于微服务的系统通常会包含数十个甚至数百个隔离的进程，
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Node" scheme="https://rollingstarky.github.io/tags/Node/"/>
    
      <category term="Schedule" scheme="https://rollingstarky.github.io/tags/Schedule/"/>
    
      <category term="Policy" scheme="https://rollingstarky.github.io/tags/Policy/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 消息中间件及其应用模式（任务分发）</title>
    <link href="https://rollingstarky.github.io/2023/01/12/node-js-design-patterns-message-broker-pattern-task-distribution/"/>
    <id>https://rollingstarky.github.io/2023/01/12/node-js-design-patterns-message-broker-pattern-task-distribution/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-01-12T12:33:13.527Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/6875152-0ad90045a8fe8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Distributing tasks to a set of consumers"></p><p>将高成本的任务委派给多个工作节点，这种类型的应用并不适合由 Pub/Sub 模式实现。因为我们并不想同一个任务被多个消费者收到，相反我们更需要一种类似负载均衡的消息分发模式。在消息系统术语中，也被称为 <em>competing consumers</em>，<em>fanout distribution</em> 或 <em>ventilator</em>。<br>与 HTTP 负载均衡器不同的是，任务分发系统中的消费者是一种更活跃的角色。绝大多数时候都是消费者连接到任务队列，请求新的任务。这一点在可扩展系统中非常关键，允许我们在不修改生产者部分的情况下，直接平滑地增加工作节点的数量。<br>此外，在一个通用的消息系统中，我们没有必要强调生产者和消费者之间的请求/响应通信。多数情况下，更优先的选择是使用单向的异步通信，从而获得更优异的并行能力和扩展性。消息基本上总是沿着一个方向流动，这样的管道允许我们构建复杂的信息处理架构，又不必承受同步通信带来的开销。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6258cabc8d854f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A messaging pipeline"></p><h4 id="ZeroMQ-Fanout-Fanin-模式"><a href="#ZeroMQ-Fanout-Fanin-模式" class="headerlink" title="ZeroMQ Fanout/Fanin 模式"></a>ZeroMQ Fanout/Fanin 模式</h4><h5 id="分布式-hashsum-破解器"><a href="#分布式-hashsum-破解器" class="headerlink" title="分布式 hashsum 破解器"></a>分布式 hashsum 破解器</h5><p>需要以下组件实现一个标准的并行管线：</p><ul><li>一个协调节点负责在多个工作节点间分发任务</li><li>多个工作节点承担具体的计算任务</li><li>一个用于收集计算结果的节点</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-91adec0584325527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The architecture of a typical pipeline with ZeroMQ"></p><p>即一个节点负责生成所有可能的字符串组合，并将它们分发给不同的工作节点；工作节点则负责计算接收到的字符串，比较 hash 值；最后一个节点负责收集暴力破解的结果。</p><h5 id="实现-producer"><a href="#实现-producer" class="headerlink" title="实现 producer"></a>实现 producer</h5><p>为了表示所有可能的字符组合，这里使用 N 维索引树。每个节点包含一个当前位置下可能出现的字母，比如只有 <code>a</code>、<code>b</code> 两个字母的话，长度为 3 的字符串组合共有图示的以下几种：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d4b87b3295b700ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Indexed n-ary tree for alphabet (a, b)"></p><p><code>indexed-string-variation</code> 包可以帮助我们由索引计算出对应的字符串，这项工作可以在工作节点完成，因此 producer 这里只需要将分好组的索引值分发给工作节点。<br>generateTasks.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">generateTasks</span>(<span class="params">searchHash, alphabet,</span></span></span><br><span class="line"><span class="function"><span class="params">    maxWordLength, batchSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nVariations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n = <span class="number">1</span>; n &lt;= maxWordLength; n++) &#123;</span><br><span class="line">        nVariations += <span class="built_in">Math</span>.pow(alphabet.length, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finding the hashsum source string over '</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;nVariations&#125;</span> possible variations`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> batchStart = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (batchStart &lt;= nVariations) &#123;</span><br><span class="line">        <span class="keyword">const</span> batchEnd = <span class="built_in">Math</span>.min(</span><br><span class="line">            batchStart + batchSize - <span class="number">1</span>, nVariations)</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            searchHash,</span><br><span class="line">            alphabet: alphabet,</span><br><span class="line">            batchStart,</span><br><span class="line">            batchEnd</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        batchStart = batchEnd + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>producer.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"><span class="keyword">import</span> delay <span class="keyword">from</span> <span class="string">'delay'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ventilator = <span class="keyword">new</span> zmq.Push()</span><br><span class="line">    <span class="keyword">await</span> ventilator.bind(<span class="string">'tcp://*:5016'</span>)</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET, maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        <span class="keyword">await</span> ventilator.send(<span class="built_in">JSON</span>.stringify(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><ul><li>创建一个 PUSH socket 并绑定给本地的 5016 端口，工作节点的 PULL socket 会连接到此端口并接收任务</li><li>将每一个生成的任务字符串化，通过 PUSH socket 的 <code>send()</code> 方法发送给工作节点。工作节点以轮询的方式接收不同的任务</li></ul><h5 id="实现-worker"><a href="#实现-worker" class="headerlink" title="实现 worker"></a>实现 worker</h5><p>process Task.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isv <span class="keyword">from</span> <span class="string">'indexed-string-variation'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createHash &#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processTask</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> variationGen = isv.generator(task.alphabet)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'processing from '</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;variationGen(task.batchStart)&#125;</span> (<span class="subst">$&#123;task.batchStart&#125;</span>)`</span> +</span><br><span class="line">        <span class="string">`to <span class="subst">$&#123;variationGen(task.batchEnd)&#125;</span> (<span class="subst">$&#123;task.batchEnd&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx = task.batchStart; idx &lt;= task.batchEnd; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> word = variationGen(idx)</span><br><span class="line">        <span class="keyword">const</span> shasum = createHash(<span class="string">'sha1'</span>)</span><br><span class="line">        shasum.update(word)</span><br><span class="line">        <span class="keyword">const</span> digest = shasum.digest(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (digest === task.searchHash) &#123;</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processTask()</code> 遍历给定区间内的所有索引值，对每一个索引生成对应的字符串，再计算其 SHA1 值，与传入的 <code>task</code> 对象中的 <code>searchHash</code> 比较。</p><p>worker.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fromVentilator = <span class="keyword">new</span> zmq.Pull()</span><br><span class="line">    <span class="keyword">const</span> toSink = <span class="keyword">new</span> zmq.Push()</span><br><span class="line"></span><br><span class="line">    fromVentilator.connect(<span class="string">'tcp://localhost:5016'</span>)</span><br><span class="line">    toSink.connect(<span class="string">'tcp://localhost:5017'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> rawMessage <span class="keyword">of</span> fromVentilator) &#123;</span><br><span class="line">        <span class="keyword">const</span> found = processTask(<span class="built_in">JSON</span>.parse(rawMessage.toString()))</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">await</span> toSink.send(<span class="string">`Found: $found`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p><code>worker.js</code> 创建了两个 socket。PULL socket 负责连接到任务发布方（Ventilator），接收任务；PUSH socket 负责连接到结果收集方（sink），传递任务执行的结果。</p><h5 id="实现-results-collector"><a href="#实现-results-collector" class="headerlink" title="实现 results collector"></a>实现 results collector</h5><p>collector.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sink = <span class="keyword">new</span> zmq.Pull()</span><br><span class="line">    <span class="keyword">await</span> sink.bind(<span class="string">'tcp://*:5017'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> rawMessage <span class="keyword">of</span> sink) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Message from worker: '</span>, rawMessage.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行以下命令测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker.js</span><br><span class="line">node worker.js</span><br><span class="line">node collector.js</span><br><span class="line">node producer.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="AMQP-实现-pipeline-和-competing-consumers"><a href="#AMQP-实现-pipeline-和-competing-consumers" class="headerlink" title="AMQP 实现 pipeline 和 competing consumers"></a>AMQP 实现 pipeline 和 competing consumers</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e0f424ea12f666ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Task distribution architecture using a message queue broker"></p><p>像前面那样在点对点的模式下，实现 pipeline 是非常直观的。假设我们需要借助 AMQP 这类系统实现任务分配模式，就必须确保每条消息都只会被一个消费者接收到。<br>可以直接将任务发布到目标 queue，不经过 exchange。避免了 exchange 有可能绑定了多个 queue 的情况。之后，多个消费者同时监听这一个 queue，消息即会以 fanout 的方式均匀地分发给所有的消费者。</p><h5 id="hashsum-破解器的-AMQP-实现"><a href="#hashsum-破解器的-AMQP-实现" class="headerlink" title="hashsum 破解器的 AMQP 实现"></a>hashsum 破解器的 AMQP 实现</h5><p>producer-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createConfirmChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertQueue(<span class="string">'tasks_queue'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET,</span><br><span class="line">        maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        channel.sendToQueue(<span class="string">'tasks_queue'</span>, Buffer.from(<span class="built_in">JSON</span>.stringify(task)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> channel.waitForConfirms()</span><br><span class="line">    channel.close()</span><br><span class="line">    connection.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><ul><li>此处创建的是一个 <code>confirmChannel</code>，它提供了一个 <code>waitForConfirms()</code> 函数，可以在 broker 确认收到消息前等待，确保应用不会过早地关闭到 broker 的连接</li><li><code>channel.sendToQueue()</code> 负责将一条消息直接发送给某个 queue，跳过任何 exchange 或者路由</li></ul><p>worker-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(<span class="string">'tasks_queue'</span>)</span><br><span class="line">    channel.consume(queue, <span class="keyword">async</span> (rawMessage) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> found = processTask(</span><br><span class="line">            <span class="built_in">JSON</span>.parse(rawMessage.content.toString()))</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">await</span> channel.sendToQueue(<span class="string">'results_queue'</span>,</span><br><span class="line">                Buffer.from(<span class="string">`Found: <span class="subst">$&#123;found&#125;</span>`</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> channel.ack(rawMessage)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>collector-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(<span class="string">'results_queue'</span>)</span><br><span class="line">    channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message from worker: <span class="subst">$&#123;msg.content.toString()&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行如下命令测试效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker-amqp.js</span><br><span class="line">node worker-amqp.js</span><br><span class="line">node collector-amqp.js</span><br><span class="line">node producer-amqp.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="通过-Redis-Streams-实现任务分发"><a href="#通过-Redis-Streams-实现任务分发" class="headerlink" title="通过 Redis Streams 实现任务分发"></a>通过 Redis Streams 实现任务分发</h4><p>Redis Stream 可以借助一种叫做 <strong>consumer groups</strong> 的特性实现任务分发模式。Consumer group 是一个有状态的实体，由一组名称标识的消费者组成，组中的消费者会以 round-robin 的方式接收记录。<br>每条记录都必须被显式地确认，否则该记录会一直处于 <em>pending</em> 状态。每个消费者都只能访问它自己的 pending 记录，假如消费者突然崩溃，在其回到线上后会先尝试获取其 pending 的记录。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1df8534f81ab4f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A Redis Stream consumer group"></p><p>Consumer group 也会记录其读取的上一条消息的 ID，因而在连续的读取操作中，consumer group 知道下一条要读取的记录时是哪个。</p><p>producer-redis.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET,</span><br><span class="line">        maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        <span class="keyword">await</span> redisClient.xadd(<span class="string">'tasks_stream'</span>, <span class="string">'*'</span>,</span><br><span class="line">            <span class="string">'task'</span>, <span class="built_in">JSON</span>.stringify(task))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisClient.disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure><p>worker-redis.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> [, , consumerName] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> redisClient.xgroup(<span class="string">'CREATE'</span>, <span class="string">'tasks_stream'</span>,</span><br><span class="line">        <span class="string">'workers_group'</span>, <span class="string">'$'</span>, <span class="string">'MKSTREAM'</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Consumer group already exists'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClient.xreadgroup(</span><br><span class="line">        <span class="string">'GROUP'</span>, <span class="string">'workers_group'</span>, consumerName, <span class="string">'STREAMS'</span>,</span><br><span class="line">        <span class="string">'tasks_stream'</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, rawTask]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">        <span class="keyword">await</span> processAndAck(recordId, rawTask)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClient.xreadgroup(</span><br><span class="line">            <span class="string">'GROUP'</span>, <span class="string">'workers_group'</span>, consumerName, <span class="string">'BLOCK'</span>, <span class="string">'0'</span>,</span><br><span class="line">            <span class="string">'COUNT'</span>, <span class="string">'1'</span>, <span class="string">'STREAMS'</span>, <span class="string">'tasks_stream'</span>, <span class="string">'&gt;'</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, rawTask]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">            <span class="keyword">await</span> processAndAck(recordId, rawTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processAndAck</span>(<span class="params">recordId, rawTask</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> found = processTask(<span class="built_in">JSON</span>.parse(rawTask))</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> redisClient.xadd(<span class="string">'results_stream'</span>, <span class="string">'*'</span>, <span class="string">'result'</span>,</span><br><span class="line">            <span class="string">`Found: <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> redisClient.xack(<span class="string">'tasks_stream'</span>, <span class="string">'workers_group'</span>, recordId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure><ul><li><code>xgroup</code> 命令用来确保 consumer group 存在。<ul><li><code>CREATE</code> 表示我们希望创建一个 consumer group</li><li><code>tasks_stream</code> 表示我们想要读取的 stream 的名字</li><li><code>workers_group</code> 是 consumer group 的名字</li><li>第四个参数表示 consumer group 开始读取的记录的位置。<code>$</code> 表示当前 stream 中最后一条记录的 ID</li><li><code>MKSTREAM</code> 表示如果 stream 不存在则创建它</li></ul></li><li>通过 <code>xreadgroup</code> 命令读取属于当前 consumer 的所有 pending 的记录。<ul><li><code>&#39;GROUP&#39;</code>、<code>&#39;workers_group&#39;</code>、<code>consumerName</code> 用来指代 consumer group 和 consumer 的名字</li><li><code>STREAMS</code> 和 <code>tasks_stream</code> 用来指代我们想要读取的 stream 的名字</li><li><code>0</code> 用来表示我们想要开始读取的记录的位置。这里表示从属于当前 consumer 的第一条记录开始，读取所有 pending 的消息</li></ul></li><li>通过另外一条 <code>xreadgroup</code> 命令读取 stream 里新增加的记录。<ul><li><code>&#39;BLOCK&#39;</code> 和 <code>&#39;0&#39;</code> 两个参数表示如果没有新的消息，就一直阻塞等待。<code>&#39;0&#39;</code> 具体表示一直等待永不超时</li><li><code>&#39;COUNT&#39;</code> 和 <code>&#39;1&#39;</code> 表示一次请求只获取一条记录</li><li>特殊 ID <code>&gt;</code> 表示只获取还没有被当前的 consumer group 处理过的消息</li></ul></li><li><code>processAndAck()</code> 函数负责当 <code>xreadgroup()</code> 返回的记录被处理完成时，调用 <code>xack</code> 命令进行确认，将该记录从当前 consumer 的 pending 列表里移除</li></ul><p>collector-redis.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastRecordId = <span class="string">'$'</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> redisClient.xread(</span><br><span class="line">            <span class="string">'BLOCK'</span>, <span class="string">'0'</span>, <span class="string">'STREAMS'</span>, <span class="string">'results_stream'</span>, lastRecordId)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [, logs] <span class="keyword">of</span> data) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, message]] <span class="keyword">of</span> logs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`Message from worker: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">                lastRecordId = recordId</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行程序测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker-redis.js workerA</span><br><span class="line">node worker-redis.js workerB</span><br><span class="line">node collector-redis.js</span><br><span class="line">node producer-redis.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6875152-0ad90045a8fe8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Pipeline" scheme="https://rollingstarky.github.io/tags/Pipeline/"/>
    
      <category term="Message" scheme="https://rollingstarky.github.io/tags/Message/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="AMQP" scheme="https://rollingstarky.github.io/tags/AMQP/"/>
    
      <category term="Redis" scheme="https://rollingstarky.github.io/tags/Redis/"/>
    
      <category term="RabbitMQ" scheme="https://rollingstarky.github.io/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
      <category term="Task" scheme="https://rollingstarky.github.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>Python 借助 asyncio 实现并发编程</title>
    <link href="https://rollingstarky.github.io/2023/01/12/python-concurrency-with-coroutine-and-asyncio-basics/"/>
    <id>https://rollingstarky.github.io/2023/01/12/python-concurrency-with-coroutine-and-asyncio-basics/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-01-12T12:38:36.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="asyncio-基础"><a href="#asyncio-基础" class="headerlink" title="asyncio 基础"></a>asyncio 基础</h4><h5 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h5><p><strong>使用 async 关键字创建 coroutine</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine_add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_result = add_one(<span class="number">1</span>)</span><br><span class="line">coroutine_result = coroutine_add_one(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(</span><br><span class="line">    <span class="string">f'Function result is <span class="subst">&#123;function_result&#125;</span> and the type is <span class="subst">&#123;type(function_result)&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># =&gt; Function result is 2 and the type is &lt;class 'int'&gt;</span></span><br><span class="line"></span><br><span class="line">print(</span><br><span class="line">    <span class="string">f'Coroutine result is <span class="subst">&#123;coroutine_result&#125;</span> and the type is <span class="subst">&#123;type(coroutine_result)&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># =&gt; Coroutine result is &lt;coroutine object coroutine_add_one at 0x7f9f495f20a0&gt; and the type is &lt;class 'coroutine'&gt;</span></span><br><span class="line"><span class="comment"># =&gt; sys:1: RuntimeWarning: coroutine 'coroutine_add_one' was never awaited</span></span><br></pre></td></tr></table></figure><p>创建 coroutine 和创建普通的函数一样直接，唯一的区别在于使用 <code>async def</code> 而不是 <code>def</code>。<br>当我们直接调用协程 <code>coroutine_add_one</code> 时，传入的参数并没有被加 1 然后返回计算结果，我们只是得到了一个 <code>coroutine object</code>。<br>即我们只是创建了一个能够在之后的某个时间运行的 coroutine 对象，为了运行它，我们总是需要显式地将其放入 event loop 中。最简单的方式就是使用 <code>asyncio.run</code> 函数。</p><p><strong>运行 coroutine</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine_add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = asyncio.run(coroutine_add_one(<span class="number">1</span>))</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># =&gt; 2</span></span><br></pre></td></tr></table></figure><p><code>asyncio.run</code> 是 asyncio 应用程序的入口。</p><p><strong>使用 await 关键字暂停执行</strong><br>asyncio 的真正用处，在于能够在一个长时间运行的操作过程中，暂停执行，从而令 event loop 有机会处理其他任务。“暂停”的动作通过 <code>await</code> 关键字触发。<code>await</code> 后面通常紧跟着一个对 coroutine （更严谨地说，一个 <code>awaitable</code> 对象）的调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>)</span><br><span class="line">    two_plus_one = <span class="keyword">await</span> add_one(<span class="number">2</span>)</span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    <span class="comment"># =&gt; 2</span></span><br><span class="line">    print(two_plus_one)</span><br><span class="line">    <span class="comment"># =&gt; 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>首先 <code>await</code> 对协程 <code>add_one(1)</code> 的调用，此时父协程（即 <code>main()</code>）被暂停，<code>add_one(1)</code> 执行并获取结果（<code>2</code>），<code>main()</code> 协程恢复执行，将结果赋值给 <code>one_plus_one</code>；同样地，对协程 <code>add_one(2)</code> 的 <code>await</code> 也会导致 <code>main()</code> 被暂停和恢复。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f3dca99e4621c760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="await"></p><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><p>前面的例子只是为了介绍协程的基本语法，并没有涉及任何 long-running 操作，因而也没有享受到 asyncio 在并发方面的作用。我们可以借助 <code>asyncio.sleep</code> 函数模拟 web API 请求或者数据库查询等长时间运行的操作，<code>asyncio.sleep</code> 能够令某个协程“睡眠”指定的时间（秒）。<br><code>asyncio.sleep</code> 本身就是一个协程，因而当我们在某个协程中 await <code>asyncio.sleep</code> 时，其他部分代码就得到了执行的机会。</p><p><strong>sleep 实现 delay 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br></pre></td></tr></table></figure><p><strong>运行两个协程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world_message</span><span class="params">()</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello Wrold!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    message = <span class="keyword">await</span> hello_world_message()</span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>)</span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    print(message)</span><br><span class="line">    <span class="comment"># =&gt; sleeping for 1 second(s)</span></span><br><span class="line">    <span class="comment"># =&gt; finished sleeping for 1 second(s)</span></span><br><span class="line">    <span class="comment"># =&gt; 2</span></span><br><span class="line">    <span class="comment"># =&gt; Hello Wrold!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>运行上面的代码，先是等待 1 秒钟，之后才是两个函数调用的结果被打印出来。我们本来希望看到的是，两个协程并发地执行，<code>add_one(1)</code> 的结果直接被输出，并不需要等待 <code>hello_world_message()</code> 中的 <code>sleep</code> 结束。<br>实际上 <code>await</code> 会暂停其所在的协程（这里是 <code>main</code>），并且不会执行当前协程中的任何其他代码，直到 <code>await</code> 表达式获得一个结果。<code>hello_world_message</code> 需要 1 秒钟才能返回结果，因而 main 协程也会被暂停 1 秒钟。排在它后面的 <code>add_one(1)</code> 在暂停结束后执行并返回结果。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-dc45bb81c8969a35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="execution flow"></p><p>上面的代码和同步、顺序执行的代码没有表现出任何区别。为了实现并发，我们需要引入一个新的概念 <strong>task</strong>。</p><h5 id="tasks"><a href="#tasks" class="headerlink" title="tasks"></a>tasks</h5><p>Task 是对协程的一种包装，能够将一个协程调度至 event loop 并争取尽快执行。这种调度是以一种<strong>非阻塞</strong>的方式发生的，即 task 被创建后会立即返回，不必等待其运行结束，从而我们能够有机会执行其他代码。</p><p><strong>并发地执行多个 task</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_every_second</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"I'm running other code while I'm waiting!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    first_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    second_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">await</span> hello_every_second()</span><br><span class="line">    <span class="keyword">await</span> first_delay</span><br><span class="line">    <span class="keyword">await</span> second_delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="comment"># =&gt; I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 3 second(s)</span></span><br></pre></td></tr></table></figure><p>上述代码创建了 2 个 task，每个都需要 3 秒钟才能执行完毕。两次对 <code>create_task</code> 的调用都会立即返回。由于 task 调度的原则是尽快执行，当后面的 <code>await</code> 代码刷新了一次 event loop 之后，前面创建的 2 个 task 会立即被执行（非阻塞）。<br>两个 delay task 在 <code>sleep</code> 过程中，应用是闲置的，我们得以有机会运行其他代码。协程 <code>hello_every_second</code> 每隔 1 秒输出一条消息。整个应用总的运行时间大约是 3 秒，即大约等于耗时最长的异步任务的时间，而不是像顺序执行的程序那样，等于多个任务运行时间的总和。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5688b12e8271ed3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="execution flow"></p><h4 id="协程和任务的陷阱"><a href="#协程和任务的陷阱" class="headerlink" title="协程和任务的陷阱"></a>协程和任务的陷阱</h4><p>将一些长时间运行的任务并发的执行，能够带来很大程度上的性能提升。因而我们会倾向于在应用的任何地方使用协程和 task。事实上，仅仅将函数用 async 修饰，将其封装进 task，并不总是带来性能上的提升。甚至有些情况下还会降低程序的效率。<br>最主要的情形有两种，<strong>一个是在不借助多进程的情况下，尝试在 task 或协程中运行 CPU-bound 代码；另一种是在不借助多线程的情况下调用阻塞式 I/O-bound API</strong>。</p><h5 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h5><p>有时候我们需要一些函数执行 CPU 密集型的任务，比如对一个很大的字典执行循环或者数学计算。为了提升效率，我们会想着将它们放置在单独的 task 中运行。然而现实是，<strong>asyncio 使用单线程并发模型，我们依然会受到单个线程和 GIL 的限制</strong>。</p><p><strong>计算协程运行时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Callable, Any</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_timed</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func: Callable)</span> -&gt; Callable:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span> -&gt; Any:</span></span><br><span class="line">            print(<span class="string">f'Starting <span class="subst">&#123;func&#125;</span> with <span class="subst">&#123;args&#125;</span> <span class="subst">&#123;kwargs&#125;</span>'</span>)</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                end = time.time()</span><br><span class="line">                total = end - start</span><br><span class="line">                print(<span class="string">f'finished <span class="subst">&#123;func&#125;</span> in <span class="subst">&#123;total:<span class="number">.4</span>f&#125;</span> second(s)'</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br></pre></td></tr></table></figure><p><strong>运行 CPU-bound 代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay, async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_work</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    task_two = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">await</span> task_one</span><br><span class="line">    <span class="keyword">await</span> task_two</span><br><span class="line">    <span class="keyword">await</span> delay_task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7f2d6b85bc70&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; in 2.7423 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; in 2.7430 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7f2d6b85a0e0&gt; with (4,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 4 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 4 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7f2d6b85a0e0&gt; in 4.0048 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7f2d6b85bc70&gt; in 9.4903 second(s)</span></span><br></pre></td></tr></table></figure><p>上述代码创建了 3 个 task，但实际执行时依然是顺序的而非并发的，耗费的时间并没有变少。两个 CPU-bound task 是依次执行的，甚至 <code>delay_task</code> 也并没有与其他两个任务呈现并发性。原因在于我们先创建了两个 CPU-bound 任务，这两个任务会阻塞 event loop，阻止其调度执行任何其他任务。<br>因此，总的运行时间等于两个 CPU-bound 任务执行完毕的时间加上 delay 任务运行的 4 秒。即 asyncio 并没有为 CPU-bound 的任务带来任何性能上的提升。<br>假如我们需要在执行 CPU-bound 任务的同时仍使用 <code>async</code> 语法，就必须借助多进程，告诉 asyncio 在 <em>process pool</em> 中执行任务。</p><h5 id="阻塞式-API"><a href="#阻塞式-API" class="headerlink" title="阻塞式 API"></a>阻塞式 API</h5><p>我们也会倾向于使用<strong>现有的库</strong>执行 I/O-bound 操作，再将其封装进协程。然而，这会引起与 CPU-bound 操作同样的问题。因为这些 API 会阻塞 main 线程。<br>当我们在协程内部调用一个阻塞的 API，我们会阻塞 event loop 线程本身，线程被阻塞请求占据，导致 event loop 无法调度任何其他协程和任务。阻塞式 API 请求包括 <code>requests</code> 库和 <code>time.sleep</code> 等。<strong>通常来说，任何执行 I/O 操作且不是协程的函数，以及执行 CPU 密集型任务的函数，都可以认为是阻塞的</strong>。</p><p><strong>协程内部调用阻塞式 API</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_example_status</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(<span class="string">'http://www.example.com'</span>).status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_1 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_2 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_3 = asyncio.create_task(get_example_status())</span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7f4335080790&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5144 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5163 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5177 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7f4335080790&gt; in 1.5488 second(s)</span></span><br></pre></td></tr></table></figure><p><code>main</code> 协程运行的总时间基本上等于所有 task 运行的时间之和。即我们并没有获取到任何并发上的收益。原因在于 <code>requests</code> 库是阻塞的，任何调用都会阻塞当前线程，而 asyncio 只有一个线程，在阻塞调用结束之前，线程中的 event loop 没有机会以异步的形式运行任何任务。<br>当你使用的库并没有返回协程，你并没有在自己的协程中使用 <code>await</code> 关键字，很大可能你就是在进行阻塞的函数调用。当前我们使用的大多数 API 都是阻塞的，并不支持与 asyncio 开箱即用。<br>要想体验到 asyncio 带来的异步和并发特性，就必须使用原生支持协程和非阻塞 socket 的库，比如 <code>aiohttp</code>。或者你坚持使用 <code>requests</code> 库，同时又需要 <code>async</code> 语法，就必须显式地告诉 <code>asyncio</code> 使用多线程的方式，通过 <em>thread pool executor</em> 执行阻塞调用。</p><p><strong>借助支持协程的库 aiohttp 实现并发</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_example_status</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    session = ClientSession()</span><br><span class="line">    resp = <span class="keyword">await</span> session.get(<span class="string">'http://example.com'</span>)</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> resp.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_1 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_2 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_3 = asyncio.create_task(get_example_status())</span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7fd9f90b6a70&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7fd9f90b6a70&gt; in 0.5196 second(s)</span></span><br></pre></td></tr></table></figure><p>可以看到所有 task 执行的总时间，基本上只比一个 task 运行的时间多一点点。此时的程序是并发执行的。</p><h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><p><strong>取消任务</strong></p><p>每个 <code>task</code> 对象都有一个 <code>cancel</code> 方法可以帮助我们随时终止该任务。当我们 <code>await</code> 取消的任务时，会报出 <code>CancelledError</code> 异常。<br>比如我们调度执行某个任务，又不希望该任务运行的时间超过 5 秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> CancelledError</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    long_task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    seconds_elapsed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> long_task.done():</span><br><span class="line">        print(<span class="string">'Task not finished, checking again in a second.'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        seconds_elapsed = seconds_elapsed + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> seconds_elapsed == <span class="number">5</span>:</span><br><span class="line">            long_task.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> long_task</span><br><span class="line">    <span class="keyword">except</span> CancelledError:</span><br><span class="line">        print(<span class="string">'Our task was cancelled'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7fdb383ae0e0&gt; with (10,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7fdb383ae0e0&gt; in 5.0079 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Our task was cancelled</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>CancelledError</code> 只会在 <code>await</code> 语句处抛出，调用 <code>cancel</code> 方法并不会神奇地强行关闭正在运行的任务，只有你刚好遇到 <code>await</code> 时任务才会被终止，不然就等待下一个 <code>await</code>。</p><p><strong>使用 wait_for 设置超时时间</strong><br>每隔一段时间手动进行检查，以确定是否取消某个任务，并不算一种简单的处理方式。asyncio 提供了一个 <code>wait_for</code> 函数，它接收一个协程或者任务，以及超时的秒数作为参数，返回一个协程对象。<br>若任务运行超时，一个 <code>TimeoutException</code> 就会被抛出，任务自动被终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(delay_task, timeout=<span class="number">1</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> asyncio.exceptions.TimeoutError:</span><br><span class="line">        print(<span class="string">'Got a timeout'</span>)</span><br><span class="line">        print(<span class="string">f'Was the task cancelled? <span class="subst">&#123;delay_task.cancelled()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7f71e18160e0&gt; with (2,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 2 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7f71e18160e0&gt; in 1.0016 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Got a timeout</span></span><br><span class="line"><span class="comment"># =&gt; Was the task cancelled? True</span></span><br></pre></td></tr></table></figure><p><strong>asyncio.shield</strong><br>在另外一些情况下，我们有可能并不希望直接取消某个超时的任务，而是当任务运行时间过长时，提醒用户这个情况，但是并不执行任何 cancel 操作。<br><code>shield</code> 可以帮助我们实现这样的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(asyncio.shield(task), <span class="number">5</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> asyncio.exceptions.TimeoutError:</span><br><span class="line">        print(<span class="string">"Task took longer than five seconds, it will finish soon!"</span>)</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7ff344d120e0&gt; with (10,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Task took longer than five seconds, it will finish soon!</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7ff344d120e0&gt; in 10.0063 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/python-concurrency-with-asyncio" target="_blank" rel="noopener">Python Concurrency with asyncio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;asyncio-基础&quot;&gt;&lt;a href=&quot;#asyncio-基础&quot; class=&quot;headerlink&quot; title=&quot;asyncio 基础&quot;&gt;&lt;/a&gt;asyncio 基础&lt;/h4&gt;&lt;h5 id=&quot;创建协程&quot;&gt;&lt;a href=&quot;#创建协程&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Async" scheme="https://rollingstarky.github.io/tags/Async/"/>
    
      <category term="Coroutine" scheme="https://rollingstarky.github.io/tags/Coroutine/"/>
    
      <category term="Asyncio" scheme="https://rollingstarky.github.io/tags/Asyncio/"/>
    
      <category term="EventLoop" scheme="https://rollingstarky.github.io/tags/EventLoop/"/>
    
      <category term="Non-blocking" scheme="https://rollingstarky.github.io/tags/Non-blocking/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 消息中间件及其应用模式（发布订阅）</title>
    <link href="https://rollingstarky.github.io/2023/01/03/node-js-design-patterns-message-queue-pub-sub-pattern/"/>
    <id>https://rollingstarky.github.io/2023/01/03/node-js-design-patterns-message-queue-pub-sub-pattern/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-01-03T12:34:12.199Z</updated>
    
    <content type="html"><![CDATA[<p>主要有两类技术可以用来整合分布式应用：一类是通过共享存储作为一个中心化的协调者，跟踪和保存所有需要共享的信息；另一类则是通过消息中间件，向系统中的所有节点散布数据、事件和命令等。<br>消息存在于软件系统的各个层级。我们通过互联网交换消息完成通信；通过管道发送消息给其他进程；设备驱动通过消息与硬件进行交互等等。任何用于在组件和系统之间交换信息的离散或结构化数据都可以视为消息。</p><h3 id="消息系统基础"><a href="#消息系统基础" class="headerlink" title="消息系统基础"></a>消息系统基础</h3><p>对于消息系统，有以下四个基本要素需要考虑：</p><ul><li>通讯的方向。可以是单向的，也可以是“请求 - 响应”模式</li><li>通讯的目的。同时决定了消息本身的内容</li><li>消息的时效性。可以同步或者异步地发送与接收</li><li>消息的投递方式。可以直接投递也可以通过某个中间件</li></ul><h4 id="单向-vs-“请求-应答”模式"><a href="#单向-vs-“请求-应答”模式" class="headerlink" title="单向 vs “请求 - 应答”模式"></a>单向 vs “请求 - 应答”模式</h4><p>单向模式：消息从源头推送到目的地。常见的应用比如邮件系统、将工作任务分派给一系列工作节点的系统。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d445119d21df5465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单向通信"></p><p>“请求 - 响应”模式：一方发出的消息总能够与对方发出的消息匹配。比如 web 服务的调用、向数据库请求数据等。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-166789a1fd06211a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Request/Reply"></p><p>包含多个响应节点的“请求 - 响应”模式：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0057bb50d2792ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Multi-node request/reply"></p><h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>消息内容主要取决于通信的目的。通常有以下三种：</p><ul><li>命令消息</li><li>事件消息</li><li>文档消息</li></ul><p>命令消息用来令接收者触发某个动作或者任务。借助它可以实现<strong>远程过程调用（RPC）</strong>系统，分布式计算等。RESTful HTTP 请求就是简单的命令消息的例子。<br>事件消息用来通知另一个组件发生了某些情况。事件在分布式系统中是一种很重要的整合机制，用来确保系统的各个组件保持同样的步调。<br>文档消息基本上就是在组件之间传输数据。比如数据库请求的结果。</p><h4 id="异步队列和流"><a href="#异步队列和流" class="headerlink" title="异步队列和流"></a>异步队列和流</h4><p>同步通信类似于打电话。电话的双方必须同时在线，连接到同一个通道，实时地交流信息。当我们需要打给另一个人时，通常就得搞一部新的手机或者挂掉当前正在进行的通话，拨打新的号码。<br>异步通信类似于发短信。我们发送短信的时刻，并不需要接收方已经接入了网络。我们可以一条接一条地发送多条短信给不同的人，以任意顺序接收对方的回复（如果有的话）。</p><p>另一个异步通信的重要特性就是，消息可以被临时存储在某个地方，再在之后的某个时间送达。当接收方非常忙碌无法处理新的消息，或者我们需要确保投递的成功率时，这个特性就非常有用了。<br>消息队列就是这样一种在生产者和消费者之间存储消息的中间组件。若消费者因为某种原因崩溃、断开连接等，消息会在队列中累积，待消费者重新上线时立即进行分发。</p><p>另外一种类似的数据结构是 <strong>log</strong>。log 是一种只能追加的结构，它是持久的，其消息可以在到达时被读取，也可以通过访问其历史记录来获取。在消息系统中，也常被叫做 <strong>stream</strong>。<br>不同于队列，在 stream 中，消息被消费后不会被移除，意味着 stream 在消息的获取方面有着更高的自由度。队列通常一次只暴露一条消息给消费者，而一个 stream 能够被多个消费者共享（甚至是同一份消息）。</p><p>消息队列：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-c6b7d3ba279f1e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message queue"></p><p>流：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-dff0875b9635f2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stream"></p><h4 id="点对点-vs-消息中间件"><a href="#点对点-vs-消息中间件" class="headerlink" title="点对点 vs 消息中间件"></a>点对点 vs 消息中间件</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-95cde728d89fdf28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer-to-peer vs broker"></p><h3 id="“发布-订阅”-模式"><a href="#“发布-订阅”-模式" class="headerlink" title="“发布 - 订阅” 模式"></a>“发布 - 订阅” 模式</h3><p>就是一种分布式的观察者模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d7b68c4fed8460c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pub/Sub"></p><h4 id="一个最小化的实时聊天应用"><a href="#一个最小化的实时聊天应用" class="headerlink" title="一个最小化的实时聊天应用"></a>一个最小化的实时聊天应用</h4><p>package.json：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"amqplib"</span>: <span class="string">"^0.10.3"</span>,</span><br><span class="line">        <span class="attr">"ioredis"</span>: <span class="string">"^5.2.4"</span>,</span><br><span class="line">        <span class="attr">"JSONStream"</span>: <span class="string">"^1.3.5"</span>,</span><br><span class="line">        <span class="attr">"level"</span>: <span class="string">"^8.0.0"</span>,</span><br><span class="line">        <span class="attr">"leveldown"</span>: <span class="string">"^6.1.1"</span>,</span><br><span class="line">        <span class="attr">"levelup"</span>: <span class="string">"^5.1.1"</span>,</span><br><span class="line">        <span class="attr">"monotonic-timestamp"</span>: <span class="string">"^0.0.9"</span>,</span><br><span class="line">        <span class="attr">"serve-handler"</span>: <span class="string">"^6.1.5"</span>,</span><br><span class="line">        <span class="attr">"superagent"</span>: <span class="string">"^8.0.6"</span>,</span><br><span class="line">        <span class="attr">"ws"</span>: <span class="string">"^8.11.0"</span>,</span><br><span class="line">        <span class="attr">"yargs"</span>: <span class="string">"^17.6.2"</span>,</span><br><span class="line">        <span class="attr">"zeromq"</span>: <span class="string">"^6.0.0-beta.16"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState == ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><ul><li>首先创建一个 HTTP 服务，将所有请求转发给一个特别的 handler（<code>staticHandler</code>），该 handler 负责 serve 所有的静态文件</li><li>创建一个 WebSocket 服务实例，绑定到 HTTP 服务。同时监听来自 WebSocket 客户端的连接请求，以及客户端发送的消息</li><li>当某个客户端发送的新消息到达时，通过 <code>broadcast()</code> 函数将消息广播给所有的客户端</li></ul><p>www/index.html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Messages:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"msgForm"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Send a message"</span> <span class="attr">id</span>=<span class="string">"msgBox"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Send"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(</span></span><br><span class="line"><span class="javascript">          <span class="string">`ws://<span class="subst">$&#123;<span class="built_in">window</span>.<span class="built_in">document</span>.location.host&#125;</span>`</span></span></span><br><span class="line"><span class="undefined">      )</span></span><br><span class="line"><span class="javascript">      ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> msgDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">          msgDiv.innerHTML = message.data</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementById(<span class="string">'messages'</span>).appendChild(msgDiv)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'msgForm'</span>)</span></span><br><span class="line"><span class="javascript">      form.addEventListener(<span class="string">'submit'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="undefined">          event.preventDefault()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'msgBox'</span>).value</span></span><br><span class="line"><span class="undefined">          ws.send(message)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementById(<span class="string">'msgBox'</span>).value = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过 <code>node index.js 8002</code> 命令运行应用，打开两个浏览器页面访问 Web 服务，测试聊天效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d15f32a8b9cdeca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="simple chat"></p><p>但我们的应用是无法进行横向扩展的。比如再启动一个新的服务实例 <code>node index.js 8003</code>，此时连接到 8002 的客户端无法与连接到 8003 的客户端通信。可以自行测试。</p><h4 id="使用-Redis-作为消息中间件"><a href="#使用-Redis-作为消息中间件" class="headerlink" title="使用 Redis 作为消息中间件"></a>使用 Redis 作为消息中间件</h4><p>架构图如下所示。每个服务实例都会把从客户端收到的消息发布到消息中间件，同时也会通过中间件订阅从其他服务实例发布的消息。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8d3811d91615328c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message broker"></p><ul><li>通过客户端网页发送的消息传递给对应的 chat server</li><li>chat server 把收到的消息发布到 Redis</li><li>Redis 将收到的消息分发给所有的订阅方（chat server）</li><li>chat server 将收到的消息再分发给所有连接的客户端</li></ul><p>index-redis.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisSub = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> redisPub = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        redisPub.publish(<span class="string">'chat_message'</span>, <span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">redisSub.subscribe(<span class="string">'chat_message'</span>)</span><br><span class="line"></span><br><span class="line">redisSub.on(<span class="string">'message'</span>, (channel, msg) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><p>运行 <code>node index-redis.js 8002</code>、<code>node index-redis.js 8003</code> 两条命令启动两个服务实例，此时连接到不同服务器的客户端相互之间也能够进行通信。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-499f672a581f13b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message broker"></p><h4 id="点对点-Pub-Sub-模式"><a href="#点对点-Pub-Sub-模式" class="headerlink" title="点对点 Pub/Sub 模式"></a>点对点 Pub/Sub 模式</h4><p>通过 ZeroMQ 创建两种类型的 socket：<code>PUB</code> 和 <code>SUB</code>。PUB socket 绑定到本地机器的某个端口，负责监听来自其他机器上 SUB socket 的订阅请求。当一条消息通过 PUB socket 发送时，该消息会被广播到所有连接的 SUB socket。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4b4de0d43ad174c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer to peer"></p><p>index-zeromq.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> yargs <span class="keyword">from</span> <span class="string">'yargs'</span></span><br><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pubSocket</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeSockets</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pubSocket = <span class="keyword">new</span> zmq.Publisher()</span><br><span class="line">    <span class="keyword">await</span> pubSocket.bind(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;yargs(process.argv).argv.pub&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subSocket = <span class="keyword">new</span> zmq.Subscriber()</span><br><span class="line">    <span class="keyword">const</span> subPorts = [].concat(yargs(process.argv).argv.sub)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> port <span class="keyword">of</span> subPorts) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Subscribing to <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">        subSocket.connect(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subSocket.subscribe(<span class="string">'chat'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> [msg] <span class="keyword">of</span> subSocket) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message from another server: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(msg.toString().split(<span class="string">' '</span>)[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initializeSockets()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        pubSocket.send(<span class="string">`chat <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(yargs(process.argv).argv.http || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><ul><li>通过 <code>yargs</code> 模块解析命令行参数</li><li>通过 <code>initializeSocket()</code> 函数创建 Publisher，并绑定到由 <code>--pub</code> 命令行参数提供的端口上</li><li>创建 Subscriber socket 并将其连接到其他应用实例的 Publisher socket。被连接的 Publisher 端口由 <code>--sub</code> 命令行参数提供。之后创建以 <code>chat</code> 为过滤器的订阅，即只接收以 <code>chat</code> 开头的消息</li><li>通过 <code>for</code> 循环监听到达 Subscriber 的消息，去除消息中的 <code>chat</code> 前缀，通过 <code>broadcast()</code> 函数将处理后的消息广播给所有连接的客户端</li><li>当有消息到达当前实例的 WebSocket 服务时，广播此消息到所有客户端，同时通过 Publisher 发布该消息</li></ul><p>运行服务测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node index-zeromq.js --http 8002 --pub 5000 --sub 5001 --sub 5002</span><br><span class="line">node index-zeromq.js --http 8003 --pub 5001 --sub 5000 --sub 5002</span><br><span class="line">node index-zeromq.js --http 8004 --pub 5002 --sub 5000 --sub 5001</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-12e13d4709bf8fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer to peer"></p><h4 id="通过队列实现可靠的消息投递"><a href="#通过队列实现可靠的消息投递" class="headerlink" title="通过队列实现可靠的消息投递"></a>通过队列实现可靠的消息投递</h4><p>消息队列是消息系统中的一种重要抽象。借助消息队列，通信中的发送方和接收方不必同时处于活跃的连接状态。队列系统会负责存储未投递的消息，直到目标处于能够接收的状态。</p><p>消息系统的投递机制可以简单概况为以下 3 类：</p><ul><li>最多一次：<em>fire-and-forget</em>。消息不会被持久化，投递状态也不会被确认。意味着在接收者崩溃或者断开连接时，消息有可能丢失</li><li>最少一次：消息会确保至少被收到一次。但是重复收取同一条消息的情况有可能出现，比如接收者在收到消息后突然崩溃，没有来得及告知发送者消息已经收到。</li><li>只有一次：这是最可靠的投递机制，保证消息只会被接收一次。但由于需要更复杂的确认机制，会牺牲一部分消息投递的效率。</li></ul><p>当消息投递机制可以实现“最少一次”或者“只有一次”时，我们就有了 <strong>durable subscriber</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-91ce9034f820ad86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="durable subscriber"></p><h5 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h5><p>AMQP 是一个被很多消息系统支持的开放标准协议。除了定义一个通用的传输协议以外，他还提供了用于描述 routing、filtering、queuing、reliability 和 security 的模型。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-41538e4ba6810317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMQP"></p><ul><li>Queue：用于存储消息的数据结构。假如多个消费者绑定了同一个队列，消息在它们之间是负载均衡的。队列可以是以下任意一种类型：<ul><li>Durable：当中间件重启时队列会自动重建。但这并不意味着其内容也会被保留。实际上只有标记为持久化消息的内容才会被保存到磁盘，并在重启时恢复</li><li>Exclusive：队列只绑定给唯一一个特定的订阅者，当连接关闭时，队列即被销毁</li><li>Auto-delete：当最后一个订阅者断开连接时，队列被删除</li></ul></li><li>Exchange：消息发布的地方。Exchange 会将消息路由至一个或者多个 queue。路由规则取决于具体的实现：<ul><li>Direct exchange：通过完整匹配一个 routing key 来对消息进行路由（如 <code>chat.msg</code>）</li><li>Topic exchange：对 routing key 进行模糊匹配（如 <code>chat.#</code> 匹配所有以 <code>chat</code> 开头的 key）</li><li>Fanout exchange：将消息广播至所有连接的 queue，忽略提供的任何 routing key</li></ul></li><li>Binding：Exchange 和 queue 之间的链接，定义了用于过滤消息的 routing key 或模式</li></ul><p>上述所有组件由中间件进行维护，同时对外暴露用于创建和维护的 API。当连接到某个中间件时，客户端会创建一个 <strong>channel</strong> 对象负责维护通信的状态。</p><h4 id="AMQP-和-RabbitMQ-实现-durable-subscriber"><a href="#AMQP-和-RabbitMQ-实现-durable-subscriber" class="headerlink" title="AMQP 和 RabbitMQ 实现 durable subscriber"></a>AMQP 和 RabbitMQ 实现 durable subscriber</h4><p>chat 应用和消息历史记录服务的架构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9da25ec0835b65cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMQP and history service"></p><h5 id="AMQP-和数据库实现-history-service"><a href="#AMQP-和数据库实现-history-service" class="headerlink" title="AMQP 和数据库实现 history service"></a>AMQP 和数据库实现 history service</h5><p>此模块由两部分组成：一个 HTTP 服务负责将聊天历史记录暴露给客户端；一个 AMQP 消费者负责获取聊天消息并将它们保存在本地数据库中。</p><p>historySvc.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> levelup <span class="keyword">from</span> <span class="string">'levelup'</span></span><br><span class="line"><span class="keyword">import</span> leveldown <span class="keyword">from</span> <span class="string">'leveldown'</span></span><br><span class="line"><span class="keyword">import</span> timestamp <span class="keyword">from</span> <span class="string">'monotonic-timestamp'</span></span><br><span class="line"><span class="keyword">import</span> JSONStream <span class="keyword">from</span> <span class="string">'JSONStream'</span></span><br><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> db = levelup(leveldown(<span class="string">'./msgHistory'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = channel.assertQueue(<span class="string">'chat_history'</span>)</span><br><span class="line">    <span class="keyword">await</span> channel.bindQueue(queue, <span class="string">'chat'</span>)</span><br><span class="line">    channel.consume(queue, <span class="keyword">async</span> msg =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = msg.content.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Saving message: <span class="subst">$&#123;content&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> db.put(timestamp(), content)</span><br><span class="line">        channel.ack(msg)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>)</span><br><span class="line">        db.createValueStream()</span><br><span class="line">            .pipe(JSONStream.stringify())</span><br><span class="line">            .pipe(res)</span><br><span class="line">    &#125;).listen(<span class="number">8090</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><ul><li>创建一个到 AMQP 中间件的连接</li><li>设置一个名为 <code>chat</code> 的 fanout 模式的 exchange。<code>assertExchange()</code> 函数会确保相应的 exchange 存在，否则就创建</li><li>创建一个名为 <code>chat_history</code> 的 queue，绑定给上一步中创建的 exchange</li><li>开始监听来自 queue 的消息，将收到的每一条消息保存至 LevelDB 数据库，以时间戳作为键。消息保存成功后由 <code>channel.ack(msg)</code> 进行确认。若确认动作未被中间件收到，则该条消息会保留在队列中再次被处理</li></ul><p>index-amqp.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> JSONStream <span class="keyword">from</span> <span class="string">'JSONStream'</span></span><br><span class="line"><span class="keyword">import</span> superagent <span class="keyword">from</span> <span class="string">'superagent'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpPort = process.argv[<span class="number">2</span>] || <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(</span><br><span class="line">        <span class="string">`chat_srv_<span class="subst">$&#123;httpPort&#125;</span>`</span>,</span><br><span class="line">        &#123; <span class="attr">exclusive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> channel.bindQueue(queue, <span class="string">'chat'</span>)</span><br><span class="line">    channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">        msg = msg.content.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`From queue: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(msg)</span><br><span class="line">    &#125;, &#123; <span class="attr">noAck</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">    wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line"></span><br><span class="line">        client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">            channel.publish(<span class="string">'chat'</span>, <span class="string">''</span>, Buffer.from(msg))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        superagent</span><br><span class="line">            .get(<span class="string">'http://localhost:8090'</span>)</span><br><span class="line">            .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line">            .pipe(JSONStream.parse(<span class="string">'*'</span>))</span><br><span class="line">            .on(<span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">                client.send(Buffer(msg).toString())</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">                client.send(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.listen(httpPort)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><ul><li>我们的聊天服务没必要是 durable subscriber，<strong>fire-and-forget</strong> 机制就足够了，因而有 <code>{ exclusive: true }</code> 选项</li><li>确认机制也是不需要的。<code>{ noAck: true }</code></li><li>发布消息也很简单，只需要指定目标 exchange（<code>chat</code>）和一个 routing key 即可，这里我们使用的是 fanout exchange，不需要路由，routing key 为空</li><li>发布到 exchange 的消息被转发到所有绑定的 queue，再到达所有订阅了 queue 的服务实例，每个实例再将消息发送到所有连接的客户端</li><li>通过 <code>superagent</code> 请求 history 微服务，将获取到的所有历史消息发送给刚连接的客户端</li></ul><p>运行服务测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node index-amqp.js 8002</span><br><span class="line">node index-amqp.js 8003</span><br><span class="line">node historySvc.js</span><br></pre></td></tr></table></figure></p><h4 id="通过-streams-实现可靠的消息投递"><a href="#通过-streams-实现可靠的消息投递" class="headerlink" title="通过 streams 实现可靠的消息投递"></a>通过 streams 实现可靠的消息投递</h4><p>在系统集成的范畴里，stream（或 log）是一种有序的、只能追加的持久化的数据结构。Stream 概念里的 message 更应该叫做 record，总是被添加到 stream 末尾，且不会在被消费之后自动删除（不同于 queue）。这种特性令 stream 更像是一种数据仓库而不是消息中间件。<br>Stream 的另一个重要特性在于，record 是被消费者从 stream 中“拉取”的，因而消费者可以按照自己的节奏处理 record。<br>Stream 可以用来实现可靠的消息投递，一旦消费者崩溃，它可以在恢复后从中断的地方继续拉取消息。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f9552fc7ba634302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Reliable message delivery with streams"></p><h5 id="Streams-vs-消息队列"><a href="#Streams-vs-消息队列" class="headerlink" title="Streams vs 消息队列"></a>Streams vs 消息队列</h5><p>Stream 明显的应用场景在于处理顺序的流数据，也支持批量处理或者根据之前的消息确定相关性，并可以跨多个节点分发数据。<br>Stream 和消息队列都可以实现 Pub/Sub 模式，但消息队列更适合复杂的系统集成任务，它可以提供更复杂的路由机制，允许我们为不同的消息提供不同的优先级，而 Stream 中 record 的顺序是一定的。</p><h5 id="通过-Redis-Streams-实现-chat-应用"><a href="#通过-Redis-Streams-实现-chat-应用" class="headerlink" title="通过 Redis Streams 实现 chat 应用"></a>通过 Redis Streams 实现 chat 应用</h5><p>index-stream.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> redisClientXRead = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="keyword">async</span> client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        redisClient.xadd(<span class="string">'chat_stream'</span>, <span class="string">'*'</span>, <span class="string">'message'</span>, msg)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> logs = <span class="keyword">await</span> redisClient.xrange(</span><br><span class="line">        <span class="string">'chat_stream'</span>, <span class="string">'-'</span>, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [, [, message]] <span class="keyword">of</span> logs) &#123;</span><br><span class="line">        client.send(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastRecordId = <span class="string">'$'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processStreamMessages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClientXRead.xread(</span><br><span class="line">            <span class="string">'BLOCK'</span>, <span class="string">'0'</span>, <span class="string">'STREAMS'</span>, <span class="string">'chat_stream'</span>, lastRecordId)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, message]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Message from stream: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">            broadcast(message)</span><br><span class="line">            lastRecordId = recordId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processStreamMessages().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><ul><li><code>xadd</code> 负责在收到来自客户端的消息时，向 stream 添加一条新的 record。它接收 3 个参数：<ul><li>Stream 的名字，这里是 <code>chat_stream</code></li><li>record 的 ID。这里传入的是星号（<code>*</code>），令 Redis 为我们生成一个 ID。ID 必须是单调递增的，以保持 record 的顺序，而 Redis 可以替我们处理这些</li><li>key-value 的列表。这里只提供 value <code>msg</code>（从客户端收到的消息）的 ‘message’ key</li></ul></li><li>使用 <code>xrange</code> 检索 stream 的过往记录，以获取聊天历史。我们在每次有客户端连接时就进行一次检索。其中 <code>-</code> 表示最小的 ID 值，<code>+</code> 表示最大的 ID 值，因而整个 <code>xrange</code> 会获取当前 stream 中所有的消息</li><li>最后一部分的逻辑是等待新的记录被添加到 stream 中，从而每个应用实例都能读取到更新的消息。这里使用一个无线循环和 <code>xread</code> 命令：<ul><li>其中 <code>BLOCK</code> 表示在新消息到达前阻塞</li><li><code>0</code> 用来指定超时时间，超过这个时间则直接返回 <code>null</code>。<code>0</code> 代表不超时</li><li><code>STREAMS</code> 是一个关键字，告诉 Redis 我们接下来会指定想要读取的 stream 的细节</li><li><code>chat_stream</code> 是 stream 的名字</li><li>最后我们提供 record ID（<code>lastRecordId</code>）作为读取新消息的节点。初始情况下是 <code>$</code>，表示当前 stream 中最大的 ID。当我们读取第一条消息后，更新 <code>lastRecordId</code> 为最近读取到的消息的 ID</li></ul></li></ul><p>此外，解包消息的代码 <code>for (const [, [, message]] of logs) {...}</code> 实际上等同于 <code>for (const [recordId, [propertyId, message]] of logs) {...}</code>，由 <code>xrange</code> 命令查询到的消息的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1588590110918-0&quot;, [&quot;message&quot;, &quot;This is a message&quot;]],</span><br><span class="line">  [&quot;1588590130852-0&quot;, [&quot;message&quot;, &quot;This is another message&quot;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要有两类技术可以用来整合分布式应用：一类是通过共享存储作为一个中心化的协调者，跟踪和保存所有需要共享的信息；另一类则是通过消息中间件，向系统中的所有节点散布数据、事件和命令等。&lt;br&gt;消息存在于软件系统的各个层级。我们通过互联网交换消息完成通信；通过管道发送消息给其他进程
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Queue" scheme="https://rollingstarky.github.io/tags/Queue/"/>
    
      <category term="Message" scheme="https://rollingstarky.github.io/tags/Message/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Observer" scheme="https://rollingstarky.github.io/tags/Observer/"/>
    
      <category term="Broker" scheme="https://rollingstarky.github.io/tags/Broker/"/>
    
      <category term="Pub/Sub" scheme="https://rollingstarky.github.io/tags/Pub-Sub/"/>
    
      <category term="AMQP" scheme="https://rollingstarky.github.io/tags/AMQP/"/>
    
      <category term="Redis" scheme="https://rollingstarky.github.io/tags/Redis/"/>
    
      <category term="RabbitMQ" scheme="https://rollingstarky.github.io/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 组合类型</title>
    <link href="https://rollingstarky.github.io/2022/12/15/programming-with-types-compound-types/"/>
    <id>https://rollingstarky.github.io/2022/12/15/programming-with-types-compound-types/</id>
    <published>2022-12-14T16:00:00.000Z</published>
    <updated>2022-12-15T12:41:26.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>最直观的创造新的复合类型的方式，就是直接将多个类型组合在一起。比如平面上的点都有 X 和 Y 两个坐标，各自都属于 number 类型。因此可以说，平面上的点是由两个 number 类型组合成的新类型。<br>通常来说，将多个类型直接组合在一起形成新的类型，这样的类型最终的取值范围，就是全部成员类型所有可能的组合值的集合。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5679c2f114176904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Compound Types"></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>假如我们需要一个函数来计算两个点之间的距离，可以这样实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1: <span class="built_in">number</span>, y1: <span class="built_in">number</span>, x2: <span class="built_in">number</span>, y2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt((x1 - x1) ** <span class="number">2</span> + (y1 - y2) ** <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述实现能够正常工作，但并不算完美。<code>x1</code> 在没有对应的 Y 坐标一起出现的情况下，是没有任何实际含义的。同时在应用的其他地方，我们很可能也会遇到很多针对坐标点的其他操作，因此相对于将 X 坐标和 Y 坐标独立地进行表示和传递，我们可以将两者组合在一起，成为一个新的元组类型。<br>元组能够帮助我们将单独的 X 和 Y 坐标组合在一起作为“点”对待，从而令代码更方便阅读和书写。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1[<span class="number">0</span>] - point2[<span class="number">0</span>]) ** <span class="number">2</span> + (point1[<span class="number">1</span>] - point2[<span class="number">1</span>]) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="DIY-元组"><a href="#DIY-元组" class="headerlink" title="DIY 元组"></a>DIY 元组</h5><p>大部分语言都提供了元组作为内置语法，这里假设在标准库里没有元组的情况下，如何自己实现包含两个元素的元组类型：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pair&lt;T1, T2&gt; &#123;</span><br><span class="line">    m0: T1;</span><br><span class="line">    m1: T2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">m0: T1, m1: T2</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m0 = m0;</span><br><span class="line">        <span class="keyword">this</span>.m1 = m1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point = Pair&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1.m0 - point2.m0) ** <span class="number">2</span> + (point1.m1 - point2.m1) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Record-类型"><a href="#Record-类型" class="headerlink" title="Record 类型"></a>Record 类型</h4><p>将坐标点定义为数字对，是可以正常工作的。但是我们也因此失去了在代码中包含更多含义的机会。在前面的例子中，我们假定第一个数字是 X 坐标，第二个数字是 Y 坐标。但最好是借助类型系统，在代码中编入更精确的含义。从而彻底消除将 X 错认为是 Y 或者将 Y 错认为是 X 的机会。<br>可以借助 Record 类型来实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1.x - point2.x) ** <span class="number">2</span> + (point1.y - point2.y) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>首要的原则是，最好优先使用含义清晰的 Record 类型，它包含的元素是有明确的命名的。而不是直接将元组传来传去</strong>。元组并不会为自己的元素提供名称，只是靠数字索引访问，因而会存在很大的误解的可能性。当然另一方面，元组是内置的，而 Record 类型通常需要额外进行定义。但大多数情况下，这样的额外工作是值得的。</p><h4 id="维持不可变性"><a href="#维持不可变性" class="headerlink" title="维持不可变性"></a>维持不可变性</h4><p>类的成员函数和成员变量可以被定义为 <code>public</code>（能够被公开访问），也可以被定义为 <code>private</code>（只允许内部访问）。在 TypeScript 中，成员默认都是公开的。<br>通常情况下我们定义 Record 类型，如果其成员变量是独立的，比如之前的 Point，X 坐标和 Y 坐标都可以独立的进行修改，不会影响到对方。且它们的值可以在不引起问题的情况下变化。像这样的成员被定义成公开的一般不会出现问题。<br>但是也存在另外一些情况。比如下面这个由 <code>dollar</code> 值和 <code>cents</code> 值组成的 Currency 类型：</p><ul><li>dollar 值必须是一个大于或者等于 0 的整数</li><li>cent 值也必须是一个大于或者等于 0 的整数</li><li>cent 值不能大于 99，每 100 cents 都必须转换成 1 dollar</li></ul><p>如果我们允许 <code>dollars</code> 和 <code>cents</code> 变量被公开访问，就有可能导致出现不规范的对象：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    dollars: <span class="built_in">number</span>;</span><br><span class="line">    cents: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        dollars = dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>);</span><br><span class="line">        cents = cents % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">        <span class="keyword">this</span>.cents = cents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> amount: Currency = <span class="keyword">new</span> Currency(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">amount.cents = <span class="number">300</span>;  <span class="comment">// 由于属性是公开的，外部代码可以直接修改。从而产生非法对象</span></span><br></pre></td></tr></table></figure></p><p>上述情况可以通过将成员变量定义为 <code>private</code> 来避免。同时为了维护方便，一般还需要提供公开的方法对私有的属性进行修改。这些方法通常会包含一定的验证规则，确保修改后的对象状态是合法的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    <span class="keyword">private</span> dollars: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> cents: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.assignDollars(dollars);</span><br><span class="line">        <span class="keyword">this</span>.assignCents(cents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDollars(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dollars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assignDollars(dollars: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getCents(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assignCents(cents: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.assignDollars(<span class="keyword">this</span>.dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">this</span>.cents = cents % <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部代码只能通过 <code>assignDollars()</code> 和 <code>assignCents()</code> 两个公开的方法，对私有的属性 <code>dollars</code> 和 <code>cents</code> 进行修改。同时这两个方法也会确保对象的状态一直符合我们定义的规则。</p><p>另外一种观点是，可以将属性定义成<strong>不可变</strong>（只读）的。这样属性就可以直接被外部访问，因为只读属性会阻止自身被修改。从而对象状态保持合法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    readonly dollars: <span class="built_in">number</span>;</span><br><span class="line">    readonly cents: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        dollars = dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>);</span><br><span class="line">        cents = cents % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">        <span class="keyword">this</span>.cents = cents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不可变对象还有一个优势，从不同的线程对这类数据并发地访问是保证安全的。可变性会导致数据竞争。<br>但其劣势在于，每次我们需要一个新的值，就必须创建一个新的实例，无法通过修改现有对象得到。而创建新对象有时候是很昂贵的操作。</p><p>最终的目的在于，阻止外部代码直接修改属性，以至于跳过验证规则。可以将属性变为私有，对属性的访问完全通过包含验证规则的公开方法；也可以将属性声明为不可变的，在构造对象时执行验证。</p><h3 id="either-or-类型"><a href="#either-or-类型" class="headerlink" title="either-or 类型"></a>either-or 类型</h3><p><strong>either-or</strong> 是另外一种基础的将类型组合在一起的方式，即某个值有可能是多个类型所有合法取值中的任何一个。比如 Rust 语言中的 <code>Result&lt;T, E&gt;</code>，可能是成功的值 <code>Ok(T)</code>，也可能是失败值 <code>Err(E)</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-ea3eccddddacfc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="either-or"></p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>先从一个简单的例子开始，通过类型系统编码周一到周日。我们可以用 0-6 的数字来表示一周的七天，0 表示一周里的第一天。但这样表示并不理想，因为不同的工程师可能对这些数字有不同的理解。有些国家第一天是周日，有些国家第一天是周一。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == <span class="number">5</span> || dayOfWeek == <span class="number">6</span>;</span><br><span class="line">&#125;  <span class="comment">// 欧洲国家判断是否是周末</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= <span class="number">1</span> &amp;&amp; dayOfWeek &lt;= <span class="number">5</span>;</span><br><span class="line">&#125;  <span class="comment">// 美国判断是否是工作日</span></span><br></pre></td></tr></table></figure></p><p>上述两个函数是冲突的。若 0 表示周日，则 <code>isWeekend()</code> 是不正确的；若 0 表示周一，则 <code>isWeekday()</code> 是不正确的。</p><p>其他的方案是定义一系列常量用来表示一周七天。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sunday: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> Monday: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> Tuesday: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> Wednesday: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> Thursday: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> Friday: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> Saturday: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == Saturday || dayOfWeek == Sunday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= Monday &amp;&amp; dayOfWeek &lt;= Friday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的实现看上去好了一些，但仍有问题。单看函数的签名，无法清楚的知道 <code>number</code> 类型的参数的期待值具体是什么。假如一个新接手代码的人刚看到 <code>dayOfWeek: number</code>，他可能不会意识到存在 <code>Sunday</code> 这类常量在某个模块的某处。因而他们会倾向于自己解释此处的数字。甚至一些人会传入非法的数字参数比如 <code>-1</code> 或 <code>10</code>。</p><p>更好的方案是借助枚举类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DayOfWeek &#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: DayOfWeek</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == DayOfWeek.Saturday</span><br><span class="line">        || dayOfWeek == DayOfWeek.Sunday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: DayOfWeek</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= DayOfWeek.Monday</span><br><span class="line">        &amp;&amp; dayOfWeek &lt;= DayOfWeek.Friday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Optional-类型"><a href="#Optional-类型" class="headerlink" title="Optional 类型"></a>Optional 类型</h4><p>假设我们需要将一个用户输入的 <code>string</code> 值转换为 <code>DayOfWeek</code>，若该 <code>string</code> 值是合法的，则返回对应的 <code>DayOfWeek</code>；若该 <code>string</code> 值非法，则显式地返回 <code>undefined</code>。<br>在 TypeScript 中，可以通过 <code>|</code> 类型操作符来实现，<code>|</code> 允许我们组合多个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">DayOfWeek</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>: <span class="keyword">return</span> DayOfWeek.Sunday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>: <span class="keyword">return</span> DayOfWeek.Monday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>: <span class="keyword">return</span> DayOfWeek.Tuesday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Wednesday"</span>: <span class="keyword">return</span> DayOfWeek.Wednesday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>: <span class="keyword">return</span> DayOfWeek.Thursday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>: <span class="keyword">return</span> DayOfWeek.Friday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>: <span class="keyword">return</span> DayOfWeek.Saturday;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInput</span>(<span class="params">input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: DayOfWeek | <span class="literal">undefined</span> = parseDayOfWeek(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Failed to parse "<span class="subst">$&#123;input&#125;</span>"`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dayOfWeek: DayOfWeek = result;</span><br><span class="line">        <span class="comment">/* Use dayOfWeek */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <code>parseDayOfWeek()</code> 函数返回一个 <code>DayOfWeek</code> 或者 <code>undefined</code>。<code>useInput()</code> 函数在调用 <code>parseDayOfWeek()</code> 后再对返回值进行解包操作，输出错误信息或者得到合法值。</p><blockquote><p><strong>Optional 类型</strong>：也常被叫做 <strong>Maybe</strong> 类型，表示一个可能存在的 T 类型值。一个 Optional 类型的实例，可能会包含一个 T 类型的任意值；也可能是一个特殊值，用来表示 T 类型的值不存在。</p></blockquote><h5 id="DIY-Optional"><a href="#DIY-Optional" class="headerlink" title="DIY Optional"></a>DIY Optional</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Optional&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> value: T | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">private</span> assigned: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value?: T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasValue(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.assigned) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;T&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Optional 类型的优势在于，直接使用 <code>null</code> 空类型非常容易出错。因为判断一个变量什么时候能够为空或者不能为空是非常困难的，我们必须在所有代码中添加非空检查，否则就会有引用指向空值的风险，进一步导致运行时错误。<br>Optional 背后的逻辑在于，将 <code>null</code> 值从合法的取值范围中解耦出来。Optional 明确了哪些变量有可能为空值。类型系统知晓 Optional 类型（比如 <code>DayOfWeek | undefined</code>，可能为空）和对应的非空类型（<code>DayOfWeek</code>）是不一样的。两者是不兼容的类型，因而我们不会将 Optional 类型及其非空类型相混淆，在需要非空类型的地方错误地使用有可能为空值的 Optional。一旦需要取出 Optional 中包含的值，就必须显式地进行解包操作，对空值进行检查。</p><h4 id="Result-or-error"><a href="#Result-or-error" class="headerlink" title="Result or error"></a>Result or error</h4><p>现在尝试扩展前面的 <code>DayOfWeek</code> 例子。当 <code>DayOfWeek</code> 值无法正常识别时，我们不是简单地返回 <code>undefined</code>，而是输出包含更多内容的错误信息。<br>常见的一个反模式就是同时返回 <code>DayOfWeek</code> 和错误码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> InputError &#123;</span><br><span class="line">    OK,</span><br><span class="line">    NoInput,</span><br><span class="line">    Invalid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Result &#123;</span><br><span class="line">    error: InputError;</span><br><span class="line">    value: DayOfWeek;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">error: InputError, value: DayOfWeek</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.NoInput, DayOfWeek.Sunday);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Sunday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Monday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Tuesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"wednesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Wednesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Thursday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Friday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Saturday);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.Invalid, DayOfWeek.Sunday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现并不是理想的，原因在于，一旦我们忘记了检查错误代码，没有任何机制阻止我们继续使用 <code>DayOfWeek</code> 值。即便错误代码表明有问题出现，我们仍然可以忽视该错误并直接取用 <code>DayOfWeek</code>。<br>将类型看作值的集合，则上述 <code>Result</code> 类型实际上是 <code>InputError</code> 和 <code>DayOfWeek</code> 所有可能值的组合。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8c4f310c4de150d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Result Type"></p><p>我们应该实现一种 <strong>either-or</strong> 类型，返回值<strong>要么</strong>是错误类型，<strong>要么</strong>是合法的值。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-987b07939b567994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Either-or Result Type"></p><h5 id="DIY-Either"><a href="#DIY-Either" class="headerlink" title="DIY Either"></a>DIY Either</h5><p><code>Either</code> 类型包含了 <code>TLeft</code> 和 <code>TRight</code> 另外两种类型。<code>TLeft</code> 用来存储错误类型，<code>TRight</code> 保存合法的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Either&lt;TLeft, TRight&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> readonly value: TLeft | TRight;</span><br><span class="line">    <span class="keyword">private</span> readonly left: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">value: TLeft | TRight, left: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isLeft(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getLeft(): TLeft &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isLeft()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TLeft&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isRight(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRight(): TRight &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isRight()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TRight&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeLeft&lt;TLeft, TRight&gt;(value: TLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeRight&lt;TLeft, TRight&gt;(value: TRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助上面的 <code>Either</code> 实现，我们可以将 <code>parseDayOfWeek()</code> 更新为返回 <code>Either&lt;InputError, DayOfWeek&gt;</code>。若函数返回 <code>InputError</code>，则结果中就不会包含 <code>DayOfWeek</code>；若函数返回 <code>DayOfWeek</code>，就可以肯定没有错误发生。<br>当然，我们需要显式地将结果（或 Error）从 <code>Either</code> 中解包出来。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> InputError &#123;</span><br><span class="line">    NoInput,</span><br><span class="line">    Invalid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result = Either&lt;InputError, DayOfWeek&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> Either.makeLeft(InputError.NoInput)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Sunday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Monday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Tuesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"wednesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Wednesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Thursday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Friday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Saturday);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeLeft(InputError.Invalid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当错误本身并不是“异常的”（大部分情况下，处理用户输入的时候），或者调用某个会返回错误码的系统 API，我们并不想直接抛出异常，但仍旧需要传递正确值或者错误码这类信息。这些时候，最好将这类信息编码到 <em>either value or error</em> 中。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复合类型&quot;&gt;&lt;a href=&quot;#复合类型&quot; class=&quot;headerlink&quot; title=&quot;复合类型&quot;&gt;&lt;/a&gt;复合类型&lt;/h3&gt;&lt;p&gt;最直观的创造新的复合类型的方式，就是直接将多个类型组合在一起。比如平面上的点都有 X 和 Y 两个坐标，各自都属于 numb
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Tuple" scheme="https://rollingstarky.github.io/tags/Tuple/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Optional" scheme="https://rollingstarky.github.io/tags/Optional/"/>
    
      <category term="Either" scheme="https://rollingstarky.github.io/tags/Either/"/>
    
      <category term="Enum" scheme="https://rollingstarky.github.io/tags/Enum/"/>
    
      <category term="Immutable" scheme="https://rollingstarky.github.io/tags/Immutable/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 高阶类型（Functor、Monad）</title>
    <link href="https://rollingstarky.github.io/2022/11/29/programming-with-types-higher-kinded-types-functor-monad/"/>
    <id>https://rollingstarky.github.io/2022/11/29/programming-with-types-higher-kinded-types-functor-monad/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:40:07.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通用的-map-实现"><a href="#通用的-map-实现" class="headerlink" title="通用的 map 实现"></a>通用的 map 实现</h4><p><strong>map</strong> 是函数式编程中非常常见的一类接口，可以将某个函数操作应用到一系列元素上。一个通用的 <code>map()</code> 实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* map&lt;T, U&gt;(iter: Iterable&lt;T&gt;, func: (item: T) =&gt; U):</span><br><span class="line">    IterableIterator&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value of iter) &#123;</span><br><span class="line">        <span class="keyword">yield</span> func(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6875152-671697213fda1f26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Map over Iterable"></p><p>上述实现主要针对可迭代对象，可以将函数 <code>func</code>（类型为 <code>(item: T) =&gt; U</code>）应用给可迭代对象 <code>iter</code> 中的每一个元素。<br>为了使 <code>map()</code> 函数的场景更为通用，<code>func</code> 的参数 <code>item: T</code> 理应能够接收更多类型的值，比如 <code>Option&lt;T&gt;</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Optional&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> value: T | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">private</span> assigned: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value?: T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasValue(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.assigned) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;T&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从逻辑上看，将一个类型为 <code>(value: T) =&gt; U</code> 的函数 map 到 <code>Optional&lt;T&gt;</code> 类型，如果该 <code>Optional&lt;T&gt;</code> 里面包含一个类型为 <code>T</code> 的值，则返回值应该是包含 <code>U</code> 的 <code>Optional&lt;U&gt;</code> 类型；若 <code>Optional&lt;T&gt;</code> 并不包含任何值，则 map 操作应该返回一个空的 <code>Optional&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8fd119a44a530d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapping a function over an optional value"></p><p>下面是支持 Optional 类型的 map 实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Optional &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        optional: Optional&lt;T&gt;, func: (value: T) =&gt; U): Optional&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (optional.hasValue()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;U&gt;(func(optional.getValue()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;U&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种简单的通用类型 <code>Box&lt;T&gt;</code> 及其 map 实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">    value: T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Box &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; U): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Box&lt;U&gt;(func(box.value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将类型为 <code>(value: T) =&gt; U</code> 的函数 map 到 <code>Box&lt;T&gt;</code>，返回一个 <code>Box&lt;U&gt;</code>。<code>Box&lt;T&gt;</code> 中 <code>T</code> 类型的值会被取出来，传递给被 map 的函数，再将结果放入 <code>Box&lt;U&gt;</code> 中返回。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-266798b640197653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapping a function over a value in a Box"></p><h4 id="处理结果-or-传递错误"><a href="#处理结果-or-传递错误" class="headerlink" title="处理结果 or 传递错误"></a>处理结果 or 传递错误</h4><p>假设我们需要实现一个 <code>square()</code> 函数来计算某个数字的平方，以及一个 <code>stringify</code> 函数将数字转换为字符串。示例如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个 <code>readNumber()</code> 函数负责从文件中读取数字。当我们需要处理输入数据时，有可能会遇到某些问题，比如文件不存在或者无法打开等。在上述情况下，<code>readNumber()</code> 函数会返回 <code>undefined</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readNumber</span>(<span class="params"></span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation omitted */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想通过 <code>readNumber()</code> 读取一个数字，再将其传递给 <code>square()</code> 处理，就必须确保 <code>readNumber()</code> 返回的值是一个实际的数字，而不是 <code>undefined</code>。一种可行的方案就是借助 <code>if</code> 语句将 <code>number | undefined</code> 转换为 <code>number</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">number</span> | <span class="literal">undefined</span> = readNumber();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> stringify(square(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>square()</code> 接收数字类型的参数，因而当输入有可能是 <code>undefined</code> 时，我们需要显式地处理这类情况。但通常意义上讲，代码的分支越少，其复杂性就越低，就更易于理解和维护。<br>另一种实现 <code>process()</code> 的方式就是，并不对 <code>undefined</code> 做任何处理，只是将其简单地传递下去。即只让 <code>process()</code> 负责数字的处理工作，error 则交给后续的其他人。</p><p>可以借助 为 sum type 实现的 <code>map()</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SumType &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        value: T | undefined, func: (value: T) =&gt; U): U | undefined &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> func(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">number</span> | <span class="literal">undefined</span> = readNumber();</span><br><span class="line">    <span class="keyword">let</span> squaredValue: <span class="built_in">number</span> | <span class="literal">undefined</span> = SumType.map(value, square)</span><br><span class="line">    <span class="keyword">return</span> SumType.map(squaredValue, stringify);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 <code>process()</code> 实现不再包含分支逻辑。将 <code>number | undefined</code> 解包为 <code>number</code> 并对 <code>underfined</code> 进行检查的操作由 <code>map()</code> 负责。</p><p>同时 <code>map()</code> 是通用的函数，可以直接在其他 process 函数中对更多不同类型的数据使用（如 <code>string | undefined</code>），减少重复代码。</p><p>版本一（不借助 <code>map</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareSumType</span>(<span class="params">value: <span class="built_in">number</span> | <span class="literal">undefined</span></span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> square(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareBox</span>(<span class="params">box: Box&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">Box</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(square(box.value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringifySumType</span>(<span class="params">value: <span class="built_in">number</span> | <span class="literal">undefined</span></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> stringify(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringifyBox</span>(<span class="params">box: Box&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">Box</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(stringify(box.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>版本二（借助 <code>map</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y: Box&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> Box(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.log(SumType.map(x, stringify))</span><br><span class="line"><span class="built_in">console</span>.log(Box.map(y, stringify))</span><br><span class="line"><span class="built_in">console</span>.log(SumType.map(x, square))</span><br><span class="line"><span class="built_in">console</span>.log(Box.map(y, square))</span><br></pre></td></tr></table></figure></p><h4 id="Functor-定义"><a href="#Functor-定义" class="headerlink" title="Functor 定义"></a>Functor 定义</h4><p><strong>Functor</strong>：对于任意的泛型，比如 <code>Box&lt;T&gt;</code>，能够通过 <code>map()</code> 操作将函数 <code>(value: T) =&gt; U</code> 应用给 <code>Box&lt;T&gt;</code>，并返回一个 <code>Box&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-26bc7d77056c267f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor"></p><p>又或者说，Functor 是支持某种 <code>map()</code> 函数的任意类型 <code>H&lt;T&gt;</code>。该 <code>map()</code> 函数接收 <code>H&lt;T&gt;</code> 作为参数，一个从 <code>T</code> 到 <code>U</code> 的函数作为另一个参数，最终返回 <code>H&lt;U&gt;</code>。<br>以更面向对象一点的形式来表现的话，参考如下代码（当然这段代码是编译不通过的，因为 TypeScript 不支持高阶类型，如 <code>&lt;H&lt;T&gt;&gt;</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Functor&lt;H&lt;T&gt;&gt; &#123;</span><br><span class="line">    map&lt;U&gt;<span class="function">(<span class="params">func: (<span class="params">value: T</span>) =&gt; U</span>): <span class="params">H</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">Box</span>&lt;<span class="params">T</span>&gt; <span class="params">implements</span> <span class="params">Functor</span>&lt;<span class="params">Box</span>&lt;<span class="params">T</span>&gt;&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">value</span>: <span class="params">T</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">constructor</span>(<span class="params">value: T</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">this</span>.<span class="params">value</span> = <span class="params">value</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">map</span>&lt;<span class="params">U</span>&gt;(<span class="params">func: (<span class="params">value: T</span>) =&gt; U</span>): <span class="params">Box</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">new</span> <span class="params">Box</span>(<span class="params">func(<span class="params"><span class="keyword">this</span>.value</span>)</span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="Functors-for-functions"><a href="#Functors-for-functions" class="headerlink" title="Functors for functions"></a>Functors for functions</h4><p>实际上还存在针对函数的 Functor。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-893278c77eac1c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor for function"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        f: (arg1: T, arg2: T) =&gt; T, func: (value: T) =&gt; U)</span><br><span class="line">        : <span class="function">(<span class="params">arg1: T, arg2: T</span>) =&gt;</span> U &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">arg1: T, arg2: T</span>) =&gt;</span> func(f(arg1, arg2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result: <span class="built_in">string</span> = <span class="built_in">Function</span>.map(add, stringify)(<span class="number">40</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h4 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h4><p>在前面的例子中，只有第一个函数 <code>readNumber()</code> 有可能返回错误（<code>undefined</code>）。借助 Functor，<code>square()</code> 和 <code>stringify()</code> 可以不经修改地正常调用，若 <code>readNumber()</code> 返回 <code>undefined</code>，该 <code>undefined</code> 不会被处理，只是简单地传递下去。<br>但是假如链条中的每一个函数都有可能返回错误，又该如何处理呢？</p><p>假设我们需要打开某个文件，读取其内容，再将读取到的字符串反序列化为一个 <code>Cat</code> 对象。<br>负责打开文件的 <code>openFile()</code> 函数可能返回一个 <code>Error</code> 或者 <code>FileHandle</code>。比如当文件不存在、文件被其他进程锁定或者用户没有权限读取文件，都会导致返回 <code>Error</code>。<br>还需要一个 <code>readFile()</code> 函数，接收 <code>FileHandle</code> 作为参数，返回一个 <code>Error</code> 或者 <code>String</code>。比如有可能内存不足导致文件无法被读取，返回 <code>Error</code>。<br>最后还需要一个 <code>deserializeCat()</code> 函数接收 <code>string</code> 作为参数，返回一个 <code>Error</code> 或者 <code>Cat</code> 对象。同样的道理，string 有可能格式不符合要求，无法被反序列化为 <code>Cat</code> 对象，返回 <code>Error</code>。</p><p>所有上述函数都遵循一种“返回一个正常结果或者一个错误对象”的模式，其返回值类型为 <code>Either&lt;Error, ...&gt;</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">openFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">FileHandle</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">handle: FileHandle</span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">string</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">deserializeCat</span>(<span class="params">serializedCat: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt;</span>;</span><br></pre></td></tr></table></figure></p><p>只是为了方便举例，上述函数并不包含具体的实现代码。同时 <code>Either</code> 类型的实现如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Either&lt;TLeft, TRight&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> readonly value: TLeft | TRight;</span><br><span class="line">    <span class="keyword">private</span> readonly left: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">value: TLeft | TRight, left: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isLeft(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getLeft(): TLeft &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isLeft()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TLeft&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isRight(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRight(): TRight &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isRight()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TRight&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeLeft&lt;TLeft, TRight&gt;(value: TLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeRight&lt;TLeft, TRight&gt;(value: TRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终将上述各个函数连接起来的 process 函数类似下面这样：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCatFromFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line">    <span class="keyword">if</span> (handle.isLeft()) <span class="keyword">return</span> Either.makeLeft(handle.getLeft());</span><br><span class="line">    <span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = readFile(handle.getRight());</span><br><span class="line">    <span class="keyword">if</span> (content.isLeft()) <span class="keyword">return</span> Either.makeLeft(content.getLeft());</span><br><span class="line">    <span class="keyword">return</span> deserializeCat(content.getRight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像在上一个例子中对 <code>process</code> 函数做的那样，我们可以实现一个类似的 <code>map()</code> 函数，将 <code>readCatFromFile()</code> 中的所有分支结构和错误检查都转移到通用的 <code>map()</code> 中。<br>按照普遍的约定，<code>Either&lt;TLeft, TRight&gt;</code> 中的 <code>TLeft</code> 包含错误对象，<code>map()</code> 只会将其不做改动地传递下去。只有当 <code>TRight</code> 存在时，<code>map()</code> 才会对 <code>Either</code> 应用给定的函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Either &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">TLeft</span>, <span class="title">TRight</span>, <span class="title">URight</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        value: Either&lt;TLeft, TRight&gt;,</span></span></span><br><span class="line">        func: (value: TRight) =&gt; URight): Either&lt;TLeft, URight&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isLeft()) <span class="keyword">return</span> Either.makeLeft(value.getLeft());</span><br><span class="line">        <span class="keyword">return</span> Either.makeRight(func(value.getRight()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述 <code>map()</code> 实现的问题在于，当我们调用 <code>openFile()</code> 得到返回值 <code>Either&lt;Error, FileHandle&gt;</code>，接下来就需要一个类型为 <code>(value: FileHandle) =&gt; string</code> 的函数从 <code>FileHandle</code> 读取文件内容。<br>但是实际上的 <code>readFile()</code> 函数的返回类型不是 <code>string</code>，而是 <code>Either&lt;Error, string&gt;</code>。</p><p>当我们调用<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line"><span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = Either.map(handle, readFile);</span><br></pre></td></tr></table></figure></p><p>会导致爆出 <code>Type &#39;Either&lt;Error, Either&lt;Error, string&gt;&gt;&#39; is not assignable to type &#39;Either&lt;Error, string&gt;&#39;.</code> 错误。</p><p>正确的实现应该是如下形式的 <code>bind()</code> 方法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Either &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>&lt;<span class="title">TLeft</span>, <span class="title">TRight</span>, <span class="title">URight</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        value: Either&lt;TLeft, TRight&gt;,</span></span></span><br><span class="line">        func: (value: TRight) =&gt; Either&lt;TLeft, URight&gt;</span><br><span class="line">    ): Either&lt;TLeft, URight&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isLeft()) <span class="keyword">return</span> Either.makeLeft(value.getLeft());</span><br><span class="line">        <span class="keyword">return</span> func(value.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借助 <code>bind()</code> 实现的 <code>readCatFromFile()</code> 函数：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCatFromFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line">    <span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = Either.bind(handle, readFile);</span><br><span class="line">    <span class="keyword">return</span> Either.bind(content, deserializeCat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Functor-vs-Monad"><a href="#Functor-vs-Monad" class="headerlink" title="Functor vs Monad"></a>Functor vs Monad</h4><p>对于 <code>Box&lt;T&gt;</code>，Functor（<code>map()</code>）会接收一个 <code>Box&lt;T&gt;</code> 值和一个从 <code>T</code> 到 <code>U</code> 的函数（<code>(value: T) =&gt; U</code>）作为参数，将 <code>T</code> 值取出并应用给传入的函数，最终返回 <code>Box&lt;U&gt;</code>。<br>Monad（<code>bind()</code>）接收一个 <code>Box&lt;T&gt;</code> 值和一个从 <code>T</code> 到 <code>Box&lt;U&gt;</code> 的函数（<code>(value: T) =&gt; Box&lt;U&gt;</code>）作为参数，将 <code>T</code> 值取出并应用给传入的函数，最终返回 <code>Box&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6184c38e9b9f1c45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor vs Monad"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">    value: T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Box &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; U): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Box&lt;U&gt;(func(box.value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; Box&lt;U&gt;): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> func(box.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s: Box&lt;<span class="built_in">string</span>&gt; = Box.map(<span class="keyword">new</span> Box(<span class="number">42</span>), stringify);</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"><span class="comment">// =&gt; Box &#123; value: '42' &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boxify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">Box</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(value.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b: Box&lt;<span class="built_in">string</span>&gt; = Box.bind(<span class="keyword">new</span> Box(<span class="number">42</span>), boxify);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// =&gt; Box &#123; value: '42' &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Monad-定义"><a href="#Monad-定义" class="headerlink" title="Monad 定义"></a>Monad 定义</h4><p>Monad 表示对于泛型 <code>H&lt;T&gt;</code>，我们有一个 <code>unit()</code> 函数能够接收 <code>T</code> 作为参数，返回类型为 <code>H&lt;T&gt;</code> 的值；同时还有一个 <code>bind()</code> 函数接收 <code>H&lt;T&gt;</code> 和一个从 <code>T</code> 到 <code>H&lt;U&gt;</code> 的函数作为参数，返回 <code>H&lt;U&gt;</code>。<br>现实中能够将 Promise 串联起来的 <code>then()</code> 方法实际上就等同于 <code>bind()</code>，能够从值创建 Promise 的 <code>resolve()</code> 方法等同于 <code>unit()</code>。</p><p>借助 Monad，函数调用序列可以表示为一条抽离了数据管理、控制流程或副作用的管道。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通用的-map-实现&quot;&gt;&lt;a href=&quot;#通用的-map-实现&quot; class=&quot;headerlink&quot; title=&quot;通用的 map 实现&quot;&gt;&lt;/a&gt;通用的 map 实现&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt; 是函数式编程中非常常见的一类接口，
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Map" scheme="https://rollingstarky.github.io/tags/Map/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Functor" scheme="https://rollingstarky.github.io/tags/Functor/"/>
    
      <category term="Monad" scheme="https://rollingstarky.github.io/tags/Monad/"/>
    
      <category term="generic" scheme="https://rollingstarky.github.io/tags/generic/"/>
    
      <category term="Optional" scheme="https://rollingstarky.github.io/tags/Optional/"/>
    
      <category term="Either" scheme="https://rollingstarky.github.io/tags/Either/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 类型及类型系统</title>
    <link href="https://rollingstarky.github.io/2022/11/29/programming-with-types-type-and-type-system/"/>
    <id>https://rollingstarky.github.io/2022/11/29/programming-with-types-type-and-type-system/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:33:14.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要有类型"><a href="#为什么要有类型" class="headerlink" title="为什么要有类型"></a>为什么要有类型</h4><p>从硬件和机器码这类底层视角来看，程序逻辑（代码）和代码操作的数据都是通过比特（bits）来表示，没有任何区别。<br>当系统没办法正确地将这两者区分开来，错误就很容易发生。这类松散解析的一个例子就是 JavaScript 中的 <code>eval()</code> 函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"40+2"</span>));</span><br><span class="line"># =&gt; 42</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"Hello world!"</span>));</span><br><span class="line"># =&gt; Uncaught SyntaxError: Unexpected identifier</span><br></pre></td></tr></table></figure></p><p>除了正确区分代码和数据以外，我们还需要知道如何将一串字节序列中的数据解释出来。<br>比如一个 16 位的字节序列 <code>1100001010100011</code> 既可以表示无符号 16 位整数 <code>49827</code>，又可以表示有符号 16 位整数 <code>-15709</code>，还可以表示 UTF-8 编码的字符 <code>£</code>，或者其他完全不同的数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d97ac5ac41b6a960.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sequence of bits can be interpreted in multiple ways"></p><p>类型赋予数据现实的意义。从而我们的软件能够在特定的上下文中，从一串给定的字节序列中解析出正确的值，不会将其误解成其他的含义。<br>此外，类型还能够限定变量的取值范围。比如一个有符号的 16 位整数，只能是  <code>-32768</code> 到 <code>32767</code> 之间的任意整数，不能超过这个范围。<strong>类型可以看作是由合法的值构成的集合</strong>。<br>这种对于取值的限制，很大程度上可以帮助我们减少代码中的错误。</p><h5 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h5><p><strong>类型</strong>是一种对数据的分类，它定义了某类数据上能够执行的操作，允许的取值以及数据本身的意义。编译器或者运行时能够对类型进行检测，确保数据的完整性、访问控制，以及本身的含义没有被曲解。</p><h4 id="类型系统的作用"><a href="#类型系统的作用" class="headerlink" title="类型系统的作用"></a>类型系统的作用</h4><p>从根本上说，所有的数据都是一堆零和一组成的字节序列。数据本身的属性，比如怎样表示、是否可变、是否对于外部可见等，都是类型级别的性质。<br>我们将某个变量声明为数字类型，类型检查器会确保不会将数据解析为字符串。我们将某个变量声明为私有或只读的，即便数据本身在内存中和公开的、可变的数据并没有任何区别，类型检查器会确保私有的变量不会在作用域外部被引用，只读的变量不会被修改。</p><h5 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h5><p>类型能够帮助我们向代码中添加更加严格的限制条件，确保其行为正确。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scriptAt</span>(<span class="params">s: <span class="built_in">any</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.indexOf(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="string">"TypeScript"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>上述代码运行时会报出 <code>TypeError</code> 错误，因为 <code>42</code> 并不是 <code>scriptAt</code> 函数的合法参数。但是编译器并没有发现这个错误，因为它没有获得足够的类型信息。<br>将参数 <code>s</code> 的类型从 <code>any</code> 改为 <code>string</code>，修改后的代码会在编译时报出类型错误：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scriptAt</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.indexOf(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="string">"TypeScript"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="number">42</span>));  <span class="comment">// Argument of type '42' is not assignable to parameter of type 'string'</span></span><br></pre></td></tr></table></figure></p><p>借助类型系统，我们可以将原来在运行时爆发的错误提前到影响相对较小的编译期，从而在代码正式运行或发布之前发现和修复 bug。</p><p>当程序进入到 <em>bad state</em> 状态时，错误就会发生。<em>bad state</em> 意味着当前所有存活着的变量的状态组合，由于某种原因是非法的。消除这类 <em>bad state</em> 的一种方式，就是通过限制变量可以接受的可能值的数量来减少状态空间。即更精确的类型定义。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a70a8613573ae081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strict types"></p><h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>不可变性的概念同样来自于将软件系统视为变化的状态空间。当我们处于一个已知的好的状态时，我们能维持该状态的某些部分不发生变化，就能降低出现错误的可能性。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeDivide</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"x should not be 0"</span>);</span><br><span class="line">    x = x - <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中，变量 <code>x</code> 在检查除数不为零的语句之后发生了改变，导致前面的检查语句变得毫无意义。这类情况在现实中经常出现，比如变量被某一个并发的线程所修改。<br>可以将变量声明为不可变的常量。若代码中尝试对常量进行修改，编译时就会报出错误。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeDivide</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"x should not be 0"</span>);</span><br><span class="line">    x = x - <span class="number">42</span>;  <span class="comment">// error TS2588: Cannot assign to 'x' because it is a constant</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量和常量在内存中的表示并无任何异同，只是对编译器而言有不同的意义。优化编译器在处理不可变变量时能够生成更高效的代码，此外当涉及到并发时，不可变性的用处非常大。当数据不可变时，数据竞争的情形就不会存在。</p><h5 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h5><p>封装代表一种隐藏代码内部细节的能力，它能够帮助我们应对复杂性问题。我们将代码分割成一个个相对较小的组件，每个组件只向外部暴露有限的功能，其内部的实现细节则被隐藏和隔离。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SafeDivisor &#123;</span><br><span class="line">    divisor: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setDivisor(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value should not be 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.divisor = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    divide(x: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x / <span class="keyword">this</span>.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> SafeDivisor();</span><br><span class="line">sd.divisor = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sd.divide(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>在上述代码中，<code>divisor</code> 不再是不可变的常量，而是可以通过公开的 API <code>setDivisor()</code> 更新的变量。但新的问题在于，调用者可以绕过包含检查功能的赋值接口，直接访问实例的 <code>divisor</code> 属性并将其改为任意值。因为 <code>divisor</code> 属性对于外部世界是可以公开访问的。<br>为了使 <code>divisor</code> 属性只对实例内部可见，外部对该属性的访问只能通过 <code>setDivisor()</code> 这类刻意公开的方法，可以将属性声明为 <code>private</code>：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SafeDivisor &#123;</span><br><span class="line">    <span class="keyword">private</span> divisor: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setDivisor(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value should not be 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.divisor = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    divide(x: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x / <span class="keyword">this</span>.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> SafeDivisor();</span><br><span class="line">sd.divisor = <span class="number">0</span>;  <span class="comment">// error TS2341: Property 'divisor' is private and only accessible within class 'SafeDivisor'</span></span><br><span class="line"><span class="built_in">console</span>.log(sd.divide(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>封装性能够帮助我们将逻辑和数据分派给公开的接口和非公开的实现，这对于构建大型系统非常有利。面向接口（抽象）编程可以减轻我们理解特定代码片段的心智负担，当我们引用某个功能时，我们只需要知晓公开的接口如何工作、如何使用，不必掌握任何内部的实现细节。<br>同时封装性能够帮助我们将非公开的信息封锁在特定的边界内，保证没有任何外部代码会对其进行改动，提高了代码的安全性。</p><h5 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstNegativeNumber</span>(<span class="params">numbers: <span class="built_in">number</span>[]</span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i of numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstOneCharacterString</span>(<span class="params">strings: <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str of strings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length == <span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个函数有着几乎一致的逻辑，这造成了一定程度的冗余代码。可以将它们之间通用的逻辑抽象成一个共享的算法，将变化的部分（操作的类型、判断条件）作为参数传入：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function first&lt;T&gt;(range: T[], p: (elem: T) =&gt; boolean): T | undefined &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> elem of range) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p(elem)) <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstNegativeNumber</span>(<span class="params">numbers: <span class="built_in">number</span>[]</span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first(numbers, <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstOneCharacterString</span>(<span class="params">strings: <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first(strings, <span class="function"><span class="params">str</span> =&gt;</span> str.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如我们需要为上述所有的实现添加自定义的 logging，只更新 <code>first</code> 函数的实现即可。又或者我们发现了一种更加高效的算法，只需要更新 <code>first</code> 函数，所有 <code>first</code> 的调用者就都能享受到性能的提升。</p><p>将相互独立的组件组合成一个灵活的模块化的系统，各部分组件松散地结合在一起，相互之间有着更少的冗余代码。整体的代码量也会大大降低。新需求的添加往往只需要独立地修改特定的组件，而不会影响到整个系统。同时这样的模块化系统理解起来也更加容易，因为其中的每一个组件都可以拆下来，独立地进行分析。</p><h5 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h5><p>读代码的动作远远多于写代码。类型提供了额外的非常有价值的信息，能够令代码更加清晰、易读。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">range: <span class="built_in">any</span>, pred: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">first</span>&lt;<span class="title">T</span>&gt;(<span class="params">range: T[],</span></span></span><br><span class="line">    p: (elem: T) =&gt; boolean): T | undefined;</span><br></pre></td></tr></table></figure><h4 id="类型系统的分类"><a href="#类型系统的分类" class="headerlink" title="类型系统的分类"></a>类型系统的分类</h4><p><strong>动态类型 vs 静态类型</strong><br>动态类型不会在编译期强加任何类型约束，类型只会在运行时生效。<br>静态类型正相反，会在编译期执行类型检查，任何不恰当的类型都会导致编译错误。能够令类型错误在编译期就爆出来，不至于导致正在运行的程序发生故障，是静态类型的主要优势。</p><p>JavaScript、Python 属于动态类型，TypeScript、Java 属于静态类型。</p><p><strong>弱类型 vs 强类型</strong><br>类型系统的强弱，用来描述系统在强制执行类型约束时的严格程度。一个弱的类型系统会隐式地尝试将某个值从实际的类型转换成期待的类型。</p><p>在强类型系统中，“牛奶”不等于“白色”。牛奶是一种液体，而颜色是另外一种不同的事物，两者无法进行比较；<br>在弱类型的世界里，我们可以直接说，因为牛奶的颜色是白色，牛奶等于白色。不需要像强类型那样，对类型显式地进行转换。</p><p>JavaScript 是弱类型的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'2'</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="string">'1'</span></span><br><span class="line"><span class="string">'11'</span></span><br></pre></td></tr></table></figure></p><p>隐式类型转换非常危险。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要有类型&quot;&gt;&lt;a href=&quot;#为什么要有类型&quot; class=&quot;headerlink&quot; title=&quot;为什么要有类型&quot;&gt;&lt;/a&gt;为什么要有类型&lt;/h4&gt;&lt;p&gt;从硬件和机器码这类底层视角来看，程序逻辑（代码）和代码操作的数据都是通过比特（bits）来表示，没有
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Static" scheme="https://rollingstarky.github.io/tags/Static/"/>
    
      <category term="Immutability" scheme="https://rollingstarky.github.io/tags/Immutability/"/>
    
      <category term="Encapsulation" scheme="https://rollingstarky.github.io/tags/Encapsulation/"/>
    
      <category term="Composability" scheme="https://rollingstarky.github.io/tags/Composability/"/>
    
      <category term="Readability" scheme="https://rollingstarky.github.io/tags/Readability/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— 生命周期管理</title>
    <link href="https://rollingstarky.github.io/2022/11/29/kubernetes-patterns-reading-notes-managing-lifecycle/"/>
    <id>https://rollingstarky.github.io/2022/11/29/kubernetes-patterns-reading-notes-managing-lifecycle/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:23:40.756Z</updated>
    
    <content type="html"><![CDATA[<p>由云原生平台管理的容器化应用，并不能控制其自身的生命周期。它们必须监听由管理平台发出的事件，再对生命周期做出相对应的变更。所谓的生命周期管理，即代表应用该如何读取和响应这些由管理平台发出的生命周期事件。</p><p>鉴于某些管理策略或者外部环境因素，在任意时间点，管理平台都有可能需要启动或者终止容器中的应用。容器化应用可以决定平台发出的哪些事件是重要的，应该以怎样的行为去响应。这实际上是一个平台用来同应用进行沟通、向应用发送命令的 API，应用可以选择接受或者忽略。</p><p>仅仅使用进程模型来启动和终止应用通常是不够的，现实世界中的应用往往需要更细粒度的交互控制和生命周期管理。有些应用需要 warm up，有些需要一个平滑、干净的关闭流程。因而 Kubernetes 设计了如下几种由平台发出的事件，容器可以选择监听和响应这些事件。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-4553383b68e82dca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="events"></p><h4 id="SIGTERM-Signal"><a href="#SIGTERM-Signal" class="headerlink" title="SIGTERM Signal"></a>SIGTERM Signal</h4><p>当 Kubernetes 决定关闭某个容器时，该容器会收到一个 SIGTERM 信号，之后容器会尝试尽快完成关闭流程。对于某些应用来说，干净的快速终止是可行的。但另外一些应用有可能需要完成处理中的请求，释放打开的连接，清理临时文件等。这会耗费更多的时间。</p><h4 id="SIGKILL-Signal"><a href="#SIGKILL-Signal" class="headerlink" title="SIGKILL Signal"></a>SIGKILL Signal</h4><p>当某个容器进程在收到 SIGTERM 信号后并没有关闭，接下来它会再收到一个 SIGKILL 信号强制终止进程。默认情况下，Kubernetes 会在发出 SIGTERM 信号 30 秒后再发送 SIGKILL。这个 30 秒的过渡时间可以通过 Pod 的 <code>.spec.terminationGracePeriodSeconds</code> 字段进行配置。</p><h4 id="Poststart-Hook"><a href="#Poststart-Hook" class="headerlink" title="Poststart Hook"></a>Poststart Hook</h4><p>仅仅使用进程信号来管理生命周期有一定程度的限制。因而 Kubernetes 又提供了 <code>postStart</code> 和 <code>postStop</code>。<br><code>postStart</code> 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">post-start-hook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sleep</span> <span class="number">30</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">"Wake up!"</span> <span class="string">&gt; /tmp/postStart_done</span></span><br></pre></td></tr></table></figure></p><p><code>postStart</code> 指定的命令会在容器创建后执行，与容器的基础进程异步。<code>postStart</code> 是一种阻塞请求，其 handler 完成之前，容器会一直处于 <em>Waiting</em> 状态，同时 Pod 处于 <em>Pending</em> 状态。<br><code>postStart</code> 的这种特性可以用来延迟容器的启动，为容器的主进程的初始化争取时间。</p><p>另一个 <code>postStart</code> 的使用场景就是在 Pod 不满足特定的前提条件时，阻止容器完成启动。当 <code>postStart</code> 命令返回了一个非 0 的返回值，主进程会被 Kubernetes 杀掉。</p><p>类似于 Health Probe，postStart 和 preStop 有如下两种 handler 类型：</p><ul><li>exec：在容器中直接运行一个命令</li><li>httpGet：向容器开放的某个端口发送 HTTP GET 请求</li></ul><p>对于 postStart 执行的逻辑，需要注意以下几点：</p><ul><li>postStart 与容器进程是并行的关系，因而这个 hook 有可能在容器启动前执行</li><li>postStart 有至少执行一次的目标，需要考虑重复执行的情况</li><li>对于失败的 HTTP 请求，postStart 不会重复尝试</li></ul><h4 id="preStop"><a href="#preStop" class="headerlink" title="preStop"></a>preStop</h4><p><code>preStop</code> hook 是一个在容器终止前发送给容器的阻塞请求。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pre-stop-hook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      preStop:</span></span><br><span class="line"><span class="attr">        httpGet:</span></span><br><span class="line"><span class="attr">          port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/shutdown</span></span><br></pre></td></tr></table></figure></p><p>虽然 <code>preStop</code> 是阻塞的，但若它挂起或者返回一个非成功的结果，并不会阻止进程被杀掉、容器被删除。<code>preStop</code> 只是为了能够平滑地关闭应用，是除 SIGTERM 之外的另一种方便的选择。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>云原生平台能提供的最大的好处之一，就是在不够可靠的云计算基础设施上，可靠地运行和扩展应用。这类平台设计了一系列应用必须遵守的协议和约束。处理和响应协议中的事件，能够确保应用平稳地启动和关闭，对接受服务的客户端只有最小的影响。应用的生命周期不再由个人所控制，而是完全由平台自动化管理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由云原生平台管理的容器化应用，并不能控制其自身的生命周期。它们必须监听由管理平台发出的事件，再对生命周期做出相对应的变更。所谓的生命周期管理，即代表应用该如何读取和响应这些由管理平台发出的生命周期事件。&lt;/p&gt;
&lt;p&gt;鉴于某些管理策略或者外部环境因素，在任意时间点，管理平台
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="lifecycle" scheme="https://rollingstarky.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 由 Promises 和 Async、Await 实现的异步模式</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:20:03.300Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。</p><p>为了获得更好的异步编程体验，第一个出现的就是 <strong>promise</strong>，一种保存了异步操作的状态和最终结果的对象。Promise 可以轻易地被串联起来，实现串行控制流，可以像其他任何对象一样自由地转移。Pormise 大大简化了异步代码，后来在此基础上又有了 <strong>async</strong> 和 <strong>await</strong>，能够令异步代码看起来就像是同步代码一样。</p><h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>Promises 是 ECMAScript 2015 标准（ES6）的一部分，为传递异步结果提供了一种健壮的解决方案，替代原本的 CPS 样式的回调函数。Promise 能够令所有主要的异步控制流更加易读、简洁和健壮。</p><p>Promise 是一种用来代表异步操作的最终结果（或错误）的对象。在专业术语中，当异步操作未完成时，我们称 Promise 是 <strong>pending</strong> 的；当异步操作成功结束时，Promise 是 <strong>fulfilled</strong> 的；当异步操作因为错误终止时，Promise 是 <strong>rejected</strong> 的；当 Promise 或者是 <strong>fulfilled</strong> 或者是 <strong>rejected</strong>，则将其认定为 <strong>settled</strong>。</p><p>Promise 对象的 <code>then()</code> 方法可以获取成功执行后的结果或者终止时报出的错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p><p>其中 <code>onFulfilled</code> 是一个回调函数，最终会接收到 Promise 成功时的值；<code>onRejected</code>是另一个回调函数，最终会接收 Promise 异常终止时的值（如果有的话）。</p><p>基于回调函数的如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation(arg, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do stuff with the result</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promise 实现上述同样的功能，则更加优雅、结构化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do stuff with result</span></span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>asyncOperationPromise()</code> 会返回一个 Promise，可以被用来获取最终结果的值或者失败的原因。但最为关键的属性是，<code>then()</code> 方法会同步地返回另一个 Promise。<br>更进一步地，如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回一个值 <code>x</code>，那么 <code>then()</code> 方法返回的 Promise 会有以下行为：</p><ul><li>若 <code>x</code> 是一个值，则 <code>then()</code> 返回的 Promise 使用 <code>x</code> 作为自身完成时的值</li><li>若 <code>x</code> 是一个 Promise 且成功完成，则 <code>x</code> 完成时返回的值作为 <code>then()</code> 返回的 Promise 完成时的值</li><li>若 <code>x</code> 是一个 Promise 且因为错误终止，则 <code>x</code> 终止的原因作为 <code>then()</code> 返回的 Promise 终止的原因</li></ul><p>上述行为能够令我们将多个 promise 连接成链，轻松地将异步操作聚合在一起。如果我们没有指定一个 <code>onFulfilled</code> 或者 <code>onRejected</code> handler，Promise 完成时的值或者终止时的原因都会自动地传递给链条中的下一个 Promise。通过 Promise 链，任务的执行顺序突然变得很简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return another promise</span></span><br><span class="line">    <span class="keyword">return</span> asyncOperationPromise(arg2)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return a value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="literal">undefined</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// any error in the chain is caught here</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h4><p>Promise 构造函数（<code>new Promise((resolve, reject) =&gt; {})</code>）会创建一个新的 Promise 实例，其完成还是终止取决于作为参数传入的函数的行为。<br>作为参数传入的函数接收如下两个参数：</p><ul><li><code>resolve(obj)</code>：resolve 是一个函数，在调用时为 Promise 提供完成时的值。当 <code>obj</code> 是值时，则 <code>obj</code> 本身作为 Promise 完成时的值；当 <code>obj</code> 是另一个 Promise 时，则 <code>obj</code> 完成时的值作为当前 Promise 完成时的值</li><li><code>reject(err)</code>：Promise 因为 <code>err</code> 终止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds()&#125;</span>s\nDelaying...`</span>)</span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">newDate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;newDate.getSeconds()&#125;</span>s`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise 最重要的静态方法：</p><ul><li><code>Promise.resolve(obj)</code>：从另一个 Promise、thenable 对象或者值创建一个新的 Promise</li><li><code>Promise.reject(err)</code>：创建一个 Promise，该 Promise 会因为 <code>err</code> 终止</li><li><code>Promise.all(iterable)</code>：从一个可迭代对象创建 Promise，若该 iterable 中的每一项都提供了一个 fulfill 值，则 Promise 最终以包含这些值的列表作为 fulfill 值；若其中有任意一项 reject，则 Promise.all() 返回的 Promise 以第一个 reject 的 err 终止</li><li><code>Promise.allSettled(iterable)</code>：此方法会等待所有输入的 Promise 或者 fulfill 或者 reject，之后返回一个包含所有 fulfill 值和 reject 原因的列表</li><li><code>Promise.race(iterable)</code>：返回可迭代对象中第一个 fulfill 或 reject 的 Promise</li></ul><p>Promise 关键的实例方法：</p><ul><li><code>promise.catch(onRejected)</code>：实际上就是 <code>promise.then(undefined, onRejected)</code> 的语法糖</li><li><code>promise.finally(onFinally)</code>：允许我们设置一个 <code>onFinally</code> 回调函数，在 <code>promise</code> fulfill 或者 reject 时调用</li></ul><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><p>顺序执行意味着，每次只执行一系列任务中的一个，完成后再依次执行后面的任务。这一系列任务的先后顺序必须是预先定义好的，因为一个任务的结果有可能影响后续任务的执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a0d217ff414af74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of sequential execution flow with three tasks"></p><p>上述执行流程有着不同形式的变种：</p><ul><li>顺序执行一系列已知的任务，不需要在它们之间传递数据</li><li>前一个任务的输出作为后一个任务的输入（<em>chain</em>、<em>pipeline</em>、<em>waterfall</em>）</li><li>迭代任务集合，同时在每个元素上一个接一个地运行异步任务</li></ul><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"03-promises-web-spider-v2"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"cheerio"</span>: <span class="string">"^1.0.0-rc.3"</span>,</span><br><span class="line">    <span class="attr">"mkdirp"</span>: <span class="string">"^0.5.1"</span>,</span><br><span class="line">    <span class="attr">"superagent"</span>: <span class="string">"^5.2.2"</span>,</span><br><span class="line">    <span class="attr">"slug"</span>: <span class="string">"^1.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;dirname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> superagent <span class="keyword">from</span> <span class="string">'superagent'</span></span><br><span class="line"><span class="keyword">import</span> mkdirp <span class="keyword">from</span> <span class="string">'mkdirp'</span></span><br><span class="line"><span class="keyword">import</span> &#123;urlToFilename, getPageLinks&#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mkdirpPromises = promisify(mkdirp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">return</span> superagent.get(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      content = res.text</span><br><span class="line">      <span class="keyword">return</span> mkdirpPromises(dirname(filename))</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> fsPromises.writeFile(filename, content))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> content</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    promise = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">return</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The file doesn't exist, so let’s download it</span></span><br><span class="line">      <span class="keyword">return</span> download(url, filename)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">content</span> =&gt;</span> spiderLinks(url, content, nesting))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider-cli.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;spider&#125; <span class="keyword">from</span> <span class="string">'./spider.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> nesting = <span class="built_in">Number</span>.parseInt(process.argv[<span class="number">3</span>], <span class="number">10</span>) || <span class="number">1</span></span><br><span class="line"></span><br><span class="line">spider(url, nesting)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Download complete'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p><code>utils.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;join, extname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;URL&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> slug <span class="keyword">from</span> <span class="string">'slug'</span></span><br><span class="line"><span class="keyword">import</span> cheerio <span class="keyword">from</span> <span class="string">'cheerio'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLinkUrl</span>(<span class="params">currentUrl, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedLink = <span class="keyword">new</span> URL(element.attribs.href || <span class="string">''</span>, currentUrl)</span><br><span class="line">  <span class="keyword">const</span> currentParsedUrl = <span class="keyword">new</span> URL(currentUrl)</span><br><span class="line">  <span class="keyword">if</span> (parsedLink.hostname !== currentParsedUrl.hostname ||</span><br><span class="line">    !parsedLink.pathname) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parsedLink.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">urlToFilename</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedUrl = <span class="keyword">new</span> URL(url)</span><br><span class="line">  <span class="keyword">const</span> urlPath = parsedUrl.pathname.split(<span class="string">'/'</span>)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> component !== <span class="string">''</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> slug(component, &#123;<span class="attr">remove</span>: <span class="literal">null</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">let</span> filename = join(parsedUrl.hostname, urlPath)</span><br><span class="line">  <span class="keyword">if</span> (!extname(filename).match(<span class="regexp">/htm/</span>)) &#123;</span><br><span class="line">    filename += <span class="string">'.html'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filename</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPageLinks</span>(<span class="params">currentUrl, body</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(cheerio.load(body)(<span class="string">'a'</span>))</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getLinkUrl(currentUrl, element)</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>node spider-cli.js http://www.baidu.com 2</code></p><p>其中的 <code>spiderLinks()</code> 函数通过循环动态地构建了一条 Promise 链：</p><ul><li>先定义一个“空的” Promise 对象（resovle 到 <code>undefined</code>），这个空 Promise 只是作为链条的起点</li><li>在循环中，不断将 <code>promise</code> 变量更新为新的 Promise 对象（通过调用上一个 Promise 的 <code>then()</code> 方法得到）。这就是 Promise 的异步遍历模式</li></ul><p>在 <code>for</code> 循环的最后，<code>promise</code> 变量会是最后一个 <code>then()</code> 方法返回的 Promise，因而只有当链条中的所有 Promise 都 resolve 时，<code>promise</code> 才会 resolve。</p><p>纵观所有代码，我们可以不需要像使用 callback 那样，强制地包含众多错误传递逻辑。因而大大减少了代码量和出错的机会。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>在某些情况下，一系列异步任务的执行顺序并不重要，我们需要的只是当所有的任务都完成后能收到通知。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf70d3d597a899bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of parallel execution with three tasks"></p><p>虽然 Node.js 是单线程的，但得益于其 non-blocking nature，我们仍可以实现并发行为。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-ae64bdc5e85d3d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of how asynchronous tasks run in parallel"></p><p>比如我们有一个 Main 函数需要执行两个异步任务：</p><ul><li>Main 函数首先触发异步任务 Task1 和 Task2 的执行。异步任务触发后，会将程序控制权立即交还给 Main 函数，再转交给 event loop</li><li>当 Task1 中的异步任务结束时，event loop 调用 Task1 的回调函数，将控制权交给 Task1。Task1 执行完成自身内部的同步指令，通知 Main 函数并返还控制权</li><li>当 Task2 中的异步任务结束时，event loop 调用 Task2 的回调函数，将控制权交给 Task2。在 Task2 的终点，Main 函数再次被通知。Main 函数得知 Task1 和 Task2 全部结束，继续执行或者返回结果</li></ul><p>简单来说，在 Node.js 中，我们只能并发地执行异步操作，因为它们的并发行为是由内部的非阻塞 API 控制的。同步（阻塞）操作无法并发地执行，除非它们的执行与异步操作交织在一起，或者由 <code>setTimeout()</code>、<code>setImmediate()</code> 包裹。</p><p>Promise 实现并发执行流，可以借助内置的 <code>Promise.all()</code> 方法。该方法会返回一个新的 Promise，只有当所有传入的 Promise 都 fulfill 时，新 Promise 才会 fulfill。如果传入的 Promise 之间没有因果关系，这些 Promise 就会并发地执行。</p><p>对于前面的 spider 应用，只需要将 <code>spiderLinks()</code> 函数改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h4><p>Promise 链相对于 callback hell 来说肯定是要好太多的，但是我们仍然需要调用 <code>then()</code> 方法，以及为链条中的每一个任务创建新的函数，对于日常编程中非常普遍的控制流来说还是比较麻烦。而 Async/await 可以帮助我们写出像同步代码一样可读性强、容易理解的异步代码。<br>Async 函数是一种特殊的函数，在函数体里面可以使用 <code>await</code> 表达式“暂停”任意一个 Promise 的执行，将控制权交还给 async 函数的调用者，等该 Promise revolve 后再返回到暂停的地方继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithDelays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial date: '</span>, <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  <span class="keyword">const</span> dateAfterOneSecond = <span class="keyword">await</span> delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after one second: '</span>, dateAfterOneSecond)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dateAfterThreeSeconds = <span class="keyword">await</span> delay(<span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after 3 secnods: '</span>, dateAfterThreeSeconds)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">playingWithDelays()</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`After 4 seconds: <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Async/await 的另一个巨大的优势在于，它能够标准化 <code>try...catch</code> 代码块的行为，不管是针对同步代码中的 <code>throw</code>，抑或是异步代码中的 Promise reject。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayError</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Error after <span class="subst">$&#123;milliseconds&#125;</span>ms`</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithErrors</span>(<span class="params">throwSyncError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (throwSyncError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is a synchronous error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> delayError(<span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`We have an error: <span class="subst">$&#123;err.message&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// playingWithErrors(true)</span></span><br><span class="line">playingWithErrors(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>借助 Async/await，可以对之前的 spider 应用实现很多优化。比如 <code>download()</code> 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">text</span>: content&#125; = <span class="keyword">await</span> superagent.get(url)</span><br><span class="line">  <span class="keyword">await</span> mkdirpPromises(dirname(filename))</span><br><span class="line">  <span class="keyword">await</span> fsPromises.writeFile(filename, content)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整段代码行数大大减少，看起来也很“平整”，没有任何层级和缩进。</p><p>接下来是 <code>spiderLinks()</code> 函数，使用 async/await 异步地遍历一个列表：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    <span class="keyword">await</span> spider(link, nesting - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是 <code>spider()</code> 函数，如何简单地通过 <code>try...catch</code> 处理错误，令异步代码更加易读：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    content = <span class="keyword">await</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    content = <span class="keyword">await</span> download(url, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spiderLinks(url, content, nesting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="并行执行-1"><a href="#并行执行-1" class="headerlink" title="并行执行"></a>并行执行</h4><p>使用纯 async/await 实现并行的异步执行流程，可以参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而上述代码存在一定的问题。如果列表中有一个 Promise reject 了，我们不得不等待列表中其他所有的 Promise 都 resolve，<code>spiderLinks()</code> 函数返回的 Promise 才会 reject。这种行为在多数情况下都是不理想的。<br>我们通常都会想要在操作发生错误的第一时间捕获错误信息。因而并行执行异步操作，最后仍建议使用下面形式的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。&lt;/p
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Async" scheme="https://rollingstarky.github.io/tags/Async/"/>
    
      <category term="Promise" scheme="https://rollingstarky.github.io/tags/Promise/"/>
    
      <category term="Concurrent" scheme="https://rollingstarky.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Streams 流编程</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:23:27.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Streams</strong> 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。</p><h3 id="Buffering-vs-streaming"><a href="#Buffering-vs-streaming" class="headerlink" title="Buffering vs streaming"></a>Buffering vs streaming</h3><p>对于输入数据的处理，buffer 模式会将来自资源的所有数据收集到 buffer 中，待操作完成再将数据作为单一的 blob of data 传递给调用者；相反地，streams 允许我们一旦接收到数据就立即对其进行处理。<br>单从效率上说，streams 在空间（内存使用）和时间（CPU 时钟）的使用上都更加高效。此外 Node.js 中的 streams 还有另一个重要的优势：<strong>组合性</strong>。</p><h4 id="空间效率"><a href="#空间效率" class="headerlink" title="空间效率"></a>空间效率</h4><p><strong>使用 buffered API 完成 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;gzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gzipPromise = promisify(gzip)</span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fs.readFile(filename)</span><br><span class="line">  <span class="keyword">const</span> gzippedData = <span class="keyword">await</span> gzipPromise(data)</span><br><span class="line">  <span class="keyword">await</span> fs.writeFile(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>, gzippedData)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p><code>node gzip-buffer.js &lt;path to file&gt;</code></p><p>如果我们使用上述代码压缩一个足够大的文件（比如说 8G），我们很有可能会收到一个错误信息，类似文件大小超过了允许的最大 buffer 大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RangeError [ERR_FS_FILE_TOO_LARGE]: File size (8130792448) is greater</span><br><span class="line">than possible Buffer: 2147483647 bytes</span><br></pre></td></tr></table></figure></p><p>即便没有超过 V8 的 buffer 大小限制，也有可能出现物理内存不够用的情况。</p><p><strong>使用 streams 实现 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream, createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createWriteStream(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>))</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>))</span><br></pre></td></tr></table></figure></p><p>streams 的优势来自于其接口和可组合性，允许我们实现干净、优雅、简洁的代码。对于此处的示例，它可以对任意大小的文件进行压缩，只需要消耗常量的内存。</p><h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><p>假设我们需要创建一个应用，能够压缩一个文件并将其上传到一个远程的 HTTP 服务器。而服务器端则负责将接收到的文件解压缩并保存。<br>如果我们使用 buffer API 实现客户端组件，则只有当整个文件读取和压缩完成之后，上传操作才开始触发。同时在服务器端，也只有当所有数据都接收完毕之后才开始解压缩操作。</p><p>更好一些的方案是使用 streams。在客户端，streams 允许我们以 chunk 为单位从文件系统逐个、分段地读取数据，并立即进行压缩和发送。同时在服务器端，每个 chunk 被接收到后会立即进行解压缩。</p><p>服务端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure></p><p>客户端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>mkdir received_files</code><br><code>node gzip-receive.js</code><br><code>node gzip-send.js &lt;path to file&gt; localhost</code></p><p>借助 streams，整套流程的流水线在我们接收到第一个数据块的时候就开始启动了，完全不需要等待整个文件被读取。除此之外，下一个数据块能够被读取时，不需要等到之前的任务完成就能被处理。即另一条流水线被并行地被装配执行，Node.js 可以将这些异步的任务并行化地执行。只需要保证数据块最终的顺序是固定的，而 Node.js 中 streams 的内部实现机制保证了这一点。</p><h4 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h4><p>借助于 <code>pipe()</code> 方法，不同的 stream 能够被组合在一起。每个处理单元负责各自的单一功能，最终被 <code>pipe()</code> 连接起来。因为 streams 拥有统一的接口，它们彼此之间在 API 层面是互通的。只需要 pipeline 支持前一个 stream 生成的数据类型（可以是二进制、纯文本甚至对象等）。</p><h5 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createCipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> secret = Buffer.from(process.argv[<span class="number">4</span>], <span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">const</span> iv = randomBytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename),</span><br><span class="line">    <span class="string">'X-Initialization-Vector'</span>: iv.toString(<span class="string">'hex'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createCipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h5 id="服务端加密"><a href="#服务端加密" class="headerlink" title="服务端加密"></a>服务端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secret = randomBytes(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Generated secret: <span class="subst">$&#123;secret.toString(<span class="string">'hex'</span>)&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> iv = Buffer.from(</span><br><span class="line">    req.headers[<span class="string">'x-initialization-vector'</span>], <span class="string">'hex'</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createDecipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure><h3 id="Streams-详解"><a href="#Streams-详解" class="headerlink" title="Streams 详解"></a>Streams 详解</h3><p>实际上在 Node.js 中的任何地方都可见到 streams。比如核心模块 fs 有 <code>createReadStream()</code> 方法用来读取文件内容，<code>createWriteStream()</code> 方法用来向文件写入数据；HTTP <code>request</code> 和 <code>response</code> 对象本质上也是 stream；zlib 模块允许我们通过流接口压缩和解压缩数据；甚至 crypto 模块也提供了一些有用的流函数比如 <code>createCipheriv</code> 和 <code>createDecipheriv</code>。</p><h4 id="streams-的结构"><a href="#streams-的结构" class="headerlink" title="streams 的结构"></a>streams 的结构</h4><p>Node.js 中的每一个 stream 对象，都是对以下四种虚拟基类里任意一种的实现，这四个虚拟类都属于 <code>stream</code> 核心模块：</p><ul><li><code>Readable</code></li><li><code>Writable</code></li><li><code>Duplex</code></li><li><code>Transform</code></li></ul><p>每一个 stream 类同时也是 <code>EventEmitter</code> 的实例，实际上 Streams 可以生成几种类型的 event。比如当一个 <code>Readable</code> 流读取完毕时触发 <code>end</code> 事件，<code>Writable</code> 流吸入完毕时触发 <code>finish</code> 事件，或者当任意错误发生时抛出 <code>error</code>。</p><p>Steams 之所以足够灵活，一个重要的原因就是它们不仅仅能够处理 binary data，还支持几乎任意的 JavaScript 值。实际上 streams 有以下两种操作模式：</p><ul><li>Binary mode：以 chunk 的形式（比如 buffers 或 strings）传输数据</li><li>Object mode：通过由独立对象（可以包含任意 JavaScript 值）组成的序列传输数据</li></ul><p>上述两种模式使得我们不仅仅可以利用 streams 处理 I/O 操作，还能够帮助我们以函数式的方式将多个处理单元优雅地组合起来。</p><h4 id="从-Readable-streams-读取数据"><a href="#从-Readable-streams-读取数据" class="headerlink" title="从 Readable streams 读取数据"></a>从 Readable streams 读取数据</h4><h5 id="non-flowing-mode"><a href="#non-flowing-mode" class="headerlink" title="non-flowing mode"></a>non-flowing mode</h5><p>默认模式。<code>readable</code> 事件表示有新的数据可供读取，再通过 <code>read()</code> 方法同步地从内部 buffer 读取数据，返回一个 Buffer 对象。<br>即从 stream 按需拉取数据。当 stream 以 Binary 模式工作时，我们还可以给 <code>read()</code> 方法指定一个 <code>size</code> 值，以读取特定数量的数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="flowing-mode"><a href="#flowing-mode" class="headerlink" title="flowing mode"></a>flowing mode</h5><p>此模式下，数据并不会像之前那样通过 <code>read()</code> 方法拉取，而是一旦有数据可用，就主动推送给 <code>data</code> 事件的 listener。flowing 模式对于数据流的控制，相对而言灵活性较低一些。<br>由于默认是 non-flowing 模式，为了使用 flowing 模式，需要绑定一个 listener 给 <code>data</code> 事件或者显式地调用 <code>resume()</code> 方法。调用 <code>pause()</code> 方法会导致 stream 暂时停止发送 <code>data</code> 事件，任何传入的数据会先被缓存到内部 buffer。即 stream 又切换回 non-flowing 模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="Async-iterators"><a href="#Async-iterators" class="headerlink" title="Async iterators"></a>Async iterators</h5><p>Readable 流同时也是 async iterators。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> process.stdin) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="实现-Readable-streams"><a href="#实现-Readable-streams" class="headerlink" title="实现 Readable streams"></a>实现 Readable streams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = Chance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream()</span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>为了实现一个自定义的 Readable stream，首先必须创建一个新的类，该类继承自 <code>stream</code> 模块中的 <code>Readable</code>。其次新创建的类中必须包含 <code>_read()</code> 方法的实现。<br>上面代码中的 <code>_read()</code> 方法做了以下几件事：</p><ul><li>借助第三方的 <code>chance</code> 模块，生成一个长度为 <code>size</code> 的随机字符串</li><li>通过 <code>push()</code> 方法将字符传推送到内部 buffer</li><li>依据 5% 的几率自行终止，终止时推送 <code>null</code> 到内部 buffer，作为 stream 的结束标志</li></ul><p><strong>简化版实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">let</span> emittedBytes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> Readable(&#123;</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h5 id="从可迭代对象创建-Readable-streams"><a href="#从可迭代对象创建-Readable-streams" class="headerlink" title="从可迭代对象创建 Readable streams"></a>从可迭代对象创建 Readable streams</h5><p><code>Readable.from()</code> 方法支持从数组或者其他可迭代对象（比如 generators, iterators, async iterators）创建 Readable streams。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountains = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Everest'</span>, <span class="attr">height</span>: <span class="number">8848</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'K2'</span>, <span class="attr">height</span>: <span class="number">8611</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Kangchenjunga'</span>, <span class="attr">height</span>: <span class="number">8586</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Lhotse'</span>, <span class="attr">height</span>: <span class="number">8516</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Makalu'</span>, <span class="attr">height</span>: <span class="number">8481</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountainsStream = Readable.from(mountains)</span><br><span class="line">mountainsStream.on(<span class="string">'data'</span>, (mountain) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mountain.name.padStart(<span class="number">14</span>)&#125;</span>\t<span class="subst">$&#123;mountain.height&#125;</span>m`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Writable-streams"><a href="#Writable-streams" class="headerlink" title="Writable streams"></a>Writable streams</h4><h5 id="向流写入数据"><a href="#向流写入数据" class="headerlink" title="向流写入数据"></a>向流写入数据</h5><p><code>write()</code> 方法可以向 Writable stream 写入数据。<br><code>writable.write(chunk, [encoding], [callback])</code></p><p><code>end()</code> 方法可以向 stream 表明没有更多的数据需要写入。<br><code>writable.end([chunk], [encoding], [callback])</code></p><p><code>callback</code> 回调函数等同于为 <code>finish</code> 事件注册了一个 listener，会在流中写入的所有数据刷新到底层资源中时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">  <span class="keyword">while</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">95</span>&#125;)) &#123;</span><br><span class="line">    res.write(<span class="string">`<span class="subst">$&#123;chance.string()&#125;</span>\n`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(<span class="string">'\n\n'</span>)</span><br><span class="line">  res.on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'All data sent'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on http://localhost:8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中 HTTP 服务里的 <code>res</code> 对象是一个 <code>http.ServerResponse</code> 对象，实际上也是一个 Writable stream。</p><h5 id="实现-Writable-stream"><a href="#实现-Writable-stream" class="headerlink" title="实现 Writable stream"></a>实现 Writable stream</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFileStream</span> <span class="keyword">extends</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options, <span class="attr">objectMode</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> ToFileStream()</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> Writable(&#123;</span><br><span class="line">  objectMode: <span class="literal">true</span>,</span><br><span class="line">  write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure></p><h4 id="Duplex-streams"><a href="#Duplex-streams" class="headerlink" title="Duplex streams"></a>Duplex streams</h4><p>Duplex 流，既 Readable 又 Writable 的流。它的场景在于，有时候我们描述的实体既是数据源，也是数据的接收者，比如网络套接字。<br>Duplex 流同时继承来着 <code>stream.Readable</code> 和 <code>stream.Writable</code> 的方法。<br>为了创建一个自定义的 Duplex 流，我们必须同时提供 <code>_read()</code> 和 <code>_write()</code> 的实现。</p><h4 id="Transform-streams"><a href="#Transform-streams" class="headerlink" title="Transform streams"></a>Transform streams</h4><p>Transform 流是一种特殊类型的 Duplex 流，主要针对数据的转换。<br>对于 Duplex 流来说，流入和流出的数据之间并没有直接的联系。比如一个 TCP 套接字，只是从远端接收或者发送数据，套接字本身不知晓输入输出之间的任何关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1a65d864ebeb31b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Duplex stream"></p><p>而 Transform 流则会对收到的每一段数据都应用某种转换操作，从 Writable 端接收数据，进行某种形式地转换后再通过 Readable 端提供给外部。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7f97e927ba0479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transform stream"></p><h5 id="实现-Transform-流"><a href="#实现-Transform-流" class="headerlink" title="实现 Transform 流"></a>实现 Transform 流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceStream</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(searchStr, replaceStr, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options&#125;)</span><br><span class="line">    <span class="keyword">this</span>.searchStr = searchStr</span><br><span class="line">    <span class="keyword">this</span>.replaceStr = replaceStr</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (<span class="keyword">this</span>.tail + chunk).split(<span class="keyword">this</span>.searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = <span class="keyword">this</span>.searchStr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(<span class="keyword">this</span>.replaceStr))</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.tail)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> ReplaceStream(<span class="string">'World'</span>, <span class="string">'Node.js'</span>)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure><p>其中核心的 <code>_transform()</code> 方法，其有着和 Writable 流的 <code>_write()</code> 方法基本一致的签名，但并不会将处理后的数据写入底层资源，而是通过 <code>this.push()</code> 推送给内部 buffer，正如 Readable 流中 <code>_read()</code> 方法的行为。<br>所以形成了 Transform 流整体上接收、转换、发送的行为。<br><code>_flush()</code> 则会在流结束前调用。</p><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchStr = <span class="string">'World'</span></span><br><span class="line"><span class="keyword">const</span> replaceStr = <span class="string">'Node.js'</span></span><br><span class="line"><span class="keyword">let</span> tail = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  defaultEncoding: <span class="string">'utf-8'</span>,</span><br><span class="line"></span><br><span class="line">  transform(chunk, encoding, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (tail + chunk).split(searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = searchStr.length - <span class="number">1</span></span><br><span class="line">    tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(replaceStr))</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,</span><br><span class="line">  flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(tail)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure></p><h4 id="Transform-流筛选和聚合数据"><a href="#Transform-流筛选和聚合数据" class="headerlink" title="Transform 流筛选和聚合数据"></a>Transform 流筛选和聚合数据</h4><p>数据源 <code>data.csv</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type,country,profit</span><br><span class="line">Household,Namibia,597290.92</span><br><span class="line">Baby Food,Iceland,808579.10</span><br><span class="line">Meat,Russia,277305.60</span><br><span class="line">Meat,Italy,413270.00</span><br><span class="line">Cereal,Malta,174965.25</span><br><span class="line">Meat,Indonesia,145402.40</span><br><span class="line">Household,Italy,728880.54</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"csv-parse"</span>: <span class="string">"^4.10.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>FilterByCountry</code> Transform 流 <code>filter-by-country.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByCountry</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(country, options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.country = country</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record.country === <span class="keyword">this</span>.country) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(record)</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SumProfit</code> Transform 流 <code>sum-profit.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SumProfit</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.total = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.total += <span class="built_in">Number</span>.parseFloat(record.profit)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.total.toString())</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> parse <span class="keyword">from</span> <span class="string">'csv-parse'</span></span><br><span class="line"><span class="keyword">import</span> &#123;FilterByCountry&#125; <span class="keyword">from</span> <span class="string">'./filter-by-conutry.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;SumProfit&#125; <span class="keyword">from</span> <span class="string">'./sum-profit.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> csvParser = parse(&#123;<span class="attr">columns</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(<span class="string">'data.csv'</span>)</span><br><span class="line">  .pipe(csvParser)</span><br><span class="line">  .pipe(<span class="keyword">new</span> FilterByCountry(<span class="string">'Italy'</span>))</span><br><span class="line">  .pipe(<span class="keyword">new</span> SumProfit())</span><br><span class="line">  .pipe(process.stdout)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Streams&lt;/strong&gt; 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
      <category term="Pipe" scheme="https://rollingstarky.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Callbacks 和 Events</title>
    <link href="https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/"/>
    <id>https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/</id>
    <published>2022-09-06T16:00:00.000Z</published>
    <updated>2022-09-07T14:18:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。</p><p>而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在“后台”启动和执行的。当我们调用某个异步操作后，即使其并没有执行完毕，该异步操作之后的代码指令也会立刻继续执行。<br>在这种情况下，我们就需要一种“通知”机制。当异步操作执行完毕，我们会收到通知，获取该操作的结果并继续之前定义的执行流程。在 Node.js 中，最基础的通知机制就是<strong>回调函数</strong>。它本质上就是一种由 runtime 调用的带有异步操作结果的函数。</p><h3 id="Callback-模式"><a href="#Callback-模式" class="headerlink" title="Callback 模式"></a>Callback 模式</h3><p>回调函数是一种能够传递操作结果的函数，正是异步编程所需要的。JavaScript 对于回调函数来说是一种理想的语言，函数是<strong>第一等对象</strong>，可以轻松地赋值给变量、作为参数传递给另一个函数、作为函数的返回值，以及存储到数据结构中。</p><h4 id="The-continuation-passing-style"><a href="#The-continuation-passing-style" class="headerlink" title="The continuation-passing style"></a>The continuation-passing style</h4><p>在 JavaScript 中，回调函数会作为参数传递给另一个函数，并且在操作完成时连同结果一起被调用。即执行结果被传递给另一个函数（callback），而不是直接返回给调用者。这种方式在函数式编程里称作 <strong>continuation-passing style (CPS)</strong>。</p><p>下面是一个非常简单的同步函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上述函数等效的 CPS 形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCps</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  callback(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">addCps(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: $result`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; Result: $result</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br></pre></td></tr></table></figure></p><p><code>addCps</code> 就是一个同步的 CPS 函数。</p><h4 id="Asynchronous-CPS"><a href="#Asynchronous-CPS" class="headerlink" title="Asynchronous CPS"></a>Asynchronous CPS</h4><p><code>addCps</code> 函数的异步版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">additionAsync</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(a + b), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">additionAsync(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: <span class="subst">$&#123;result&#125;</span>`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br><span class="line"><span class="comment">// =&gt; Result: 3</span></span><br></pre></td></tr></table></figure></p><p>上面的代码使用 <code>setTimeout</code> 来模拟回调函数的异步调用。由于 <code>setTimeout</code> 触发的是异步操作，它并不会等待回调函数 callback 执行，而是立即返回。将控制权交还给 <code>additionAsync</code> 进而回到调用者身上，执行主程序中的第二个 <code>console.log</code>。当异步操作执行完毕后，程序从之前控制权转移时的位置起恢复执行，callback 中的 <code>console.log</code> 被执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9fbb0d2cfbef3f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Control flow of an asynchronous function&#39;s invocation"></p><p>总结一下就是，同步函数会阻塞其他操作步骤，直到其自身执行完毕；异步函数会立即返回，它的执行结果会在 event loop 的后续周期中传递给 handler（即回调函数）。</p><h4 id="同步-or-异步"><a href="#同步-or-异步" class="headerlink" title="同步 or 异步"></a>同步 or 异步</h4><p>指令的执行顺序取决于函数的自然属性——同步还是异步，这对于整个应用流程的正确性和效率都有很大的影响。所以需要时刻注意避免制造矛盾和困惑。</p><h5 id="Unleashing-Zalgo"><a href="#Unleashing-Zalgo" class="headerlink" title="Unleashing Zalgo"></a>Unleashing Zalgo</h5><p>一个 API 最危险的情形之一，就是有些时候表现为同步另一些情况下表现为异步。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// invoked synchronously</span></span><br><span class="line">    cb(cache.get(filename))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述程序就是危险的。假如某个文件是第一次被读取，它会表现为异步操作，读取文件设置缓存；当某个文件的内容已经存在于缓存中时，它会表现为同步操作。</p><p>参考下面的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  inconsistentRead(filename, value =&gt; &#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`First call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">  reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Second call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中 <code>createFileReader</code> 函数会创建一个新的 <code>{ onDataReady: function() }</code> 对象作为通知器，以帮助我们为文件读取操作设置多个 listener。若 <code>inconsistentRead</code> 是纯异步操作，实际上 <code>onDataReady</code> 会先被调用，将传入的 listener 添加到 listeners 列表中。之后 <code>inconsistentRead</code> 读取文件内容完毕，回调函数 <code>cb</code> 执行，遍历 listeners 列表并将读取到的文件内容传给 listener。</p><p>实际的执行结果为：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First <span class="keyword">call</span> data: some data</span><br></pre></td></tr></table></figure></p><p>第二次读取同一个文件并没有获取到任何内容。</p><p>原因在于，当 <code>reader1</code> 创建时，<code>inconsistentRead</code> 函数表现为异步的，因为该文件是第一次被读取。因而 <code>onDataReady</code> 会在刚开始读取文件时就将传入的 listener 添加到 listeners 列表中。文件读取完毕后 listeners 中注册的 listener 被调用。<br><code>reader2</code> 创建时同一个文件的缓存内容已经存在，<code>inconsistentRead</code> 表现为同步的。它的回调函数会立即调用，遍历 listeners 列表。然而我们是先创建的 <code>reader2</code> 再添加的 listener，这就导致遍历 listeners 列表时，向 listeners 添加 listener 的操作还没有执行，我们传入的 listener 并没有来得及注册。</p><p>在实际的应用中，上述类型的 bug 会非常难以定位和复现。npm 的创造者 Isaac Z. Schlueter 将类似的使用不可预测函数的行为，叫做 <em>unleashing Zalgo</em>。</p><h5 id="使用同步-API"><a href="#使用同步-API" class="headerlink" title="使用同步 API"></a>使用同步 API</h5><p>想修复前面的 <code>inconsistentRead</code> 函数，一种可能的方案就是令其彻底变成同步的。实际上 Node.js 针对基础的 I/O 操作提供了一系列同步的 API。比如 <code>fs.readFileSync</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFileSync&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadSync</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(filename)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = readFileSync(filename)</span><br><span class="line">    cache.set(filename, data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，使用同步 API 而不是异步 API 也有一定的风险：</p><ul><li>针对特定功能的同步 API 有可能不存在</li><li>同步 API 会阻塞 event loop，暂停任何并发请求。从而破坏 Node.js 的并发模型并拖慢整个应用</li></ul><p>在很多情况下，使用同步 I/O 操作在 Node.js 里都是非常不推荐的。但在一些场景下，同步 I/O 可能是最简单和高效的方案。比如在应用启动时使用同步阻塞 API 加载配置文件。</p><h5 id="通过延迟执行保证异步性"><a href="#通过延迟执行保证异步性" class="headerlink" title="通过延迟执行保证异步性"></a>通过延迟执行保证异步性</h5><p>另一种修复 <code>inconsistentRead</code> 函数的方案就是，将其变成纯异步操作。诀窍就是将同步的回调函数延期到“未来”执行，而不是在同一个 event loop 周期里立即被调用。<br>在 Node.js 中，可以通过 <code>process.nextTick()</code> 来实现。它会接收一个回调函数作为参数，将其推入到事件队列顶部，位于所有 pending 的 I/O 事件之前，然后立即返回。回调函数会在 event loop 再次收回控制权时立即被调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// deferred callback invocation</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache.get(filename)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Node-js-回调函数的最佳实践"><a href="#Node-js-回调函数的最佳实践" class="headerlink" title="Node.js 回调函数的最佳实践"></a>Node.js 回调函数的最佳实践</h4><h5 id="回调函数出现在最后"><a href="#回调函数出现在最后" class="headerlink" title="回调函数出现在最后"></a>回调函数出现在最后</h5><p>在所有核心的 Node.js 函数中，当其接收一个回调函数作为输入时，回调函数必须作为最后一个参数传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readFile(filename, [options], callback)</span><br></pre></td></tr></table></figure></p><h5 id="error-总是出现在前面"><a href="#error-总是出现在前面" class="headerlink" title="error 总是出现在前面"></a>error 总是出现在前面</h5><p>在 Node.js 中，任何 CPS 函数产生的错误都必须作为回调函数的第一个参数传递，任何实际的执行结果都从第二个参数开始。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    handleError(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processData(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最佳实践还在于总是检查 error 是否存在，以及 error 的定义必须是 <code>Error</code> 类型。</p><h5 id="传递-error"><a href="#传递-error" class="headerlink" title="传递 error"></a>传递 error</h5><p>在同步的函数中，传递 error 可以通过常用的 <code>throw</code> 语句。而在异步的 CPS 函数中，则可以简单地将 error 传递给链条上的下一个回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSON</span>(<span class="params">filename, callack</span>) </span>&#123;</span><br><span class="line">  readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsed</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// propagate the error and exit the current function</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// parse the file contents</span></span><br><span class="line">      parsed = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// catch parsing errors</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no errors, propagate just the data</span></span><br><span class="line">    callack(<span class="literal">null</span>, parsed)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在 Node.js 中另外一种非常重要和基础的模式就是<strong>观察者（Ovserver）模式</strong>。同 Reactor 模式、回调函数一起，它们都是掌握 Node.js 异步编程的绝对要求。<br>观察者模式定义了一类称为 subject 的对象，它们可以在状态改变时向一系列称为观察者的对象发送通知。它是对回调函数的完美补充。主要区别在于 subject 能够通知多个观察者，而传统的 CPS 回调函数通常只会将结果传递给一个 listener。</p><h4 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h4><p>观察者模式实际上已经通过 <code>EventEmitter</code> 类内置到 Node.js 的核心中了。<code>EventEmitter</code> 类允许我们注册一个或者多个函数作为 listener，这些 listener 会在特定的事件触发时自动被调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9577c60299839e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Listeners receiving events from an EventEmitter"></p><p><code>EventEmitter</code> 类的基础方法如下：</p><ul><li><code>on(event, listener)</code>：该方法允许我们为指定的事件类型（一个字符串）注册一个新的 listener（一个函数）</li><li><code>once(event, listener)</code>：该方法允许我们注册一个新的 listener，并且该 listener 会在事件触发一次之后自动被移除</li><li><code>emit(event, [arg1], [...])</code>：该方法会产生一个新的事件，并向指定向 listeners 传递的额外的参数</li><li><code>removeListener(event, listener)</code>：该方法用来移除某个 listener</li></ul><p>上述所有的方法都会返回一个 <code>EventEmitter</code> 实例并允许被串联起来。</p><h5 id="创建和使用-EventEmitter"><a href="#创建和使用-EventEmitter" class="headerlink" title="创建和使用 EventEmitter"></a>创建和使用 EventEmitter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findRegex</span>(<span class="params">files, regex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> emitter.emit(<span class="string">'error'</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      emitter.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line">      <span class="keyword">const</span> match = content.match(regex)</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> emitter.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> emitter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findRegex([<span class="string">'fileA.txt'</span>, <span class="string">'fileB.json'</span>], /hello \w+<span class="regexp">/g)</span></span><br><span class="line"><span class="regexp">  .on('fileread', file =&gt; console.log(`$&#123;file&#125; was read`))</span></span><br><span class="line"><span class="regexp">  .on('found', (file, match) =&gt; console.log(`Matched "$&#123;match&#125;" in $&#123;file&#125;`))</span></span><br><span class="line"><span class="regexp">  .on('error', err =&gt; console.error(`Error emitted $&#123;err.message&#125;`))</span></span><br></pre></td></tr></table></figure><h5 id="令任意对象变得“可监测”"><a href="#令任意对象变得“可监测”" class="headerlink" title="令任意对象变得“可监测”"></a>令任意对象变得“可监测”</h5><p>在 Node.js 的世界里，<code>EventEmitter</code> 很少像上面的例子那样被直接使用。更为常见的情况是其他类继承 <code>EventEmitter</code> 从而变成一个可监测的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindRegex</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(regex) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.regex = regex</span><br><span class="line">    <span class="keyword">this</span>.files = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addFile(file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.files.push(file)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> <span class="keyword">this</span>.files) &#123;</span><br><span class="line">      readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> match = content.match(<span class="keyword">this</span>.regex)</span><br><span class="line">        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">          match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRegexInstance = <span class="keyword">new</span> FindRegex(<span class="regexp">/hello \w+/g</span>)</span><br><span class="line">findRegexInstance</span><br><span class="line">  .addFile(<span class="string">'fileA.txt'</span>)</span><br><span class="line">  .addFile(<span class="string">'fileB.json'</span>)</span><br><span class="line">  .find()</span><br><span class="line">  .on(<span class="string">'found'</span>, (file, match) =&gt; <span class="built_in">console</span>.log(<span class="string">`Matched "<span class="subst">$&#123;match&#125;</span>" in file <span class="subst">$&#123;file&#125;</span>`</span>))</span><br><span class="line">  .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.error(<span class="string">`Error emitted <span class="subst">$&#123;err.message&#125;</span>`</span>))</span><br></pre></td></tr></table></figure></p><h4 id="EventEmitter-vs-Callback"><a href="#EventEmitter-vs-Callback" class="headerlink" title="EventEmitter vs Callback"></a>EventEmitter vs Callback</h4><p>以下的几点可以作为选择 EventEmitter 还是 Callback 的依据：</p><ul><li>当涉及到需要支持不同类型的事件时，Callback 会有一定的限制。实际上 Callback 也可以区分多个事件，只需要将事件类型作为参数传给回调函数，或者接收多个回调函数。但在这样的情况下，EventEmitter 可以提供更优雅的接口和更精简的代码</li><li>当同样的事件可能多次发生或者根本不会发生时，应该使用 EventEmitter。而无论操作是否成功，回调函数都只会被调用一次</li><li>回调函数机制只支持通知一个特定的 listener，而 EventEmitter 允许我们为同一个事件注册多个 listener</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。&lt;/p&gt;
&lt;p&gt;而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Callback" scheme="https://rollingstarky.github.io/tags/Callback/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Observer" scheme="https://rollingstarky.github.io/tags/Observer/"/>
    
      <category term="Asynchronous" scheme="https://rollingstarky.github.io/tags/Asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Node.js 的设计哲学和原理</title>
    <link href="https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/"/>
    <id>https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/</id>
    <published>2022-09-04T16:00:00.000Z</published>
    <updated>2022-09-07T14:02:50.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Node-js-哲学"><a href="#一、Node-js-哲学" class="headerlink" title="一、Node.js 哲学"></a>一、Node.js 哲学</h4><p>每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受的指导原则和规范。这些规范对语言平台本身的演进以及如何设计和开发应用都有着深刻的影响。</p><h5 id="小的核心"><a href="#小的核心" class="headerlink" title="小的核心"></a>小的核心</h5><p>Node.js 核心，包含 Node.js 运行时以及所有内置的模块。这个核心遵循一系列基本的设计原则。其中一个就是<strong>尽可能只实现所需功能的最小集合</strong>，在此之外的非核心功能则由用户自行实现。用户自己开发的模块围绕在核心周围，形成了一个自由开放的软件生态。<br>将核心的功能限制在最小程度，其他的需求则给与社区足够的自由度，去验证和实现更广泛的解决方案。不仅提升了核心本身的可维护性，同时也给整个生态环境带来了正向的文化氛围。</p><h5 id="小的模块"><a href="#小的模块" class="headerlink" title="小的模块"></a>小的模块</h5><p>Node.js 使用<strong>模块（module）</strong>这个概念来表示程序代码的基础构件，模块是构成应用和库的基本单位。<br>在 Node.js 中，一个广受推崇的原则就是，设计小的模块和包。这里的“小”不仅仅是指代码本身的规模，更为关键的是功能上的“小”和集中。<br>上述原则深受 Unix 设计哲学的影响，即：</p><ul><li>Small is beautiful（小即为美）</li><li>Make each program do one thing well（只做好一件事）</li></ul><p>小的模块具有以下特点：</p><ul><li>更容易理解和使用</li><li>更容易测试和维护</li><li>体积小，在浏览器上运行有优势</li></ul><p>更小、更集中的模块鼓励每一个人共享和重用每一段哪怕是最小的代码块，在一定程度上提升了代码的可重用性。牢记 <strong>Don’t Repeat Yourself (DRY)</strong> 原则。</p><h5 id="Small-surface-area"><a href="#Small-surface-area" class="headerlink" title="Small surface area"></a>Small surface area</h5><p>除了在代码量和功能性上更小以外，Node.js 模块的另一个理想特征就是，尽可能向外界公开一组最小的功能集合。这可以帮助我们实现更清晰、不容易被错误使用的 API。模块只向外暴露单一的功能，只向外提供唯一一个清晰的、明确无误的入口。</p><p>很多 Node.js 模块的另一个特点是，模块本身被创建出来，是为了被使用而不是被扩展。通过禁止任何扩展来锁定模块内部，听起来缺乏一定的灵活性。但同时也带来了减少用例、简化实现、增强可维护性、提升可用性等优势。<br>在实践中，这意味着更倾向于对外暴露函数而不是类，避免向外部世界泄露任何内部的细节。</p><h5 id="简单性和实用主义"><a href="#简单性和实用主义" class="headerlink" title="简单性和实用主义"></a>简单性和实用主义</h5><p><strong>Keep It Simple, Stupid (KISS)</strong><br>设计简单的，而不是“完美”的、功能完备的软件，在实践中往往是更优的选择：</p><ul><li>更少的时间和资源去实现</li><li>更快地完成交付</li><li>更容易适应不断变化和增加的需求</li><li>更容易理解和维护</li></ul><p>JavaScript 是一种非常“现实”的语言。在实践中，经常见到使用更简单的类、函数和闭包替换复杂的层级结构的类。<br>纯粹的 OO 设计常常致力于使用数学模型完整地复制现实世界，并没有考虑到现实本身的“不完美”和复杂性。事实上，我们的软件一直都是对现实世界的接近，如果能够放弃创建“完美”软件的执念，尝试构造一个有着合理复杂度、能够快速工作的成品，有可能会获取到更大的成功。</p><h4 id="二、Node-js-核心原理"><a href="#二、Node-js-核心原理" class="headerlink" title="二、Node.js 核心原理"></a>二、Node.js 核心原理</h4><h5 id="I-O-很慢"><a href="#I-O-很慢" class="headerlink" title="I/O 很慢"></a>I/O 很慢</h5><p>在计算机的世界里，I/O 算得上基础操作里最慢的一种了。比如访问 RAM 的速度处于纳秒（10^-9）量级，而访问磁盘或者网络数据的速度则处于毫秒（10^-3）量级。I/O 操作通常并不消耗多少 CPU 资源，但它实际上在请求发出和操作完成之间增添了很大的延迟。<br>此外，我们还必须考虑人为因素。很多场景下应用的输入依赖于具体的个人，比如点击鼠标等。从而导致现实里的 I/O 速度，有可能比纯技术层面的磁盘和网络读写要慢得多。</p><h5 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h5><p>在传统的阻塞式 I/O 编程中，I/O 请求关联的函数调用会阻塞线程的执行，直到 I/O 操作完成。这会导致一定程度的延迟，有可能是毫秒级别，比如 I/O 操作涉及到磁盘读写；也有可能长达几分钟甚至更久，比如等待用户提供某些输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks the thread until the data is available</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// data is available</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>很明显，由阻塞式 I/O 实现的 Web 服务无法在同一个线程中同时处理多个连接请求，因为 socket 上的每个 I/O 操作都会阻塞任何其他连接的访问。解决此问题的传统方法就是借助多线程，每个独立的线程分别处理并发连接中的一个请求。<br>一个线程被 I/O 操作阻塞，并不会影响其他的线程继续提供服务。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f4675436ce4d0fd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using multiple threads to process multiple connections"></p><p>多线程的缺点在于，从资源消耗的角度看，线程并不是一个低廉的选择。他会消耗内存，引发上下文切换等。一个长时间运行的只处理一个网络请求的线程，实际上有可能大部分时间并没有在工作，这意味着对内存和 CPU 资源的浪费。</p><h5 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h5><p>除了阻塞式 I/O 外，现代的操作系统还支持另一种访问资源的机制，称为<strong>非阻塞式 I/O</strong>。在这种模式下，系统调用会立即返回，无需等待读写操作彻底完成。若返回时还没有获取到任何结果，则返回一个预定义的对象，该对象表明此时没有任何数据可以获取到。<br>处理非阻塞式 I/O 的最基本的模式就是，通过循环主动轮询资源池中的资源，直到某个对象返回了实际的数据。这种方式称为 <strong>busy-waiting</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, fileA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (resource <span class="keyword">of</span> resources) &#123;</span><br><span class="line">    <span class="comment">// try to read</span></span><br><span class="line">    data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// there is no data to read at the moment</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the list</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//some data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述简单的机制，不同的资源即能够在同一个线程中被处理。但仍然不够高效。实际上，CPU 的大部分时钟都被循环用来查询还没有准备好的资源，轮询算法通常意味着 CPU 资源的大量浪费。</p><h5 id="解多路复用"><a href="#解多路复用" class="headerlink" title="解多路复用"></a>解多路复用</h5><p>Busy-waiting 并不是处理非阻塞资源的理想技术，好在现代的大部分操作系统还提供了一种高效的原生机制，专门用来处理并发的非阻塞需求。该机制称为 <strong>synchronous event demultiplexer</strong> 或 <strong>event notification interface</strong>。<br><strong>multiplexing</strong> 是指将多路信号合并到一条通信链路中进行传输；<strong>demultiplexing</strong> 则是指相反的操作，将合并到一条链路中的数据重新还原成原本的多路信号。</p><p>synchronous event demultiplexer 会同时监听多个资源，当其中任何一个资源对应的读写操作完成时，就会返回一个或一系列新的事件。它的优势在于 <strong>synchronous</strong>，即它是<strong>同步</strong>的，当没有任何新的事件需要处理时，它会一直处于阻塞状态。<br>因而我们可以在同一个线程中处理多个 I/O 操作，同时不至于像 busy-waiting 那样持续轮询消耗资源。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1a479833a864587d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using a single thread to process multiple connections"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watchedList.add(socketA, FOR_READ)</span><br><span class="line">watchedList.add(fileB, FOR_READ)</span><br><span class="line"><span class="keyword">while</span> (events = demultiplexer.watch(watchedList)) &#123;</span><br><span class="line">  <span class="comment">// event loop</span></span><br><span class="line">  <span class="keyword">for</span> (event <span class="keyword">of</span> events) &#123;</span><br><span class="line">    <span class="comment">// This read will never block and will always return data</span></span><br><span class="line">    data = event.resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the watched list</span></span><br><span class="line">      demultiplexer.unwatch(event.resource)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// some actual data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>demultiplexer.watch()</code> 方法是同步的，当它监听的资源没有任何一个准备好时，它会一直处于阻塞状态。直到有任意资源准备好后，才会返回一系列新的事件。这个时间点返回的事件及其关联的资源由于是已经“准备好”的，可以被直接读取而不会阻塞。</p><h5 id="Reactor-pattern"><a href="#Reactor-pattern" class="headerlink" title="Reactor pattern"></a>Reactor pattern</h5><p>Reactor 模式背后的主要理念，就是给每一个 I/O 操作绑定一个 handler。在 Node.js 中可以使用回调函数来表示 handler。当某个事件被 event loop 生产和处理完之后，对应的 handler 就会立即被触发。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1c7eb9186ecf94f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The reactor pattern"></p><ul><li>应用首先向 <strong>Event Demultiplexer</strong> 提交一个请求，由此生成一个新的 I/O 操作。与此同时应用会为该请求绑定一个 handler，当 I/O 操作结束时自动被调用。向 Event Demultiplexer 提交请求的操作是非阻塞的，该操作提交后程序控制权会立即返还给应用</li><li>当一系列 I/O 操作完成后，Event Demultiplexer 会向 <strong>Event Queue</strong> 中推入对应的事件</li><li><strong>Event Loop</strong> 会不断遍历 Event Queue 中的事件，调用每一个事件对应的 handler</li><li>handler 代码实际上是应用本身的一部分，它在执行完毕后又会把控制权给到 Event Loop。在 handler 执行的过程中，应用仍然可以向 Event Demultiplexer 提交新的异步操作请求</li></ul><p>简单来说，所谓的异步行为，就是应用先在某个时间点表达出想要访问某个资源的兴趣（这个操作是非阻塞的），并给这个资源定义一个 handler。在另一个时间节点当资源能够被访问之后，绑定的 handler 自动被调用，处理对应的资源。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、Node-js-哲学&quot;&gt;&lt;a href=&quot;#一、Node-js-哲学&quot; class=&quot;headerlink&quot; title=&quot;一、Node.js 哲学&quot;&gt;&lt;/a&gt;一、Node.js 哲学&lt;/h4&gt;&lt;p&gt;每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="KISS" scheme="https://rollingstarky.github.io/tags/KISS/"/>
    
      <category term="DRY" scheme="https://rollingstarky.github.io/tags/DRY/"/>
    
      <category term="Reactor" scheme="https://rollingstarky.github.io/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Template 模式</title>
    <link href="https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/"/>
    <id>https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-07-18T11:52:30.745Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Template</strong> 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。<br>之后由虚拟基类的子类来实现上述组件中缺失的未定义部分，这部分之前未定义的方法称为 <strong>template methods</strong>。<br>此模式的目的在于，定义一系列属于“同一家族”的类，能够囊括某个组件的所有变体。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-766fa71787b062ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML of Template pattern"></p><p>Template 和 Strategy 模式的目的是非常相似的，它们之间的区别主要在于结构和实现。<br>两者都允许我们在共享组件中通用部分的同时，修改组件中变化的部分，以此形成不同的变体。不同的地方在于，Strategy 是在运行时<strong>动态</strong>实现的，而 Template 则在子类定义的时刻就已经被确定了。</p><h4 id="配置管理模板"><a href="#配置管理模板" class="headerlink" title="配置管理模板"></a>配置管理模板</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> template &amp;&amp; <span class="built_in">cd</span> template</span><br><span class="line">npm install ini</span><br><span class="line">npm install objec-<span class="built_in">path</span></span><br></pre></td></tr></table></figure><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>configTemplate.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> objectPath <span class="keyword">from</span> <span class="string">'object-path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> load(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>._deserialize(</span><br><span class="line">      <span class="keyword">await</span> fsPromises.readFile(file, <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> save(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> fsPromises.writeFile(file, <span class="keyword">this</span>._serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(path) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(path, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, path, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'_serialize() must be implemented'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _deserialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`_deserialize() must be implemented`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>configTemplate</code> 虚拟基类实现了配置管理逻辑中的通用部分，即加载和保存文件、获取和设置属性。同时不对序列化和反序列化部分的逻辑进行定义，从而可以通过再创建不同的 Config 子类（即后面的 <code>jsonConfig</code> 和 <code>iniConfig</code>）来实现具体的序列化逻辑，进而支持特定的配置文件格式。</p><p><code>jsonConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>iniConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"><span class="keyword">import</span> ini <span class="keyword">from</span> <span class="string">'ini'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">IniConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;JsonConfig&#125; <span class="keyword">from</span> <span class="string">'./jsonConfig.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;IniConfig&#125; <span class="keyword">from</span> <span class="string">'./iniConfig.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> jsonConfig = <span class="keyword">new</span> JsonConfig()</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.load(<span class="string">'samples/conf.json'</span>)</span><br><span class="line">  jsonConfig.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.save(<span class="string">'samples/conf_mod.json'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> iniConifg = <span class="keyword">new</span> IniConfig()</span><br><span class="line">  <span class="keyword">await</span> iniConifg.load(<span class="string">'samples/conf.ini'</span>)</span><br><span class="line">  iniConifg.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> iniConifg.save(<span class="string">'samples/conf_mod.ini'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Template&lt;/strong&gt; 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。&lt;br&gt;之后由虚拟基类的子类来实现上述组件中缺失的未
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Javascript" scheme="https://rollingstarky.github.io/tags/Javascript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Template" scheme="https://rollingstarky.github.io/tags/Template/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
  </entry>
  
</feed>
