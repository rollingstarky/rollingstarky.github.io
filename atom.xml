<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2022-01-15T11:49:22.737Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 使用 ConfigMaps、Secrets 和 Downward API 配置应用</title>
    <link href="https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/"/>
    <id>https://rollingstarky.github.io/2022/01/15/kubernetes-in-action-reading-notes-config-maps-secrets-and-downward-api/</id>
    <published>2022-01-14T16:00:00.000Z</published>
    <updated>2022-01-15T11:49:22.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="设置命令、参数和环境变量"><a href="#设置命令、参数和环境变量" class="headerlink" title="设置命令、参数和环境变量"></a>设置命令、参数和环境变量</h4><p>同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、文件等完成配置。<br>比如容器启动时执行的命令可以由 Dockerfile 中的 <code>ENTRYPOINT</code> 选项指定；命令参数通常由 <code>CMD</code> 选项指定；环境变量则可以使用 <code>ENV</code> 选项指定；假如应用通过文件进行配置，则这些配置文件可以借助 <code>COPY</code> 选项复制到容器镜像中。</p><p>下面是一个名为 <code>kiada</code> 的示例应用。<br><code>Dockerfile</code> 配置文件：<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">12</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> app.js /app.js</span></span><br><span class="line"><span class="bash">COPY html /html</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENV INITIAL_STATUS_MESSAGE=<span class="string">"This is the default status message"</span></span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"node"</span>, <span class="string">"app.js"</span>]</span></span><br><span class="line"><span class="bash">CMD [<span class="string">"--listen-port"</span>, <span class="string">"8080"</span>]</span></span><br></pre></td></tr></table></figure></p><p>其他文件如 <code>html</code>、<code>app.js</code> 可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09/kiada-0.4" target="_blank" rel="noopener">Github</a> 处获取。同时构建好的镜像也被作者放到了 Dockerhub 的 <code>luksa/kiada:0.4</code> 位置。</p><p>借助上述 Dockerfile，应用的监听端口可以通过 <code>--listen-port</code> 命令参数配置；同时应用会读取环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来获取初始状态信息。</p><p>将配置硬编码进容器的镜像，事实上和将配置硬编码到应用的源代码中一样，都不是理想的情况。因为每当应用需要修改配置，都必须再重新 build 一遍镜像。此外，还必须避免在镜像中包含敏感的配置信息，比如认证数据或密钥等。<br>将上述配置文件放置在 Volume 中并挂载到容器上，相对而言更安全一点。</p><h5 id="配置命令和参数"><a href="#配置命令和参数" class="headerlink" title="配置命令和参数"></a>配置命令和参数</h5><p>在创建镜像时，容器启动时执行的命令和参数分别由 Dockerfile 中的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 选项指定。<br>Kubernetes 提供了两个同样功能的字段：<code>commands</code> 和 <code>args</code>。假如在 Pod 的清单文件中指定了 <code>commands</code> 和 <code>args</code>，或者其中任何一个字段，则 Dockerfile 中对应的 <code>ENTRYPOINT</code> 和 <code>CMD</code> 配置会被覆盖。</p><p><strong>设置命令</strong><br>假如需要在运行 Kiada 应用时启用 CPU 和 heap 优化，对于 Node.js 而言，可以在执行时传入 <code>--cpu-prof</code> 和 <code>--heap-prof</code> 参数。<br>相对于修改 Dockerfile 重新 build 镜像，其实可以直接修改 Pod 的清单文件。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">node</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--cpu-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--heap-prof</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">app.js</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><strong>设置命令参数</strong><br>比如需要将 Dockerfile 中的命令参数 <code>--listen-port 8080</code> 改为 <code>--listen-port 9090</code>，可以使用如下配置的 Pod 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">9090</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>容器在创建时会自动组合 Dockerfile 中的 <code>ENTRYPOINT</code> 和 Pod 清单文件中的 <code>args</code>。</p><h5 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h5><p><strong>为环境变量设置字面量值</strong><br>Kiada 应用在运行时会显示 Pod 的名字，该名称由应用源代码从环境变量 <code>POD_NAME</code> 读取。此外还可以通过修改环境变量 <code>INITIAL_STATUS_MESSAGE</code> 来更改状态信息。</p><p>为了修改上述环境变量，可以向 Dockerfile 中添加 <code>ENV</code> 选项并重新构建镜像，但更快速的方式时向 Pod 的清单文件中添加 <code>env</code> 选项。<br>示例清单文件如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        value:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">pod</span> <span class="string">spec.</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">        containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用上述 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada-env.yml</span></span><br><span class="line">pod/kiada unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">POD_NAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the pod spec.</span><br><span class="line">KUBERNETES_SERVICE_PORT=443</span><br><span class="line">KUBERNETES_SERVICE_PORT_HTTPS=443</span><br><span class="line">KUBERNETES_PORT=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP=tcp://10.96.0.1:443</span><br><span class="line">KUBERNETES_PORT_443_TCP_PROTO=tcp</span><br><span class="line">KUBERNETES_PORT_443_TCP_PORT=443</span><br><span class="line">KUBERNETES_PORT_443_TCP_ADDR=10.96.0.1</span><br><span class="line">KUBERNETES_SERVICE_HOST=10.96.0.1</span><br><span class="line">NODE_VERSION=16.11.1</span><br><span class="line">YARN_VERSION=1.22.15</span><br><span class="line">HOME=/root</span><br></pre></td></tr></table></figure></p><p><strong>使用变量引用</strong><br>除了给环境变量设置一个固定值外，还可以采用 <code>$(VAR_NAME)</code> 格式引用其他变量。如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">My</span> <span class="string">name</span> <span class="string">is</span> <span class="string">$(POD_NAME).</span> <span class="string">I</span> <span class="string">run</span> <span class="string">NodeJS</span> <span class="string">version</span> <span class="string">$(NODE_VERSION).</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>引用的变量中，<code>POD_NAME</code> 是在同一个 Pod 清单文件中定义的，<code>NODE_VERSION</code> 是在容器镜像中定义的。<br>最终的状态信息会显示为 <code>My name is kiada. I run NodeJS version $(NODE_VERSION).</code>，因为此方式只支持引用同一个 Pod 清单文件中定义的变量，且该变量必须在引用位置之前定义。</p><p><strong>在命令和参数中使用变量引用</strong><br>还可以在命令和参数中引用清单文件中定义的变量。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    args:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="bullet">--listen-port</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">$(LISTEN_PORT)</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">LISTEN_PORT</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"9090"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9090</span></span><br></pre></td></tr></table></figure></p><h4 id="使用-config-map-将配置与-Pod-解耦"><a href="#使用-config-map-将配置与-Pod-解耦" class="headerlink" title="使用 config map 将配置与 Pod 解耦"></a>使用 config map 将配置与 Pod 解耦</h4><p>在前面的章节中，可以将应用的配置硬编码进 Pod 的 yaml 清单文件中。这种方式比将配置硬编码到容器镜像中要好很多，即不需要每次修改配置后都必须重新构建镜像。<br>但这种方式也有一定的缺陷，它意味着比如针对不同环境的部署（development、staging、production 等），可能需要多个不同版本的清单文件。<br>为了在多个环境下重复利用同一个清单文件，最好是将配置与 Pod 的清单文件解耦。</p><h5 id="ConfigMaps-介绍"><a href="#ConfigMaps-介绍" class="headerlink" title="ConfigMaps 介绍"></a>ConfigMaps 介绍</h5><p>ConfigMap 是一种包含一系列键值对的 Kubernetes API 对象。其中的值可以是短字符串，也可以是一大段结构化的文本。Pod 可以引用一个或多个 ConfigMap 中的值。<br>一个 Pod 可以引用多个 ConfigMaps，多个 Pods 可以使用同一个 ConfigMap。</p><p>如下图所示，ConfigMap 中的键值对通常作为环境变量传递给 Pod，或者通过 ConfigMap Volume 作为文件挂载到容器的文件系统中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-9c8df1bf7a6cd5ea.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods use config maps through environment variables andconfigMap volumes"></p><p>将配置保存在一个独立的 ConfigMap 对象中，而不是直接保存在 Pod 里。这使得在不同的环境中能够部署同一个 Pod 清单文件，与此同时应用不同的配置（引用不同的 ConfigMap 对象）。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-674fcbf8eedefb8e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying the same pod manifest and different configmap manifests in different environments"></p><h5 id="创建-ConfigMap-对象"><a href="#创建-ConfigMap-对象" class="headerlink" title="创建 ConfigMap 对象"></a>创建 ConfigMap 对象</h5><p><strong>从 YAML 文件创建 ConfigMap</strong><br><code>cm.kiada-config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  status-message:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>kubectl apply -f cm.kiada-config.yml</code> 命令创建清单文件中定义的 ConfigMap 对象。</p><p><strong>查看 ConfigMap</strong><br>可以使用 <code>kubectl get cm</code> 命令列出 ConfigMap 对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME               DATA   AGE</span><br><span class="line">kiada-config       1      6s</span><br><span class="line">kube-root-ca.crt   1      55d</span><br></pre></td></tr></table></figure></p><p>可以使用如下命令查看 ConfigMap 的详细信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o yaml</span></span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  status-message: This status message is set in the kiada-config config map</span><br><span class="line">kind: ConfigMap</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    kubectl.kubernetes.io/last-applied-configuration: |</span><br><span class="line">      &#123;"apiVersion":"v1","data":&#123;"status-message":"This status message is set in the kiada-config config map"&#125;,"kind":"ConfigMap","metadata":&#123;"annotations":&#123;&#125;,"name":"kiada-config","namespace":"default"&#125;&#125;</span><br><span class="line">  creationTimestamp: "2022-01-10T05:11:35Z"</span><br><span class="line">  name: kiada-config</span><br><span class="line">  namespace: default</span><br><span class="line">  resourceVersion: "99447"</span><br><span class="line">  uid: e39e2676-2183-4582-9922-eac963b81093</span><br></pre></td></tr></table></figure></p><p>若只想精确地查找 ConfigMap 中的配置项，可以使用如下命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq .data</span></span><br><span class="line">&#123;</span><br><span class="line">  "status-message": "This status message is set in the kiada-config config map"</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm kiada-config -o json | jq <span class="string">'.data["status-message"]'</span></span></span><br><span class="line">"This status message is set in the kiada-config config map"</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的值注入到环境变量"><a href="#将-ConfigMap-中的值注入到环境变量" class="headerlink" title="将 ConfigMap 中的值注入到环境变量"></a>将 ConfigMap 中的值注入到环境变量</h5><p><code>pod.kiada.env-valueFrom.yml</code><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">      env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">INITIAL_STATUS_MESSAGE</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          configMapKeyRef:</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">            key:</span> <span class="string">status-message</span></span><br><span class="line"><span class="attr">            optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看环境变量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.env-valueFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p><strong>注入整个 ConfigMap</strong><br>容器定义中的 <code>env</code> 字段接收的是由值组成的列表，因此可以同时设置多个环境变量。实际上可以使用 <code>envFrom</code> 注入整个 ConfigMap 中定义的多个值，而无需像 <code>valueFrom</code> 那样分别指定每一个键。<br>唯一需要注意的是，ConfigMap 中的键必须与实际的环境变量名称保持一致。即之前使用的键 <code>status-message</code> 必须改成 <code>INITIAL_STATUS_MESSAGE</code>。</p><p><code>cm.kiada-config.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  INITIAL_STATUS_MESSAGE:</span> <span class="string">This</span> <span class="string">status</span> <span class="string">message</span> <span class="string">is</span> <span class="string">set</span> <span class="string">in</span> <span class="string">the</span> <span class="string">kiada-config</span> <span class="string">config</span> <span class="string">map</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl replace</code> 命令更新 ConfigMap：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">$</span> <span class="string">kubectl</span> <span class="string">replace</span> <span class="bullet">-f</span> <span class="string">cm.kiada-config.yml</span></span><br><span class="line"><span class="string">configmap/kiada-config</span> <span class="string">replaced</span></span><br></pre></td></tr></table></figure></p><p>创建 Pod 清单文件 <code>pod.kiada.envFrom.yml</code>：<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    envFrom:</span></span><br><span class="line"><span class="attr">    - configMapRef:</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">kiada-config</span></span><br><span class="line"><span class="attr">        optional:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 Pod 清单文件并查看效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kubectl delete -f pod.kiada.env-valueFrom.yml</span><br><span class="line">pod "kiada" deleted</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada.envFrom.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada -- env</span></span><br><span class="line">PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin</span><br><span class="line">HOSTNAME=kiada</span><br><span class="line">INITIAL_STATUS_MESSAGE=This status message is set in the kiada-config config map</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><h5 id="将-ConfigMap-中的配置项作为文件嵌入到容器"><a href="#将-ConfigMap-中的配置项作为文件嵌入到容器" class="headerlink" title="将 ConfigMap 中的配置项作为文件嵌入到容器"></a>将 ConfigMap 中的配置项作为文件嵌入到容器</h5><p>环境变量通常用于向应用传递较小的单行的值，而多行的数据通常作为文件传递。<br>ConfigMap 中的配置项可以包含大块的数据，通过特殊的 ConfigMap volume 类型将这些数据以文件的形式注入到容器中。</p><p><strong>从文件创建 ConfigMaps</strong><br>除了直接在集群中创建 ConfigMap 对象之外，还可以先创建一个用于描述 ConfigMap 的 YAML 清单文件，从而可以将其保存到版本控制系统中。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create configmap kiada-envoy-config \</span></span><br><span class="line">--from-file=envoy.yaml \</span><br><span class="line">--from-file=dummy.bin \</span><br><span class="line">--dry-run=client -o yaml &gt; cm.kiada-envoy-config.yml</span><br></pre></td></tr></table></figure></p><p>其中 dummy.bin 和 <code>envoy.yaml</code> 两个文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter09" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 <code>kiada-envoy-config</code> 的 ConfigMap 的 YAML 描述文件。当命令中使用了 <code>--dry-run</code> 选项时，该命令并不会在 API server 创建新对象，而是只生成对象的定义。后续可继续运行 <code>kubectl apply -f xxx.yml</code> 命令创建对象。</p><p>生成的 <code>cm.kiada-envoy-config.yml</code> 文件的具体内容如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">binaryData:</span></span><br><span class="line">  <span class="string">dummy.bin:</span> <span class="string">n2VW39IEkyQ6Jxo+rdo5J06Vi7cz5XxZzkPOtN7MOGyXxVzWv07vUz8bxY5h4njJfZixwhPwoGepLnGZdRGw1qgpFB9HpyLsqVZ6jAwjjHD0afxxwEjb6+wofmgGmS1E3U9BZScMPZGWJK7RGzZmQOeJeDPIt/1tBvQYwzMc8wu6owky4Ri3rOY9PlFnp5VOTzvBZadW8scbqtntJeWCtJFoS0AH2y4ZFyJPJ0l0V3JpY1qunnz60CyAMO9v1DgB2PUQUG/1HH89bpzf2OyMvHUJmOTIDZOh3D7aAEuYQ/6hU0uQsQ/K7Xx/nM9TA0RzEzuh8RBoXdkAvQPP5jk7yM2DqxG/CiHVp+7CDRFWgEN2GFd76RfO+pIoOFbD1Xm4yE/JBljOA9ztwm865m3A4l2ToT2p7ZWHKmdZe8pXz4ZwIGBYDUHHNVQW5UUnf0Jbd9UR8GJ//gmbxLfVxjC/lMSWGUqCpYO4YdBPjXQGM1xdxE+YP3Pzso6Z4rw27RJu5KEc2yPMxFY9dpFyVufP81kS19glNiQq+LM4B9EFPrNW1hqi+1Tb8ni+aFkriH1YuvHepIH0Px/ifFLgn+yDgwDs4UfMru2j4t5zAftUa0i6m3sH5adKcx4aCXYN9ijvEvjRmkcB/VJU6Zbd65UZVgD1Nwt2ZCrkoEdqO3Oe1/o=</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line">  <span class="string">envoy.yaml:</span> <span class="string">|</span></span><br><span class="line"><span class="string"></span><span class="attr">    admin:</span></span><br><span class="line"><span class="attr">      access_log_path:</span> <span class="string">/tmp/envoy.admin.log</span></span><br><span class="line"><span class="attr">      address:</span></span><br><span class="line"><span class="attr">        socket_address:</span></span><br><span class="line"><span class="attr">          protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">          address:</span> <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span></span><br><span class="line"><span class="attr">          port_value:</span> <span class="number">9901</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-envoy-config</span></span><br></pre></td></tr></table></figure></p><p><strong>在 Pod 中使用 ConfigMap</strong><br>为了令 ConfigMap 能够作为文件呈现在容器的文件系统中，需要在 Pod 中定义一个 ConfigMap Volume 并将其挂载到容器里。<br>参考下面的 <code>pod.kiada-ssl.configmap-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada-ssl-proxy:0.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>创建 <code>kiada-envoy-config</code> ConfigMap：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f cm.kiada-envoy-config.yml</span></span><br><span class="line">configmap/kiada-envoy-config created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get cm</span></span><br><span class="line">NAME                 DATA   AGE</span><br><span class="line">kiada-config         1      46h</span><br><span class="line">kiada-envoy-config   2      13s</span><br><span class="line">kube-root-ca.crt     1      57d</span><br></pre></td></tr></table></figure></p><p>创建 Pod 并查看文件挂载情况：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f pod.kiada-ssl.configmap-volume.yml</span></span><br><span class="line">pod/kiada-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls /etc/envoy</span></span><br><span class="line">dummy.bin</span><br><span class="line">envoy.yaml</span><br></pre></td></tr></table></figure></p><h5 id="理解-ConfigMap-Volume-是如何工作的"><a href="#理解-ConfigMap-Volume-是如何工作的" class="headerlink" title="理解 ConfigMap Volume 是如何工作的"></a>理解 ConfigMap Volume 是如何工作的</h5><p><strong>挂载 Volume 会隐藏文件系统中本来就存在的文件</strong><br>当挂载任意 volume 到容器的文件系统中时，挂载的路径下原本存在的文件就无法被访问。比如把某个 ConfigMap volume 挂载到容器的 <code>/etc</code> 路径下，则本来位于 <code>/etc</code> 下面的配置文件都会被隐藏掉。<br>如果你还是想将 ConfigMap volume 挂载到 <code>/etc</code> 目录，又不影响原来存在的文件，可以结合使用 <code>mountPath</code> 和 <code>subPath</code>。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">my-container</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">my-volume</span></span><br><span class="line"><span class="attr">      subPath:</span> <span class="string">my-app.conf</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/my-app.conf</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-c49e7b4386aac0dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using subPath to mount a single file from the volume"></p><p><strong>ConfigMap volumes 使用符号链接来实现原子化更新</strong><br>有些应用会监控其配置文件的变化来决定是否重新加载配置。但是，假如应用的配置文件很大或者涉及到很多文件，应用可能会在所有更新全部完成之前检查到变化并加载更新。若应用最终读取了未全部更新的文件，可能导致出现不正常的行为。<br>为了防止上述情况发生，Kubernetes 会确保 ConfigMap volume 中所有文件的更新操作是<strong>原子</strong>的，即所有更新都会立即完成。<br>上述机制是通过文件的符号链接实现的。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kiada-ssl -c envoy -- ls -lA /etc/envoy</span></span><br><span class="line">total 4</span><br><span class="line">drwxr-xr-x 2 root root 4096 Jan 12 03:33 ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   31 Jan 12 03:33 ..data -&gt; ..2022_01_12_03_33_58.815959464</span><br><span class="line">lrwxrwxrwx 1 root root   16 Jan 12 03:33 dummy.bin -&gt; ..data/dummy.bin</span><br><span class="line">lrwxrwxrwx 1 root root   17 Jan 12 03:33 envoy.yaml -&gt; ..data/envoy.yaml</span><br></pre></td></tr></table></figure></p><p>每次用户修改 ConfigMap，Kubernetes 都会新建一个以当前时间戳命名的目录，将新的配置文件放到该目录中。再修改符号链接的指向，立即同时替换所有文件。</p><h5 id="更新和删除-ConfigMaps"><a href="#更新和删除-ConfigMaps" class="headerlink" title="更新和删除 ConfigMaps"></a>更新和删除 ConfigMaps</h5><p>和大多数 Kubernetes API 对象一样，ConfigMaps 也支持手动修改其清单文件，再使用 <code>kubectl apply</code> 命令将最新版本重新应用到集群环境。<br>此外还可以使用下面这种更快捷的方式。</p><p><strong>使用 kubectl edit 就地修改 API 对象</strong><br><code>kubectl edit cm kiada-config</code><br><img src="https://upload-images.jianshu.io/upload_images/6875152-1f41ca72be09f6ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl edit"></p><p>上面的命令会使用系统默认的编辑器（比如 <code>Vim</code>）打开 ConfigMap <code>kiada-config</code> 的清单文件，允许用户直接修改该 ConfigMap 对象。当关闭编辑器时，最新的改动会自动应用到 Kubernetes API server。</p><p><strong>修改 ConfigMap 的影响</strong><br>当更新某个 ConfigMap 后，若 ConfigMap 是以存储卷的形式作为配置文件挂载到容器中，则其中的文件会自动进行更新。<br>但是不同于文件，环境变量在容器运行时不会自动进行更新。然而当容器因为某些特殊原因重启后，Kubernetes 会使用最新版本的 ConfigMap 值来初始化新容器的环境变量。</p><p>容器最重要的属性之一就是其<strong>不变性</strong>，即用户可以肯定同一个容器的多个实例一定是相同的。<br>假如应用通过 ConfigMap 以环境变量的方式注入配置，当 ConfigMap 修改后，实际上并不会影响正在运行的应用实例。但是当应用的某一部分实例因为故障重新启动，或者需要添加新的实例副本，就会导致只有这一部分实例在使用最新的配置。<br>类似的场景甚至发生在应用自动重新加载其配置文件的时候。Kubernetes 对于 ConfigMap volumes 采用异步的更新方式，这导致某些实例可能会比其他实例更早地看到配置的变化。上述更新操作有可能会持续几十秒的时间，则在这部分时间内，各应用实例上的配置文件之间实际上是不同步的。<br>从而也会导致应用的各个容器实例之间正使用着不同的配置。</p><p><strong>阻止 ConfigMap 被修改</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ConfigMap</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-immutable-configmap</span></span><br><span class="line"><span class="attr">data:</span></span><br><span class="line"><span class="attr">  mykey:</span> <span class="string">myvalue</span></span><br><span class="line"><span class="attr">  another-key:</span> <span class="string">another-value</span></span><br><span class="line"><span class="attr">immutable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>不可变 ConfigMap 可以阻止用户意外地修改应用配置，同时也会提高 Kubernetes 集群的性能。因为工作节点上的 Kubelets 无需再接收 ConfigMap 对象变化的通知。<br>假如需要添加一系列使用不同配置的 Pods，就创建一个新的 ConfigMap。</p><p><strong>删除 ConfigMap</strong><br>ConfigMap 对象可以使用 <code>kubectl delete</code> 命令删除。删除某个 ConfigMap 后，引用它的正在运行的应用不会受到任何影响，直到容器重新启动。<br>若 ConfigMap 没有被标记成可选的，则容器会在重启时失败。</p><h4 id="使用-Secrets-向容器嵌入敏感信息"><a href="#使用-Secrets-向容器嵌入敏感信息" class="headerlink" title="使用 Secrets 向容器嵌入敏感信息"></a>使用 Secrets 向容器嵌入敏感信息</h4><h5 id="Secrets-介绍"><a href="#Secrets-介绍" class="headerlink" title="Secrets 介绍"></a>Secrets 介绍</h5><p>Secrets 和 ConfigMaps 非常相似。它们也是包含一系列键值对且能够作为环境变量或文件注入到容器中。<br>事实上 Secrets 比 ConfigMap 更早出现。但是 Secrets 在存储普通的明文文本时友好性较差，因而引入了 ConfigMaps。<br>对于 Secrets 对象，Kubernetes 在处理它们时会特别注意安全性。比如 Kubernetes 会确保 Secret 中的数据在分发时只传给有需要的节点；工作节点上的 Secrets 只保存在内存中，从来不会写入到物理存储。<br>因此，必须将敏感数据保存到 Secrets 而不是 ConfigMaps 中。</p><h5 id="创建-Secret"><a href="#创建-Secret" class="headerlink" title="创建 Secret"></a>创建 Secret</h5><p><strong>创建一个 TLS secret</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret tls kiada-tls --cert example-com.crt --key example-com.key</span></span><br><span class="line">secret/kiada-tls created</span><br></pre></td></tr></table></figure></p><p>其中 crt 文件和 key 文件可以从作者的 <a href="https://github.com/luksa/kubernetes-in-action-2nd-edition/tree/master/Chapter05/kiada-ssl-proxy-0.1" target="_blank" rel="noopener">Github</a> 下载。<br>上述命令会创建一个名为 kiada-tls 的 Secret。</p><p><strong>从 YAML 清单文件创建 Secrets</strong><br>显而易见，从 YAML 文件创建 Secrets 并不是一个好主意。<br>假如你只是需要在本地创建一个 YAML 清单文件而不是直接通过 API server 创建 Secret 对象，可以使用 <code>kubectl create</code> 加上 <code>--dry-run=client -o yaml</code> 选项。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create secret generic my-credentials \</span></span><br><span class="line">--from-literal user=my-username \</span><br><span class="line">--from-literal pass=my-password \</span><br><span class="line">--dry-run=client -o yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">data:</span><br><span class="line">  pass: bXktcGFzc3dvcmQ=</span><br><span class="line">  user: bXktdXNlcm5hbWU=</span><br><span class="line">kind: Secret</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: my-credentials</span><br></pre></td></tr></table></figure></p><p><strong>使用 <code>stringData</code> 字段</strong><br>因为并不是所有敏感数据都是二进制形式，Kubernetes 允许用户通过 <code>stringData</code> 字段指定 Secret 中的文本数据。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Secret</span></span><br><span class="line"><span class="attr">stringData:</span></span><br><span class="line"><span class="attr">  user:</span> <span class="string">my-username</span></span><br><span class="line"><span class="attr">  pass:</span> <span class="string">my-password</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  creationTimestamp:</span> <span class="literal">null</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">my-credentials</span></span><br></pre></td></tr></table></figure></p><h5 id="在容器中使用-Secrets"><a href="#在容器中使用-Secrets" class="headerlink" title="在容器中使用 Secrets"></a>在容器中使用 Secrets</h5><p><strong>借助 Secret Volume 注入 Secret 配置</strong><br>Secret volume 和前面提到的 ConfigMap volume 用法基本相同。参考如下 YAML 配置文件 <code>pod.kiada-ssl.secret-volume.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">    secret:</span></span><br><span class="line"><span class="attr">      secretName:</span> <span class="string">kiada-tls</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.crt</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.crt</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">tls.key</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">example-com.key</span></span><br><span class="line"><span class="attr">        mode:</span> <span class="number">0600</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">    configMap:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">kiada-envoy-config</span></span><br><span class="line"><span class="attr">      items:</span></span><br><span class="line"><span class="attr">      - key:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">envoy.yaml</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">envoyproxy/envoy:v1.14.1</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">cert-and-key</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/certs</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">envoy-config</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/etc/envoy</span></span><br><span class="line"><span class="attr">      readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3207fa46e0b47047.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Secret Volume"></p><h4 id="通过-Downward-API-向应用传递-Pod-的元数据"><a href="#通过-Downward-API-向应用传递-Pod-的元数据" class="headerlink" title="通过 Downward API 向应用传递 Pod 的元数据"></a>通过 Downward API 向应用传递 Pod 的元数据</h4><p>前面介绍了如何向容器中的应用传递配置信息。但数据并不总是静态的，假如某些数据只有在 Pod 创建之后才能被知晓，比如 Pod 的 IP 地址、工作节点的名称、容器分配到的 CPU 和内存等。<br>这些需求可以通过 Downward API 实现。</p><h5 id="Downward-API-介绍"><a href="#Downward-API-介绍" class="headerlink" title="Downward API 介绍"></a>Downward API 介绍</h5><p>Downward API 并不是一个需要应用去访问的 REST 端点，它实际上是一种将 Pod 的 metadata、spec 和 status 字段注入到容器中的方式。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6c519adcce0bfaef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The Downward API exposes pod metadata throughenvironment variables or files"></p><h5 id="Downward-API-支持哪些元数据"><a href="#Downward-API-支持哪些元数据" class="headerlink" title="Downward API 支持哪些元数据"></a>Downward API 支持哪些元数据</h5><p>用户并不能通过 Downward API 注入 Pod 对象中的所有字段。实际上只有一部分数据被支持，其列表如下。</p><p><strong>通过 <code>fieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>metadata.name</code></td><td>Pod 的名称</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.namespace</code></td><td>Pod 的命名空间</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.uid</code></td><td>Pod 的 UID</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.labels</code></td><td>Pod 的所有标签</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.labels[&#39;key&#39;]</code></td><td>某个标签的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>metadata.annotations</code></td><td>Pod 的所有注释</td><td>No</td><td>Yes</td></tr><tr><td><code>metadata.annotations[&#39;key&#39;]</code></td><td>某个注释的值</td><td>Yes</td><td>Yes</td></tr><tr><td><code>spec.nodeName</code></td><td>Pod 运行的工作节点的名称</td><td>Yes</td><td>No</td></tr><tr><td><code>spec.serviceAccountName</code></td><td>Pod 的服务账户</td><td>Yes</td><td>No</td></tr><tr><td><code>status.podIP</code></td><td>Pod 的 IP 地址</td><td>Yes</td><td>No</td></tr><tr><td><code>status.hostIP</code></td><td>工作节点的 IP 地址</td><td>Yes</td><td>No</td></tr></tbody></table><p><strong>通过 <code>resourceFieldRef</code> 字段注入的数据</strong></p><table><thead><tr><th>Resource Field</th><th>Description</th><th>Allowed in env</th><th>Allowed in volume</th></tr></thead><tbody><tr><td><code>requests.cpu</code></td><td>容器的 CPU 请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.memory</code></td><td>容器的内存请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>requests.ephemeral-storage</code></td><td>容器的临时存储请求</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.cpu</code></td><td>容器的 CPU 限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.memory</code></td><td>容器的内存限制</td><td>Yes</td><td>Yes</td></tr><tr><td><code>limits.ephemeral-storage</code></td><td>容器的临时存储限制</td><td>Yes</td><td>Yes</td></tr></tbody></table><h5 id="将-Pod-的元数据注入到环境变量中"><a href="#将-Pod-的元数据注入到环境变量中" class="headerlink" title="将 Pod 的元数据注入到环境变量中"></a>将 Pod 的元数据注入到环境变量中</h5><p><strong>注入 Pod 对象中的字段</strong><br><code>kiada.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kiada</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kiada:0.4</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">POD_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.podIP</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_NAME</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">spec.nodeName</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">NODE_IP</span></span><br><span class="line"><span class="attr">        valueFrom:</span></span><br><span class="line"><span class="attr">          fieldRef:</span></span><br><span class="line"><span class="attr">            fieldPath:</span> <span class="string">status.hostIP</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p>应用 <code>kiada.yml</code> 清单文件并查看其日志输出：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kiada.yml</span></span><br><span class="line">pod/kiada created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs -f kiada</span></span><br><span class="line">Kiada - Kubernetes in Action Demo Application</span><br><span class="line">---------------------------------------------</span><br><span class="line">Kiada 0.4 starting...</span><br><span class="line">Pod name is kiada</span><br><span class="line">Local hostname is kiada</span><br><span class="line">Local IP is 172.17.0.6</span><br><span class="line">Running on node minikube</span><br><span class="line">Node IP is 192.168.49.2</span><br><span class="line">Status message is This is the default status message</span><br><span class="line">Listening on port 8080</span><br></pre></td></tr></table></figure></p><p><strong>注入容器的资源数据</strong><br>示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_CPU_CORES</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.cpu</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">MAX_MEMORY_KB</span></span><br><span class="line"><span class="attr">    valueFrom:</span></span><br><span class="line"><span class="attr">      resourceFieldRef:</span></span><br><span class="line"><span class="attr">        resource:</span> <span class="string">limits.memory</span></span><br><span class="line"><span class="attr">        divisor:</span> <span class="number">1</span><span class="string">k</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;设置命令、参数和环境变量&quot;&gt;&lt;a href=&quot;#设置命令、参数和环境变量&quot; class=&quot;headerlink&quot; title=&quot;设置命令、参数和环境变量&quot;&gt;&lt;/a&gt;设置命令、参数和环境变量&lt;/h4&gt;&lt;p&gt;同普通的应用一样，容器化应用也可以通过命令行参数、环境变量、
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 向容器挂载存储卷</title>
    <link href="https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/"/>
    <id>https://rollingstarky.github.io/2022/01/06/kubernetes-in-action-reading-notes-mount-storage-volumes/</id>
    <published>2022-01-05T16:00:00.000Z</published>
    <updated>2022-01-06T15:30:53.513Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Volumes-介绍"><a href="#Volumes-介绍" class="headerlink" title="Volumes 介绍"></a>Volumes 介绍</h4><p>Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运行着应用的各个进程。这些进程可以共享 CPU、RAM、网络接口等计算资源。<br>在普通的计算机中，应用的进程使用同一个文件系统。但是在 Pod 中，每个容器都有自己独有的、由容器镜像提供的隔离的文件系统。</p><p>容器构建时添加到镜像中的文件构成了容器的文件系统，容器启动后，运行在容器中的进程就可以修改这些文件或者添加新的文件。<br>但是当容器终止和重启时，所有对于文件系统的改动都不会被保留。事实上容器并不是真正意义上的重启，而是完全地被一个新容器<strong>替换</strong>掉了。这对于一些类型的应用是 OK 的，其他应用则需要在重启时至少保留一部分文件系统。<br>这可以通过挂载 Volume 来实现。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b6512cfe7b8b10cc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mounting a filesystem into the file tree"></p><h5 id="Volumes-与-Pod"><a href="#Volumes-与-Pod" class="headerlink" title="Volumes 与 Pod"></a>Volumes 与 Pod</h5><p>Volumes 并不是 Pod 或 Node 那样的顶层资源，而是和容器一样是 Pod 中的一个组件，因而会使用 Pod 的生命周期。Volumes 与其挂载的容器的生命周期是毫无关联的，也因此能够用来在容器重启时保持数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a1dbdaf7fcc1a252.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes are defined at the pod level and mounted in the pod’s containers"></p><p>Volumes 在 Pod 中定义，挂载到 Pod 下的容器中。</p><p><strong>在容器重启时保持数据</strong><br>Pod 中的所有 Volumes 都会在容器启动前创建，在 Pod 关闭时销毁。<br>应用可以向挂载到容器文件系统中的 Volume 写入数据。当容器重启时，其被替换为一个新容器，文件系统也重新从镜像创建。此时则可以再次挂载同样的 Volume，完成对之前数据的访问。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-5b341a1a50a8938a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Volumes ensure that part of the container’s filesystem is persisted across restarts"></p><p>通常由应用的作者决定哪些文件需要在容器重启时被保留，一般是一些代表应用状态的数据。但不包括应用的本地缓存数据，这些数据会阻止容器完成一次“全新”的重启。而全新的重启有利于应用的“自愈”。</p><p><strong>在一个容器中挂载多个 Volume</strong><br>一个 Pod 可以包含多个 Volumes，Pod 中的每个容器都可以挂载这些 Volumes 中的零个或多个。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f630769df6056546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A pod can contain multiple volumes and a container can mount multiple volumes"></p><p><strong>在多个容器间共享文件</strong><br>一个 Volume 可以被同时挂载到多个容器中，从而这些容器中的应用可以共享文件。<br>比如可以创建一个 Pod，包含一个 Web Server 容器和一个 content-producing agent 容器。Agent 容器负责生成静态媒体内容保存至 Volume，Web 容器则将 Volume 中的内容发布给客户端。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-8bafa09cc1369c5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A volume can be mounted into more than one container"></p><p><strong>在 Pod 重启时保持数据</strong><br>Volume 与 Pod 的生命周期绑定，只会在 Pod 存在时存在。但是依靠某些特殊的 Volume 类型，其中的文件也可以在 Pod 和 Volume 消失后继续存在，后续也能够挂载到一个新的 Volume 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-ea1ae1c57074b2de.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod volumes can also map to storage volumes that persist across pod restarts"></p><p>如上图所示，Pod 中的 Volume 可以映射到 Pod 外面的永久存储。代表 Volume 的文件目录并不是 Pod 内部的本地路径，而是挂载的一个脱离了 Pod 生命周期的 NAS。<br>假如 Pod 被删除并被一个新的 Pod 所替换，同一个 NAS 可以被关联到新的 Pod 实例中，从而前一个 Pod 保持的数据可以被新的 Pod 访问。</p><p><strong>在多个 Pod 间共享文件</strong><br>取决于 external storage volume 使用的具体技术，同一个外挂存储也能够同时被关联给多个 Pod，从而这些 Pod 之间能够共享数据。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-db595737626572c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using volumes to share data between pods"></p><h5 id="Volume-类型"><a href="#Volume-类型" class="headerlink" title="Volume 类型"></a>Volume 类型</h5><p>当向某个 Pod 添加 Volume 时，必须指定 Volume 类型。主要的几种 Volume 类型如下：</p><ul><li><code>emptyDir</code>：一个简单的空目录，允许 Pod 在其生命周期内向该路径下存储数据</li><li><code>hostPath</code>：从工作节点的文件系统向 Pod 挂载文件</li><li><code>nfs</code>：挂载到 Pod 中的 NFS 共享</li><li><code>gcePersistentDisk</code> (Google Compute Engine Persistent Disk), <code>awsElasticBlockStore</code> (Amazon Web Services Elastic Block Store), <code>azureFile</code> (Microsoft Azure File Service), <code>azureDisk</code> (Microsoft Azure Data Disk)</li><li><code>cephfs</code>, <code>cinder</code>, <code>fc</code>, <code>flexVolume</code>, <code>flocker</code>, <code>glusterfs</code>, <code>iscsi</code>, <code>portworxVolume</code>, <code>quobyte</code>, <code>rbd</code>, <code>scaleIO</code>, <code>storageos</code>, <code>photonPersistentDisk</code>, <code>vsphereVolume</code></li><li><code>configMap</code>, <code>secret</code>, <code>downwardAPI</code>, <code>projected</code>：特殊类型的 Volume，用来暴露 Pod 及其他 Kubernetes 对象的信息</li><li><code>csi</code>：一种可插拔的通过 <strong>Container Storage Interface</strong> 添加存储的方式。任何人都可以使用这种 Volume 类型来实现自己的存储驱动</li></ul><h4 id="使用-Volumes"><a href="#使用-Volumes" class="headerlink" title="使用 Volumes"></a>使用 Volumes</h4><h5 id="使用-emptyDir-在容器重启时保留文件"><a href="#使用-emptyDir-在容器重启时保留文件" class="headerlink" title="使用 emptyDir 在容器重启时保留文件"></a>使用 <code>emptyDir</code> 在容器重启时保留文件</h5><p><code>emptyDir</code> 是最简单的 Volume 类型。它最开始以空目录的形式挂载到容器的文件系统，任何写入到该路径下的文件都会在 Pod 的整个生命周期中存在。<br>这类 Volume 通常用于在容器重启后保留部分数据；或者当整个容器的文件系统都是只读时，令其部分文件系统可写；又或者在包含两个或以上容器的 Pod 中，在各容器间传递数据。</p><p><strong>向 Pod 添加 <code>emptyDir</code> Volume</strong><br>创建如下 <code>fortune-emptydir.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-emptydir</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    volumeMounts:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"ls /usr/share/nginx/html/quote || (apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote)"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>当容器第一次启动时，<code>postStart</code> hook 会执行 <code>apk add fortune</code> 命令安装 fortune 软件包，并执行 <code>fortune &gt; /usr/share/nginx/html/quote</code> 创建 <code>quote</code> 文件。<br>后续若容器因为各种原因重启，由于 <code>quote</code> 文件位于挂载的 Volume 中，不会随着容器一同被销毁。<br>并且在新容器生成后仍会挂载到原来的路径下，即不管后续容器如何重启，<code>quote</code> 文件都会保持第一次创建时的状态。</p><p>若没有挂载 Volume，则 <code>quote</code> 文件会在容器重启时随着旧容器一同被销毁，每次新容器生成，都会在同样的路径下产生一个新的不同版本的 <code>quote</code> 文件。</p><p>运行 <code>kubectl apply -f fortune-emptydir.yml</code> 命令应用清单文件，检查容器中 Volume 的挂载状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-emptydir.yml</span></span><br><span class="line">pod/fortune-emptydir created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune-emptydir -- mount --list | grep nginx/html</span></span><br><span class="line">/dev/sdb on /usr/share/nginx/html type ext4 (rw,relatime,discard,errors=remount-ro,data=ordered)</span><br></pre></td></tr></table></figure></p><h5 id="使用-emptyDir-在容器间共享文件"><a href="#使用-emptyDir-在容器间共享文件" class="headerlink" title="使用 emptyDir 在容器间共享文件"></a>使用 <code>emptyDir</code> 在容器间共享文件</h5><p>创建如下内容的清单文件 <code>fortune.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">      emptyDir:</span> <span class="string">&#123;&#125;</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">fortune</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">luksa/fortune-writer:1.0</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/var/local/output</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">      image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/usr/share/nginx/html</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">content</span></span><br><span class="line"><span class="attr">          readOnly:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">      ports:</span></span><br><span class="line"><span class="attr">        - containerPort:</span> <span class="number">80</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">http</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>fortune</code> 容器是作者自己构建的，会每隔 30s 执行一次 <code>fortune &gt; /var/local/output/quote</code> 命令。<code>fortune</code> 每次执行都会随机输出一段名言警句类型的话，即 <code>/var/local/output/quote</code> 文件中的内容会每隔 30s 变化一次。<br>整个 Pod 包含两个容器和一个 Volume，其中 <code>fortune</code> 容器挂载 <code>content</code> Volume 到自己的 <code>/var/local/output</code> 路径下，而 <code>nginx</code> 容器挂载同一个 <code>content</code> Volume 到自己的 <code>/usr/share/nginx/html</code> 路径下。<br><code>fortune</code> 容器会每隔 30s 生成一个新的 <code>quote</code> 文件，保存到挂载的 <code>content</code> Volume 下；而另一个 <code>nginx</code> 容器也挂载了 <code>content</code> Volume，并且将其中的 <code>quote</code> 文件作为 Web 服务的静态文件向外提供服务。<br>即同一个 Pod 中的两个容器通过挂载同一个 Volume 实现文件的共享。</p><p><strong>运行 Pod</strong><br>使用 <code>kubectl apply -f fortune.yml</code> 命令应用清单文件创建 Pod，再分别从两个容器中查看 Volume 下 <code>quote</code> 文件的内容：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune.yml</span></span><br><span class="line">pod/fortune configured</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c fortune -- cat /var/<span class="built_in">local</span>/output/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> fortune -c nginx -- cat /usr/share/nginx/html/quote</span></span><br><span class="line">Life is too important to take seriously.</span><br><span class="line">                -- Corky Siegel</span><br></pre></td></tr></table></figure></p><p>后两条命令输出了同样的内容。虽然两个容器查看的 <code>quote</code> 文件本地路径不同，它们实际上指向了同一个 Volume。</p><h4 id="理解-external-volumes-是如何挂载的"><a href="#理解-external-volumes-是如何挂载的" class="headerlink" title="理解 external volumes 是如何挂载的"></a>理解 external volumes 是如何挂载的</h4><p>如下图所示，网络存储卷首先是被宿主节点挂载，然后再授予 Pod 访问挂载点的权限。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0f593c120f4cd3c1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Network volumes are mounted by the host node and then exposed in pods"></p><p>通常情况下，底层的存储技术并不允许一个 Volume 以读写模式同时挂载到一个以上的节点，但是同一个节点上的多个 Pods 可以同时以读写模式使用 Volume。<br>对于云环境提供的大多数存储技术，多个节点使用同一个网络存储卷的方式只有一种，即以只读模式挂载。<br>在设计分布式应用的架构时，考虑网络存储卷的上述限制是很有必要的。同一个 Pod 的多个副本通常不能以读写模式挂载同一个网络存储卷。</p><h4 id="访问工作节点上的文件系统"><a href="#访问工作节点上的文件系统" class="headerlink" title="访问工作节点上的文件系统"></a>访问工作节点上的文件系统</h4><p>绝大多数 Pods 不应该关注部署它们的宿主节点，不应该访问节点文件系统中的任何文件。除非这些 Pods 是系统级别的。<br>可以使用 <code>hostPath</code> 类型的 Volume 令 Pod 能够访问宿主节点。</p><h5 id="hostPath-Volume-介绍"><a href="#hostPath-Volume-介绍" class="headerlink" title="hostPath Volume 介绍"></a><code>hostPath</code> Volume 介绍</h5><p><code>hostPath</code> Volume 指向宿主节点文件系统中的特定文件或目录，形成 Pod 与宿主节点之间的文件共享。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-48b1a7db394ddd26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="hostPath volume mounts a file or directory from the worker node’s filesystem into the container"></p><p><code>hostPath</code> Volume 并不适合存放数据库中的数据。因为此 Volume 的内容只是保存在某个特定的工作节点上，假如数据库 Pod 被重新分配给了另一个节点，则保存在 Volume 中的数据库数据对新的 Pod 不再可见。</p><p>通常情况下，<code>hostPath</code> Volume 只用在当 Pod 确实是需要读写 Node 中的文件，比如 Node 上的系统日志。<br><code>hostPath</code> 是最危险的 Volume 类型之一，一般只用于具有特殊权限的 Pod。假如不对 <code>hostPath</code> 的使用加以限制，用户有可能对工作节点做任何事。<br>比如用户可以使用 <code>hostPath</code> 挂载容器的 Docker socket 文件，然后在容器内运行 Docker 客户端，接着便可以作为 root 用户在宿主节点上执行任意命令。</p><h5 id="使用-hostPath-Volume"><a href="#使用-hostPath-Volume" class="headerlink" title="使用 hostPath Volume"></a>使用 <code>hostPath</code> Volume</h5><p>部署如下配置的 Pod：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  volumes:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">host-root</span></span><br><span class="line"><span class="attr">      hostPath:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">node-explorer</span></span><br><span class="line"><span class="attr">      image:</span> <span class="string">alpine</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"sleep"</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">"9999999999"</span></span><br><span class="line"><span class="attr">      volumeMounts:</span></span><br><span class="line"><span class="attr">        - mountPath:</span> <span class="string">/host</span></span><br><span class="line"><span class="attr">          name:</span> <span class="string">host-root</span></span><br></pre></td></tr></table></figure></p><p>Pod 部署完成后，即可运行 <code>kubectl exec -it node-explorer -- sh</code> 命令在 Pod 中运行一个交互式命令行窗口，在执行 <code>cd /host</code> 命令即可进入宿主节点的文件系统：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it node-explorer -- sh</span></span><br><span class="line">/ # cd /host</span><br><span class="line">/host # ls</span><br><span class="line">Release.key  boot         dev          etc          kic.txt      lib          lib64        media        opt          root         sbin         sys          usr</span><br><span class="line">bin          data         docker.key   home         kind         lib32        libx32       mnt          proc         run          srv          tmp          var</span><br><span class="line">/host #</span><br></pre></td></tr></table></figure></p><p><code>hostPath</code> Volume 指向的是宿主节点的 <code>/</code> 路径，由此整个工作节点的文件系统都会向 Pod 开放。执行完上面的命令后，即可以修改工作节点上的任何文件。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Volumes-介绍&quot;&gt;&lt;a href=&quot;#Volumes-介绍&quot; class=&quot;headerlink&quot; title=&quot;Volumes 介绍&quot;&gt;&lt;/a&gt;Volumes 介绍&lt;/h4&gt;&lt;p&gt;Pod 就像是一个部署着某个应用的逻辑化的计算机，可以包含一个或几个容器，运
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Storage" scheme="https://rollingstarky.github.io/tags/Storage/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Volumes" scheme="https://rollingstarky.github.io/tags/Volumes/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 管理 Pod 的生命周期</title>
    <link href="https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/"/>
    <id>https://rollingstarky.github.io/2022/01/05/kubernetes-in-action-reading-notes-managing-pod-lifecycle/</id>
    <published>2022-01-04T16:00:00.000Z</published>
    <updated>2022-01-04T16:30:25.056Z</updated>
    
    <content type="html"><![CDATA[<h4 id="理解-Pod-的状态"><a href="#理解-Pod-的状态" class="headerlink" title="理解 Pod 的状态"></a>理解 Pod 的状态</h4><h5 id="Pod-phase"><a href="#Pod-phase" class="headerlink" title="Pod phase"></a>Pod phase</h5><p>在 Pod 完整的生命周期中，存在着 5 种不同的阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-fcf20a7154d53893.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod’s phases"></p><ul><li><code>Pending</code>：创建 Pod 对象后的初始化阶段。会一直持续到 Pod 被分配给某个工作节点，镜像被拉取到本地并启动</li><li><code>Running</code>：Pod 中至少一个容器处于运行状态</li><li><code>Succeeded</code>：对于不打算无限期运行的 Pod，其容器部署完成后的状态</li><li><code>Failed</code>：对于不打算无限期运行的 Pod，其容器中至少有一个由于错误终止</li><li><code>Unknown</code>：由于 Kubelet 与 API Server 的通信中断，Pod 的状态未知。可能是工作节点挂掉或断网</li></ul><p>从 <code>kubia.yml</code> 清单文件创建一个 Pod。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><code>$ kubectl apply -f kubia.yml</code></p><p><strong>查看 Pod 的 Phase</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o yaml | grep phase</span></span><br><span class="line">  phase: Running</span><br></pre></td></tr></table></figure></p><p>或者借助 <code>jq</code> 工具从 JSON 格式的输出中检索 phase 字段：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.phase</span></span><br><span class="line">"Running"</span><br></pre></td></tr></table></figure></p><p>也可以使用 <code>kubectl describe</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Status:</span></span><br><span class="line">Status:       Running</span><br></pre></td></tr></table></figure></p><h5 id="Pod-conditions"><a href="#Pod-conditions" class="headerlink" title="Pod conditions"></a>Pod conditions</h5><p>Pod 的 conditions 用来表示某个 Pod 是否达到了特定的状态以及达到或未达到的原因。<br>与 phase 相反，一个 Pod 可以同时有几个 conditions。</p><ul><li><code>PodScheduled</code>：表明 Pod 是否已经被安排给了某个工作节点</li><li><code>Initialized</code>：Pod 的初始化容器已经部署完成</li><li><code>ContainersReady</code>：Pod 中的所有容器都已经准备完毕</li><li><code>Ready</code>：Pod 自身已经准备好对其客户端提供服务</li></ul><p><strong>查看 Pod 的 conditions</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Conditions: -A5</span></span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br></pre></td></tr></table></figure></p><p><code>kubectl describe</code> 命令只会显示每个 condition 是 <code>true</code> 还是 <code>false</code>，不会显示更详细的信息。<br>为了显示某个 condition 为 false 的具体原因，需要检索 Pod 的清单文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.conditions</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Initialized"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "Ready"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:46Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "ContainersReady"</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    "lastProbeTime": null,</span><br><span class="line">    "lastTransitionTime": "2021-12-30T03:02:45Z",</span><br><span class="line">    "status": "True",</span><br><span class="line">    "type": "PodScheduled"</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>当 condition 为 <code>false</code> 时，上述输出中会包含 <code>reason</code> 和 <code>message</code> 字段来显示失败的具体原因和详细信息。</p><h5 id="容器的-status"><a href="#容器的-status" class="headerlink" title="容器的 status"></a>容器的 status</h5><p>容器的 status 包含多个字段。其中 <code>state</code> 字段表示该容器当前的状态，<code>restartCount</code> 表示容器重启的频率，此外还有 <code>containerID</code>、<code>image</code>、<code>imageID</code> 等。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2425c752e41b4cc1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Container status"></p><p>容器的 status 包含以下几种：</p><ul><li><code>Waiting</code>：容器等待启动。<code>reason</code> 和 <code>message</code> 字段会记录容器处于此状态的原因</li><li><code>Running</code>：容器已经创建，进程正在运行</li><li><code>Terminated</code>：容器中运行的进程已经终止。<code>exitCode</code> 字段会记录进程的退出码</li><li><code>Unknown</code>：容器的状态无法确定</li></ul><p>比如修改 <code>kubia.yml</code> 清单文件中的 <code>image</code> 字段，故意改成 <code>uksa/kubia:1.0</code> 这样无效的地址，运行 <code>kubectl apply -f kubia.yml</code> 命令重新应用清单文件。<br>等待几分钟直到新的配置生效，查看容器的状态。</p><p>可以使用 <code>kubectl describe</code> 命令查看容器的状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe po kubia | grep Containers: -A15</span></span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91</span><br><span class="line">    Image:          uksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Waiting</span><br><span class="line">      Reason:       ImagePullBackOff</span><br><span class="line">    Last State:     Terminated</span><br><span class="line">      Reason:       Error</span><br><span class="line">      Exit Code:    137</span><br><span class="line">      Started:      Fri, 31 Dec 2021 14:50:39 +0800</span><br><span class="line">      Finished:     Fri, 31 Dec 2021 14:51:36 +0800</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl get po kubia -o json</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get po kubia -o json | jq .status.containerStatuses</span></span><br><span class="line">[</span><br><span class="line">  &#123;</span><br><span class="line">    "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">    "image": "luksa/kubia:1.0",</span><br><span class="line">    "imageID": "docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7",</span><br><span class="line">    "lastState": &#123;</span><br><span class="line">      "terminated": &#123;</span><br><span class="line">        "containerID": "docker://62fa208957d396c38f65305fd073d6b334dd8da22ab5beab196ca9bcf2f9ff91",</span><br><span class="line">        "exitCode": 137,</span><br><span class="line">        "finishedAt": "2021-12-31T06:51:36Z",</span><br><span class="line">        "reason": "Error",</span><br><span class="line">        "startedAt": "2021-12-31T06:50:39Z"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    "name": "kubia",</span><br><span class="line">    "ready": false,</span><br><span class="line">    "restartCount": 0,</span><br><span class="line">    "started": false,</span><br><span class="line">    "state": &#123;</span><br><span class="line">      "waiting": &#123;</span><br><span class="line">        "message": "Back-off pulling image \"uksa/kubia:1.0\"",</span><br><span class="line">        "reason": "ImagePullBackOff"</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>上面输出中的 <code>state</code> 字段都表明了容器当前的状态是 <code>waiting</code>，还有 <code>reason</code> 和 <code>message</code> 字段表明处于此状态的原因：镜像拉取失败。</p><h4 id="确保容器的健康状态"><a href="#确保容器的健康状态" class="headerlink" title="确保容器的健康状态"></a>确保容器的健康状态</h4><h5 id="理解容器的自动重启机制"><a href="#理解容器的自动重启机制" class="headerlink" title="理解容器的自动重启机制"></a>理解容器的自动重启机制</h5><p>当一个 Pod 被分配给了某个工作节点，该工作节点上的 Kubelet 就会负责启动容器并保证该容器一直处于运行状态，只要该 Pod 对象一直存在没被移除。<br>如果容器中的主进程由于某些原因终止运行，Kubernetes 就会自动重启该容器。</p><p>创建如下内容的清单文件 <code>kubia-ssl.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>运行如下命令应用上述清单文件，并启用端口转发：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-ssl.yml</span></span><br><span class="line">pod/kubia-ssl created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-ssl 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>待容器启动成功后，访问 localhost 的 8080、8443、9901 端口就等同于访问容器中 8080、8443、9901 端口上运行的服务。</p><p>打开一个新的命令行窗口运行 <code>kubectl get pods -w</code> 命令，实时监控容器的运行状态。<br>打开一个新的命令行窗口运行 <code>kubectl get events -w</code> 命令，实时监控触发的事件。</p><p>打开一个新的命令行窗口，尝试终止 Envoy 容器中运行的主进程。Envoy 容器 9901 端口上运行的服务刚好提供了一个管理接口，能够接收 HTTP POST 请求来终止进程：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST http://localhost:9901/quitquitquit</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时查看前两个窗口中的输出，负责监控容器状态的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods -w</span></span><br><span class="line">NAME        READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-ssl   2/2     Running   0          11m</span><br><span class="line">kubia-ssl   1/2     NotReady   0          12m</span><br><span class="line">kubia-ssl   2/2     Running    1 (2s ago)   12m</span><br></pre></td></tr></table></figure></p><p>最新的输出表明，在杀掉 Envoy 容器中的主进程后，Pod 的状态是先变成 <code>NotReady</code>，之后就立即重启该容器，Pod 的状态稍后恢复成 <code>Running</code>。</p><p>负责监控最新事件的窗口输出如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get events -w</span></span><br><span class="line">LAST SEEN   TYPE     REASON      OBJECT          MESSAGE</span><br><span class="line">11m         Normal   Scheduled   pod/kubia-ssl   Successfully assigned default/kubia-ssl to minikube</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container kubia</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container kubia</span><br><span class="line">11m         Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">11m         Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">11m         Normal   Started     pod/kubia-ssl   Started container envoy</span><br><span class="line">0s          Normal   Pulled      pod/kubia-ssl   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal   Created     pod/kubia-ssl   Created container envoy</span><br><span class="line">0s          Normal   Started     pod/kubia-ssl   Started container envoy</span><br></pre></td></tr></table></figure></p><p>最新的事件信息中包含了新的 envoy 容器启动的过程。其中有一个很重要的细节：<strong>Kubernetes 从来不会重启容器，而是直接丢弃停止的容器并创建一个新的</strong>。一般在 Kubernetes 中提及“重启”容器，实质上都指的是“重建”。<br><strong>任何写入到容器文件系统中的数据，在容器重新创建后都会丢失。为了持久化这些数据，需要向 Pod 添加 Volume</strong>。</p><p><strong>配置容器的重启策略</strong><br>Kubernetes 支持 3 种容器重启策略：</p><ul><li><code>Always</code>：默认配置。不管容器中主进程的退出码是多少，容器都会自动重启</li><li><code>OnFailure</code>：容器只会在退出码非 0 时重启</li><li><code>Never</code>：容器永不重启</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-469232db79083201.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Restart policy"></p><p><strong>容器重启时的延迟时间</strong><br>第一次容器终止时，重启会立即触发。但容器第二次重启时会先等待 10s，这个等待时间会随着重启次数依次增加到 20、40、80、160s。再之后则一直保持在 5 分钟。<br>等待过程中容器会处于 <code>Waiting</code> 状态，<code>reason</code> 字段显示 <code>CrashLoopBackOff</code>，<code>message</code> 字段显示需要等待的时间。</p><h5 id="liveness-probes"><a href="#liveness-probes" class="headerlink" title="liveness probes"></a>liveness probes</h5><p>Kubernetes 会在容器的进程终止时重启容器，以保证应用的健康。但应用实际上有可能在进程不终止的情况下无响应，比如一个 Java 应用报出 OutOfMemoryError 错误，而 JVM 进程仍在运行中。<br>理想情况下，Kubernetes 需要能够检测到此类错误并重启容器。</p><p>当然，应用自身也可以捕获这类错误并令进程立即终止。但假如应用因为进入无限循环或死锁导致无响应，又或者应用本身无法检测到错误存在呢？<br>为了确保容器能够在这些复杂情况下重启，应该提供一种从外部检查应用状态的机制。</p><p><strong>liveness probe 介绍</strong><br>Kubernetes 可以通过配置 liveness probe 来检查某个应用是否能够正常响应，Pod 中的每个容器都可以分别配置 liveness probe。一旦应用无响应或有错误发生，容器就会被认为是不健康的并被终止掉。之后容器被 Kubernetes 重新启动。</p><p>Kubernetes 支持以下三种 probe 机制：</p><ul><li><code>HTTP GET probe</code>：会发送 GET 请求到容器的 IP 地址、端口号和 URL 路径。如果 probe 收到正常的响应（2xx 或 3xx），该 probe 就被认定是成功的。如果服务返回了一个错误的响应码，或者没有在规定的时间内响应，则该 probe 被认定是失败的。</li><li><code>TCP Socket probe</code>：会尝试打开一个 TCP 连接到容器的特定端口。若连接成功，probe 就被认定是成功的；否则失败。</li><li><code>Exec probe</code>：会在容器内部执行一个命令并检查该命令的退出码。若退出码为 0，则 probe 被认定是成功的；否则失败。</li></ul><p><strong>HTTP GET liveness probe</strong><br>创建如下内容的 <code>kubia-liveness.yml</code> 清单文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-liveness</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/ready</span></span><br><span class="line"><span class="attr">        port:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">      periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">      timeoutSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">      failureThreshold:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>其中 kubia 容器的 liveness probe 是最简单版本的 HTTP 应用的 probe。该 probe 只是向 8080 端口的 <code>/</code> 路径发送 HTTP GET，看容器是否仍然能够处理请求。当应用的响应码介于 200 到 399 之间时，该应用就被认为是健康的。<br>由于该 probe 没有配置其他选项，默认配置生效。第一次检查请求会在容器启动 10s 后发起，之后每隔 10s 发起新的请求。若应用没有在 1s 之内响应，则该次 probe 请求被认定是失败的。连续 3 次请求失败以后，容器就被认为是不健康的并被终止掉。</p><p>Envoy 容器的管理员接口提供了一个 <code>/ready</code> 入口，可以返回其健康状态，因此 envoy 容器的 liveness probe 的目标可以是容器的 <code>admin</code> 端口即 9901。<br>参数 <code>initialDelaySeconds</code> 表示容器启动后到发起第一个检测请求之间的等待时间，<code>periodSeconds</code> 表示两次连续的检测请求之间的时间间隔，<code>timeoutSeconds</code> 表示多长时间以后没有响应则认定此次检测失败，<code>failureThreshold</code> 则表示连续多少次检测失败以后才认定容器失效并重启。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-659b273518b2d676.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="liveness probe"></p><p><strong>观察 liveness probe 的效果</strong><br>运行 <code>kubectl apply</code> 命令应用上述清单文件并通过 <code>kubectl port-forward</code> 命令启用端口转发，启动该 Pod 并令其能够被访问：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia-liveness.yml</span></span><br><span class="line">pod/kubia-liveness created</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-liveness 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>Pod 启动成功以后，liveness probe 会在初始等待时间过后持续向 Pod 中的容器发起检测请求，其检测结果只会在容器的 log 中看到。<br>kubia 容器中的 Node.js 应用会在每次处理 HTTP 请求时向标准输出打印记录，这些请求也包括 liveness probe 的检测请求。因此可以打开一个新的命令行窗口，使用如下命令查看请求记录：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-liveness -c kubia -f</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia-liveness</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>envoy 容器的 liveness probe 被配置成向其管理员接口发送 HTTP 请求，这些请求被记录在 <code>/var/log/envoy.admin.log</code> 文件中。可以使用如下命令查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia-liveness -c envoy -- tail -f /var/<span class="built_in">log</span>/envoy.admin.log</span></span><br><span class="line">[2022-01-02T18:34:59.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:04.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:09.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br><span class="line">[2022-01-02T18:35:14.818Z] "GET /ready HTTP/1.1" 200 - 0 5 0 - "172.17.0.1" "kube-probe/1.22" "-" "172.17.0.3:9901" "-"</span><br></pre></td></tr></table></figure></p><p><strong>观察失败的 liveness probe</strong><br>可以尝试手动令 liveness probe 的检测请求失败。先在一个新的窗口中运行 <code>kubectl get events -w</code> 命令，方便后续观察检测失败时输出的事件信息。<br>访问 Envoy 容器的管理员接口，手动配置其健康状态为 <code>fail</code>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl -X POST localhost:9901/healthcheck/fail</span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure></p><p>此时转到观察事件信息的命令行窗口，发现连续输出了 3 次 probe failed 503 错误，之后 envoy 容器开始重启：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">kubectl get events -w</span><br><span class="line">LAST SEEN   TYPE      REASON          OBJECT               MESSAGE</span><br><span class="line">...</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Warning   Unhealthy       pod/kubia-liveness   Liveness probe failed: HTTP probe failed with statuscode: 503</span><br><span class="line">0s          Normal    Killing         pod/kubia-liveness   Container envoy failed liveness probe, will be restarted</span><br><span class="line">0s          Normal    Pulled          pod/kubia-liveness   Container image "luksa/kubia-ssl-proxy:1.0" already present on machine</span><br><span class="line">0s          Normal    Created         pod/kubia-liveness   Created container envoy</span><br><span class="line">0s          Normal    Started         pod/kubia-liveness   Started container envoy</span><br></pre></td></tr></table></figure></p><h5 id="exec-amp-tcpSocket-liveness-probe"><a href="#exec-amp-tcpSocket-liveness-probe" class="headerlink" title="exec &amp; tcpSocket liveness probe"></a>exec &amp; tcpSocket liveness probe</h5><p><strong>添加 tcpSocket liveness probe</strong><br>对于接收非 HTTP 请求的应用，可以配置 tcpSocket liveness probe。<br>一个 tcpSocket liveness probe 的示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  tcpSocket:</span></span><br><span class="line"><span class="attr">    port:</span> <span class="number">1234</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>该 probe 会检查容器的 1234 端口是否打开，每隔 2s 检查一次，一次检查失败则认定该容器是不健康的并重启它。</p><p><strong>exec liveness probe</strong><br>不接受 TCP 连接的应用可以配置一条命令去检测其状态。<br>下面的示例配置会每隔 2s 运行 <code>/usr/bin/healthcheck</code> 命令，检测容器中的应用是否仍在运行：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">livenessProbe:</span></span><br><span class="line"><span class="attr">  exec:</span></span><br><span class="line"><span class="attr">    command:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">/usr/bin/healthcheck</span></span><br><span class="line"><span class="attr">  periodSeconds:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  timeoutSeconds:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">  failureThreshold:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure></p><h5 id="startup-probe"><a href="#startup-probe" class="headerlink" title="startup probe"></a>startup probe</h5><p>默认的 liveness probe 配置会给应用 20 到 30s 的时间启动，如果应用需要更长的时间才能启动完成，容器会永远达不到 liveness probe 检测成功的状态，从而进入了无限重启的循环。<br>为了防止上述情况发生，可以增大 <code>initialDelaySeconds</code>、<code>periodSeconds</code> 或 <code>failureThreshold</code> 的值，但也会有一定的副作用。<code>periodSeconds * failureThreshold</code> 的值越大，当应用不健康时重启的时间就越长。</p><p>Kubernetes 还提供了一种 startup probe。当容器配置了 startup probe 时，容器启动时只有 startup probe 会执行。startup probe 可以按照应用的启动时间配置，检测成功之后 Kubernetes 会切换到使用 liveness probe 检测。<br>比如 Node.js 应用需要 1 分钟以上的时间启动，当启动成功以后若应用状态不正常，则在 10s 以内重启。可以这样配置：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">containers:</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  startupProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">10</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">12</span></span><br><span class="line"><span class="attr">  livenessProbe:</span></span><br><span class="line"><span class="attr">    httpGet:</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/</span></span><br><span class="line"><span class="attr">      port:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">    periodSeconds:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">    failureThreshold:</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>上面配置的效果如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-0958a2c039bc32f6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="startup probe &amp; liveness probe"></p><p>应用有 120s 的时间启动。Kubernetes 一开始每隔 10s 发起 startup probe 请求，最多尝试 12 次。<br>不同于 liveness probe，startup probe 失败是很正常的，只是说明应用还未成功启动。一旦某次 startup probe 检测返回成功状态，Kubernetes 就会立即切换到 liveness probe 模式，通常拥有更短的检测间隔，能够对未响应应用做出更快速的反应。</p><h4 id="在容器启动或关闭时触发动作"><a href="#在容器启动或关闭时触发动作" class="headerlink" title="在容器启动或关闭时触发动作"></a>在容器启动或关闭时触发动作</h4><p>可以向容器中添加 lifecycle hooks。Kubernetes 目前支持两种类型的钩子：</p><ul><li>Post-start hooks：在容器启动后执行</li><li>Pre-stop hooks：在容器停止前执行</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-77db56c2b1e8d783.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Lifecycle hooks"></p><h5 id="post-start-hooks"><a href="#post-start-hooks" class="headerlink" title="post-start hooks"></a>post-start hooks</h5><p>post-start lifecycle hook 会在容器创建完成之后立即触发。可以使用 <code>exec</code> 类型的钩子在主进程启动的同时执行一个额外的程序，或者 <code>httpGet</code> 类型的钩子向容器中运行的应用发送 HTTP 请求，以完成初始化或预热操作。<br>假如你是应用的作者，类似的操作当然可以加入到应用本身的代码中。但对于一个已经存在的并非自己创建的应用，就有可能无法做到。post-start hook 提供了一种不需要修改应用或容器镜像的替代方案。</p><p><strong>post-start hook 在容器中执行命令</strong><br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">fortune-poststart</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">nginx</span></span><br><span class="line"><span class="attr">    image:</span> <span class="attr">nginx:alpine</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">"apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure></p><p>上述清单文件定义的 Pod 名为 <code>fortune-poststart</code>，包含一个基于 <code>nginx:alpine</code> 镜像的容器，同时定义了一个 <code>postStart</code> 钩子。该钩子会在 Nginx 服务启动时执行以下命令：<br><code>sh -c &quot;apk add fortune &amp;&amp; fortune &gt; /usr/share/nginx/html/quote&quot;</code></p><p><code>postStart</code> 这个名称其实有些误导作用，它并不是在主进程完全启动后才开始执行，而是在容器创建后，几乎和主进程同时执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f fortune-poststart.yml</span></span><br><span class="line">pod/fortune-poststart unchanged</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward fortune-poststart 8080:80</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 80</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 80</span><br></pre></td></tr></table></figure><p>打开一个新的命令行窗口使用 <code>curl</code> 命令测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080/quote</span></span><br><span class="line">The Official MBA Handbook on business cards:</span><br><span class="line">        Avoid overly pretentious job titles such as "Lord of the Realm,</span><br><span class="line">        Defender of the Faith, Emperor of India" or "Director of Corporate</span><br><span class="line">        Planning."</span><br></pre></td></tr></table></figure></p><p><strong>post-startup hook 对容器的影响</strong><br>虽然 post-start hook 相对于容器的主进程以异步的方式执行，它还是会对容器产生两个方面的影响。<br>首先，在 post-start hook 的执行过程中容器会一直处于 <code>Waiting</code> 状态，原因显示为 <code>ContainerCreating</code>，直到 hook 执行完毕。<br>其次，若 hook 绑定的命令无法执行或返回了一个非零的状态值，则整个容器会被重启。</p><h5 id="在容器终止前执行命令"><a href="#在容器终止前执行命令" class="headerlink" title="在容器终止前执行命令"></a>在容器终止前执行命令</h5><p>前面 fortune Pod 中的 Nginx 服务在收到 <code>TERM</code> 信号后会立即关闭所有打开的连接并终止进程，这并不是理想的操作，不会等待正在处理的客户端请求彻底完成。<br>可以使用 pre-stop hook 执行 <code>nginx -s quit</code> 命令舒缓地关闭 Nginx 服务。示例配置如下：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">lifecycle:</span></span><br><span class="line"><span class="attr">  preStop:</span></span><br><span class="line"><span class="attr">    exec:</span></span><br><span class="line"><span class="attr">      command:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">nginx</span></span><br><span class="line"><span class="bullet">      -</span> <span class="bullet">-s</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">quit</span></span><br></pre></td></tr></table></figure></p><p>假如某个 pre-stop hook 执行失败，只会在 Pod 的 events 消息中显示一条 <code>FailedPreStopHook</code> 警告信息，并不影响容器继续被终止。</p><h4 id="理解容器的生命周期"><a href="#理解容器的生命周期" class="headerlink" title="理解容器的生命周期"></a>理解容器的生命周期</h4><p>一个 Pod 的生命周期可以被分成如下三个阶段：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2cd22a41e5907b5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod 生命周期的三个阶段"></p><ul><li>初始化阶段：Pod 的 init 容器从开始运行到启动完成</li><li>运行阶段：Pod 的普通容器从开始运行到启动完成</li><li>终止阶段：Pod 的所有容器被终止运行</li></ul><h5 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h5><p>Pod 中的初始化容器会最先运行，按照 <code>spec</code> 的 <code>initContainers</code> 字段中定义的顺序。<br>第一个初始化容器的镜像被下载到工作节点并启动，完成后继续拉取第二个初始化容器的镜像，直到所有的初始化容器都成功运行。<br>若某个初始化容器因为某些错误启动失败，且其重启策略设置为 <code>Always</code> 或 <code>OnFailure</code>，则该失败的容器自动重启。若其重启策略设置为 <code>Never</code>，则 Pod 的状态显示为 <code>Init:Error</code>，必须删除并重新创建 Pod 对象。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-84a2ee1a08b66cac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="All init containers must run to completion before the regular containers can start"></p><h5 id="运行阶段"><a href="#运行阶段" class="headerlink" title="运行阶段"></a>运行阶段</h5><p>当所有的初始化容器成功运行后，Pod 的普通容器开始以<strong>并行</strong>的方式创建（需要注意的是，容器的 post-start hook 会阻塞下一个容器的创建）。</p><p><strong>termination grace period</strong><br>容器中的应用都有一个固定的关闭时间做缓冲用，定义在 <code>spec</code> 下的 <code>terminationGracePeriodSeconds</code> 字段中，默认是 30s。<br>该时间从 pre-stop hook 触发或收到 <code>TERM</code> 信号时开始计算，若时间过了进程仍在运行，应用会收到 <code>KILL</code> 信号被强制关闭。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-63ea58db03568a1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container’s termination sequence"></p><h5 id="终止阶段"><a href="#终止阶段" class="headerlink" title="终止阶段"></a>终止阶段</h5><p>Pod 的容器以并行的方式终止。对每个容器来说，pre-stop hook 触发，然后主进程接收 <code>TERM</code> 信号，如果应用关闭的时间超过了 <code>terminationGracePeriodSeconds</code>，就发送 <code>KILL</code> 信号给容器的主进程。<br>在所有的容器都被终止以后，Pod 对象被删除。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-3d36f79107e20ec0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="termination sequence inside a pod"></p><p>可以在删除一个 Pod 时手动指定一个新的时间覆盖 <code>terminationGracePeriodSeconds</code> 的值，如：<br><code>kubectl delete po kubia-ssl --grace-period 10</code></p><h5 id="Pod-完整生命周期图示"><a href="#Pod-完整生命周期图示" class="headerlink" title="Pod 完整生命周期图示"></a>Pod 完整生命周期图示</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8da03ba0126724f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="初始化阶段"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8fc4e425cb34fcd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="运行阶段和终止阶段"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;理解-Pod-的状态&quot;&gt;&lt;a href=&quot;#理解-Pod-的状态&quot; class=&quot;headerlink&quot; title=&quot;理解 Pod 的状态&quot;&gt;&lt;/a&gt;理解 Pod 的状态&lt;/h4&gt;&lt;h5 id=&quot;Pod-phase&quot;&gt;&lt;a href=&quot;#Pod-phase&quot; c
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Administrator" scheme="https://rollingstarky.github.io/tags/Administrator/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 深入了解 Pod 概念</title>
    <link href="https://rollingstarky.github.io/2021/12/29/kubernetes-in-action-reading-notes-understanding-pods/"/>
    <id>https://rollingstarky.github.io/2021/12/29/kubernetes-in-action-reading-notes-understanding-pods/</id>
    <published>2021-12-28T16:00:00.000Z</published>
    <updated>2021-12-28T16:33:54.248Z</updated>
    
    <content type="html"><![CDATA[<p>下图展示了 Kubernetes 如何通过 Deployment、Pod、Service 三种对象部署一个最小化应用。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-74a8e16f03a556f7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Three basic objects comprising a deployed application"></p><p>其中的 Pod 对象是 Kubernetes 中最重要的一个核心概念，它代表着一个处于运行状态的应用实例。</p><h4 id="理解-Pods"><a href="#理解-Pods" class="headerlink" title="理解 Pods"></a>理解 Pods</h4><p>Pod 可以包含一个或多个有协作关系的容器，是 Kubernetes 中最基本的构造单位。</p><ul><li>容器只能借助 Pod 进行部署，无法独立运行</li><li>一个 Pod 可以包含多个容器，但只包含一个容器的 Pod 也是很常见的</li><li>Pod 中的多个容器只允许在同一个工作节点上运行，即单个 Pod 不能跨节点部署</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f32a9b5c16f87b25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pods"></p><h5 id="Pod-机制的优势"><a href="#Pod-机制的优势" class="headerlink" title="Pod 机制的优势"></a>Pod 机制的优势</h5><p>为什么要在一个 Pod 中运行多个容器，而不是在一个容器中运行多个进程。</p><p><strong>一个容器不应该包含多个进程</strong><br>容器就像是一台隔离的虚拟机，因此是可以同时运行多个进程的。但这样会使得容器难于管理。<br>容器被设计成只会运行一个进程（子进程不计算在内），大多数容器管理工具也都是基于这个原则去设计的。<br>比如容器中运行的进程有时候会向标准输出打印其日志信息，Kubernetes 中查看日志的命令就只会显示从这个输出中捕获到的内容。如果容器中同时运行多个进程，都向外输出日志信息，Kubernetes 捕获到的日志内容就会变得错综复杂。</p><p>另一个原因在于，容器运行时只会在容器的根进程挂掉时重启该容器。<br>为了充分利用容器运行时提供的特性，应该在每个容器中只运行一个进程。</p><p><strong>Pod 如何组合多个容器</strong><br>不应该在同一个容器中运行多个进程。与此同时，将分散在多个容器中相互关联的进程结合成一个单位，统一进行管理也是很有必要的。<br>因此引入了 Pod 机制。</p><p>Pod 可以同时运行多个关系紧密的进程（容器），给它们（几乎）相同的运行环境，使得它们就像是运行在同一个容器中那样。<br>这些进程是相互独立、隔离的，但也会共享某些资源。因而既可以使用容器提供的各种隔离特性，又能够促使多个进程相互协作。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-96652ef6b6588fcb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pod share network interface"></p><p>如上图所示，Pod 中的多个容器共享同一个 Network 命名空间，因而共享该命名空间的网络接口、IP 地址、端口空间等。这些容器能够使用 loopback 设备进行通信，但不能绑定同一个网络端口。</p><p>同一个 Pod 中的多个容器还会共享相同的 UTS 命名空间，因而能看到同一个主机名；共享相同的 IPC 命名空间，因而不同容器中的多个进程之间可以通过 IPC 进行通信；还可以配置成共享同一个 PID 命名空间，使得这些容器中的进程使用同一个进程树。<br>与前面的内容相反，每个 Pod 总是有自己的 Mount 命名空间，这意味着每个 pod 都有自己的文件系统。当然，假如 Pod 中有两个容器需要共享部分文件系统，也可以向该 Pod 添加 Volume，作为共享存储挂载到每一个容器上。</p><h5 id="单容器-or-多容器"><a href="#单容器-or-多容器" class="headerlink" title="单容器 or 多容器"></a>单容器 or 多容器</h5><p>可以将 Pod 看作一台独立的计算机。不同于虚拟机通常需要同时运行多个应用，每个 Pod 中一般只运行一个应用。 Pod 几乎没有额外的资源开销，因而在同一个 Pod 中运行多个应用并不是必须的。</p><p>假如一个系统的前端和后端运行在同一个 Pod 中，而单个 Pod 不能跨节点存在（即单个 Pod 只能部署在某一个节点上）。如果你有一个双节点的集群且只创建了一个 Pod，则该 Pod 只会运行在其中一个节点上，造成 CPU、内存、存储和带宽等资源的闲置。<br>将前后端分别部署到不同的 Pod 中则能够提高硬件的利用率。</p><p>另一个不将多个应用部署到同一个 Pod 中的原因与横向扩展有关。<strong>Pod 不仅仅是部署的基本单位，也是扩展的基本单位</strong>。<br>当通过修改 Deployment 对象扩展应用时，Kubernetes 并不会复制 Pod 中的容器，而是直接创建新的 Pod 实例（应用副本）。<br>前端和后端组件通常有着不同的扩展需求，基本上都会独立地进行扩展。而同一个 Pod 中不同组件的扩展是同步的。如果一个容器中的某个组件相对于其他组件需要独立地进行扩展，该应用就必须部署在另一个 Pod 中。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-654d7387ed98ca4c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Splitting application"></p><p>将多个容器放置在同一个 Pod 中的唯一场景，就是某个应用包含一个基础进程以及一个或者多个对基础进程有补充作用的附加进程。运行附加进程称为 <em>sidecar container</em>。</p><p>比如某个 Pod 包含一个运行 Node.js 应用的容器，而该 Node.js 应用只支持 HTTP 协议。为了令其支持 HTTPS，可以对 JavaScript 代码做一些小的改动。其实也可以在不改动应用代码的情况下完成此需求。<br>只需要向 Pod 中再添加一个反向代理容器，将 HTTPS 流量转发成 HTTP 传给 Node.js 容器。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d44dbea66eecf68d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sidecar container that converts HTTPS traffic to HTTP"></p><p>另一个例子如下图所示，基础容器运行一个 Web 服务，其资源文件存放在挂载的 Volume 上。Pod 中的另一个容器则挂载了同一个 Volume，作为 Agent 定期从外部拉取新的资源文件，存储在 Volume 供 Web 服务使用。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1589f4979d504c7d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sidecar container that delivers content to the web server container via a volume"></p><h4 id="从-YAML-文件创建-Pod"><a href="#从-YAML-文件创建-Pod" class="headerlink" title="从 YAML 文件创建 Pod"></a>从 YAML 文件创建 Pod</h4><p>可以使用 <code>kubectl create</code> 命令创建 Pod 对象（<a href="https://www.jianshu.com/p/7bc34ff88d9d" target="_blank" rel="noopener">Kubernetes in Action 笔记 —— 部署第一个应用</a>），但更常见的方式是创建一个 JSON 或 YAML 格式的清单文件，描述整个应用的架构，再将其发送给 Kubernetes API 来生成 Pod 等对象。</p><p>比如下面的 <code>kubia.yml</code> 文件：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    images:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></p><p><strong>创建 Pod 对象</strong><br>可以使用 <code>kubectl apply -f xxx.yml</code> 命令将清单文件发送给 API 并应用到 Kubernetes 集群：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl apply -f kubia.yml</span></span><br><span class="line">pod/kubia created</span><br></pre></td></tr></table></figure></p><p><code>kubectl apply</code> 命令不仅仅用于创建对象，同时也可以对现有的对象进行修改。<br>比如 Pod 对象创建之后需要对其做一些改动，可以直接编辑 <code>yml</code> 文件，再运行一遍 <code>kubectl apply</code> 命令即可。但有些描述 Pod 的字段是不可变的，因而更新操作有可能会失败，此时就可以先删除后再重建。</p><p><strong>检查新创建的 Pod</strong><br>使用 <code>kubectl get pod</code> 命令获取某个 Pod 的汇总信息：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia   1/1     Running   0          6m37s</span><br></pre></td></tr></table></figure></p><p>想获取更详细一点的信息可以加上 <code>-o wide</code> 选项：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia -o wide</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE    IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia   1/1     Running   0          8m3s   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl describe pod</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod kubia</span></span><br><span class="line">Name:         kubia</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.49.2</span><br><span class="line">Start Time:   Fri, 24 Dec 2021 15:08:57 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.3</span><br><span class="line">IPs:</span><br><span class="line">  IP:  172.17.0.3</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://aa8778766a69122de8c8b401922d2318b15b8aaf220945d747e494de2fda9199</span><br><span class="line">    Image:          luksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">...</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age    From               Message</span><br><span class="line">  ----    ------     ----   ----               -------</span><br><span class="line">  Normal  Scheduled  9m28s  default-scheduler  Successfully assigned default/kubia to minikube</span><br><span class="line">  Normal  Pulled     9m27s  kubelet            Container image "luksa/kubia:1.0" already present on machine</span><br><span class="line">  Normal  Created    9m27s  kubelet            Created container kubia</span><br><span class="line">  Normal  Started    9m27s  kubelet            Started container kubia</span><br></pre></td></tr></table></figure></p><h4 id="与-Pod-进行交互"><a href="#与-Pod-进行交互" class="headerlink" title="与 Pod 进行交互"></a>与 Pod 进行交互</h4><h5 id="向-Pod-中的应用发起请求"><a href="#向-Pod-中的应用发起请求" class="headerlink" title="向 Pod 中的应用发起请求"></a>向 Pod 中的应用发起请求</h5><p>可以使用 <code>kubectl expose</code> 命令创建一个 Service 对象，给 Pod 分配一个负载均衡器，从而可以从外部访问 Pod 中运行的应用。但是对于开发、测试和调试等目的，有可能需要直接与 Pod 中的应用进行交互。<br>每个 Pod 都会自动绑定一个 IP 地址，从而可以被集群中的其他 Pod 访问，但该 IP 地址是仅限于集群内部的。</p><p><strong>获取 Pod 的 IP 地址</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pod kubia -o wide</span></span><br><span class="line">NAME    READY   STATUS    RESTARTS   AGE   IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia   1/1     Running   0          58m   172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p><strong>从工作节点连接 Pod</strong><br>Kubernetes 的网络模型支持从任意节点直接访问集群中所有节点上的任何 Pod。因而可以先登录某一个工作节点，再从该节点访问集群中的 Pod。<br>对于 Minikube 而言，可以使用 <code>minikube ssh</code> 命令登录工作节点。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube ssh</span></span><br><span class="line">docker@minikube:~$</span><br></pre></td></tr></table></figure></p><p>登录成功后，即可使用内部 IP 地址访问 kubia Pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker@minikube:~$ curl 172.17.0.3:8080</span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><h5 id="One-off-客户端-Pod"><a href="#One-off-客户端-Pod" class="headerlink" title="One-off 客户端 Pod"></a>One-off 客户端 Pod</h5><p>第二种测试应用连通性的方法是创建一个临时的 Pod 并运行 <code>curl</code> 命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl run --image=curlimages/curl -it --restart=Never --rm client-pod curl 172.17.0.2:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:172.17.0.4.</span><br><span class="line">pod "client-pod" deleted</span><br></pre></td></tr></table></figure></p><p>上面的命令会从 <code>curlimages/curl</code> 镜像创建一个容器，执行 <code>curl 172.17.0.2:8080</code> 命令。<br>其中 <code>-it</code> 选项会将当前的终端与容器的标准输入输出绑定，<code>--restart=Never</code> 选项确保 <code>curl</code> 命令执行完后容器直接停掉，<code>--rm</code> 选项负责在最后删除 Pod。</p><p>这种方式在测试 Pod 与 Pod 之间连通性的时候非常有用。</p><p><strong>通过 Kubectl 端口转发访问 Pod</strong><br>在开发过程中，最简单的访问容器中应用的方法是使用 <code>kubectl port-forward</code> 命令。该命令可以通过绑定到本地机器端口上的代理来访问特定的 Pod。<br>此方式甚至不需要知道 Pod 的 IP 地址，只需要指定 Pod 的名字和端口号即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia 8080</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br></pre></td></tr></table></figure></p><p>上述命令会在本地机器的 8080 端口开启一个代理，指向 kubia 容器的 8080 端口。<br>此时打开另一个命令行窗口，运行 <code>curl localhost:8080</code> 命令即等同于访问 kubia 容器的 8080 端口：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6a79ebdee7b3a1dd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl port-forward 的底层机制"></p><h5 id="查看应用日志"><a href="#查看应用日志" class="headerlink" title="查看应用日志"></a>查看应用日志</h5><p>不同于将日志写入到文件中，容器化应用通常会将日志输出到标准输出（stdout）和标准错误输出（stderr）。这使得容器运行时能够拦截应用的日志输出，将其转存在固定的位置（通常是 <code>/var/log/containers</code>），而不需要知道容器中日志文件的保存位置。<br>当使用 Kubernetes 运行应用时，可以登录到工作节点通过 <code>docker logs</code> 命令查看应用的日志，但更简单的方式是直接在本地使用 <code>kubectl logs</code> 命令。</p><p><strong>获取某个 Pod 的日志</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.1</span><br><span class="line">Received request for / from ::ffff:172.17.0.4</span><br><span class="line">Received request for / from ::ffff:172.17.0.4</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br></pre></td></tr></table></figure></p><p>加上 <code>-f (--follow)</code> 选项可以实时显示日志输出。</p><p><strong>在日志输出中显示时间戳</strong><br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia --timestamps=<span class="literal">true</span></span></span><br><span class="line">2021-12-27T13:40:21.606420000Z Kubia server starting...</span><br><span class="line">2021-12-27T13:40:21.606992200Z Local hostname is kubia</span><br><span class="line">2021-12-27T13:40:21.607003000Z Listening on port 8080</span><br><span class="line">2021-12-27T13:43:11.228907300Z Received request for / from ::ffff:172.17.0.1</span><br><span class="line">2021-12-27T13:47:45.648686300Z Received request for / from ::ffff:172.17.0.1</span><br><span class="line">2021-12-27T13:59:16.819436200Z Received request for / from ::ffff:172.17.0.4</span><br><span class="line">2021-12-27T14:01:19.101277000Z Received request for / from ::ffff:172.17.0.4</span><br><span class="line">2021-12-27T14:34:40.145715500Z Received request for / from ::ffff:127.0.0.1</span><br></pre></td></tr></table></figure></p><p>此外还可以根据时间筛选日志输出，比如只显示最近一段时间内的日志。<br><code>kubectl logs kubia --since=2h</code> 显示最近 2 小时内输出的日志内容。</p><p>也可以通过 <code>--since-time</code> 选项筛选特定时间后输出的日志：<br><code>kubectl logs kubia –-since-time=2020-02-01T09:50:00Z</code></p><p>或者直接使用 <code>--tail=n</code> 选项显示最近的 n 条日志。</p><p><strong>PS</strong><br>Kubernetes 会为每一个容器都保留一个独立的日志文件。它们通常保存在容器运行节点的 <code>/var/log/containers</code> 路径下，容器重启后其日志会写入到一个新的文件中。</p><p>如果某些容器应用将其日志写入到文件中而不是 stdout，理想情况下，应该配置一个中心化的日志系统定期收集这些日志。<br>如果只是想简单地手动访问容器中的日志文件，可以参考后面的内容。</p><h5 id="容器的文件传输"><a href="#容器的文件传输" class="headerlink" title="容器的文件传输"></a>容器的文件传输</h5><p>有些时候需要向运行的容器中添加文件，或者从容器中获取文件。虽然修改容器中的文件的场景并不多见（尤其在生产环境中），但在开发过程中还是有一定用处的。</p><p>Kubernetes 提供了 <code>cp</code> 命令，能够从本地磁盘复制文件或目录到任意 Pod，或者相反方向。<br><code>kubectl cp kubia:/etc/hosts /tmp/kubia-hosts</code> 将 kubia 容器中的 <code>/etc/hosts</code> 文件复制到本地 <code>/tmp</code> 路径下。</p><p><code>kubectl cp /path/to/local/file kubia:path/in/container</code> 将本地文件复制到 kubia 容器。</p><h5 id="在运行的容器中执行命令"><a href="#在运行的容器中执行命令" class="headerlink" title="在运行的容器中执行命令"></a>在运行的容器中执行命令</h5><p><strong>运行单个命令</strong><br>可以使用 <code>kubernetes exec</code> 命令运行容器文件系统中的某个可执行文件。<br>用户远程执行命令，无需登录到对应的工作节点上。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- ps aux</span></span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.2 564436 30216 ?        Ssl  13:40   0:00 node app.js</span><br><span class="line">root          13  5.0  0.0  36632  2660 ?        Rs   15:54   0:00 ps aux</span><br></pre></td></tr></table></figure></p><p>前面的章节中曾经通过一个 one-off 客户端容器运行 <code>curl</code> 命令，向应用发送请求。实际上也可以直接在应用容器中运行 <code>curl</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> kubia -- curl -s localhost:8080</span></span><br><span class="line">Hey there, this is kubia. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><strong>开启一个交互式 Shell</strong><br>如果想要交互式地在容器中运行多条命令，可以开启一个 Shell：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl <span class="built_in">exec</span> -it kubia -- bash</span></span><br><span class="line">root@kubia:/#</span><br></pre></td></tr></table></figure></p><p>之后就可以像在本地运行 Linux 命令一样在容器中执行命令了。</p><p>需要注意的是，为了保证容器的镜像足够小同时提高安全性，生产环境中使用的容器通常只包含运行应用所需要的可执行文件。这会大大减少潜在的攻击目标，同时也意味着用户无法使用 Shell 或其他 Linux 工具。</p><h4 id="在-Pod-中运行多个容器"><a href="#在-Pod-中运行多个容器" class="headerlink" title="在 Pod 中运行多个容器"></a>在 Pod 中运行多个容器</h4><p>前面的 kubia 容器只支持 HTTP 协议，可以为其添加 TLS 支持。其实有一种简单的不需要修改现有代码的方案，就是在现有的 Node.js 容器旁边添加一个提供反向代理功能的 sidecar 容器。</p><p><strong>用 Envoy 代理扩展 kubia 应用</strong><br>简单来说，Pod 中包含两个容器，其中 Node.js 容器仍然负责处理 HTTP 请求，而新加的 Envoy 容器负责转发 HTTPS 请求。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-17bb086353f53de8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="架构示意图"></p><p>创建如下清单文件 <code>kubia-ssl.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">kubia-ssl</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">kubia</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">  - name:</span> <span class="string">envoy</span></span><br><span class="line"><span class="attr">    image:</span> <span class="string">luksa/kubia-ssl-proxy:1.0</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">https</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">8443</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">admin</span></span><br><span class="line"><span class="attr">      containerPort:</span> <span class="number">9901</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>kubectl apply -f kubia-ssl.yml</code> 命令应用清单文件创建 Pod，之后等待创建完成即可。<br>可以运行 <code>kubectl describe pod kubia-ssl</code> 命令查看创建的进度。</p><p><strong>与两个容器的 Pod 进行交互</strong><br>使用 <code>kubectl port-forward</code> 命令启用端口转发：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl port-forward kubia-ssl 8080 8443 9901</span></span><br><span class="line">Forwarding from 127.0.0.1:8080 -&gt; 8080</span><br><span class="line">Forwarding from [::1]:8080 -&gt; 8080</span><br><span class="line">Forwarding from 127.0.0.1:8443 -&gt; 8443</span><br><span class="line">Forwarding from [::1]:8443 -&gt; 8443</span><br><span class="line">Forwarding from 127.0.0.1:9901 -&gt; 9901</span><br><span class="line">Forwarding from [::1]:9901 -&gt; 9901</span><br></pre></td></tr></table></figure></p><p>打开一个新的命令行窗口，使用 <code>curl</code> 命令测试与 kubia-ssl 应用的连通性：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl localhost:8080</span></span><br><span class="line">Hey there, this is kubia-ssl. Your IP is ::ffff:127.0.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl https://localhost:8443 --insecure</span></span><br><span class="line">Hey there, this is kubia-ssl. Your IP is ::ffff:127.0.0.1.</span><br></pre></td></tr></table></figure></p><p><strong>查看日志</strong><br>由于 kubia-ssl 包含两个容器，因此查看日志时需要使用 <code>--container</code> 或 <code>-c</code> 选项指定容器的名称。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-ssl -c kubia</span></span><br><span class="line">Kubia server starting...</span><br><span class="line">Local hostname is kubia-ssl</span><br><span class="line">Listening on port 8080</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br><span class="line">Received request for / from ::ffff:127.0.0.1</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl logs kubia-ssl -c envoy</span></span><br><span class="line">[2021-12-28 15:08:51.671][1][info][main] [source/server/server.cc:255] initializing epoch 0 (hot restart version=11.104)</span><br><span class="line">[2021-12-28 15:08:51.671][1][info][main] [source/server/server.cc:257] statically linked extensions:</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>或者使用 <code>kubectl logs kubia-ssl --all-containers</code> 命令显示所有容器的日志</p><h4 id="删除-Pod-和其他对象"><a href="#删除-Pod-和其他对象" class="headerlink" title="删除 Pod 和其他对象"></a>删除 Pod 和其他对象</h4><p>删除 kubia Pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete pod kubia</span></span><br><span class="line">pod "kubia" deleted</span><br></pre></td></tr></table></figure></p><p><code>kubectl delete</code> 命令默认会等待删除操作彻底完成后才退出，可以加上 <code>--wait=false</code> 异步执行此命令。</p><p>删除清单文件中定义的对象：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl delete -f kubia-ssl.yml</span></span><br><span class="line">pod "kubia-ssl" deleted</span><br></pre></td></tr></table></figure></p><p>删除所有 Pod：<code>kubectl delete po --all</code><br>删除所有对象：<code>kubectl delete all --all</code></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;下图展示了 Kubernetes 如何通过 Deployment、Pod、Service 三种对象部署一个最小化应用。&lt;br&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6875152-74a8e16f0
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="MicroService" scheme="https://rollingstarky.github.io/tags/MicroService/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="Administration" scheme="https://rollingstarky.github.io/tags/Administration/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 部署第一个应用</title>
    <link href="https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/"/>
    <id>https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/</id>
    <published>2021-12-13T16:00:00.000Z</published>
    <updated>2021-12-14T14:28:49.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Minikube-amp-kubectl"><a href="#Minikube-amp-kubectl" class="headerlink" title="Minikube &amp; kubectl"></a>Minikube &amp; kubectl</h4><p><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube</a> 是一个能够在本地环境搭建 Kubernetes 集群的工具，支持 Windows、Linux 和 MacOS 等平台，由 Kubernetes 社区进行维护。<br>它通常在 Linux 虚拟机中运行 Kubernetes。如果宿主机是基于 Linux 的系统，也可以通过 Docker 实现。<br>即为了运行 Minikube，需要先安装 Hypervisor 比如 Virtualbox；对于 Linux 系统，也可以直接使用 Docker。</p><p>具体的安装配置步骤可以参考官方文档 <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">Getting Started Guide</a>。</p><p>kubectl 是一个命令行工具，能够向 Kubernetes 集群发送命令并执行，支持的功能包括部署应用、查询和管理资源、查看日志等。<br>安装步骤可参考官方文档 <a href="https://kubernetes.io/docs/tasks/tools/" target="_blank" rel="noopener">Install Tools</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-cd8f312f56764487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl"></p><h4 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h4><p>通常情况下，部署应用时要准备一个 JSON 或者 YAML 文件，里面包含对该应用的所有组件的描述信息，再把该描述文件应用到 Kubernetes 集群。<br>从演示的角度来看，也可以通过单行命令的方式部署简单的应用。</p><h5 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h5><p>可以使用 <code>kubectl create deployment</code> 命令部署应用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create deployment kubia --image=luksa/kubia:1.0</span></span><br><span class="line">deployment.apps/kubia created</span><br></pre></td></tr></table></figure></p><p>其中 <code>kubia</code> 表示创建的 <strong>deployment</strong> 对象的名称，<code>luksa/kubia:1.0</code> 指代需要使用的容器镜像。</p><p><code>kubia</code> 对象的存在告诉 Kubernetes <code>luksa/kubia:1.0</code> 容器必须运行在集群中。它定义了一种用户期待的状态，而 Kubernetes 负责确保实际的状态一定会满足该期望。</p><p><code>kubectl get deployment</code> 命令可以列出当前集群中存在的所有 deployment 对象及其状态。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deployment</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   0/1     1            0           5m17s</span><br></pre></td></tr></table></figure></p><h5 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h5><p>容器并不是 Kubernetes 中部署的最小单位。不同于直接部署独立的容器，Kubernetes 实际上会部署一组相互关联的容器，称为 <strong>pod</strong>。<br>pod 包含一组一个或一个以上关系密切的容器实例，同时运行在同一个工作节点上，并共享特定的 Linux 命名空间。<br>同一个 pod 中的容器共享相同的网络和 UTS 命名空间，因而共享同样的网络接口、IP 地址、端口空间和主机名等。也可以在描述文件中定义其他需要共享的命名空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8722b456a653d61a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pods"></p><p>每个 pod 都有自己的 IP、机器名、进程、网络接口以及其他资源。同一个 pod 中的容器都会将自己看作是 pod 中唯一运行的容器，它们并不能看到其他容器中的进程。</p><p>创建 Deployment 对象后就表示已经部署了 pod，Kubernetes 会基于 Deployment 对象创建一个或多个 pod。<br>可以使用 <code>kubectl get pods</code> 来列出系统中的 pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          41m</span><br></pre></td></tr></table></figure></p><p>如果某些 issue 导致 pod 运行失败，或者单纯想查看更多 pod 相关的信息，可以使用 <code>kubectl describe pod</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod</span></span><br><span class="line">Name:         kubia-767f9bc59d-77d2z</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.49.2</span><br><span class="line">Start Time:   Tue, 14 Dec 2021 11:16:58 +0800</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">              pod-template-hash=767f9bc59d</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.3</span><br><span class="line">IPs:</span><br><span class="line">  IP:           172.17.0.3</span><br><span class="line">Controlled By:  ReplicaSet/kubia-767f9bc59d</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://e9bd5cf8f2eb15959c08bc8f154742b7194030d8ce0f9e6290cd80fc21b48692</span><br><span class="line">    Image:          luksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Tue, 14 Dec 2021 11:26:25 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-n9n9b (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  kube-api-access-n9n9b:</span><br><span class="line">    Type:                    Projected (a volume that contains injected data from multiple sources)</span><br><span class="line">    TokenExpirationSeconds:  3607</span><br><span class="line">    ConfigMapName:           kube-root-ca.crt</span><br><span class="line">    ConfigMapOptional:       &lt;nil&gt;</span><br><span class="line">    DownwardAPI:             true</span><br><span class="line">QoS Class:                   BestEffort</span><br><span class="line">Node-Selectors:              &lt;none&gt;</span><br><span class="line">Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s</span><br><span class="line">                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  11m   default-scheduler  Successfully assigned default/kubia-767f9bc59d-77d2z to minikube</span><br><span class="line">  Normal  Pulling    11m   kubelet            Pulling image "luksa/kubia:1.0"</span><br><span class="line">  Normal  Pulled     115s  kubelet            Successfully pulled image "luksa/kubia:1.0" in 9m24.3380576s</span><br><span class="line">  Normal  Created    113s  kubelet            Created container kubia</span><br><span class="line">  Normal  Started    113s  kubelet            Started container kubia</span><br></pre></td></tr></table></figure></p><p>输出的最后就包含 pod 创建和启动时触发的一系列事件（Events）。</p><h5 id="Pods-的创建流程"><a href="#Pods-的创建流程" class="headerlink" title="Pods 的创建流程"></a>Pods 的创建流程</h5><ul><li>运行 <code>kubectl create deployment</code> 命令，向 Kubernetes API Server 发送 HTTP 请求，创建一个新的 Deployment 对象</li><li>之后 Kubernetes 创建一个新的 Pod 对象，该 Pod 对象被分配给某个工作节点</li><li>工作节点上的 Kubelet agent 得知新的 Pod 对象被创建，且分配给了自己。于是 Kubelet 控制 Docker 拉取特定的镜像并创建、运行容器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a4e1b15833234eb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deployment object to a running container"></p><h4 id="向外部暴露应用"><a href="#向外部暴露应用" class="headerlink" title="向外部暴露应用"></a>向外部暴露应用</h4><p>应用已经成功运行了，接下来就是控制它如何被外部访问。每个 pod 都会获得一个专属的 IP 地址，但该地址是只有集群内部可见的。为了使 pod 能够从外部访问，还需要创建一个 <strong>Service</strong> 对象。</p><p>Service 对象有好几种类型，其中一种 LoadBalancer 会生成一个外部的负载均衡器，令服务能够从集群外部访问。<br>可以使用 <code>kubectl expose</code> 命令创建 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl expose deployment kubia --<span class="built_in">type</span>=LoadBalancer --port 8080</span></span><br><span class="line">service/kubia exposed</span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl get svc</code> 命令查看当前系统中存在的 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          29d</span><br><span class="line">kubia        LoadBalancer   10.106.111.39   &lt;pending&gt;     8080:30077/TCP   2m28s</span><br></pre></td></tr></table></figure></p><p>创建 LoadBalancer 服务时，正常情况下 Kubernetes 会访问云服务提供商，令其创建负载均衡器并获取公共 IP。<br>Minikube 是本地模拟的集群环境，因而无法完成上述操作。kubia Service 的 EXTERNAL-IP 会一直处于 <pending> 状态。</pending></p><p>在没有获取到外部 IP 的情况下，minikube 可以使用下面的方法获取服务的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube service kubia --url</span></span><br><span class="line">🏃  Starting tunnel for service kubia.</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| NAMESPACE | NAME  | TARGET PORT |          URL           |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| default   | kubia |             | http://127.0.0.1:39529 |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">http://127.0.0.1:39529</span><br><span class="line">❗  Because you are using a Docker driver on linux, the terminal needs to be open to run it.</span><br></pre></td></tr></table></figure></p><p>打开一个新的命令行窗口，可以成功访问上面的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><h5 id="LoadBalancer-的创建流程"><a href="#LoadBalancer-的创建流程" class="headerlink" title="LoadBalancer 的创建流程"></a>LoadBalancer 的创建流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-847957263408bbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service object to LoadBalancer"></p><h4 id="横向扩展应用"><a href="#横向扩展应用" class="headerlink" title="横向扩展应用"></a>横向扩展应用</h4><p>在容器中部署应用的一个主要好处就是，横向扩展应用变得非常简单和直观。<br>可以使用下列命令扩展 kubia 应用，令其同时运行 3 个实例副本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl scale deployment kubia --replicas=3</span></span><br><span class="line">deployment.apps/kubia scaled</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deploy</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   3/3     3            3           3h58m</span><br></pre></td></tr></table></figure></p><p>此时共有 3 个 pod 实例运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          3h59m</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          3m56s</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          3m56s</span><br></pre></td></tr></table></figure></p><p>可以加上 <code>-o wide</code> 选项获取更详细的 pods 信息，比如 IP、运行的节点等：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          4h      172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          5m31s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          5m31s   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>再次访问 Service 的 URL，可以看到多次访问返回的信息并不一样，可以证实后台提供服务的 pod 并不是同一个，而是 3 个 pod 轮流接收请求并提供服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-rvsdq. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><p>负载均衡架构示意图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2ec179df5ff6687c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Load balancing"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>部署应用可以使用 <code>kubectl create deployment</code> 命令，暴露应用使用 <code>kubectl expose deployment</code> 命令，横向扩展应用使用 <code>kubectl scale deployment</code> 命令。</li><li>应用部署的基本单位不是容器而是 pod，一个 pod 可以包含一个或多个相互关联的容器。</li><li>Deployments、Services、Pods 和 Nodes 都是 Kubernetes 对象/资源。可以使用 <code>kubectl get</code> 命令获取这些对象的列表，或者使用 <code>kubectl describe</code> 命令获取对象的详细信息。</li><li>Deployment 对象负责部署指定数量的 pods。Services 对象则可以令这些 pods 能够通过一个单一的 IP 地址访问。</li><li>Service 在集群内部提供负载均衡。如果指定其类型为 LoadBalancer，则 Kubernetes 会请求云服务提供商令应用可以通过公共地址访问。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Minikube-amp-kubectl&quot;&gt;&lt;a href=&quot;#Minikube-amp-kubectl&quot; class=&quot;headerlink&quot; title=&quot;Minikube &amp;amp; kubectl&quot;&gt;&lt;/a&gt;Minikube &amp;amp; kubectl&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="MicroService" scheme="https://rollingstarky.github.io/tags/MicroService/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="Cluster" scheme="https://rollingstarky.github.io/tags/Cluster/"/>
    
      <category term="LoadBalance" scheme="https://rollingstarky.github.io/tags/LoadBalance/"/>
    
  </entry>
  
  <entry>
    <title>Uncle Bob 的 SOLID 软件设计原则——Python 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/"/>
    <id>https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2021-12-13T15:27:42.347Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 <a href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank" rel="noopener">Robert C. Martin</a>（习惯上被称为 Uncle Bob）总结。可以帮助程序员写出更加灵活、容易理解、可维护性强、方便扩展的健壮代码。</p><ul><li>S 代表 <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">Single Responsibility Principle (SRP)</a>，一个类应该只包含一种单一的职责，有且仅有一种原因能促使其变更。通俗点说，让一个类只做一件事。如果需要承担更多的工作，那么分解这个类。</li><li>O 代表 <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">Open/Closed Principle (OCP)</a>，软件实体应该对扩展是开放的，同时对修改是封闭的。如果需要添加额外的功能，应该优先扩展某个类而不是修改它。</li><li>L 代表 <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">Liskov Substitution Principle (LSP)</a>，程序中的对象应该能够替换为其子类型的实例，仍不影响代码的正确性。</li><li>I 代表 <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">Interface Segregation Principle (ISP)</a>，多个专门的基于客户端的接口要好于只有一个通用的接口。一个类对另一个类的依赖性应该建立在最小的接口上，客户端不应该被强迫实现一些他们不会使用的接口。</li><li>D 代表 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">Dependency Inversion Principle (DIP)</a>，抽象不应该依赖于细节，细节应当依赖于抽象。即要针对抽象（接口）编程，而不是针对实现细节编程。</li></ul><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, payment_type, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> payment_type == <span class="string">"debit"</span>:</span><br><span class="line">            print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">elif</span> payment_type == <span class="string">"credit"</span>:</span><br><span class="line">            print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f"Unknown payment type: <span class="subst">&#123;payment_type&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">order.pay(<span class="string">"debit"</span>, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure><p>上述 Python 代码实现了一个简单的“购物车”（订单）应用。</p><ul><li><code>add_item</code> 方法可以向订单中添加新的货物</li><li><code>total_price</code> 方法可以计算订单的总价</li><li><code>pay</code> 方法实现了订单的支付功能，支持借记卡、信用卡等支付方式</li></ul><h4 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h4><p>单一职能原则。<br>将支付功能从 <code>Order</code> 类中分离出来，在另一个 <code>PaymentProcessor</code> 类中实现。同时去掉 <code>pay</code> 方法中的 <code>if-else</code> 判断，分别用两个函数 <code>pay_debit</code> 和 <code>pay_credit</code> 实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_debit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_credit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaymentProcessor()</span><br><span class="line">processor.pay_debit(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h4><p>在最新的支付功能的实现中，如果我们需要添加一个新的支付方法（比如 PayPal），就必须修改 <code>PaymentProcessor</code> 类的原始代码。这就违反了 Open/Closed 原则，额外的功能应该通过扩展而不是修改原来的类来实现。<br>改进的方法是用一个基类（<code>PaymentProcessor</code>）来定义基本的支付逻辑，再通过子类（如 <code>DebitPaymentProcessor</code>）来实现具体的支付方法。这样每当添加一种新的支付方式，直接实现一个新的子类即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = DebitPaymentProcessor()</span><br><span class="line">processor.pay(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h4><p>假设我们现在需要添加一种新的支付方式 <code>PayPalPaymentProcessor</code>，它在支付时并不依赖于 <code>security_code</code> 而是需要 <code>email_address</code> 进行验证。即 <code>pay</code> 方法的定义是 <code>pay(self, order, email_address)</code>，与基类中虚拟方法的签名冲突。<br>改进的方法是将 <code>pay</code> 方法依赖的参数 <code>security_code</code> 或 <code>email_address</code> 移动到支付类的 <code>__init__</code> 方法中，将基类和子类的 <code>pay</code> 方法签名都改为 <code>pay(self, order)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h4><p>假设我们需要在支付组件中添加一个验证短信的功能。直观的想法是直接在 <code>PaymentProcessor</code> 基类中添加一个 <code>auth_sms</code> 虚拟方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>对于需要验证短信的支付方式比如借记卡，改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>对于不需要短信验证的支付方式比如信用卡，就改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(</span><br><span class="line">            <span class="string">"Credit card payments don't support SMS code authorization."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>上述实现的问题在于，我们定义了一个通用的支付接口（<code>PaymentProcessor</code>），包含 <code>pay</code> 和 <code>auth_sms</code> 两种验证逻辑。但这两种逻辑并不总是被具体的支付方式（比如 <code>CreditPaymentProcessor</code>）所需要。<br>这违反了接口分离原则。即接口的实现应该依赖于具体的客户端（子类）需求，而不能不管客户端是否需要，就将所有的功能都放在一个胖接口中。<br>可以额外再实现一个 <code>PaymentProcessor_SMS</code> 基类来定义短信验证的逻辑，让不需要短信验证的支付方式继承 <code>PaymentProcessor</code> 基类，需要短信验证的支付方式继承 <code>PaymentProcessor_SMS</code> 基类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor_SMS</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.auth_sms(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h5 id="Composition-over-Inheritance"><a href="#Composition-over-Inheritance" class="headerlink" title="Composition over Inheritance"></a>Composition over Inheritance</h5><p>在软件设计的大部分场景中，组合要优于继承。因为继承总是意味着更紧密的耦合性。<br>实际上短信认证并不一定通过继承来实现（<code>PaymentProcessor_SMS</code>），还可以通过组合来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = SMSAuth()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.verify_code(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><p>定义一个 <code>SMS_Auth</code> 类来实现短信验证的逻辑，再通过组合的方式将其实例添加到具体的需要短信验证的支付方式中（比如 <code>DebitPaymentProcessor</code>）。</p><h4 id="Dependency-Inversion-Principle"><a href="#Dependency-Inversion-Principle" class="headerlink" title="Dependency Inversion Principle"></a>Dependency Inversion Principle</h4><p>细节应该依赖于抽象，而不是抽象依赖于细节。上述实现中就违反了这个原则。<br>比如借记卡支付方式（<code>DebitPaymentProcessor</code>）的 <code>__init__</code> 方法，签名是 <code>__init__(self, security_code, authorizer: SMSAuth)</code>。其中的 <code>SMSAuth</code> 是一个具体的短信验证类型，而不是一个通用的代表某种验证类型的抽象。<br>这样当支付方式需要的是另外一种验证方法（比如 <code>NotARobot</code>），这里的签名就需要修改。</p><p>可以创建一个 <code>Authorizer</code> 基类来代表通用的验证方式，具体的验证方式比如 <code>SMSAuth</code>、<code>NotARobot</code> 则作为 <code>Authorizer</code> 的子类来实现。<br>在支付方式的实现中，则使用 <code>Authorizer</code> 作为验证方式的类型定义。这样在使用支付类的实例时，就可以灵活地传入 <code>Authorizer</code> 的子类 <code>SMSAuth</code> 或者 <code>NotARobot</code> 进行组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authorizer</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotARobot</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">not_a_robot</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Are you a robot? Naa"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = NotARobot()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.not_a_robot()</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=pTB30aXS77U" target="_blank" rel="noopener">Uncle Bob’s SOLID principles made easy 🍀 - in Python!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 &lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_C._Martin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Robert C. Marti
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Interface" scheme="https://rollingstarky.github.io/tags/Interface/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Principle" scheme="https://rollingstarky.github.io/tags/Principle/"/>
    
      <category term="SOLID" scheme="https://rollingstarky.github.io/tags/SOLID/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Dependency" scheme="https://rollingstarky.github.io/tags/Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Linux xargs 命令解析</title>
    <link href="https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/"/>
    <id>https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-09T12:37:35.469Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>xargs</code> 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并执行。<br><code>xargs</code> 可以帮助 <code>echo</code>、<code>rm</code>、<code>mkdir</code> 等命令接收标准输入作为参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xargs mkdir</span></span><br><span class="line">test1 test2</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2</span><br></pre></td></tr></table></figure><p>比如执行 <code>xargs mkdir</code> 命令，输入 <code>test1 test2</code> 后回车，再按 <code>CTRL-D</code> 结束输入，等效于直接执行 <code>mkdir test1 test2</code> 命令。<br>即 <code>xarg</code> 读取了标准输入中的 <code>test1 test2</code>，并将它们作为参数传递给 <code>mkdir</code> 命令，组合成一个完整的 <code>mkdir test1 test2</code> 命令并执行。</p><p>实际上 <code>xargs</code> 很少用在上述交互式场景中，更多的是搭配管道符 <code>|</code>，通过前一个命令的输出构建新的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test3 test4 test5 | xargs mkdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2  test3  test4  test5</span><br></pre></td></tr></table></figure><p><code>|</code> 和 <code>| xargs</code> 的区别：</p><ul><li>管道符 <code>|</code> 是将左边命令的输出结果作为右边命令的输入值</li><li><code>| xargs</code> 则可以将左边命令的输出结果作为右边命令的参数选项</li></ul><h4 id="find-与-xargs"><a href="#find-与-xargs" class="headerlink" title="find 与 xargs"></a>find 与 xargs</h4><p><code>xargs</code> 最常见的搭配应该就是 <code>find</code> 命令了。即通过 <code>find</code> 查找特定的文件或目录，再将结果传递给 <code>xargs</code>，对找到的结果执行特定的操作。</p><p>如删除 <code>/tmp</code> 路径下最近两周内未做改动的文件：<br><code>find /tmp -type f -mtime +14 | xargs rm</code></p><p>有一点特别需要注意：默认情况下，<code>xargs</code> 从标准输入读取命令参数时，会以空格作为分隔符来识别多个选项。<br>而文件和目录的名字有时候也会包含空格，导致一个文件名被 <code>xargs</code> 识别为两个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="built_in">test</span>\ 6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'   test1   test2   test3   test4   test5</span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> d | xargs rmdir</span></span><br><span class="line">rmdir: failed to remove './test': No such file or directory</span><br><span class="line">rmdir: failed to remove '6': No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'</span><br></pre></td></tr></table></figure><p>更安全一点的做法是使用 <code>-0</code> 选项。<code>-0</code> 选项可以指定 <code>xargs</code> 在读取标准输入时使用 <code>null</code> 作为分隔符。而 <code>find</code> 命令的 <code>-print0</code> 选项同样可以将输出指定为使用 <code>null</code> 进行分割。</p><p>即将前面的命令替换为 <strong><code>find . -type d -print0 | xargs -0 rmdir</code></strong>。</p><h5 id="find-搭配-exec-选项和搭配-xargs-命令的区别"><a href="#find-搭配-exec-选项和搭配-xargs-命令的区别" class="headerlink" title="find 搭配 -exec 选项和搭配 xargs 命令的区别"></a>find 搭配 <code>-exec</code> 选项和搭配 xargs 命令的区别</h5><p><code>find</code> 命令可以使用其 <code>-exec</code> 选项对查找到的结果执行特定的操作。同样的需求 <code>xargs</code> 也可以实现。</p><p>比如需要删除当前目录下所有的 TXT 文件：</p><ul><li>使用 <code>-exec</code>：<code>find . -type f -name &quot;*.txt&quot; -exec rm {} \;</code></li><li>使用 <code>xargs</code>：<code>find . -type f -name &quot;*.txt&quot; | xargs rm</code></li></ul><p>实际上两者的执行效率存在着很大的差距。<br>比如使用 <code>for i in {1..100}; do touch $i.txt; done</code> 命令创建 100 个 TXT 文件，再分别使用上述两个命令删除这些文件（用 <code>time</code> 命令计时），具体的效率如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">1.txt    18.txt  27.txt  36.txt  45.txt  54.txt  63.txt  72.txt  81.txt  90.txt</span><br><span class="line">10.txt   19.txt  28.txt  37.txt  46.txt  55.txt  64.txt  73.txt  82.txt  91.txt</span><br><span class="line">100.txt  2.txt   29.txt  38.txt  47.txt  56.txt  65.txt  74.txt  83.txt  92.txt</span><br><span class="line">11.txt   20.txt  3.txt   39.txt  48.txt  57.txt  66.txt  75.txt  84.txt  93.txt</span><br><span class="line">12.txt   21.txt  30.txt  4.txt   49.txt  58.txt  67.txt  76.txt  85.txt  94.txt</span><br><span class="line">13.txt   22.txt  31.txt  40.txt  5.txt   59.txt  68.txt  77.txt  86.txt  95.txt</span><br><span class="line">14.txt   23.txt  32.txt  41.txt  50.txt  6.txt   69.txt  78.txt  87.txt  96.txt</span><br><span class="line">15.txt   24.txt  33.txt  42.txt  51.txt  60.txt  7.txt   79.txt  88.txt  97.txt</span><br><span class="line">16.txt   25.txt  34.txt  43.txt  52.txt  61.txt  70.txt  8.txt   89.txt  98.txt</span><br><span class="line">17.txt   26.txt  35.txt  44.txt  53.txt  62.txt  71.txt  80.txt  9.txt   99.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span></span><br><span class="line">find . -type f -name "*.txt" -exec rm &#123;&#125; \;  0.05s user 0.02s system 104% cpu 0.060 total</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> | xargs rm</span></span><br><span class="line">find . -type f -name "*.txt"  0.00s user 0.00s system 80% cpu 0.001 total</span><br><span class="line">xargs rm  0.00s user 0.00s system 94% cpu 0.003 total</span><br></pre></td></tr></table></figure></p><p>前者是 0.06，后者是 0.004。使用 <code>xargs</code> 的执行效率更高。</p><h4 id="输出执行的命令"><a href="#输出执行的命令" class="headerlink" title="输出执行的命令"></a>输出执行的命令</h4><p><code>-t</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印到终端窗口中。方便对脚本进行调试。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test1 test2 test3 | xargs -t mkdir</span></span><br><span class="line">mkdir test1 test2 test3</span><br></pre></td></tr></table></figure></p><h4 id="输出命令并提示用户确认"><a href="#输出命令并提示用户确认" class="headerlink" title="输出命令并提示用户确认"></a>输出命令并提示用户确认</h4><p><code>-p</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印出来，并等待用户进行确认。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls | xargs -p rmdir</span></span><br><span class="line">rmdir test1 test2 test3 ?...y</span><br></pre></td></tr></table></figure></p><h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>借助 <code>-I</code> 选项可以令 <code>xargs</code> 同时执行多个命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt | xargs -I % sh -c <span class="string">'echo %; mkdir %'</span></span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">foo.txt  one  three  two</span><br></pre></td></tr></table></figure></p><h4 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h4><p><strong>查找当前路径下所有的 PNG 图片并将它们归档到 <code>images.tar.gz</code> 压缩包中</strong>：<br><code>$ find . -name &quot;*.png&quot; -type f -print0 | xargs -0 tar -cvzf images.tar.gz</code></p><p><strong>获取当前系统中所有用户的用户名，以单行列表的形式输出</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="built_in">echo</span></span></span><br><span class="line">_apt backup bin daemon games gnats irc landscape list lp mail man messagebus news nobody pollinate postgres proxy root sshd starky sync sys syslog systemd-network systemd-resolve systemd-timesync tcpdump tss uucp uuidd www-data</span><br></pre></td></tr></table></figure></p><p><strong>删除当前路径下名为 <code>no_use</code> 的文件</strong>：<br><code>$ find . -name &quot;no_use&quot; -type f -print0 | xargs -0 rm -v -f</code></p><p><strong>复制一个文件到多个路径下</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">dest1  dest2  test_file</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 cp -v ./test_file</span></span><br><span class="line">'./test_file' -&gt; './dest1/test_file'</span><br><span class="line">'./test_file' -&gt; './dest2/test_file'</span><br></pre></td></tr></table></figure></p><p>上面例子中 <code>xargs</code> 的 <code>-n 1</code> 选项非常重要。<code>-n</code> 选项用于指定 <code>xargs</code> 在将标准输入作为参数与命令拼接在一起时，参数的最大长度。</p><p>简单来说，当 <code>-n</code> 为 1 时，标准输入中以空格分割的每一项都与命令进行拼接，最终形成多条命令；当不存在 <code>-n 1</code> 时，标准输入中以空格分割的所有参数项直接与命令进行拼接，形成一条命令并执行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/</span><br><span class="line">cp ./test_file ./dest2/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/ ./dest2/</span><br><span class="line">cp: -r not specified; omitting directory './dest1/'</span><br></pre></td></tr></table></figure></p><ul><li><code>echo ./dest1/ ./dest2/ | xargs -n 1 cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/</code> 和 <code>cp ./test_file ./dest2/</code> 两条命令</li><li><code>echo ./dest1/ ./dest2/ | xargs cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/ ./dest2/</code> 一条命令（语法是错的）</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://shapeshed.com/unix-xargs/" target="_blank" rel="noopener">Linux and Unix xargs command tutorial with examples</a><br><a href="https://www.tecmint.com/xargs-command-examples/" target="_blank" rel="noopener">12 Practical Examples of Linux Xargs Command for Beginners</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h4&gt;&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Script" scheme="https://rollingstarky.github.io/tags/Script/"/>
    
      <category term="Administration" scheme="https://rollingstarky.github.io/tags/Administration/"/>
    
      <category term="Xargs" scheme="https://rollingstarky.github.io/tags/Xargs/"/>
    
      <category term="Find" scheme="https://rollingstarky.github.io/tags/Find/"/>
    
  </entry>
  
  <entry>
    <title>Python code smells 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/"/>
    <id>https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2021-12-06T15:38:09.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>code smells</strong> 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。<br>很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够健壮等问题。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: str</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self, payout: bool)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday, or pay out 5 holidays."""</span></span><br><span class="line">        <span class="keyword">if</span> payout:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                            Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">                )</span><br><span class="line">            self.vacation_days -= <span class="number">1</span></span><br><span class="line">            print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        managers = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"manager"</span>:</span><br><span class="line">                managers.append(employee)</span><br><span class="line">        <span class="keyword">return</span> managers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_vice_presidents</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        vice_presidents = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"president"</span>:</span><br><span class="line">                vice_presidents.append(employee)</span><br><span class="line">        <span class="keyword">return</span> vice_presidents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_interns</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        interns = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"intern"</span>:</span><br><span class="line">                interns.append(employee)</span><br><span class="line">        <span class="keyword">return</span> interns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                            $<span class="subst">&#123;employee.hourly_rate&#125;</span> for <span class="subst">&#123;employee.amount&#125;</span> hours."</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br><span class="line">    print(company.find_vice_presidents())</span><br><span class="line">    print(company.find_managers())</span><br><span class="line">    print(company.find_interns())</span><br><span class="line">    company.pay_employee(company.employees[<span class="number">0</span>])</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday(<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码实现了一个简单的“员工管理系统”。</p><ul><li>Employee 类代表公司里的员工，有姓名、角色、假期等属性。可以请假（<code>take_a_holiday</code>），或者单独请一天，或者以 5 天为单位将假期兑换为报酬</li><li>HourlyEmployee 和 MonthlyEmployee 分别代表以时薪或者月薪来计算工资的员工</li><li>Company 类代表公司，可以招收员工（<code>add_employee</code>）、返回特定角色的员工列表（如 <code>find_managers</code>）、发放薪资等（<code>pay_employee</code>）</li></ul><h4 id="code-smells"><a href="#code-smells" class="headerlink" title="code smells"></a>code smells</h4><p>上面的代码中存在着很多可以改进的地方。</p><h5 id="用-Enum-类型替代-str-作为员工的-role-属性"><a href="#用-Enum-类型替代-str-作为员工的-role-属性" class="headerlink" title="用 Enum 类型替代 str 作为员工的 role 属性"></a>用 Enum 类型替代 str 作为员工的 role 属性</h5><p>上面的 <code>Employee</code> 类使用了 <code>str</code> 类型来存储 <code>role</code> 属性的值，比如用 <code>&quot;manager&quot;</code> 代表经理，用 <code>&quot;intern&quot;</code> 代表实习生。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br></pre></td></tr></table></figure></p><p>实际上 String 过于灵活，可以拥有任何含义，用来表示角色属性时不具有足够清晰的指向性。不同的拼写规则和大小写习惯都会导致出现错误的指向，比如 <code>&quot;Manager&quot;</code> 和 <code>&quot;manager&quot;</code>，<code>&quot;vice-president&quot;</code> 和 <code>&quot;vice_president&quot;</code>。<br>可以使用 Enum 替代 str。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br></pre></td></tr></table></figure></p><p>修改 <code>Employee</code> 类中 <code>role</code> 属性的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br></pre></td></tr></table></figure></p><p><code>Company</code> 类中 <code>find_managers</code> 等方法也做相应的修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">    managers = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == Role.MANAGER:</span><br><span class="line">            managers.append(employee)</span><br><span class="line">    <span class="keyword">return</span> managers</span><br></pre></td></tr></table></figure></p><p><code>main</code> 方法中使用新的 role 创建员工对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h5><p><code>Company</code> 类中有一个功能是返回特定角色的员工列表，即 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 三个方法。<br>这三个方法实际上有着同样的逻辑，却分散在了三个不同的函数里。可以合并成一个方法来消除重复代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line">    employees = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == role:</span><br><span class="line">            employees.append(employee)</span><br><span class="line">    <span class="keyword">return</span> employees</span><br></pre></td></tr></table></figure></p><p>同时将 <code>main</code> 函数中的 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 都改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">print(company.find_employees(Role.MANAGER))</span><br><span class="line">print(company.find_employees(Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="尽量使用内置函数"><a href="#尽量使用内置函数" class="headerlink" title="尽量使用内置函数"></a>尽量使用内置函数</h5><p>上面版本中的 <code>find_employees</code> 方法，包含了一个 <code>for</code> 循环。实际上该部分逻辑可以使用 Python 内置的<strong>列表推导</strong>来实现。<br>合理的使用 Python 内置函数可以使代码更短、更直观，同时内置函数针对很多场景在性能上也做了一定的优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br></pre></td></tr></table></figure></p><h5 id="更清晰明确的变量名"><a href="#更清晰明确的变量名" class="headerlink" title="更清晰明确的变量名"></a>更清晰明确的变量名</h5><p>旧版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>新版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h5 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h5><p>当你在代码的任何地方看到 <code>isinstance</code> 这个函数时，都需要特别地加以关注。它意味着代码中有可能存在某些有待提升的设计。</p><p>比如代码中的 <code>pay_employee</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                        $<span class="subst">&#123;employee.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;employee.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>这里 <code>isinstance</code> 的使用，实际上在 <code>pay_employee</code> 函数中引入了对 <code>Employee</code> 的子类的依赖。这种依赖导致各部分代码之间的职责划分不够清晰，耦合性变强。<br><code>pay_employee</code> 方法需要与 <code>Employee</code> 的子类的具体实现保持同步。每新增一个新的员工类型（<code>Employee</code> 的子类），此方法中的 <code>if-else</code> 也就必须再新增一个分支。即需要同时改动不同位置的两部分代码。</p><p>可以将 <code>pay_employee</code> 的实现从 <code>Company</code> 类转移到具体的 <code>Employee</code> 子类中。即特定类型的员工拥有对应的报酬支付方法，公司在发薪时只需要调用对应员工的 <code>pay</code> 方法，无需实现自己的<code>pay_employee</code> 方法。<br>由 <code>isinstance</code> 引入的依赖关系从而被移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@dataclass</span><br><span class="line">class HourlyEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot; Employee that&apos;s paid based on number of worked hours.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = 50</span><br><span class="line">    hours_worked: int = 10</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a hourly rate of \</span><br><span class="line">                    $&#123;self.hourly_rate_dollars&#125; for &#123;self.hours_worked&#125; hours.&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class SalariedEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot;Employee that&apos;s paid based on a fixed monthly salary.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    monthly_salary: float = 5000</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a monthly salary of $&#123;self.monthly_salary&#125;&quot;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>再把 <code>main</code> 函数中的 <code>company.pay_employee(company.employees[0])</code> 改为 <code>company.employees[0].pay()</code>。</p><p>由于每一个特定的 <code>Employee</code> 子类都需要实现 <code>pay</code> 方法，更好的方式是将 <code>Employee</code> 实现为虚拟基类，<code>pay</code> 成为子类必须实现的虚拟方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br></pre></td></tr></table></figure></p><h5 id="Bool-flag"><a href="#Bool-flag" class="headerlink" title="Bool flag"></a>Bool flag</h5><p><code>Employee</code> 类中的 <code>take_a_holiday</code> 方法有一个名为 <code>payout</code> 的参数。它是布尔类型，作为一个开关，来决定某个员工是请一天假，还是以 5 天为单位将假期兑换为报酬。<br>这个开关实际上导致了 <code>take_a_holiday</code> 方法包含了两种不同的职责，只通过一个布尔值来决定具体执行哪一个。</p><p><strong>函数原本的目的就是职责的分离</strong>。使得同一个代码块中不会包含过多不同类型的任务。<br>因此 <code>take_a_holiday</code> 方法最好分割成两个不同的方法，分别应对不同的休假方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                        Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h5 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h5><p><code>payout_a_holiday</code> 方法中有一步 <code>try-except</code> 代码。但该部分代码实际上对 Exception 没有做任何事。对于 Exception 而言：</p><p><strong>如果需要 catch Exception，就 catch 特定类型的某个 Exception，并对其进行处理；如果不会对该 Exception 做任何处理，就不要 catch 它</strong>。</p><p>在此处使用 <code>try-except</code> 会阻止异常向外抛出，导致外部代码在调用 <code>payout_a_holiday</code> 时获取不到异常信息。此外，使用 <code>Exception</code> 而不是某个特定类型的异常，会导致所有的异常信息都被屏蔽掉，包括语法错误、键盘中断等。<br>因此，去掉上述代码中的 <code>try-except</code>。</p><h5 id="使用自定义-Exception-替代-ValueError"><a href="#使用自定义-Exception-替代-ValueError" class="headerlink" title="使用自定义 Exception 替代 ValueError"></a>使用自定义 Exception 替代 ValueError</h5><p><code>ValueError</code> 是 Python 内置的在内部出现值错误时抛出的异常，并不适合用在自定义的场景中。最好在代码中定义自己的异常类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">        <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">            requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">            remaining_days=self.vacation_days,</span><br><span class="line">            message=<span class="string">"You don't have enough holidays left over for a payout."</span>)</span><br><span class="line">    self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">    print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h4 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=<span class="number">1</span>,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have any holidays left. Now back to work, you!"</span>)</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have enough holidays left over for a payout."</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">        print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                    $<span class="subst">&#123;self.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;self.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a monthly salary of $<span class="subst">&#123;self.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">        <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">    company.add_employee(HourlyEmployee(</span><br><span class="line">        name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br><span class="line">    print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">    print(company.find_employees(Role.MANAGER))</span><br><span class="line">    print(company.find_employees(Role.INTERN))</span><br><span class="line">    company.employees[<span class="number">0</span>].pay()</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=LrtnLEkOwFE" target="_blank" rel="noopener">7 Python Code Smells: Olfactory Offenses To Avoid At All Costs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;code smells&lt;/strong&gt; 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。&lt;br&gt;很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Refactoring" scheme="https://rollingstarky.github.io/tags/Refactoring/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Exception" scheme="https://rollingstarky.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— Kubernetes 介绍</title>
    <link href="https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/"/>
    <id>https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2021-11-30T11:39:02.008Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。</p><p><strong>Kubernetes 是一个负责自动化部署和管理应用的软件系统，主要针对由容器构成的复杂的大型应用系统</strong>。</p><h4 id="Kubernetes-的基本特性"><a href="#Kubernetes-的基本特性" class="headerlink" title="Kubernetes 的基本特性"></a>Kubernetes 的基本特性</h4><p><strong>抽象化基础设施</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8ecedf6a16f124ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Infrastructure abstraction"></p><p>Kubernetes 为用户和应用在底层的硬件之上提供了一个抽象层，底层的基础设施如计算机、网络及其他组件等对应用都是不可见的。用户通过这个抽象层部署和管理应用，不需要再面对每一台特定的机器。因此配置起来更加方便。</p><p><strong>标准化部署</strong><br>由于底层基础设施的具体细节不会再影响到应用的部署，本地数据中心和云环境都可以使用同样的部署方式。任何底层基础设施的差异都交给 Kubernetes 去处理，用户可以只关注产品及其内部逻辑。</p><p><strong>声明式部署</strong><br>Kubernetes 使用声明式的模型来定义具体的应用。用户只需要完成对应用中各组件的描述，Kubernetes 就会将这些描述转化成运行的应用。并在之后保证该应用的健康运行，在必要的时候重启或重新创建某个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-948914611a361f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Declarative model"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4474de5ae26d30a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Changes in the description"></p><p>当用户修改了某些描述，Kubernetes 会根据改动自动采取必要的步骤重新配置应用，令应用满足最新的描述。</p><p><strong>接管应用的日常管理</strong><br>一旦用户通过 Kubernetes 部署了某个应用，该应用的日常管理就会被 Kubernetes 接管。假如服务停止运行，Kubernetes 会自动重启该应用；或者由于硬件失效、基础设施架构调整导致该应用需要移动到其他机器上，Kubernetes 也会自行处理。</p><p>就像之前提到的，用户类似于船长负责更高层级的决策，而 Kubernetes 则类似于舵手负责执行具体的底层任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e8b20e65761088c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes takes over the management of applications"></p><h4 id="Kubernetes-与微服务"><a href="#Kubernetes-与微服务" class="headerlink" title="Kubernetes 与微服务"></a>Kubernetes 与微服务</h4><p>之前的年头，绝大多数应用都是单体应用。应用里的各个组件是强耦合的，全部运行在同一个进程里。<br>当应用的容量需要提升时，水平扩展单体应用是非常困难的。只能不断升级服务器的硬件，即垂直扩展。</p><p>微服务范式是后来才出现的。单体应用被分割成数十甚至数百个独立的进程（微服务）。每一个微服务都拥有自己所独有的开发和部署周期，不同微服务的依赖会随着时间的推移差距越来越大。这使得在同一个操作系统内部运行两个微服务应用变得非常困难。<br>容器正好方便解决这个问题。但每个微服务都是一个独立的应用，需要单独进行管理。随着应用数量的上升这将会越来越困难。<br>整个应用系统的各个部分不需要部署到同一台机器上，这使得扩展起来更加方便。但同时也意味着各组件之间需要配置成能够相互通信的状态。同样增加了维护成本。<br>因此当微服务的规模变得很大时，自动化管理就显得尤为必要。Kubernetes 则正好提供了这种自动化功能。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-59ad3de50dca8dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Monolithic vs Microservices"></p><h4 id="Kubernetes-的架构"><a href="#Kubernetes-的架构" class="headerlink" title="Kubernetes 的架构"></a>Kubernetes 的架构</h4><p>Kubernetes 可以看作是一个面向服务器集群的操作系统。<br>操作系统用来支撑计算机的基本功能比如 CPU 调度，作为应用和计算机硬件之间沟通的接口。类似的，Kubernetes 负责在服务器集群的各台机器上调度安排分布式应用的各个组件，作为应用和集群之间的接口。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9daef5eac57b2474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OS vs Kubernetes"></p><p>一个 Kubernetes 集群包含两组节点：</p><ul><li>主节点：负责运行 Control Plane 组件，是系统的大脑，控制整个集群</li><li>工作节点：组成 Workload Plane，承接应用和负载</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30cd2137a1a1be44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes cluster"></p><h5 id="控制平台"><a href="#控制平台" class="headerlink" title="控制平台"></a>控制平台</h5><p>Control Plane 负责控制整个集群。它运行在一台主节点上，或者以副本的方式运行在多个主节点上。包含 Scheduler、Controllers、Kubernetes API Server、etcd 等几个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d8b81875430d46ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Components of Control Plane"></p><ul><li>Kubernetes API Server 负责暴露 RESTful API 接口，用户可以通过此接口创建对象</li><li>etcd 分布式数据仓库负责持久化通过 API 创建的对象，因为 API Server 本身是无状态的。Server 是唯一一个与 etcd 交互的组件</li><li>Scheduler 负责决定每个应用实例具体运行在哪个工作节点上</li><li>Controllers 负责具体化由 API 创建的对象。它们中的大部分实际上就是负责创建其他对象，有一些也会与外部系统进行交互（比如云提供商）</li></ul><h5 id="负载平台"><a href="#负载平台" class="headerlink" title="负载平台"></a>负载平台</h5><p>工作节点就是实际上运行应用的节点，它们构成了 Workload Plane。负责运行、监控各个应用，并在各应用之间提供连通性。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f0c322b076452baf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Workload Plane"></p><p>其中各组件的功能如下：</p><ul><li>Kubelet：一个与 API Server 进行交互的 agent，负责管理当前节点上运行的应用。会通过 API 向主节点报告应用的状态</li><li>Container Runtime：可以是 Docker 或其他与 Kubernetes 兼容的容器运行时，受 kubelet 指挥，负责运行应用</li><li>Kubernetes Service Proxy：在各应用的网络流量之间提供负载均衡</li></ul><h4 id="Kubernetes-的工作流程"><a href="#Kubernetes-的工作流程" class="headerlink" title="Kubernetes 的工作流程"></a>Kubernetes 的工作流程</h4><p>Kubernetes 中的所有元素都由对象表示，可以通过 API 创建和获取这些对象。用户需要几种不同的对象来定义自己的应用，通常在 YAML 或 JSON 格式的清单文件中定义。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-541fea79d28b6f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying an application to Kubernetes"></p><p>向 Kubernetes 部署应用的具体步骤为：</p><ul><li>向 Kubernetes API 提交应用的 manifest 文件。API Server 将文件中定义的对象写入 etcd</li><li>controller 接到已经创建了新对象的通知，继续创建几个新的对象，对应不同的应用实例</li><li>Scheduler 为每一个应用实例分配工作节点</li><li>工作节点上的 Kubelet 接到通知，借助容器运行时运行应用实例</li><li>应用实例准备好接收客户端请求后，Kube Proxy 收到通知，为这些应用实例配置负载均衡</li><li>工作节点上的 Kubelets 和 Controllers 负责之后的监控工作，保证应用健康运行</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 是一个负责自动化部署和
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Microservice" scheme="https://rollingstarky.github.io/tags/Microservice/"/>
    
      <category term="Cloud" scheme="https://rollingstarky.github.io/tags/Cloud/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 理解容器技术</title>
    <link href="https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/"/>
    <id>https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2021-11-29T13:55:06.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、容器-vs-虚拟机"><a href="#一、容器-vs-虚拟机" class="headerlink" title="一、容器 vs 虚拟机"></a>一、容器 vs 虚拟机</h4><h5 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h5><p>每一台虚拟机都需要安装独属于自己的操作系统，包含一系列系统进程；而同一台宿主机上的多个容器会共享宿主机的操作系统，它们的环境仍然是独立的。<br>即对于容器而言，不需要装一个独立的操作系统。不会像虚拟机那样，存在很多套重复的系统进程。因而容器更加轻量。<br><strong>容器只包含一套隔离的进程，运行在已有的宿主机操作系统上，只会消耗这套隔离进程运行所需的系统资源</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a8f80aa3c08ae7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="overhead VM vs Container"></p><p>由于虚拟机高额的开销，通常需要将多个关联的应用部署在同一台虚拟机上。对于开销较低的容器而言，则可以为每一个应用都创建一个独立的容器。<br>实际上也应该<strong>确保每一个容器都只包含一个应用</strong>，这样方便管理，同时 Kubernetes 等容器管理平台也是默认这个原则的。</p><h5 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h5><p>容器拥有更快的启动时间。因为容器只需要启动自身包含的应用进程，不需要像启动一台新的虚拟机那样，先启动一些额外的系统进程。</p><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>无疑虚拟机的隔离性更好。<br>当使用虚拟机部署应用时，每台虚拟机都拥有一套独立的操作系统和内核。这些虚拟机的底层是 hypervisor，将物理硬件划分成一系列更小的虚拟资源，供给不同的虚拟机使用。</p><p>当虚拟机中运行的应用向虚拟机内核发起系统调用时，内核会先在虚拟的 CPU 上执行机器指令，再通过 hypervisor 转发给宿主机的物理 CPU 执行。<br>容器发起的系统调用则都可以直接传递给宿主机上运行的系统内核，再转化为机器指令传递给宿主机的 CPU。宿主机 CPU 不需要处理任何形式的虚拟化。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e7e28095583e19c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="system calls"></p><p>同一台机器上的多个容器共享同一个宿主机内核，但它们之间仍然是隔离的，相互之间并不清楚其他人的存在，也只能看到一部分物理硬件。<br>这种隔离是由宿主机内核提供的。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f1b4cacdc98d0138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Isolation"></p><h5 id="由隔离性引发的安全性"><a href="#由隔离性引发的安全性" class="headerlink" title="由隔离性引发的安全性"></a>由隔离性引发的安全性</h5><p>容器使用同一个内核。如果内核出现 bug，某个容器中的应用有可能会利用这个 bug 读取其他容器中其他应用的内存。<br>此外，容器会共享内存空间。如果不限制某个容器能够使用的内存总量，有可能会导致其他容器没有足够的内存使用。</p><h4 id="二、Docker-容器平台介绍"><a href="#二、Docker-容器平台介绍" class="headerlink" title="二、Docker 容器平台介绍"></a>二、Docker 容器平台介绍</h4><p>Docker 是一个帮助用户打包、发布和运行容器应用的平台。用户可以使用 Docker 将应用及其运行环境（可以是一些动态库等依赖，甚至操作系统提供的所有文件）打包，并可以将打包后的镜像发布到一个公共的镜像源，再部署到其他安装了 Docker 的机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-651e5432eed2654a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker Platform"></p><p>三个 Docker 中的基本概念：</p><ul><li>Images（镜像）：类似于一个 zip 压缩包，包含了应用及其运行环境</li><li>Registries（源）：一个方便用户和机器分发、共享镜像的站点。可以将打包好的镜像 push 到源，这样另一台机器就可以从镜像源 pull 该镜像到本地</li><li>Containers（容器）：相当于实例化的镜像。<strong>一个运行的容器相当于宿主机中一个普通的进程，只不过它的环境是隔离的</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e505cff02f642b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker push"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3f8802fae79fd57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker pull"></p><h5 id="Image-Layers"><a href="#Image-Layers" class="headerlink" title="Image Layers"></a>Image Layers</h5><p>不同于虚拟机镜像是由整个文件系统构成的一个大的文件块，容器镜像通常是由更小的<strong>层</strong>构成。这些层可以被多个镜像所共享。<br>如果某个镜像需要的部分镜像层已经被下载到了宿主机上（在 pull 其他镜像的时候），则 pull 该镜像时只需要下载之前未 pull 的层即可。<br>镜像层使得发布镜像变得更加高效，同时也提升了宿主机的存储空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf0919122843a478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image Layers"></p><p>如上图中的三个容器，它们可以共享访问一部分共有的文件。但它们是如何同时做到隔离的呢？其中某个容器若修改了共享的文件，如何做到不对其他容器可见？<br>文件系统的隔离由 <strong>Copy-on-Write (CoW)</strong> 机制实现。<br>容器中的文件系统由从镜像而来的只读层和加在只读层上面的一个读写层构成。当某个运行的容器修改了只读层中的文件，该文件会被整个复制到容器的读写层。每个容器都拥有自己所独有的读写层，因此对共享文件的修改并不会对其他容器可见。<br>当删除某个文件，该文件只是在读写层中被标记为已删除，实际上该文件仍然存在于只读层中。因此删除文件并不会减少镜像的大小。</p><h5 id="镜像层的潜在限制"><a href="#镜像层的潜在限制" class="headerlink" title="镜像层的潜在限制"></a>镜像层的潜在限制</h5><p>理论上讲，基于 Docker 的镜像可以运行在任意一台启用了 Docker 的机器上。但是由于容器并没有自己的内核，如果一个容器需要特定版本的内核才能运行，它有可能不会运行在每一台机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bedcb0dfebe1576c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container requires specific kernel version"></p><p>此外，容器化的应用只能运行在特定的硬件架构上。比如不能把一个构建在 x86 CPU 架构上的应用，部署在 ARM 平台的 Docker 上。</p><h4 id="三、容器背后的技术"><a href="#三、容器背后的技术" class="headerlink" title="三、容器背后的技术"></a>三、容器背后的技术</h4><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>Linux 命名空间可以确保每个进程都只能看到它自己视角的系统。即容器中的进程只能看到部分文件、进程、网络接口和机器名，就好像它运行在一个独立的虚拟机上。<br>内核可以创建额外的命名空间，然后将部分资源移动到该命名空间，并令其只对某一个或一组进程可见。</p><p>命名空间的类型：</p><ul><li>Mount 命名空间用来隔离挂载点（文件系统）</li><li>Process ID 命名空间用来隔离进程 ID</li><li>Network 命名空间用来隔离网络设备、端口等</li><li>ipc 命名空间用来隔离进程间的通信（包括管理消息队列、共享内存等）</li><li>UTS (UNIX Time-sharing System) 命名空间用来隔离系统的主机名和 NIS (Network Information Service) 域名</li><li>User ID 命名空间用来隔离用户和组 ID</li><li>Cgroup 命名空间用来隔离 Control Groups 根目录</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e436794540627a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="network namespace"></p><p>有时候并不会想要将某个容器与另一个容器完全隔离，相互关联的容器之间有可能会共享特定的资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-120889e397b108e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shared namespace"></p><p>比如上图中的两个容器。它们可以看见并使用相同的两个网络设备（<code>eth0</code> 和 <code>lo</code>），因为它们拥有相同的网络命名空间。它们也因此可以绑定相同的 IP 地址并通过 loopback 设备相互通信。<br>这两个容器还使用同一个 UTS 命名空间，因此它们可以见到相同的主机名。但它们的 Mount 命名空间是不同的，即拥有不同的文件系统。</p><p><strong>容器中运行的进程只是一个绑定了 7 类命名空间的普通进程</strong>。</p><h5 id="Linux-Control-Groups"><a href="#Linux-Control-Groups" class="headerlink" title="Linux Control Groups"></a>Linux Control Groups</h5><p>Linux 命名空间可以控制进程只能访问一部分系统资源，但它们不能限制每个进程消耗的资源总量。<br>Linux Control Groups (cgroups) 则可以限制进程只能使用预先分配好的固定额度的 CPU 时间、内存和网络带宽等。避免某些进程吃掉所有的系统资源。</p><h4 id="sys-calls"><a href="#sys-calls" class="headerlink" title="sys-calls"></a>sys-calls</h4><p>Linux 命名空间和 Cgroups 能够隔离容器的环境并防止某个容器消耗掉所有的计算资源。但这些容器中的进程仍然使用同一个系统内核，一个非法容器仍然可以通过一些恶意的系统调用来影响其他容器。</p><p>内核提供了一系列 sys-calls 可以被程序用来与操作系统及底层的硬件交互，包括创建进程、操作文件和设备、创建应用间的通信通道等。<br>其中有些 sys-calls 是安全的，可以被任意进程使用。其他一些则只允许具有更高权限的进程使用。比如容器中的应用应该允许访问它们的本地文件，但不能修改系统时钟或者以破坏其他容器的方式修改内核。</p><p>Linux 内核把这些权限分成了名为 capabilities 的单位。如：</p><ul><li>CAP_NET_ADMIN：允许进程执行网络相关的操作</li><li>CAP_NET_BIND_SERVICE：允许进程绑定小于 1024 的端口号</li><li>CAP_SYS_TIME：允许进程修改系统时钟</li></ul><p>Capabilities 能够在容器创建时添加或移除，每个 Capability 都代表一系列特殊权限。<br>此外，还可以使用 <strong>seccomp (Secure Computing Mode)</strong> 。创建一个 包含 seccomp 配置的 JSON 文件，在构建容器时提供给 Docker。</p><h5 id="AppArmor-amp-SELinux"><a href="#AppArmor-amp-SELinux" class="headerlink" title="AppArmor &amp; SELinux"></a>AppArmor &amp; SELinux</h5><p>容器还可以依靠两种 MAC（强制访问控制）机制 SELinux 和 AppArmor 来获得更高的安全性。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、容器-vs-虚拟机&quot;&gt;&lt;a href=&quot;#一、容器-vs-虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、容器 vs 虚拟机&quot;&gt;&lt;/a&gt;一、容器 vs 虚拟机&lt;/h4&gt;&lt;h5 id=&quot;系统开销&quot;&gt;&lt;a href=&quot;#系统开销&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="Isolation" scheme="https://rollingstarky.github.io/tags/Isolation/"/>
    
      <category term="VM" scheme="https://rollingstarky.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Python 语言实现循环的最快方式（for、while 等速度对比）</title>
    <link href="https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/"/>
    <id>https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/</id>
    <published>2021-11-22T16:00:00.000Z</published>
    <updated>2021-11-23T12:51:53.254Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。<br>假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。</p><p><code>while</code> 和 <code>for</code> 是 Python 中常用的两种实现循环的关键字，它们的运行效率实际上是有差距的。比如下面的测试代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br></pre></td></tr></table></figure></p><p>这是一个简单的求和操作，计算从 1 到 n 之间所有自然数的总和。<br>可以看到 <code>for</code> 循环相比 <code>while</code> 要快 1.5 秒。其中的差距主要在于两者的机制不同。<br>在每次循环中，<code>while</code> 实际上比 <code>for</code> 多执行了两步操作：边界检查和变量 <code>i</code> 的自增。即每进行一次循环，while 都会做一次边界检查 (<code>while i &lt; n</code>）和自增计算（<code>i +=1</code>）。这两步操作都是显式的纯 Python 代码。<br><code>for</code> 循环不需要执行边界检查和自增操作，没有增加显式的 Python 代码（纯 Python 代码效率低于底层的 C 代码）。当循环的次数足够多，就出现了明显的效率差距。</p><p>可以再增加两个函数，在 <code>for</code> 循环中加上不必要的边界检查和自增计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_inc</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_test</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with increment\t\t'</span>,</span><br><span class="line">          timeit.timeit(for_loop_with_inc, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with test\t\t'</span>, timeit.timeit(for_loop_with_test, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; for loop with increment          4.602369500091299</span></span><br><span class="line"><span class="comment"># =&gt; for loop with test               4.18337869993411</span></span><br></pre></td></tr></table></figure></p><p>可以看出，增加的边界检查和自增操作确实大大影响了 <code>for</code> 循环的执行效率。</p><p>前面提到过，Python 底层的解释器和内置函数是用 C 语言实现的。而 C 语言的执行效率远大于 Python。<br>对于上面的求等差数列之和的操作，借助于 Python 内置的 <code>sum</code> 函数，可以获得远大于 <code>for</code> 或 <code>while</code> 循环的执行效率。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br></pre></td></tr></table></figure></p><p>可以看到，使用内置函数 <code>sum</code> 替代循环之后，代码的执行效率实现了成倍的增长。内置函数 <code>sum</code> 的累加操作实际上也是一种循环，但它由 C 语言实现，而 <code>for</code> 循环中的求和操作是由纯 Python 代码 <code>s += i</code> 实现的。C &gt; Python。</p><p>再拓展一下思维。小时候都听说过童年高斯巧妙地计算 1 到 100 之和的故事。1…100 之和等于 (1 + 100) * 50。这个计算方法同样可以应用到上面的求和操作中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math_sum</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n * (n - <span class="number">1</span>)) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'math sum\t\t'</span>, timeit.timeit(math_sum, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br><span class="line"><span class="comment"># =&gt; math sum                 2.400018274784088e-06</span></span><br></pre></td></tr></table></figure></p><p>最终 math sum 的执行时间约为 <code>2.4e-6</code>，缩短了上百万倍。这里的思路就是，既然循环的效率低，一段代码要重复执行上亿次。<br>索性直接不要循环，通过数学公式，把上亿次的循环操作变成只有一步操作。效率自然得到了空前的加强。</p><p>最后的结论（有点谜语人）：</p><p><strong>实现循环的最快方式</strong><br>——<br>——<br>——<br><strong>就是不用循环</strong></p><p>对于 Python 而言，则尽可能地使用内置函数，将循环中的纯 Python 代码降到最低。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://youtu.be/Qgevy75co8c" target="_blank" rel="noopener">The Fastest Way to Loop in Python - mCoding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。&lt;br&gt;假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 和 
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="loop" scheme="https://rollingstarky.github.io/tags/loop/"/>
    
      <category term="C" scheme="https://rollingstarky.github.io/tags/C/"/>
    
      <category term="big-O" scheme="https://rollingstarky.github.io/tags/big-O/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 使用 lineinfile 模块修改配置文件</title>
    <link href="https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/"/>
    <id>https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-11-16T14:33:03.362Z</updated>
    
    <content type="html"><![CDATA[<p>需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 <code>shell</code> 模块，<code>echo</code> 加 <code>&gt;&gt;</code> 就完事了。<br>但仔细一琢磨，很可能会引发一些意想不到的问题，比如：</p><ul><li>如果需要添加的配置已经存在，<code>echo</code> 仍会向配置文件底部添加同样的内容</li><li>如果添加配置的任务重复执行多次，则配置文件中也会多次出现重复的内容。无法做到<strong>幂等</strong></li><li>如何做到，当对应的配置已经存在，则将该配置改为期望的值；当对应的配置不存在，不做任何操作（有就修改，没有就不动。好像可以用 <code>sed</code>）</li><li>如何安全地移除指定的配置项</li></ul><p>诸如此类。运维工作常常要关系到生产环境。任何无法预期的效果都可能产生严重的影响。而单纯使用 <code>echo</code> 和 <code>&gt;&gt;</code> 向配置文件中添加内容，具有很大的不确定性。<br>当然可以形成一个 Shell 脚本，对各种边界进行足够的检查和判定，但这会导致代码量变大，结构复杂难以标准化；同时也容易出现遗漏的情况。</p><p>实际上 Ansible 内置的 <code>lineinfile</code> 就是专门用来处理上述任务的模块。</p><p>比如针对如下内容的配置文件 <code>test_conf.ini</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>需要添加一行配置 <code>THIRD=3</code>。</p><p>可以运行如下内容的 playbook <code>change_config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">THIRD=3</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>lineinfile</code> 模块的 <code>path</code> 参数用于指定目标配置文件的路径；<code>regexp</code> 参数则用于指定对文件内容进行匹配时使用的正则表达式；最后的 <code>line</code> 参数表示希望在目标文件中出现的内容。</p><p>具体的步骤为：</p><ul><li>检查 <code>line</code> 对应的内容是否存在于 <code>path</code> 对应的目标文件中</li><li>若已经存在。则目标文件符合要求，不对该文件做任何操作</li><li>若不存在。通过 <code>regexp</code> 指定的正则表达式对目标文件进行匹配</li><li>若 <code>regexp</code> 匹配到文本行，则将该行内容修改为 <code>line</code> 指定的内容</li><li>若 <code>regexp</code> 未匹配到文本行，则将 <code>line</code> 对应的内容作为新的一行添加到目标文件末尾</li></ul><p>运行效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>此时 <code>test_conf.ini</code> 配置文件的内容被修改为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>若再次运行 <code>ansible-playbook change_config.yml</code> 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">ok: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>可以看到修改配置文件的任务执行结果为 <code>ok</code>，而不同于上一次的 <code>changed</code>。这表示 <code>lineinfile</code> 模块对配置文件的内容进行了检查，发现需要添加的配置行已经存在，因此未做任何改动。符合<strong>幂等</strong>的原则。</p><p>假如将配置文件中的 <code>THIRD=3</code> 改为 <code>THIRD=false</code>，再次运行 playbook：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>正则表达式 <code>^THIRD</code> 会匹配到配置文件的第三行 <code>THIRD=false</code>，再将该行内容替换为 <code>THIRD=3</code>。</p><p>最终仍可以得到我们想要的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>对于 Ansible playbook 而言，我们只需要关注<strong>期望达到的状态</strong>，而不用纠结<strong>为了达到该状态需要执行哪些步骤</strong>。<br>如 <code>lineinfile</code> 模块，<code>line</code> 指定的内容即为我们期望目标文件达到的状态。即该文件最终一定会包含一行与 <code>line</code> 相同的文本。<br>不管该行内容是本就已经存在的，还是通过修改 <code>regexp</code> 匹配到的文本行得到的，还是直接在目标文件末尾新增的。而我们只需要定义 <code>path</code>、<code>regexp</code>、<code>line</code> 三个参数即可。</p><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><h5 id="backrefs"><a href="#backrefs" class="headerlink" title="backrefs"></a>backrefs</h5><p><code>lineinfile</code> 默认的行为是若 <code>line</code> 指定的内容未存在，<code>regexp</code> 正则表达式也没有任何匹配，就在文件末尾添加一行 <code>line</code> 指定的内容。<br><code>backrefs</code> 参数可以修改此行为。当 <code>backrefs</code> 设定为 <code>true</code> 时，若 <code>line</code> 指定的内容不存在，正则表达式也没有匹配。则不做任何操作。</p><p>比如如下 playbook：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'THIRD=3'</span></span><br><span class="line"><span class="attr">        backrefs:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>当目标文件的内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>playbook 实际不会对其做任何修改，不会在文件末尾添加 <code>THIRD=3</code>。只有当文件中存在如 <code>THIRD=false</code> 这类内容时，playbook 才会完成匹配并替换对应的行。</p><p>没有 <code>backrefs</code> 表示匹配就替换，不匹配就在文件末尾添加；有 <code>backrefs</code> 表示匹配就替换，不匹配就不动。</p><h5 id="删除一行内容"><a href="#删除一行内容" class="headerlink" title="删除一行内容"></a>删除一行内容</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">absent</span></span><br></pre></td></tr></table></figure><h5 id="在匹配行前-后添加"><a href="#在匹配行前-后添加" class="headerlink" title="在匹配行前/后添加"></a>在匹配行前/后添加</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertbefore:</span> <span class="string">'^FIRST'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'ZERO=false'</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertafter:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'FOURTH=4'</span></span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><ul><li>当 <code>line</code> 指定的内容已经存在于目标文件中时，不管其具体在什么位置，目标文件都不会做任何修改</li><li>当 <code>insertbefore</code> 或 <code>insertafter</code> 指定的正则表达式没有任何匹配时，都会在文件末尾添加 <code>line</code> 指定的内容</li></ul><h4 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a>官网示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">SELinux</span> <span class="string">is</span> <span class="string">set</span> <span class="string">to</span> <span class="string">enforcing</span> <span class="string">mode</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/selinux/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^SELINUX='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">SELINUX=enforcing</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Make</span> <span class="string">sure</span> <span class="string">group</span> <span class="string">wheel</span> <span class="string">is</span> <span class="string">not</span> <span class="string">in</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">configuration</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">absent</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%wheel'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">with</span> <span class="string">our</span> <span class="string">own</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^127\.0\.0\.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">searching</span> <span class="string">for</span> <span class="string">a</span> <span class="string">literal</span> <span class="string">string</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">escaping</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">default</span> <span class="string">Apache</span> <span class="string">port</span> <span class="string">is</span> <span class="number">8080</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^Listen '</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^#Listen '</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">Listen</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">php</span> <span class="string">extension</span> <span class="string">matches</span> <span class="string">new</span> <span class="string">pattern</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'&lt;FilesMatch ".php[45]?$"&gt;'</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^\t&lt;Location \/&gt;\n'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'        &lt;FilesMatch ".php[34]?$"&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">we</span> <span class="string">have</span> <span class="string">our</span> <span class="string">own</span> <span class="string">comment</span> <span class="string">added</span> <span class="string">to</span> <span class="string">/etc/services</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/services</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^# port for http'</span></span><br><span class="line"><span class="attr">    insertbefore:</span> <span class="string">'^www.*80/tcp'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'# port for http by default'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Add</span> <span class="string">a</span> <span class="string">line</span> <span class="string">to</span> <span class="string">a</span> <span class="string">file</span> <span class="string">if</span> <span class="string">the</span> <span class="string">file</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist,</span> <span class="string">without</span> <span class="string">passing</span> <span class="string">regexp</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/testfile</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.99</span> <span class="string">foo.lab.net</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    create:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Yaml requires escaping backslashes in double quotes but not in single quotes</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">JBoss</span> <span class="string">memory</span> <span class="string">settings</span> <span class="string">are</span> <span class="string">exactly</span> <span class="string">as</span> <span class="string">needed</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/opt/jboss-as/bin/standalone.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^(.*)Xms(\d+)m(.*)$'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'\1Xms$&#123;xms&#125;m\3'</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Validate</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">file</span> <span class="string">before</span> <span class="string">saving</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%ADMIN ALL='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'%ADMIN ALL=(ALL) NOPASSWD: ALL'</span></span><br><span class="line"><span class="attr">    validate:</span> <span class="string">/usr/sbin/visudo</span> <span class="bullet">-cf</span> <span class="string">%s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3/library/re.html for further details on syntax</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Use</span> <span class="string">backrefs</span> <span class="string">with</span> <span class="string">alternative</span> <span class="string">group</span> <span class="string">syntax</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">conflicts</span> <span class="string">with</span> <span class="string">variable</span> <span class="string">values</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">^(host=).*</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">\g&lt;1&gt;&#123;&#123;</span> <span class="string">hostname</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/lineinfile_module.html" target="_blank" rel="noopener">ansible.builtin.lineinfile – Manage lines in text files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 &lt;code&gt;shell&lt;/code&gt; 模块，&lt;code&gt;echo&lt;/code&gt; 加 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 就完事了。&lt;br&gt;但仔细一琢磨，很可能会引发一些意想不
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Ansible" scheme="https://rollingstarky.github.io/tags/Ansible/"/>
    
      <category term="Devops" scheme="https://rollingstarky.github.io/tags/Devops/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>Vim 技巧 —— 实现多行注释的几种方法</title>
    <link href="https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/"/>
    <id>https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:12:59.653Z</updated>
    
    <content type="html"><![CDATA[<p>习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。<br>于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。</p><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>命令模式下可以使用 <code>:s/old/new</code> 替换当前文本行中的指定字符串。前面还可以加上数字等用来指定范围。如：</p><ul><li><code>:n1,n2 s/old/new</code>：从 <code>n1</code> 行开始，到 <code>n2</code> 行结束，将每一行中符合 <code>old</code> 模式的内容替换为 <code>new</code></li><li><code>:% s/old/new</code>：将整个文件中的 <code>old</code> 替换为 <code>new</code></li></ul><p>类似于 Vim 中内置了一个 <code>sed</code> 工具。</p><p>对于 Python 代码，注释代码块当然可以用双 <code>&#39;&#39;&#39;</code>，临时的注释我个人比较偏向行首加 <code>#</code>。借助字符串替换可以很方便的实现。命令如下：<br><code>:n1,n2 s/^/#</code><br>将 <code>n1</code> 到 <code>n2</code> 行中的行首空白字符替换为 <code>#</code>，等同于在每一行行首插入 <code>#</code></p><p>对于如下 Python 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30ef29b5184224b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before replace"></p><p>在 Vim 中运行 <code>:1,3 s/^/#</code>，后，效果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from datetime import datetime</span></span><br><span class="line"><span class="comment"># import calendar</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>如果要取消注释，再运行如下命令即可：<br><code>:1,3 s/# /</code><br>将 1 - 3 行行首的 <code>#</code> 替换为空字符串（即移除行首的 <code>#</code>)</p><h5 id="visual-模式下指定文本范围"><a href="#visual-模式下指定文本范围" class="headerlink" title="visual 模式下指定文本范围"></a>visual 模式下指定文本范围</h5><p>如果不喜欢用数字行号指定施行替换的文本行，也可以在 Visual 模式下手动选择生效的文本范围。</p><p>Normal 模式下按键盘上的 <code>v</code> 键进入 visual 模式，然后就可以通过光标移动命令（如 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>、<code>{</code>、<code>}</code> 等）选中多行文本。</p><p>接着在命令模式下运行 <code>:&#39;&lt;,&#39;&gt; s/^/#</code> 即可在选中的文本上执行文本替换。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-161da4aa97379bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="select &amp; replace"></p><p>其中 <code>&#39;&lt;,&#39;&gt;</code> 即代表 visual 模式下选中的文本行。一般情况下，选中文本以后再按 <code>:</code> 进入命令模式，<code>&#39;&lt;,&#39;&gt;</code> 部分内容会自动补全。</p><h4 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h4><p>多行编辑指同时在多行文本中每一行的相同位置插入相同的内容。只需要编辑某一行文本，其他文本行就会自动进行同样的修改。</p><p>比如需要注释 Python 代码的前 3 行，就可以同时编辑这 3 行文本，在第一行行首插入 <code>#</code>，则前 3 行会同时被注释掉。</p><p>首先光标定位到第一行行首，按下键盘上的 <code>ctrl + v</code> 组合键（Windows 下可以用 <code>ctrl + q</code>）进入 Visual Block 模式，按两次 <code>j</code> 键下移光标，选中前三行的首字符。<br>再按下键盘上 <code>I</code>（大写）键进入插入模式，在第一行行首插入 <code>#</code> 字符。<br>按下 <code>Esc</code> 退出插入模式，则后两行行首也会自动插入 <code>#</code> 字符。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b302ab3a0626969b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VISUAL BLOCK"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e830dec31ab8eef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before Esc"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7546479fe2f06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="after Esc"></p><h4 id="录制-Macro"><a href="#录制-Macro" class="headerlink" title="录制 Macro"></a>录制 Macro</h4><p>Vim 中的<strong>宏</strong>（Macro）即一系列编辑操作的合集。<br>在 Vim 中，可以把需要重复执行的多步编辑操作录制下来，绑定到某个按键上。之后就可以按下 <code>@绑定的按键</code> 重复执行录制好的步骤。<br>有点像定义和调用函数。</p><p>使用 <code>q某按键</code> 开始录制宏，执行某些编辑操作后，再按下 <code>q</code> 结束录制。随后按下 <code>@某按键</code> 调用录制好的宏。</p><p>如需要注释前 3 行 Python 代码，则可以录制包含如下步骤的宏：</p><ul><li>在当前行的行首开始插入文本（<code>I</code>）</li><li>输入注释符号（<code>#</code>）</li><li>退出插入模式（<code>Esc</code>）</li><li>移动到下一行（<code>j</code>)</li></ul><p>上述宏中的操作步骤可以首尾相接，无限循环。即注释当前行，移动到下一行；注释当前行，移动到下一行。。。</p><p>具体的操作步骤如下：</p><ul><li>在 Normal 模式下，光标移动到首行，按下 <code>qq</code> 开始录制宏（录制结束后会绑定给 <code>q</code>）</li><li>按下 <code>I</code> 键（大写），进入行首插入模式</li><li>输入 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 移动光标到下一行文本</li><li>按下 <code>q</code> 结束宏的录制</li></ul><p>宏录制结束后，即可连按两次 <code>@q</code> 连续调用两次宏，分别注释第二行和第三行内容。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-397bc3a22c028f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recording macro"></p><h5 id="命令"><a href="#命令" class="headerlink" title=". 命令"></a><code>.</code> 命令</h5><p><code>.</code> 命令相当于一种简化了的宏。它表示重复应用上一步中对内容的更改。<br><code>.</code> 命令无需录制，但只会重复对内容的编辑（如插入、替换等），不会重复其他操作。<br>比如前面的需要注释 Python 代码的前三行，可以执行如下操作：</p><ul><li>光标定位到首行，按 <code>I</code>（大写）在行首插入内容</li><li>输入注释符号 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 跳转到下一行，按 <code>.</code> 重复执行对上一行的编辑操作（行首插入 <code>#</code>）</li><li>重复上一步操作（<code>j.</code>），注释第三行</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在查阅资料的时候，还发现一个 <code>norm</code> 命令。<br>比如还是需要注释前 3 行，可以执行如下命令：<br><code>:1,3 norm I #</code></p><p>其中 <code>1,3</code> 表示只对 1 - 3 行应用后面的命令；<br><code>norm</code> 表示从 Normal 模式下开始；<br><code>I #</code> 表示进入插入模式（同时光标移动到行首），插入文本 <code>#</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://stackoverflow.com/questions/9549729/vim-insert-the-same-characters-across-multiple-lines" target="_blank" rel="noopener">Vim: insert the same characters across multiple lines</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。&lt;br&gt;于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。&lt;/p&gt;
&lt;h4 id=&quot;字符串替换&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Tools" scheme="https://rollingstarky.github.io/tags/Tools/"/>
    
      <category term="Tricks" scheme="https://rollingstarky.github.io/tags/Tricks/"/>
    
      <category term="Vim" scheme="https://rollingstarky.github.io/tags/Vim/"/>
    
      <category term="Editor" scheme="https://rollingstarky.github.io/tags/Editor/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="Macro" scheme="https://rollingstarky.github.io/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（Queue）</title>
    <link href="https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/"/>
    <id>https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:08:25.436Z</updated>
    
    <content type="html"><![CDATA[<h4 id="借助-Queue-实现多线程间的协同"><a href="#借助-Queue-实现多线程间的协同" class="headerlink" title="借助 Queue 实现多线程间的协同"></a>借助 Queue 实现多线程间的协同</h4><h5 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h5><p>并行地执行多个任务的 Python 程序通常都需要一种协作机制，使得多个线程负责的各部分之间的工作能够相互协同。<br>其中一种协作机制称为<strong>管线</strong>（<em>pipeline</em>）。pipeline 的工作方式类似于工厂里的流水线，分为串行排列的多道工序（<em>phase</em>）。每道工序都由特定的函数处理，函数之间可以并行地执行。</p><p>比如需要创建这样一个系统，可以从相机接收持续的图片流，再将收到的图片更改尺寸，最后上传到线上的图片库中。<br>这样的系统就可以分为三道工序，分别用 <code>download</code>、<code>resize</code>、<code>upload</code> 三个函数去处理。此外还需要一个在各道工序间传递任务对象的媒介，这个可以通过线程安全的 <strong>producer-consumer</strong> 队列去实现。</p><p>具体的示例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items = deque()</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> self.items.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line">        self.polled_count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># self.work_done = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            self.polled_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = self.in_queue.get()</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = self.func(item)</span><br><span class="line">                self.out_queue.put(result)</span><br><span class="line">                <span class="comment"># self.work_done += 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = MyQueue()</span><br><span class="line">resize_queue = MyQueue()</span><br><span class="line">upload_queue = MyQueue()</span><br><span class="line">done_queue = MyQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    Worker(download, download_queue, resize_queue),</span><br><span class="line">    Worker(resize, resize_queue, upload_queue),</span><br><span class="line">    Worker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(done_queue.items) &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">processed = len(done_queue.items)</span><br><span class="line">polled = sum(t.polled_count <span class="keyword">for</span> t <span class="keyword">in</span> threads)</span><br><span class="line">print(<span class="string">f'Processed <span class="subst">&#123;processed&#125;</span> items after '</span></span><br><span class="line">      <span class="string">f'polling <span class="subst">&#123;polled&#125;</span> times'</span>)</span><br><span class="line"><span class="comment"># Processed 100 items after polling 308 times</span></span><br></pre></td></tr></table></figure></p><p>上述实现虽然能够处理完成输入的所有任务，但仍存在很多问题。<br>首先是 <code>polled_count</code> 值远大于任务的数量。即工作线程的 <code>run</code> 方法中定义的从队列中取项目的动作执行了太多次。<br>各个工作函数的执行速度其实是不一致的，前置位的工作函数（比如 <code>download</code>）运行缓慢，会导致后一道工序（比如 <code>resize</code>）上的函数持续不断的向其队列请求新的任务，然而队列为空导致不断地触发 <code>IndexError</code> 错误，最终导致 CPU 时间的浪费。</p><p>其次，确认所有任务是否全部完成，需要一个 <code>while</code> 循环不断地检查 <code>done_queue</code> 队列中元素的数量。</p><p>再次，工作线程中的 <code>run</code> 方法会一直处于 <code>while True</code> 的循环当中，没有一种明显的方法可以向该工作线程发送任务完成可以退出的消息。</p><p>最后，当第一道工序执行很快而第二道工序执行很慢时，处于两道工序之间的队列中的元素数量会持续增长。如果有足够多的任务和足够长的时间，程序最终会耗尽内存并崩溃。</p><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>内置的 <code>queue</code> 模块中的 <code>Queue</code> 类可以解决上述问题。</p><p><code>Queue</code> 类中的 <code>get</code> 方法是阻塞的，即在有新的项目放置到队列中以前，<code>get</code> 会一直处于等待状态，直到获取到某个项目。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">my_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>即便线程先于主程序运行，它也会先处于等待状态，直到一个新的项目被放置到队列中，能够被 <code>get</code> 获取到。<br>这可以解决前面的程序中 <code>polled_count</code> 值过大的问题。</p><p><code>Queue</code> 类可以指定 buffer size，从而限制了两道工序间 pending 的任务的最大数量。即队列中的元素数量达到最大值后，向队列中放入新元素的 <code>put</code> 方法会阻塞，等待队列中某个元素被消耗从而为新元素腾出空间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">my_queue = Queue(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 1'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 2'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 1'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 2'</span>)</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Producer put 1</span></span><br><span class="line"><span class="comment"># Consumer got 1</span></span><br><span class="line"><span class="comment"># Producer put 2</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer got 2</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>Consumer 线程中的 <code>sleep</code> 应该使得主程序有足够的时间将两个对象都放置到队列中。但队列的大小是 1，就导致队列中先放入的元素必须通过 <code>get</code> 方法取出之后，才能继续使用 <code>put</code> 方法放置新的元素进去。<br>即 Producer 会等待 Consumer 线程把放置到队列中的旧元素消耗掉，才能继续向队列中添加新的元素。</p><h5 id="task-done"><a href="#task-done" class="headerlink" title="task_done"></a>task_done</h5><p><code>Queue</code> 类可以使用其 <code>task_done</code> 方法来追踪任务的进度，使得程序可以确保在某个特定的时间点，队列中的所有任务都已经被处理完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    work = in_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer working'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line">    in_queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">in_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer waiting'</span>)</span><br><span class="line">in_queue.join()</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer waiting</span></span><br><span class="line"><span class="comment"># Consumer working</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br></pre></td></tr></table></figure></p><p>在代码中调用 <code>in_queue.join()</code> 后，只有队列 <code>in_queue</code> 中的所有元素都执行了一遍 <code>task_done</code>（即有几个元素就需要几条 <code>task_done</code>），<code>in_queue.join()</code> 之后的代码才会执行。否则就继续等待，直到 Consumer 调用了足够次数的 <code>task_done</code>。</p><p>结合前面提到的特性，可以创建一个新的 <code>Queue</code> 类，它能够告知工作线程什么时候该停止执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br></pre></td></tr></table></figure></p><p>更新后的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    StoppableWorker(download, download_queue, resize_queue),</span><br><span class="line">    StoppableWorker(resize, resize_queue, upload_queue),</span><br><span class="line">    StoppableWorker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">download_queue.close()</span><br><span class="line">download_queue.join()</span><br><span class="line">resize_queue.close()</span><br><span class="line">resize_queue.join()</span><br><span class="line">upload_queue.close()</span><br><span class="line">upload_queue.join()</span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><p>逻辑上就是给 <code>Queue</code> 类加了一个 <code>SENTINEL</code> 对象，用来作为队列结束的标志。工作线程通过循环读取输入队列中的任务，这些任务对象经过特定函数处理后放置到输出队列中。若读取到的任务是 <code>SENTINEL</code> 对象，则线程结束运行。</p><p><code>task_done</code> 方法和主程序中的 <code>xxx_queue.join</code> 用于确保某个队列中的所有任务都已经处理完成，转移到了下一个队列中。后面再调用下一个队列的 <code>close</code> 方法在该队列尾部添加一个 <code>SENTINEL</code> 对象，作为队列的结束标志。</p><p>上述实现的好处在于，工作线程会在读取到 <code>SENTINEL</code> 对象时自动结束运行；主程序中 <code>upload_queue.join()</code> 执行结束后就能保证三个阶段的所有任务都被处理完了，而不再需要频繁地去检查 <code>done_queue</code> 中的元素数量。</p><h5 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h5><p>当需要对不同的阶段（<code>download</code>、<code>resize</code>、<code>upload</code>）都分别绑定多个线程去处理时，只稍微修改下代码就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_threads</span><span class="params">(count, *args)</span>:</span></span><br><span class="line">    threads = [StoppableWorker(*args) <span class="keyword">for</span> _ <span class="keyword">in</span> range(count)]</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">return</span> threads</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_threads</span><span class="params">(closable_queue, threads)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> threads:</span><br><span class="line">        closable_queue.close()</span><br><span class="line"></span><br><span class="line">    closable_queue.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">download_threads = start_threads(</span><br><span class="line">    <span class="number">3</span>, download, download_queue, resize_queue)</span><br><span class="line">resize_threads = start_threads(</span><br><span class="line">    <span class="number">4</span>, resize, resize_queue, upload_queue)</span><br><span class="line">upload_threads = start_threads(</span><br><span class="line">    <span class="number">5</span>, upload, upload_queue, done_queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">stop_threads(download_queue, download_threads)</span><br><span class="line">stop_threads(resize_queue, resize_threads)</span><br><span class="line">stop_threads(upload_queue, upload_threads)</span><br><span class="line"></span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>Pipeline 可以很好地组织流水线类型的工作，尤其是 IO 相关的 Python 多线程程序</li><li>需要特别注意构建 pipeline 时的隐藏问题：怎样告诉工作线程终止运行、busy waiting 以及潜在的内存爆炸等</li><li><code>Queue</code> 类具备构建健壮的 pipeline 所需的特性，如阻塞式操作、buffer size 和 joining 等。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;借助-Queue-实现多线程间的协同&quot;&gt;&lt;a href=&quot;#借助-Queue-实现多线程间的协同&quot; class=&quot;headerlink&quot; title=&quot;借助 Queue 实现多线程间的协同&quot;&gt;&lt;/a&gt;借助 Queue 实现多线程间的协同&lt;/h4&gt;&lt;h5 id=&quot;P
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Queue" scheme="https://rollingstarky.github.io/tags/Queue/"/>
    
      <category term="Pipeline" scheme="https://rollingstarky.github.io/tags/Pipeline/"/>
    
      <category term="Producer" scheme="https://rollingstarky.github.io/tags/Producer/"/>
    
      <category term="Consumer" scheme="https://rollingstarky.github.io/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（subprocess、Thread、Lock）</title>
    <link href="https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/"/>
    <id>https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-23T14:32:01.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用-subprocess-管理子进程"><a href="#使用-subprocess-管理子进程" class="headerlink" title="使用 subprocess 管理子进程"></a>使用 <code>subprocess</code> 管理子进程</h4><p>由 Python 启动的子进程能够以<strong>并行</strong>的方式运行，从而最大化地利用 CPU 的多个核心。</p><p>可以借助 <code>subprocess</code> 内置模块调用子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [<span class="string">'echo'</span>, <span class="string">'Hello from the child!'</span>],</span><br><span class="line">    capture_output=<span class="keyword">True</span>,</span><br><span class="line">    encoding=<span class="string">'utf-8'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result.check_returncode()</span><br><span class="line">print(result.stdout)</span><br><span class="line"><span class="comment"># =&gt; Hello from the child!</span></span><br></pre></td></tr></table></figure></p><p>子进程相对于其父进程是独立地运行的。<br>如果使用 <code>Popen</code> 类创建一个子进程处理某个任务，则主程序能够在处理其他任务的同时，通过轮询的方式定期查看子进程的状态，确认其是否已经终止运行。<br><code>Popen</code> 中的 <code>poll</code> 方法可以实时地检查子进程的运行状态。若子进程还在运行中，则返回 <code>None</code>；若子进程执行完毕，则返回一个 <em>returncode</em> 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">'Working...'</span>)</span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># Exit status 0</span></span><br></pre></td></tr></table></figure><p>解耦子进程与父进程使得父进程可以同时调用多个并行执行的子程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">sleep_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line">    sleep_procs.append(proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> sleep_procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Finished in <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># =&gt; Finished in 1.01 seconds</span></span><br></pre></td></tr></table></figure></p><p>代码中的 <code>communicate</code> 方法可以用来与子进程通信并等待其终止，此处用于等待所有的子进程执行完毕。<br>如果上述代码中的子进程以顺序的方式执行，最终整体的延迟会达到 10s 以上。而实际的延迟只略大于 1s，即多个子进程之间是并行的关系。</p><p>可以通过<strong>管道</strong>从 Python 程序向调用的子进程传递数据，并获取子进程的输出内容。<br>比如调用如下形式的 Shell 测试脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> input your name</span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> your name is <span class="variable">$name</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen(<span class="string">'bash name.sh'</span>,</span><br><span class="line">                        stdin=subprocess.PIPE,</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        shell=<span class="keyword">True</span>)</span><br><span class="line">proc.stdin.write(<span class="string">b'john'</span>)</span><br><span class="line">proc.stdin.flush()</span><br><span class="line"></span><br><span class="line">stdout, stderr = proc.communicate()</span><br><span class="line">print(stdout)</span><br><span class="line"><span class="comment"># b'input your name\nyour name is john\n'</span></span><br></pre></td></tr></table></figure><p>其中在初始化 <code>Popen</code> 对象时，传入了 <code>stdin=subprocess.PIPE</code> 和 <code>stdout=subprocess.PIPE</code> 两个参数，目的是将子进程的标准输入 STDIN 绑定到 <code>proc</code> 实例的 <code>stdin</code> 属性上，将标准输出 STDOUT 绑定到 <code>proc</code> 实例的 <code>stdout</code> 属性上。从而可以使用 <code>proc.stdin.write()</code> 方法向子进程传入数据。<br><code>proc</code> 实例的 <code>communicate</code> 方法会等待子进程终止，并返回 <code>stdout</code> 和 <code>stderr</code>，即子进程的标准输出和标准错误输出。<br>若初始化 <code>Popen</code> 时未传入 <code>stdout=subprocess.PIPE</code> 参数，则上面返回的 <code>stdout</code> 为 <code>None</code>。</p><p>如果担心子程序永远不会终止或者长时间阻塞了输入和输出，可以向 <code>communicate</code> 方法传入 <code>timeout</code> 参数来指定等待的最长时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'10'</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    proc.communicate(timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">    proc.terminate()</span><br><span class="line">    proc.wait()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Exit status -15</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul><li><code>subprocess</code> 模块可以调用子进程，且能够管理子进程的输入流和输出流，达到源程序与子进程交互的目的</li><li>子进程和 Python 解释器之间是并行运行的，因而可以最大化地利用 CPU 的多个核心</li><li><code>subprocess</code> 模块提供的 <code>run</code> 函数可以完成简单的调用操作，而 <code>Popen</code> 类提供了类似 Unix 管线的高级功能</li><li><code>communicate</code> 方法的 <code>timeout</code> 参数可以避免死锁及卡住的子进程</li></ul><h4 id="使用线程处理阻塞式-IO"><a href="#使用线程处理阻塞式-IO" class="headerlink" title="使用线程处理阻塞式 IO"></a>使用线程处理阻塞式 IO</h4><p>Python 的标准实现叫做 <strong>CPython</strong>。CPython 在运行 Python 程序时，会首先解析源代码并将其编译为字节码，再通过一个基于栈的解释器来运行字节码。<br>CPython 通过一种称为 <strong>GIL</strong> 的机制来管理解释器自身的状态信息，强化其一致性。GIL 是一种可以阻止 CPython 解释器受<strong>抢占式</strong>多线程影响的<strong>互斥锁</strong>（mutex），从而使控制程序的线程不会被另一个线程意外中断，导致解释器的状态发生混乱。</p><p>但 GIL 有一个非常严重的负面影响。不像 C++ 或 Java 等语言可以利用多线程最大化多核心 CPU 的计算能力，Python 虽然支持多线程，但 <strong>GIL 会导致任一时刻实际上都只能有一个线程在推进</strong>。<br>简单来说，Python 中的多线程不是<strong>并行</strong>计算，无法同时利用 CPU 的多个核心来提升<strong>计算密集型</strong>多任务的效率。</p><p>单线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    list(factorize(number))</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.19 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactorizeThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.number = number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.factors = list(factorize(self.number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    thread = FactorizeThread(number)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end -start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.3 seconds</span></span><br></pre></td></tr></table></figure></p><p>可以看出，Python 中的单线程和多线程在应对计算密集型任务时，两者的处理时间没有相差多少。</p><p>但是对于 <strong>IO 密集</strong> 型的任务，比如从磁盘读写文件、网络传输等<strong>阻塞式 IO</strong> 操作，使用 Python 中的多线程对于效率的提升就会非常显著。<br>多线程使得 CPU 不必去等待缓慢的文件读写等 IO 操作。</p><p>单线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    get_example_page()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.853585243225098 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target=get_example_page)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 0.8039891719818115 seconds</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h5><ul><li>由于 GIL 的存在，Python 中的线程无法并行地在多个 CPU 核心上执行</li><li>Python 中的多线程能够并行地发起多个系统调用，因而可以同时处理计算任务和阻塞式 IO</li></ul><h4 id="使用-Lock-避免数据竞争"><a href="#使用-Lock-避免数据竞争" class="headerlink" title="使用 Lock 避免数据竞争"></a>使用 Lock 避免数据竞争</h4><p>GIL 总是会阻止 Python 代码在多个 CPU 核心上并行执行，任意时刻都只能有一个 Python 线程处于活跃状态。<br>但 GIL 并不会保护代码不受数据竞争的影响。一个线程对于数据结构的操作仍有可能被 Python 解释器中邻近的字节码破坏，尤其是在通过多线程同步地去访问同一个对象的时候。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = Counter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 252472</span></span><br></pre></td></tr></table></figure></p><p>上述代码模拟了一个从传感器网络并行地读取数据并计数的过程。对任意一个传感器，其数据的读取都属于阻塞式 IO，由独立的工作线程去处理，数据读取完成后该工作线程会调用一个计数器对象来累计结果。</p><p>但程序运行后，实际得到的计数结果与预期差距很大。<br>Python 解释器在执行多个线程时会确保这些线程之间的“平等关系”，令它们获得几乎相等的处理时间。这因此需要 Python 时不时地在线程间进行切换，暂时挂起一个正在运行的线程，转而去恢复执行另一个线程。<br>一个线程甚至有可能在看似符合原子性的操作中间被暂停。</p><p>比如 <code>+=</code> 操作符在作用到实例的属性上时，类似这样的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter.count += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>实际上等同于 Python 做出如下所示的三个分开的步骤：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result = value + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result)</span><br></pre></td></tr></table></figure></p><p>再加上线程切换，就有可能导致出现下面这种情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running in Thread A</span></span><br><span class="line">value_a = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line"><span class="comment"># Context switch to Thread B</span></span><br><span class="line">value_b = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result_b = value_b + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_b)</span><br><span class="line"><span class="comment"># Context switch back to Thread A</span></span><br><span class="line">result_a = value_a + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_a)</span><br></pre></td></tr></table></figure></p><p>即原本应该计算两次的累加操作实际上只有一次生效了，最终导致出现错误的结果。</p><p>为避免上述情形中的数据竞争或者其他形式的数据结构损坏现象，可以借助 <code>Lock</code> 类保护特定的值不被多个线程同步访问。即任一时刻都只能有一个线程可以获得该数据的锁。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = LockingCounter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 500000</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><ul><li>Python 有 GIL，但在编写代码时仍需关注多线程中的数据竞争</li><li>允许多个线程修改同一个不加锁的对象，有可能会损坏数据结构</li><li><code>Lock</code> 类可以保护多线程中数据的一致性</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用-subprocess-管理子进程&quot;&gt;&lt;a href=&quot;#使用-subprocess-管理子进程&quot; class=&quot;headerlink&quot; title=&quot;使用 subprocess 管理子进程&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;subprocess&lt;/code&gt; 管理
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Process" scheme="https://rollingstarky.github.io/tags/Process/"/>
    
      <category term="Lock" scheme="https://rollingstarky.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——不安全 Rust</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:11:49.524Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 内部隐藏了一种不会强制实施内存安全保障的语言：<strong>不安全 Rust</strong>。<br>其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。<br>使用不安全代码的缺点在于程序员需要对自己的行为负责。若错误地使用了不安全代码，就可能引发不安全的内存问题，如空指针解引用等。</p><p>另一个原因在于底层计算机硬件固有的不安全性。若 Rust 不允许进行不安全的操作，则某些底层任务可能根本就完成不了。</p><p>不安全 Rust 允许你执行 4 种在安全 Rust 中不被允许的操作：</p><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现不安全 trait</li></ul><p>可以在代码块前使用关键字 <code>unsafe</code> 来切换到不安全模式。<code>unsafe</code> 关键字并不会关闭借用检查器或禁用任何其他 Rust 安全检查。<code>unsafe</code> 仅仅令你可以访问上述 4 种不会被编译器检查的特性。因此即便处于不安全的代码块中，也仍然可以获得一定程度的安全性。</p><p><code>unsafe</code> 并不意味着块中的代码一定就是危险的或一定会导致内存安全问题，它仅仅是将责任转移到了程序员的肩上。<br>通过对 4 种不安全操作标记上 <code>unsafe</code>，可以在出现内存相关的错误时快速地将问题定位到 <code>unsafe</code> 代码块中。<br><strong>应当尽量避免使用 <code>unsafe</code> 代码块</strong>。</p><p>为了尽可能地隔离不安全代码，可以将其封装在一个安全的抽象中并提供一套安全的 API。实际上某些标准库功能同样使用了不安全代码，并以此为基础提供了安全的抽象接口。</p><h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p>不安全 Rust 拥有两种类似于引用的新指针类型，都被叫做<strong>裸指针（raw pointer）</strong>。与引用类似，裸指针要么是可变的，要么是不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号 <code>*</code> 是类型名的一部分而不代表解引用操作。</p><p>裸指针与引用、智能指针的区别：</p><ul><li>允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针</li><li>不能保证自己总是指向了有效的内存地址</li><li>允许为空</li><li>没有实现任何自动清理机制</li></ul><p>在避免 Rust 强制执行某些保障后，就能够以放弃安全保障为代价换取更好的性能，或者与其他语言、硬件进行交互的能力。</p><p><strong>通过引用创建裸指针</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中并没有使用 <code>unsafe</code> 关键字。你可以在安全代码内合法地创建裸指针，但不能在不安全代码块外解引用裸指针。</p><p>创建一个指向任意内存地址的裸指针，这个地址可能有数据，也可能没有数据，因此无法确定其有效性。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure></p><p>为了使用 <code>*</code> 解引用裸指针，需要添加一个 <code>unsafe</code> 块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用裸指针时，我们可以创建同时指向同一地址的可变指针和不可变指针，并通过可变指针来修改数据。这样的修改操作会导致潜在的数据竞争。<br>裸指针主要用来与 C 代码接口进行交互，或者构造一些借用检查器无法理解的安全抽象。</p><h4 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h4><p>除了在定义前面要标记 <code>unsafe</code>，不安全函数或方法看上去与正常的函数或方法几乎一模一样。<br>这里的 <code>unsafe</code> 关键字意味着我们需要在调用该函数时手动满足一些先决条件，因为 Rust 无法对这些条件进行验证。通过在 <code>unsafe</code> 代码块中调用不安全函数，我们向 Rust 表明自己确实理解并实现了相关约定。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    dangerous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为不安全函数的函数体也是 <code>unsafe</code> 代码块，你可以直接在一个不安全函数中执行其他不安全操作而无需添加额外的 <code>unsafe</code> 代码块。</p><h5 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" class="headerlink" title="创建不安全代码的安全抽象"></a>创建不安全代码的安全抽象</h5><p>函数中包含不安全代码并不意味着我们需要将整个函数都标记为不安全的。实际上，将不安全代码封装在安全函数中是一种十分常见的抽象。</p><p>比如标准库中使用了不安全代码的 <code>split_at_mut</code> 函数。这个安全方法被定义在可变切片上，它接收一个切片并从给定的索引参数处将其分割为两个切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = r.split_at_mut(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们无法仅仅使用安全 Rust 来实现这个函数。比如尝试用安全代码将 <code>split_at_mut</code> 实现为函数，并只处理 i32 类型的切片：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid], &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会首先取得整个切片的长度，并通过断言检查给定的参数是否小于或等于当前切片的长度。若大于则会在尝试使用该索引前触发 panic。<br>我们会返回一个包含两个可变切片的元组，一个从原切片的起始位置到 <code>mid</code> 索引的位置，另一个则从 <code>mid</code> 索引的位置到原切片的末尾。</p><p>尝试编译上述代码会触发 <code>error[E0499]: cannot borrow `*slice` as mutable more than once at a time</code> 错误。<br>Rust 的借用检查器无法理解我们正在借用一个切片的不同部分，它只知道我们借用了两次同一个切片。借用一个切片的不同部分从原理上来讲是没有任何问题的，因为没有交叉的地方。但 Rust 没有足够智能到理解这些信息。此类场景即适用于不安全代码。</p><p>使用 <code>unsafe</code>、裸指针及一些不安全函数实现 <code>split_at_mut</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line">    <span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (</span><br><span class="line">            slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">            slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = split_at_mut(r, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 unsafe 代码中，<code>slice::from_raw_parts_mut</code> 函数接收一个裸指针和长度来创建一个切片。这里使用该函数从 <code>ptr</code> 处创建了一个拥有 <code>mid</code> 个元素的切片，接着又在 <code>ptr</code> 上使用 <code>mid</code> 作为偏移量参数调用 <code>offset</code> 方法得到了一个从 <code>mid</code> 处开始的裸指针，并基于它创建了另外一个起始于 <code>mid</code> 处且拥有剩余所有元素的切片。</p><p>函数 <code>slice::from_raw_parts_mut</code> 接收一个裸指针作为参数并默认该参数的合法性，所以它是不安全的。裸指针的 <code>offset</code> 方法默认此地址的偏移量也是一个有效的指针，它也是不安全的。<br>因此我们必须在 <code>unsafe</code> 代码块中调用上述两个函数。通过审查代码并添加断言，我们可以确定 <code>unsafe</code> 中的裸指针都会指向有效的切片数据且不会产生数据竞争。这就是一个恰当的 <code>unsafe</code> 使用场景。</p><p>代码没有将 <code>split_at_mut</code> 函数标记为 <code>unsafe</code>，因此我们可以在安全 Rust 中调用该函数。这就是对不安全代码的安全抽象。</p><p>与上述代码相反，下面对 <code>slice::from_raw_parts_mut</code> 函数的调用就很有可能导致崩溃。其试图用一个随意的内存地址来创建拥有 10000 个元素的切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> address = <span class="number">0x01234usize</span>;</span><br><span class="line">    <span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = <span class="keyword">unsafe</span> &#123; slice::from_raw_parts_mut(r, <span class="number">10000</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 <code>extern</code> 函数调用外部代码</h5><p>Rust 代码可能需要与另外一种语言编写的代码进行交互。Rust 为此提供了 <code>extern</code> 关键字来简化创建和使用<strong>外部函数接口（FFI）</strong>的过程。<br>任何 <code>extern</code> 块中声明的函数都是不安全的。因为其他语言不会强制执行 Rust 遵守的规则，Rust 又无法对它们进行检查。因此保证安全的责任就落到了开发者身上。</p><p>下面的代码集成了 C 标准库中的 <code>abs</code> 函数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Absolute value of -3: &#123;&#125;"</span>, abs(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问或修改静态变量"><a href="#访问或修改静态变量" class="headerlink" title="访问或修改静态变量"></a>访问或修改静态变量</h4><p>Rust 支持全局变量，但在使用的过程中可能因为所有权机制而产生某些问题。如果两个线程同时访问同一个可变的全局变量，就会产生数据竞争。<br>全局变量也被称为<strong>静态（static）变量</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name is: &#123;&#125;"</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态变量必须要标注类型，访问一个不可变的静态变量是安全的。<br>静态变量的值在内存中拥有固定的地址，使用它的值总会访问到同样的数据。而常量则允许在任何被使用到的时候复制其数据。<br>与常量不同的是，静态变量是可变的。但访问和修改可变的静态变量是不安全的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，任何读写静态变量 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 代码块中。</p><h4 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h4><p>当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，我们就称这个 trait 是不安全的。可以在 trait 定义的前面加上 <code>unsafe</code> 关键字来声明一个不安全 trait，同时该 trait 也只能在 <code>unsafe</code> 代码块中实现。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 某些方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 对应的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过使用 <code>unsafe impl</code>，我们向 Rust 保证我们会手动维护好那些编译器无法验证的不安全因素。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 内部隐藏了一种不会强制实施内存安全保障的语言：&lt;strong&gt;不安全 Rust&lt;/strong&gt;。&lt;br&gt;其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。&lt;br&gt;使用不安全代码的缺点在于程序员需要对自己的行为负责。若
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Unsafe" scheme="https://rollingstarky.github.io/tags/Unsafe/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——面向对象编程</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:18:48.184Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象编程（OOP）</strong>是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。</p><p><strong>对象包含数据和行为</strong></p><p>面向对象的程序由对象构成。对象包装了数据和操作这些数据的流程（称作方法)。<br>基于这个定义，Rust 是面向对象的。比如结构体和枚举都可以包含数据，而 <code>impl</code> 块则提供了可用于结构体和枚举的方法。</p><h4 id="封装实现细节"><a href="#封装实现细节" class="headerlink" title="封装实现细节"></a>封装实现细节</h4><p>封装使得调用对象的外部代码无法直接访问对象内部的实现细节，而唯一可以与对象进行交互的方法便是通过它公开的接口。<br><strong>使用对象的代码不应当深入对象的内部去改变数据或行为，封装使得开发者在修改或重构对象的内部实现时无需改变调用这个对象的外部代码</strong>。</p><p>在 Rust 中，我们可以使用 <code>pub</code> 关键字来决定代码中哪些模块、类型、函数和方法是公开的，而默认情况下所有内容都是私有的。</p><p>如下面计算移动平均值的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AveragedCollection</span></span> &#123;</span><br><span class="line">    list: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">    average: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> AveragedCollection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.push(value);</span><br><span class="line">        <span class="keyword">self</span>.update_average();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.list.pop();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.update_average();</span><br><span class="line">                <span class="literal">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">average</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_average</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> total: <span class="built_in">i32</span> = <span class="keyword">self</span>.list.iter().sum();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.list.len() <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> collection = AveragedCollection &#123;</span><br><span class="line">        list: <span class="built_in">vec!</span>[],</span><br><span class="line">        average: <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    collection.add(<span class="number">1</span>);</span><br><span class="line">    collection.add(<span class="number">2</span>);</span><br><span class="line">    collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The average of the collection is: &#123;&#125;"</span>, collection.average());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先是定义了一个名为 <code>AveragedCollection</code> 的结构体，其 <code>list</code> 字段包含了一个存储 <code>i32</code> 元素的动态数组；为了避免每次取元素平均值的时候重复计算，又添加了一个用于存储平均值的 <code>average</code> 字段。<br>结构体本身被标记为 <code>pub</code> 使得其他代码可以使用它，但其内部字段仍然保持私有。<br>公共方法 <code>add</code>、<code>remove</code>、<code>average</code> 是仅有的几个可以访问或修改 <code>AveragedCollection</code> 实例中数据的方法。当用户调用 <code>add</code> 方法向 <code>list</code> 中添加元素，或者调用 <code>remove</code> 从 <code>list</code> 中删除元素时，方法内部的实现都会再调用私有方法 <code>update_average</code> 来更新 <code>average</code> 字段。</p><p>由于 <code>list</code> 和 <code>average</code> 字段是私有的，外部代码无法直接读取 <code>list</code> 字段来增加或删除其中的元素。<br>一旦缺少了这样的封装，<code>average</code> 字段便无法在用户私自更新 <code>list</code> 字段时同步保持更新。</p><p>因为结构体 <code>AveragedCollection</code> 封装了内部的实现细节，我们能够在未来轻松地改变数据结构等内部实现。比如可以在 <code>list</code> 字段上使用 <code>HashSet&lt;i32&gt;</code> 替代 <code>Vec&lt;i32&gt;</code>。<br>只要 <code>add</code>、<code>remove</code>、<code>average</code> 这几个公共方法的签名保持不变，正在使用 <code>AveragedCollection</code> 的外部代码就无需进行任何修改。<br>假如将 <code>list</code> 字段声明为 <code>pub</code>，就必然会失去上面这一优势。<code>HashSet&lt;i32&gt;</code> 和 <code>Vec&lt;i32&gt;</code> 在增加或删除元素时使用的具体方法是不同的，因此若直接修改 <code>list</code>，外部代码将不得不随之发生变化。</p><h4 id="作为类型系统和代码共享机制的继承"><a href="#作为类型系统和代码共享机制的继承" class="headerlink" title="作为类型系统和代码共享机制的继承"></a>作为类型系统和代码共享机制的继承</h4><p>继承机制使得对象可以沿用另一个对象的数据与行为，而无需重复定义代码。<br>Rust 中无法定义一个继承父结构体字段和方法的子结构体。</p><p>选择继承主要有两个原因。其一是代码复用，作为替代方案，可以使用 Rust 中的默认 <code>trait</code> 方法来进行代码共享。<br>它与继承十分相似，父类中实现的方法可以被继承它的子类所拥有；子类也可以选择覆盖父类中的方法。</p><p>另一个使用继承的原因与类型系统有关，希望子类型能够被应用到一个需要父类型的地方。即<strong>多态</strong>：<strong>如果一些对象具有某些共同的特征，则这些对象就可以在运行时相互替换使用</strong>。<br>可以在 Rust 中使用泛型来构建不同类型的抽象，并使用 <code>trait</code> 约束来决定类型必须提供的具体特性。这一技术被称为<strong>限定参数化多态</strong>。</p><p>许多较为新潮的语言已经不太喜欢将继承作为内置的程序设计方案，因为<strong>使用继承意味着你会无意间共享出比所需内容更多的代码</strong>。<br>子类并不应该总是共享父类的所有特性，但使用继承机制却会始终产生这样的结果，进而使程序设计缺乏灵活性。而某些语言强制要求子类只能继承自单个父类，进一步限制了程序设计的灵活性。</p><h4 id="使用-trait-对象来存储不同类型的值"><a href="#使用-trait-对象来存储不同类型的值" class="headerlink" title="使用 trait 对象来存储不同类型的值"></a>使用 trait 对象来存储不同类型的值</h4><p>动态数组有一个限制，即只能存储同一类型的元素。有些时候的变通方案可以使用枚举。<br>比如定义一个 <code>SpreadsheetCell</code> 枚举同时包含了可以持有整数、浮点数和文本的变体。这样我们就可以在每个表格中存储不同的数据类型，且依然能够用一个动态数组来表示一整行单元格。<br>但是总有某些时候，我们希望用户能够在特定的场景下为类型的集合进行扩展。</p><p>比如需要创建一个含有 GUI 库架构的 gui 包，并在包中提供一些可供用户使用的具体类型，如 <code>Button</code> 或 <code>TextField</code> 等，这些类型都实现了 <code>draw</code> 方法用于支持将其绘制到屏幕中。<br>此外，gui 的用户也应当能够创建支持绘制的自定义类型，如某些开发者可能会添加 <code>Image</code>，另一些可能会添加 <code>SelectBox</code> 等。<br>在那些支持继承的语言中，我们可以定义出一个拥有 <code>draw</code> 方法的 <code>Component</code> 类。其他如 <code>Button</code>、<code>Image</code>、<code>SelectBox</code> 等则都需要继承 <code>Component</code> 类来获得 <code>draw</code> 方法。<br>当然也可以选择覆盖 <code>draw</code> 方法来实现自定义行为，但框架会在处理过程中将它们全部视作 <code>Component</code> 类型的实例，并以此调用 <code>draw</code> 方法。</p><h5 id="为共有行为定义一个-trait"><a href="#为共有行为定义一个-trait" class="headerlink" title="为共有行为定义一个 trait"></a>为共有行为定义一个 trait</h5><p>Rust 没有继承功能。<br>为了在 gui 中实现预期的功能，需要定义一个拥有 <code>draw</code> 方法的 <code>Draw</code> trait。trait 对象可以被用在泛型或具体类型所处的位置，无论我们在哪里使用 trait 对象，Rust 类型系统都会在编译时确保出现在相应位置上的值实现了 trait 对象中的指定方法。</p><p>Rust 有意避免将结构体和枚举称为对象，以便于与其他语言中的对象区别开。<strong>对于结构体和枚举而言，其字段中的数据与 <code>impl</code> 块中的行为是分开的；而在其他语言中，数据和行为往往被组合在名为对象的概念中</strong>。<br>trait 对象则有些类似于其他语言中的对象，它也在某种程度上组合了数据和行为。但 trait 对象被专门用于抽象某些共有行为，没有其他语言中的对象那么通用。</p><p>创建一个名为 <code>gui</code> 的 Rust 项目：<br><code>cargo new gui</code></p><p>在 <code>lib.rs</code> 中定义一个拥有 <code>draw</code> 方法的 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个持有 <code>components</code> 动态数组的 <code>Screen</code> 结构体，代码中的 <code>Box&lt;dyn Draw&gt;</code> 代表所有被放置在 <code>Box</code> 中且实现了 Draw trait 的具体类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Screen</code> 结构体定义了一个名为 <code>run</code> 的方法，会逐一调用 <code>components</code> 中每个元素的 <code>draw</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> Screen &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="实现-trait"><a href="#实现-trait" class="headerlink" title="实现 trait"></a>实现 trait</h5><p>在代码中添加一些实现了 Draw trait 的具体类型。需要注意的是，<code>draw</code> 方法不会包含任何有意义的内容，仅作为演示：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> height: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> label: <span class="built_in">String</span>, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a button, the button's label is &#123;&#125;"</span>, <span class="keyword">self</span>.label);</span><br><span class="line">        <span class="comment">// 实际绘制一个按钮的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Button</code> 中持有的 <code>width</code>、<code>height</code> 和 <code>label</code> 字段也许会不同于其他组件中的字段，比如 <code>TextField</code> 类型就可能在这些字段外额外持有一个 <code>placeholder</code> 字段。<br>每一个希望绘制在屏幕上的类型都应当实现 Draw trait，并在 <code>draw</code> 方法中使用不同的代码来自定义具体的绘制行为。<br>除了实现 Draw trait，<code>Button</code> 类型也许会在另外的 <code>impl</code> 块中实现响应用户点击按钮时的行为，这些方法并不适用于 <code>TextField</code> 等其他类型。</p><p>用户也可以在 <code>main.rs</code> 中为<code>SelectBox</code> 这种自定义类型实现 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">    options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a selectbox, the options are &#123;:?&#125;"</span>, <span class="keyword">self</span>.options);</span><br><span class="line">        <span class="comment">// 实际绘制一个选择框的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时就可以在编写 <code>main</code> 函数的时候创建 <code>Screen</code> 实例了。使用 <code>Box&lt;T&gt;</code> 生成 <code>SelectBox</code> 或 <code>Button</code> 的 trait 对象，再将它们添加到 <code>Screen</code> 实例中。便可以运行 <code>Screen</code> 实例的 <code>run</code> 方法来依次调用所有组件的 <code>draw</code> 实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> scrren = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">Box</span>::new(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Yes"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Maybe"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"No"</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="built_in">Box</span>::new(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="built_in">String</span>::from(<span class="string">"OK"</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">    scrren.run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; Drawing a selectbox, the options are ["Yes", "Maybe", "No"]</span></span><br><span class="line"><span class="comment">// =&gt; Drawing a button, the button's label is OK</span></span><br></pre></td></tr></table></figure></p><p>我们在编写库的时候无法得知用户是否会添加自定义的 <code>SelectBox</code> 类型，但我们的 <code>Screen</code> 实现依然能够接收新的类型并完成绘制工作。因为 <code>SelectBox</code> 实现了 Draw trait 及其 <code>draw</code> 方法。</p><p><code>run</code> 方法只关心值对行为的响应，而不在意值的具体类型。这一概念与动态类型中的 <strong>duck typing</strong> 十分相似。<br>通过在定义动态数组 <code>components</code> 时指定 <code>Box&lt;dyn Draw&gt;</code> 元素类型，<code>Screen</code> 实例只会接收那些能够调用 <code>draw</code> 方法的值，而不会去检查该值究竟是 <code>Button</code> 实例还是 <code>SelectBox</code> 实例。</p><p>使用 trait 对象与类型系统实现 duck typing 的优势在于，不需要在运行时检查某个值是否实现了指定的方法，或者担心出现调用未定义方法等运行时错误。Rust 会在编译时发现这类错误。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;面向对象编程（OOP）&lt;/strong&gt;是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象包含数据和行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向对象的程序由对象构成。对象包装了数据和操作这些数据
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Trait" scheme="https://rollingstarky.github.io/tags/Trait/"/>
    
      <category term="Encapsulation" scheme="https://rollingstarky.github.io/tags/Encapsulation/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Polymorphism" scheme="https://rollingstarky.github.io/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——并发</title>
    <link href="https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/"/>
    <id>https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-07-28T16:58:34.590Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发编程（concurrent programming）</strong>允许程序中的不同部分相互独立地运行，而<strong>并行编程（parallel programming）</strong>则允许程序中的不同部分同时执行。<br>Rust 中的所有权和类型系统能够同时帮助开发者管理内存安全及并发问题。</p><p>高级语言往往通过放弃部分控制能力来获得有益于用户的抽象，因此只支持全部解决方案的一部分是可以理解的设计策略。比如 Erlang 提供了一套优雅的消息传递并发特性，但没有提供可以在线程间共享状态的简单方法。<br>底层语言被期望在任意场景下都可以提供一套性能最佳的解决方案，并对硬件建立尽可能少的抽象，因此 Rust 提供了多种建模并发问题的工具。</p><h4 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h4><p>多个线程可以同时运行，因此将程序中的计算操作拆分至多个线程可以提高性能。但也增加了程序的复杂度，因为<strong>不同线程在执行过程中的具体顺序是无法确定的</strong>。可能导致下列问题：</p><ul><li>当多个线程以不一致的顺序访问数据或资源时产生的<strong>竞争状态（race condition）</strong></li><li>当两个线程同时尝试获取对方持有的资源时产生的<strong>死锁（deadlock）</strong>，会导致这两个线程都无法继续运行</li><li>只会出现在特定情形下且难以稳定复现和修复的 bug</li></ul><h5 id="使用-spawn-创建新线程"><a href="#使用-spawn-创建新线程" class="headerlink" title="使用 spawn 创建新线程"></a>使用 <code>spawn</code> 创建新线程</h5><p>可以调用 <code>thread::spawn</code> 函数来创建线程，它接收一个闭包作为参数，该闭包会包含我们想要在新线程中运行的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>主线程首先打印出了文本，即便新线程的打印语句出现得更早一些。这些线程可能会交替执行，执行顺序由操作系统的线程调度策略决定。<br>需要注意的是，只要上述程序中的主线程运行结束，创建出的新线程也会停止，不管其打印任务是否完成。<br>虽然我们要求新线程不停打印文本直到 <code>i</code> 迭代到 9，但它在主线程停止前仅迭代到了 5。</p><h5 id="使用-join-句柄等待所有线程结束"><a href="#使用-join-句柄等待所有线程结束" class="headerlink" title="使用 join 句柄等待所有线程结束"></a>使用 <code>join</code> 句柄等待所有线程结束</h5><p><code>thread::spawn</code> 的返回类型是一个自持有所有权的 <code>joinHandle</code>，调用它的 <code>join</code> 方法可以阻塞当前线程直到对应的新线程运行结束。</p><p>调用 <code>join</code> 方法保证新线程能够在 <code>main</code> 函数退出前执行完毕：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>假如将 <code>handle.join()</code> 放置到 <code>main</code> 函数的 <code>for</code> 循环之前，即：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，由于主线程会等待新线程执行完毕后才开始执行自己的 <code>for</code> 循环，程序的输出将不再出现交替的情形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 4 from the main thread!</span><br></pre></td></tr></table></figure></p><p>在并发编程中，诸如在哪里调用 <code>join</code> 等微小细节也会影响到多个线程是否能够同时运行。</p><h5 id="在线程中使用-move-闭包"><a href="#在线程中使用-move-闭包" class="headerlink" title="在线程中使用 move 闭包"></a>在线程中使用 <code>move</code> 闭包</h5><p><code>move</code> 闭包常被用来与 <code>thread::spawn</code> 函数配合使用，允许在某个线程中使用来自另一个线程的数据。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译上述代码时会报出 <code>error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</code> 错误。<br>Rust 在推导出如何捕获 <code>v</code> 后决定让闭包借用 <code>v</code>，因为闭包中的 <code>println!</code> 只需要使用 <code>v</code> 的引用。但 Rust 不知道新线程会运行多久，因此它无法确定 <code>v</code> 的引用是否一直有效。</p><p>通过在闭包前添加 <code>move</code> 关键字，会强制闭包获得它所需值的所有权，而不仅仅是基于 Rust 的推导来获得值的借用。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用消息传递在线程间转移数据"><a href="#使用消息传递在线程间转移数据" class="headerlink" title="使用消息传递在线程间转移数据"></a>使用消息传递在线程间转移数据</h4><p>使用消息传递（message passing）机制来保证并发安全正变得越来越流行。Go 语言文档中的口号正体现了这样的思路：<strong>不要通过共享内存来通信，而是通过通信来共享内存</strong>。</p><p>Rust 的标准库中实现了一个名为<strong>通道（channel）</strong>的编程概念，可以被用来实现基于消息传递的并发机制。<br>通道由发送者（transmitter）和接收者（receiver）两部分组成。发送者位于通道的上游，接收者位于下游。<br>某一处的代码可以通过调用发送者的方法来传送数据，另一处代码则可以通过检查接收者来获取数据。<br>当发送者或接收者的任何一端被丢弃，则相应的通道被关闭。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br></pre></td></tr></table></figure><p>上述代码使用 <code>mpsc::channel</code> 函数创建了一个新的通道。<strong>mpsc</strong> 是英文 <strong>multiple producer, single consum</strong>（多个生产者，单个消费者）的缩写。<br><code>mpsc::channel</code> 会返回一个含有发送端与接收端的元组。<br>再使用 <code>thread::spawn</code> 生成一个新线程。为了令新线程拥有发送端 <code>tx</code> 的所有权，使用 <code>move</code> 关键字将 <code>tx</code> 移动到了闭包的环境中。<br>新线程必须拥有通道发送端的所有权才能通过通道来发送消息。<br>发送端提供了 <code>send</code> 方法来处理我们想要发送的值，该方法会返回 <code>Result&lt;T, E&gt;</code> 类型作为结果。当接收端已经被丢弃而无法继续传递内容时，执行发送操作会返回一个错误。</p><p>通道的接收端有两个可用于获取消息的方法。其中 <code>recv</code> 会阻塞主线程的执行直到有值被传入通道。一旦有值传入通道，<code>recv</code> 就会将其包裹在 <code>Result&lt;T, E&gt;</code> 中返回。若通道的发送端全部关闭了，<code>recv</code> 会返回一个错误来表明当前通道再也没有可接收的值。<br><code>try_recv</code> 方法不会阻塞线程，它会立即返回 <code>Result&lt;T, E&gt;</code>。当通道中存在消息时，返回包含该消息的 <code>Ok</code> 变体；否则返回 <code>Err</code> 变体。可以编写一个不断调用 <code>try_recv</code> 方法的循环，并在有消息时对其进行处理，没有消息时执行其他指令。</p><h5 id="发送多个值"><a href="#发送多个值" class="headerlink" title="发送多个值"></a>发送多个值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure><p>上述代码会迭代新线程中的动态数组来逐个发送其中的字符串，并在每次发送后调用 <code>thread::sleep</code> 函数来稍作暂停。<br>在主线程中，我们会将 <code>rx</code> 视作迭代器，不再显式地调用 <code>recv</code> 函数。迭代中的代码会打印出每个接收到的值，并在通道关闭时退出循环。<br>代码执行时每次打印后都会出现 1 秒的时间间隔。但我们并没有在主线程的 <code>for</code> 循环中执行延迟指令，表明主线程确实在等待接收新线程中传递过来的值。</p><h5 id="通过克隆发送者创建多个生产者"><a href="#通过克隆发送者创建多个生产者" class="headerlink" title="通过克隆发送者创建多个生产者"></a>通过克隆发送者创建多个生产者</h5><p>通过克隆通道的发送端来创建出多个能够发送值到同一个接收端的线程：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"more"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"messages"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"for"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"you"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: more</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: messages</span></span><br><span class="line"><span class="comment">// =&gt; Got: for</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: you</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure></p><h4 id="共享状态的并发"><a href="#共享状态的并发" class="headerlink" title="共享状态的并发"></a>共享状态的并发</h4><p>从某种程度上来说，任何编程语言中的通道都有些类似于<strong>单一所有权</strong>的概念。因为用户不应该在值传递给通道后再次使用它。<br>基于共享内存的并发通信机制更类似于<strong>多重所有权</strong>概念，多个线程可以同时访问相同的内存地址。<br>我们可以通过智能指针实现多重所有权，但由于需要同时管理多个所有者，会为系统增加额外的复杂性。当然，Rust 的类型系统和所有权规则有助于正确地管理这些所有权。</p><h5 id="互斥体（mutex）"><a href="#互斥体（mutex）" class="headerlink" title="互斥体（mutex）"></a>互斥体（mutex）</h5><p><strong>互斥体在任意时刻只允许一个线程访问数据</strong>。为了访问互斥体中的数据，线程必须首先发出信号来获取互斥体的锁（lock）。<br>锁是互斥体的一部分，这种数据结构被用来记录当前谁拥有数据的唯一访问权。</p><p>关于互斥体必须牢记以下两条规则：</p><ul><li>必须在使用数据前尝试获取锁</li><li>必须在使用完互斥体守护的数据后释放锁，这样其他线程才能继续执行获取锁的操作</li></ul><p>在单线程环境中使用互斥体：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; m = Mutex &#123; data: 6 &#125;</span></span><br></pre></td></tr></table></figure></p><p>为了访问 <code>Mutex&lt;T&gt;</code> 实例中的数据，我们首先需要调用其 <code>lock</code> 方法来获取锁。此调用会阻塞当前线程直到我们取得锁为止。<br>当前线程对于 <code>lock</code> 函数的调用会在其他某个持有锁的线程发生 <code>panic</code> 时失败，因此上述代码选择使用 <code>unwrap</code> 在意外发生时触发当前线程的 <code>panic</code>。</p><p>一旦获取了锁，便可以将它的返回值 <code>num</code> 视作一个指向内部数据的可变引用。<br>Rust 的类型系统会确保我们在使用 <code>m</code> 的值之前执行加锁操作。因为 <code>Mutex&lt;i32&gt;</code> 并不是 <code>i32</code> 类型，我们必须获取锁才能使用其内部的 <code>i32</code> 值。</p><p>实际上对 <code>lock</code> 的调用会返回一个名为 <code>MutexGuard</code> 的智能指针。该智能指针通过实现 <code>Deref</code> 来指向存储在内部的数据，通过实现 <code>Drop</code> 完成自己离开作用域时的自动解锁操作。<br>这种释放过程会发生在内部作用域的结尾处，因此我们不会因为忘记释放锁而导致其他线程无法继续使用该互斥体。</p><h5 id="多个线程间共享-Mutex-lt-T-gt"><a href="#多个线程间共享-Mutex-lt-T-gt" class="headerlink" title="多个线程间共享 Mutex&lt;T&gt;"></a>多个线程间共享 <code>Mutex&lt;T&gt;</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Mutex::new(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次启动 10 个线程，并在每个线程中分别为共享的计数器的值加 1。<br>但代码目前无法通过编译，会报出 <strong>error[E0382]: use of moved value: <code>counter</code></strong> 错误。<br>原因是变量 <code>counter</code> 被移动进了 <code>handle</code> 指代的线程中，这一移动行为阻止我们在另一个线程中调用 <code>lock</code> 来再次捕获 <code>counter</code>。</p><h5 id="多线程与多重所有权"><a href="#多线程与多重所有权" class="headerlink" title="多线程与多重所有权"></a>多线程与多重所有权</h5><p>智能指针 <code>Rc&lt;T&gt;</code> 提供的引用计数能够为单个值赋予多个所有者。<br>现在尝试使用 <code>Rc&lt;T&gt;</code> 来包裹 <code>Mutex&lt;T&gt;</code>，并在每次需要移动所有权至线程时克隆 <code>Rc&lt;T&gt;</code>。看改进后的程序能否编译通过。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Rc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Rc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次尝试编译代码，报出另外一个错误：<code>error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。<br>原因是 <code>Rc&lt;T&gt;</code> 在跨线程使用时并不安全。<code>Rc&lt;T&gt;</code> 会在每次调用 <code>clone</code> 的过程中增加引用计数，在克隆出的实例被丢弃后减少引用计数。但它并没有使用任何并发原语来保证修改计数的过程中不会被另一个线程所打断。这极有可能导致计数错误并产生诡异的 bug。</p><h5 id="原子引用计数-Arc-lt-T-gt"><a href="#原子引用计数-Arc-lt-T-gt" class="headerlink" title="原子引用计数 Arc&lt;T&gt;"></a>原子引用计数 <code>Arc&lt;T&gt;</code></h5><p><code>Arc&lt;T&gt;</code> 类型既拥有类似于 <code>Rc&lt;T&gt;</code> 的行为，又保证自己可以被安全地用于并发场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Result: 10</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>Arc&lt;T&gt;</code> 替换掉代码中的 <code>Rc&lt;T&gt;</code> 后，代码可以编译通过。</p><p>需要注意的是，Rust 并不能使你完全避免使用 <code>Mutex&lt;T&gt;</code> 过程中所有的逻辑错误。使用 <code>Mutex&lt;T&gt;</code> 也会有产生死锁（deadlock）的风险。当某个操作需要同时锁住两个资源，而两个线程分别持有其中一个锁并相互请求另外一个锁时，这两个线程就会陷入无穷尽的等待过程。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;并发编程（concurrent programming）&lt;/strong&gt;允许程序中的不同部分相互独立地运行，而&lt;strong&gt;并行编程（parallel programming）&lt;/strong&gt;则允许程序中的不同部分同时执行。&lt;br&gt;Rust 中的所有权
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Deadlock" scheme="https://rollingstarky.github.io/tags/Deadlock/"/>
    
      <category term="Channel" scheme="https://rollingstarky.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——智能指针</title>
    <link href="https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/"/>
    <id>https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-07-26T15:34:22.264Z</updated>
    
    <content type="html"><![CDATA[<p><strong>指针（pointer）</strong>是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。<br>Rust 中最常见的指针是<strong>引用</strong>，会<strong>借用</strong>它所指向的数据。除此之外，引用没有任何其他功能和额外的开销。<br><strong>智能指针（smart pointer）</strong>是一种数据结构，它的行为类似于指针但<strong>拥有额外的元数据和附加功能</strong>。</p><p>在拥有所有权和借用概念的 Rust 中：<strong>引用只是用来借用数据的指针；而大多数智能指针本身就拥有它们指向的值</strong>。<br>比如 <code>String</code> 和 <code>Vec&lt;T&gt;</code> 类型就都可以被算作智能指针。它们都拥有一片内存区域并允许用户对其进行操作，拥有元数据（如容量等），能提供额外的功能或保障（如 <code>String</code> 会保证其中的数据必是合法的 <code>UTF-8</code> 编码）。</p><p>通常使用结构体来实现智能指针。区别于普通的结构体，智能指针会实现 <code>Deref</code> 与 <code>Drop</code> 这两个 <code>trait</code>。Deref trait 使得智能指针的实例拥有与引用一致的行为；Drop trait 使得用户可以自定义智能指针离开作用域时运行的代码。</p><p>标准库中最为常见的智能指针如下：</p><ul><li><code>Box&lt;T&gt;</code>：可用于在堆上分配数据</li><li><code>Rc&lt;T&gt;</code>：具备多重所有权的<strong>引用计数类型</strong></li><li><code>Ref&lt;T&gt;</code> 和 <code>ReMut&lt;T&gt;</code>：可以通过 <code>RefCell&lt;T&gt;</code> 访问，是一种可以在运行时而不是编译时执行借用规则的类型</li></ul><h4 id="使用-Box-lt-T-gt-在堆上分配数据"><a href="#使用-Box-lt-T-gt-在堆上分配数据" class="headerlink" title="使用 Box&lt;T&gt; 在堆上分配数据"></a>使用 <code>Box&lt;T&gt;</code> 在堆上分配数据</h4><p><strong>装箱（box）</strong>是最简单的一种智能指针，其类型为 <code>Box&lt;T&gt;</code>。它使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针。</p><p>装箱常被用于以下场景：</p><ul><li>拥有一个无法在编译时确定大小的类型，但又想在一个要求固定尺寸的上下文环境中使用这个类型</li><li>需要传递大量数据的所有权，但又不希望产生大量数据的复制行为</li><li>希望拥有一个实现了指定 trait 的类型值，但又不关心具体的类型</li></ul><p>使用装箱在堆上存储一个 <code>i32</code> 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将单一值存放在堆上没有太大用处，大部分情况下都可以将类似的单个 <code>i32</code> 值默认放置在栈上。</p><h5 id="使用装箱定义递归类型"><a href="#使用装箱定义递归类型" class="headerlink" title="使用装箱定义递归类型"></a>使用装箱定义递归类型</h5><p>Rust 必须在编译时知道每一种类型占据的空间大小，但有一种被称为<strong>递归</strong>的类型无法在编译时确定具体大小。<br>递归类型的值可以在自身中存储另一个相同类型的值，这种嵌套理论上可以无穷无尽地进行下去，根本无法计算出具体的空间大小。</p><p>链接列表（cons list）是一种在函数式语言中非常常见的数据类型。<code>cons</code> 函数会将两个参数组成一个二元组，而这个元组通常由一个值和另一个二元组组成，通过这种不断嵌套元组的形式最终组成一个列表。<br>使用枚举来定义一个链接列表：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码在编译时会报出 <code>error[E0072]: recursive type `List` has infinite size</code> 错误。</p><p>Rust 在计算枚举类型需要的空间大小时，会遍历枚举中的每一个成员来找到需要最大空间的那个变体。因为在每个时间点，只会有一个变体存在。<br>对于递归类型大小的计算，以前面的 <code>List</code> 为例，编译器会先检查 <code>Cons</code> 变体，它持有一个 <code>i32</code> 类型的值及另外一个 <code>List</code> 类型；为了确定此处<code>List</code> 的大小，编译器又会从 <code>Cons</code> 开始遍历其下的所有变体，这样的检查将永远进行下去。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-23761fd6dc9ac77d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="包含无穷多 Cons 变体的无穷 List"></p><p>可以使用 <code>Box&lt;T&gt;</code> 将递归类型的大小固定下来。<br><code>Box&lt;T&gt;</code> 是一个指针，其大小总是恒定的，不会因为指向数据的大小而发生变化。我们可以在 <code>Cons</code> 变体中存放一个 <code>Box&lt;T&gt;</code> 指针，<code>Box&lt;T&gt;</code> 指向下一个存储在堆上的 <code>List</code>。即嵌套的 <code>List</code> 并没有直接存放在 <code>Cons</code> 变体中，而是放置在堆上，打破了无限递归的过程。<br>此时任意的 <code>List</code> 值都只需要占用一个 <code>i32</code> 值加上一个装箱指针的大小。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-688437fa1045d8cb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Box in Cons"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装箱除了间接访问内存和堆分配，没有提供任何其他的特殊功能，也没有这些特殊功能附带的性能开销。因此正好能被用在类似于链接列表这类只是需要间接访问的场景中。</p><h4 id="通过-Deref-trait-将智能指针视作常规引用"><a href="#通过-Deref-trait-将智能指针视作常规引用" class="headerlink" title="通过 Deref trait 将智能指针视作常规引用"></a>通过 <code>Deref trait</code> 将智能指针视作常规引用</h4><p>实现 <code>Deref trait</code> 使我们可以自定义解引用运算符 <code>*</code> 的行为，这意味着原本用于处理引用的代码可以不加修改地用于处理智能指针。</p><h5 id="使用解引用跳转到指针指向的值"><a href="#使用解引用跳转到指针指向的值" class="headerlink" title="使用解引用跳转到指针指向的值"></a>使用解引用跳转到指针指向的值</h5><p>指针可以被理解为一种箭头，会指向存储在别处的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数字和引用是两种不同的类型，所以不能直接比较 <code>5</code> 和 <code>y</code>。必须使用 <code>*y</code> 来跳转到引用指向的值。</p><h5 id="把-Box-lt-T-gt-当成引用来操作"><a href="#把-Box-lt-T-gt-当成引用来操作" class="headerlink" title="把 Box&lt;T&gt; 当成引用来操作"></a>把 <code>Box&lt;T&gt;</code> 当成引用来操作</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>MyBox</code> 是一个拥有 <code>T</code> 类型的元组结构体，其关联函数 <code>MyBox::new</code> 接收一个 <code>T</code> 类型的参数，并返回一个存储有传入值的 <code>MyBox</code> 实例作为结果。</p><p>为了为 <code>MyBox&lt;T&gt;</code> 类型实现解引用功能，代码中实现了 <code>Deref trait</code>。<br>标准库中的 Deref trait 要求我们实现一个 <code>deref</code> 方法，该方法会借用 <code>self</code> 并返回一个指向内部数据的引用。<br><code>deref</code> 方法体中的 <code>&amp;self.0</code> 意味着 <code>deref</code> 会返回一个指向值的引用，进而允许调用者通过 <code>*</code> 运算符访问值。<br>代码中的 <code>*y</code> 会被 Rust 隐式地展开为 <code>*(y.deref())</code>。使得我们可以用完全相同的方式编写代码来处理常规引用及实现了 Deref trait 的类型。</p><h4 id="函数和方法的隐式解引用转换"><a href="#函数和方法的隐式解引用转换" class="headerlink" title="函数和方法的隐式解引用转换"></a>函数和方法的隐式解引用转换</h4><p>解引用转换是 Rust 为函数和方法的参数提供的一种编程特性。当某个类型 T 实现了 Deref trait 时，它能够将 T 的引用转换为 T 经过 Deref 操作后生成的引用。<br>当我们将某个类型的值引用作为参数传递给类型或方法，但传入的类型与参数类型不一致时，解引用转换就会自动发生。编译器会插入一系列的 deref 方法来将我们提供的类型转换为参数所需的类型。</p><p>解引用转换使程序员在调用函数或方法时无需多次显式地使用 <code>&amp;</code> 和 <code>*</code> 操作符来进行引用和解引用操作。我们因而可以更多地编写出能够同时作用于常规引用和智能指针的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;m</code> 是一个指向 <code>MyBox&lt;String&gt;</code> 值的引用。因为 <code>MyBox&lt;T&gt;</code> 实现了 Deref trait，Rust 可以通过调用 deref 将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>String</code>；因为标准库为 <code>String</code> 提供的 Deref 实现会返回字符串切片，所以 Rust 可以继续调用 deref 将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，最终与 <code>hello</code> 函数的定义匹配。</p><h5 id="解引用转换与可变性"><a href="#解引用转换与可变性" class="headerlink" title="解引用转换与可变性"></a>解引用转换与可变性</h5><p>使用 <code>Deref trait</code> 能够重载不可变引用的 <code>*</code> 运算符，使用 <code>DerefMut trait</code> 能够重载可变引用的 <code>*</code> 运算符。</p><p>Rust 会在类型与 trait 满足下面 3 种情况时执行解引用转换：</p><ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code></li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code></li></ul><h4 id="借助-Drop-trait-在清理时运行代码"><a href="#借助-Drop-trait-在清理时运行代码" class="headerlink" title="借助 Drop trait 在清理时运行代码"></a>借助 <strong>Drop trait</strong> 在清理时运行代码</h4><p>Drop trait 允许我们在变量离开作用域时执行某些自定义操作。可以为任意类型实现一个 Drop trait，它常常被用来释放诸如文件、网络连接等资源。<br>几乎每一种智能指针的实现都会用到这一 trait，比如 <code>Box&lt;T&gt;</code> 通过自定义 Drop 来释放装箱指针指向的堆内存空间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"my stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> d = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"other stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure><h5 id="使用-std-mem-drop-提前丢弃值"><a href="#使用-std-mem-drop-提前丢弃值" class="headerlink" title="使用 std::mem::drop 提前丢弃值"></a>使用 <code>std::mem::drop</code> 提前丢弃值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="built_in">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer dropped before the end of main</span></span><br></pre></td></tr></table></figure><h4 id="基于引用计数的智能指针-Rc"><a href="#基于引用计数的智能指针-Rc" class="headerlink" title="基于引用计数的智能指针 Rc"></a>基于引用计数的智能指针 <strong>Rc<t></t></strong></h4><p>所有权在大多数情况下都是清晰的，对于一个给定的值，可以准确地判断出哪个变量拥有它。<br>但在某些场景中，单个值也可能同时被多个所有者持有。<br>比如在图数据结构中，多个边可能会指向相同的节点，这个节点同时属于所有指向它的边。一个节点只要在任意指向它的边还存在时就不应该被清理掉。<br>Rust 提供了一种名为 <code>Rc&lt;T&gt;</code> 的类型来支持多重所有权。<code>Rc&lt;T&gt;</code> 类型的实例会在内部维护一个用于记录值引用次数的计数器，从而确认这个值是否仍在使用。若对一个值的引用次数为零，就意味着这个值可以被安全地清理掉。</p><p>当你希望将堆上的一些数据分享给程序的多个部分同时使用，而又无法在编译期确定哪个部分会最后释放这些数据时，就可以使用 <code>Rc&lt;T&gt;</code> 类型。<br>相反地，若我们能够在编译期确定哪一部分最后会释放数据，那么就只需要让这部分代码成为数据的所有者即可。<br><strong><code>Rc&lt;T&gt;</code> 只能被用于单线程场景中</strong>。</p><h5 id="使用-Rc-lt-T-gt-共享数据"><a href="#使用-Rc-lt-T-gt-共享数据" class="headerlink" title="使用 Rc&lt;T&gt; 共享数据"></a>使用 <code>Rc&lt;T&gt;</code> 共享数据</h5><p>创建两个链接列表，并让它们同时持有第三个列表的所有权。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-46c80b946fd197b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cons List"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>, <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译上述代码会报出 <strong>error[E0382]: use of moved value: <code>a</code></strong> 错误。原因是 <code>a</code> 列表会在创建 <code>b</code> 列表时被移动至 <code>b</code> 中。即 <code>b</code> 列表持有了 <code>a</code> 列表的所有权。随后再次尝试使用 <code>a</code> 来创建 <code>c</code> 列表时就会出现编译错误，因为 <code>a</code> 已经被移走了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，每个 <code>Cons</code> 变体都持有一个值及一个指向 List 的 <code>Rc&lt;T&gt;</code>。我们只需要在创建 <code>b</code> 的过程中克隆 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 智能指针即可，无需获取 <code>a</code> 的所有权。<br>这使得 <code>a</code> 和 <code>b</code> 可以共享 <code>Rc&lt;List&gt;</code> 数据的所有权，并使智能指针中的引用计数从 1 增加到 2。随后创建 <code>c</code> 时也会同样克隆 <code>a</code> 并将引用计数从 2 增加到 3。<br>每次调用 <code>Rc::clone</code> 都会使引用计数增加，而 <code>Rc&lt;List&gt;</code> 中的数据只有在引用计数器减少到 0 时才会被真正清理掉。</p><h5 id="克隆-Rc-lt-T-gt-会增加引用计数"><a href="#克隆-Rc-lt-T-gt-会增加引用计数" class="headerlink" title="克隆 Rc&lt;T&gt; 会增加引用计数"></a>克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; count after creating a = 1</span></span><br><span class="line"><span class="comment">// =&gt; count after creating b = 2</span></span><br><span class="line"><span class="comment">// =&gt; count after creating c = 3</span></span><br><span class="line"><span class="comment">// =&gt; count after c goes out of scope = 2</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>a</code> 存储的 <code>Rc&lt;List&gt;</code> 拥有初始引用计数 1，并在随后每次调用 <code>clone</code> 时增加 1。当 <code>c</code> 离开作用域被丢弃时，引用计数减少 1。<code>Rc&lt;T&gt;</code> 的 <code>Drop</code> 实现会在 <code>Rc&lt;T&gt;</code> 离开作用域时自动将引用计数减 1。</p><p>使用 <code>Rc&lt;T&gt;</code> 可以使单个值拥有多个所有者，而引用计数机制则保证了这个值会在其所有者存活时一直有效，并在所有者全部离开作用域时被自动清理。<br><code>Rc&lt;T&gt;</code> 通过不可变引用使你可以在程序的不同部分之间共享只读数据。但如果 <code>Rc&lt;T&gt;</code> 也允许持有多个可变引用的话，就会违反一个借用原则：多个指向同一区域的可变借用会导致数据竞争及数据不一致。<br>但在实际开发中，允许数据可变是非常有用的。实际上可以通过 <code>RefCell&lt;T&gt;</code> 与 <code>Rc&lt;T&gt;</code> 联合使用来绕开不可变的限制。</p><h4 id="RefCell-和内部可变性模式"><a href="#RefCell-和内部可变性模式" class="headerlink" title="RefCell 和内部可变性模式"></a>RefCell<t> 和内部可变性模式</t></h4><p><strong>内部可变性</strong> 是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改。为了能够改变数据，此模式在它的数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则。<br>假如我们能够保证自己的代码在运行时符合借用规则，就可以在即使编译器无法在编译阶段保证符合借用规则的前提下，使用那些采用了内部可变性模式的类型。实现过程中涉及的那些不安全代码会被妥善地封装在安全的 API 内，而类型本身从外部看依然是不可变的。</p><h5 id="使用-RefCell-lt-T-gt-在运行时检查借用规则"><a href="#使用-RefCell-lt-T-gt-在运行时检查借用规则" class="headerlink" title="使用 RefCell&lt;T&gt; 在运行时检查借用规则"></a>使用 <code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h5><p>Rust 中的借用规则如下：</p><ul><li>在任何给定的时间内，只能拥有一个可变引用或者任意数量的不可变引用</li><li>引用总是有效的</li></ul><p>对于一般引用和 <code>Box&lt;T&gt;</code> 的代码，Rust 会在<strong>编译阶段</strong>强制代码遵守这些借用规则。而对于使用 <code>RefCell&lt;T&gt;</code> 的代码，Rust 只会在<strong>运行时</strong>检查这些规则，并在违反的时候触发 panic 来提前终止程序。</p><p>借用规则的检查放在编译阶段不仅会帮助我们在开发阶段尽早暴露问题，并且不会带来任何运行时开销。对于大多数场景都是最佳的选择。<br>在运行时检查借用规则可以使我们实现某些特定的内存安全场景，即便这些场景无法通过编译时检查。因为某些静态分析是根本无法完成的。这类编译器无法理解代码，但开发者可以保证借用规则能够满足的场景，就适用于 <code>RefCell&lt;T&gt;</code>。</p><h5 id="可变地借用一个不可变的值"><a href="#可变地借用一个不可变的值" class="headerlink" title="可变地借用一个不可变的值"></a>可变地借用一个不可变的值</h5><p><strong>内部可变性模式允许用户更改一个不可变值的内部数据</strong>。<br>借用规则限制用户可变地借用一个不可变的值，如下面的代码无法通过编译：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是在某些情况下，我们也需要一个值对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代码仍不能修改这个值。<br>使用 <code>RefCell&lt;T&gt;</code> 可以获得这种内部可变性。<br>这种内部可变性的机制把借用规则的检查从编译期延后到了运行阶段，若违反了借用规则，只会在运行时触发 <strong>panic!</strong>。</p><p><strong>内部可变性的应用场景：模拟对象</strong><br><strong>测试替代</strong>是一种通用的编程概念，代表了那些在测试工作中被用作其他类型替代品的类型。而<strong>模拟对象</strong>则指代了测试替代中某些特定的类型，会承担起记录测试过程的工作。</p><p>Rust 没有和其他语言中类似的对象概念，也没有在标准库中提供模拟对象的测试功能。但是可以自定义一个结构体来实现与模拟对象相同的效果。<br>比如我们希望开发一个库，会基于当前值与最大值之间的接近程度向外传递信息。比如可以记录用户调用不同 API 的次数，并与设置的调用限额作比较。<br>使用这个库的应用程序需要自行实现发送消息的功能，例如在应用程序中打印信息、发送邮件、发送文字短信等。<br>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>Messenger</code> trait 的 <code>send</code> 方法可以接收 <code>self</code> 的不可变引用及一条文本消息作为参数。我们需要在测试中确定的是，当某段程序使用一个实现了 Messenger trait 的模拟对象与一个 max 值来创建 <code>LimitTracker</code> 实例时，传入的不同 value 值能够触发 messenger 发送不同的信息。<br>此处的模拟对象 <code>MockMessenger</code> 在调用 <code>send</code> 时只需要将收到的消息存档记录即可，不需要真的去发送邮件或短信。使用模拟对象创建 <code>LimitTracker</code> 实例后，就可以通过调用 <code>set_value</code> 方法检查模拟对象中是否存储了我们希望见到的消息。</p><p>尝试编译（<code>cargo test</code>）上述代码会报出如下错误：<br><code>error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</code></p><p><code>send</code> 方法接收了 <code>self</code> 的不可变引用，因此我们无法通过修改 <code>MockMessenger</code> 的内容来记录消息。我们也不能将函数签名修改为 <code>&amp;mut self</code>，因为修改后的签名与 Messenger trait 定义的 <code>send</code> 签名不符。<br>此时就是一个非常适合内部可变性的场景。只要在 <code>RefCell&lt;T&gt;</code> 中存入 <code>sent_messages</code>，<code>send</code> 方法就能够修改 <code>sent_messages</code>。</p><p>修改后的代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>sent_messages</code> 字段的类型变为了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>。对于 <code>send</code> 方法的实现，其第一个参数依然是 <code>self</code> 的不可变借用，与 trait 的定义保持一致。后面的代码调用 <code>self.messages.borrow_mut</code> 方法获取 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 内部值（也就是动态数组）的可变引用，再调用其 <code>push</code> 方法存入数据。<br>在断言语句中，调用了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 的 <code>borrow</code> 方法来取得动态数组的不可变引用。</p><p>对于 <code>RefCell&lt;T&gt;</code> 而言，我们可以使用 <code>borrow</code> 与 <code>borrow_mut</code> 分别创建不可变和可变引用。这两个方法会分别返回 <code>Ref&lt;T&gt;</code> 与 <code>RefMut&lt;T&gt;</code> 两种智能指针，可以被当作一般的引用来对待。<br><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，维护和编译器同样的借用规则：任何给定的时间都只允许拥有多个不可变借用或一个可变借用。<br>当借用规则被违背时，<code>RefCell&lt;T&gt;</code> 会在<strong>运行时</strong>触发 panic。</p><h4 id="Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据"><a href="#Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据" class="headerlink" title="Rc&lt;T&gt; 和 RefCell&lt;T&gt; 实现一个拥有多重所有权的可变数据"></a><code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 实现一个拥有多重所有权的可变数据</h4><p><code>Rc&lt;T&gt;</code> 允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。若在 <code>Rc&lt;T&gt;</code> 内存储了 <code>RefCell&lt;T&gt;</code>，就可以定义出拥有多个所有者且能够进行修改的值了。</p><p>在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code> 来实现修改现有列表内数值的功能：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环引用与内存泄漏"><a href="#循环引用与内存泄漏" class="headerlink" title="循环引用与内存泄漏"></a>循环引用与内存泄漏</h4><p>与数据竞争不同，在编译期彻底防止内存泄漏并不是 Rust 做出的保证。这意味着内存泄漏在 Rust 中是一种内存安全行为。<br>可以通过使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 创建出相互引用成环状的实例。由于环中每一个指针的引用计数都不可能减少到 0，对应的值也不会被释放丢弃，最终造成内存泄漏。</p><p>代码中先创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>a</code>，其中的 List 初始值为 <code>5, Nil</code>。<br>之后又创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>b</code>，其中的 List 包含数值 10 及指向列表 <code>a</code> 的指针。<br>接着将 <code>a</code> 指向的下一个元素 <code>Nil</code> 修改为 <code>b</code>，此时即创建出了循环引用。</p><p>在完成 <code>a</code> 指向 <code>b</code> 的操作后，这两个 <code>Rc&lt;List&gt;</code> 实例的引用计数都变为了 2。而在 <code>main</code> 函数结尾处，Rust 会首先释放 <code>b</code>，并使 <code>b</code> 存储的 <code>Rc&lt;List&gt;</code> 实例的引用计数减少 1。<br>但由于 <code>a</code> 仍然有一个指向 <code>b</code> 中 <code>Rc&lt;List&gt;</code> 的引用，这个 <code>Rc&lt;List&gt;</code> 的引用计数仍然是 1 而不是 0。因此该 <code>Rc&lt;List&gt;</code> 在堆上的内存不会被释放，这块内存会永远以引用计数为 1 的状态保留在堆上。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-55a8d6b393cb625e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 和 b 相互指向的循环引用"></p><p>假如去除最后一行 <code>println!</code> 的注释并再次运行程序，Rust 会在尝试将循环引用打印出来的过程中反复地从 <code>a</code> 跳转到 <code>b</code>，再从 <code>b</code> 跳转至 <code>a</code>，直到发生栈溢出为止。</p><p>如果程序中存在 <code>RefCell&lt;T&gt;</code> 包含 <code>Rc&lt;T&gt;</code> 或其他联用了内部可变性与引用计数指针的情形，就需要自行确保不会在代码中创建出循环引用。<br>创建出循环引用意味着代码逻辑有 bug，可以通过自动化测试及其他软件开发手段来尽可能地避免。</p><h4 id="使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用"><a href="#使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用" class="headerlink" title="使用 Weak&lt;T&gt; 替代 Rc&lt;T&gt; 来避免循环引用"></a>使用 <code>Weak&lt;T&gt;</code> 替代 <code>Rc&lt;T&gt;</code> 来避免循环引用</h4><p>调用 <code>Rc::clone</code> 会增加 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code> 引用计数，而 <code>Rc&lt;T&gt;</code> 实例只有在 <code>strong_count</code> 为 0 时才会被清理。<br>除此之外，我们还可以调用 <code>Rc::downgrade</code> 函数来创建 <code>Rc&lt;T&gt;</code> 实例中值的弱引用。使用 <code>Rc&lt;T&gt;</code> 的引用来调用 <code>Rc::downgrade</code> 会返回一个类型为 <code>Weak&lt;T&gt;</code> 的智能指针，这一操作会让 <code>Rc&lt;T&gt;</code> 的 <code>weak_count</code> 计数增加 1。<code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来记录当前存在多少个 <code>Weak&lt;T&gt;</code> 引用，但不会在执行清理操作前要求 <code>weak_count</code> 必须为 0。<br>强引用可以被用来共享一个 <code>Rc&lt;T&gt;</code> 实例的所有权，而弱引用则不会表达所有权关系。一旦强引用计数为 0，任何由弱引用组成的循环就会被打破。<strong>弱引用不会造成循环引用</strong>。<br>我们无法确定 <code>Weak&lt;T&gt;</code> 引用的值是否已经被释放，因此需要在使用 <code>Weak&lt;T&gt;</code> 指向的值之前确保它依然存在。可以调用 <code>Weak&lt;T&gt;</code> 实例的 <code>upgrade</code> 方法来完成这一验证。此函数返回的 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 会在 <code>Rc&lt;T&gt;</code> 值依然存在时表达为 <code>Some</code>，在 <code>Rc&lt;T&gt;</code> 值被释放时表达为 <code>None</code>。Rust 能够保证 <code>Some</code> 和 <code>None</code> 两个分支都得到妥善的处理，不会产生无效指针之类的问题。</p><h5 id="创建树状结构体：带有子节点的-Node"><a href="#创建树状结构体：带有子节点的-Node" class="headerlink" title="创建树状结构体：带有子节点的 Node"></a>创建树状结构体：带有子节点的 Node</h5><p>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们希望 Node 持有自身所有子节点并通过变量来共享它们的所有权，从而可以直接访问树中的每个 Node。因此将 <code>Vec&lt;T&gt;</code> 的元素定义为 <code>Rc&lt;Node&gt;</code> 类型的值。<br>我们还希望在 <code>children</code> 字段中使用 <code>RefCell&lt;T&gt;</code> 包裹 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 来实现内部可变性。<br>我们使用上述结构体定义一个值为 3 且没有子节点的 Node 实例，并将其作为叶子节点存入 <code>leaf</code> 变量。再定义一个值为 5 且将 <code>leaf</code> 作为子节点的 <code>branch</code> 实例。接着克隆 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 实例，并将其存入 <code>branch</code>。<br>此时我们可以使用 <code>branch.children</code> 来从 <code>branch</code> 访问 <code>leaf</code>，但是反之则不行。因为 <code>leaf</code> 并不持有 <code>branch</code> 的引用，它甚至对两个节点之间存在父子关系一无所知。</p><h5 id="增加子节点指向父节点的引用"><a href="#增加子节点指向父节点的引用" class="headerlink" title="增加子节点指向父节点的引用"></a>增加子节点指向父节点的引用</h5><p>为了让子节点意识到父节点的存在，可以为 <code>Node</code> 结构体添加一个 <code>parent</code> 字段。但 <code>parent</code> 的类型不能是 <code>Rc&lt;T&gt;</code>，会创建循环引用。<code>branch.children</code> 指向 <code>leaf</code> 的同时使 <code>leaf.parent</code> 指向 <code>branch</code> 会导致两者的 <code>strong_count</code> 都无法清零。</p><p>父节点自然拥有子节点的所有权，因为父节点被丢弃时，子节点也应该随之被丢弃；但子节点却不应该拥有父节点的所有权，即父节点的存在不会因为丢弃子节点而受到影响。<br>这恰好是使用弱引用的场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; leaf parent = None</span></span><br><span class="line"><span class="comment">// =&gt; leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>branch</code> 创建完毕后，我们通过 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 的 <code>borrow_mut</code> 方法取出 <code>leaf</code> 中 <code>parent</code> 字段的可变借用，再使用 <code>Rc::downgrade</code> 函数获取 <code>branch</code> 中 <code>Rc&lt;Node&gt;</code> 的 <code>Weak&lt;Node&gt;</code> 引用，将其存入 <code>leaf</code> 的 <code>parent</code> 字段中。<br>最后在打印 <code>leaf</code> 的父节点时，便可以看到一个包含了 <code>branch</code> 实际内容的 <code>Some</code> 变体，即表明 <code>leaf</code> 可以访问其父节点。另外，此时打印 <code>leaf</code> 还可以避免之前因循环引用导致的栈溢出故障，因为 <code>Weak&lt;Node&gt;</code> 引用会被直接打印为 <code>(Weak)</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;指针（pointer）&lt;/strong&gt;是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。&lt;br&gt;Rust 中最常见的指针是&lt;strong&gt;引用&lt;/strong&gt;，会&lt;strong&gt;借用&lt;/strong&gt;它所指向的数据。除此之
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="https://rollingstarky.github.io/tags/Ownership/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
      <category term="Heap" scheme="https://rollingstarky.github.io/tags/Heap/"/>
    
      <category term="Stack" scheme="https://rollingstarky.github.io/tags/Stack/"/>
    
      <category term="Borrow" scheme="https://rollingstarky.github.io/tags/Borrow/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——枚举类型</title>
    <link href="https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/"/>
    <id>https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/</id>
    <published>2021-07-12T16:00:00.000Z</published>
    <updated>2021-07-13T13:02:39.454Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类型（<strong>enum</strong>），通常也被简称为<strong>枚举</strong>，它允许我们列举所有可能的值来定义一个类型。<br>枚举搭配 <code>match</code> 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。<br>Rust 中的枚举更类似于 Haskell 这类函数式编程语言中的<strong>代数数据类型（ADT）</strong>。</p><h4 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h4><p>假设我们需要对 IP 地址进行处理。目前只有两种广泛被使用的 IP 地址标准：IPv4 和 IPv6。<br>我们只需要处理这两种情形，且一个地址要么是 IPv4，要么是 IPv6，因此可以使用枚举将所有可能的值（IPv4 和 IPv6）列举出来，作为一种新的数据类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>IpAddrKind</code> 就是一个可以在代码中随处使用的自定义数据类型了。</p><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>可以参照下面的代码使用 <code>IpAddrKind</code> 中的两个变体（<code>V4</code> 和 <code>V6</code>）创建实例：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure></p><p>由于 <code>IpAddrKind:V4</code> 和 <code>IpAddrKind:V6</code> 拥有相同的类型（都是 <code>IpAddrKind</code>），我们可以定义一个接收 <code>IpAddrKind</code> 类型参数的函数来统一处理它们：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_type: IpAddrKind) &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以使用任意一个变体来调用这个函数了：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route(IpAddrKind::V4);</span><br><span class="line">route(IpAddrKind::V6);</span><br></pre></td></tr></table></figure></p><p>当前定义的枚举类型 <code>IpAddrKind</code>，还只能区分 IP 地址的种类，没有办法去存储实际的 IP 地址数据。<br>可以使用结构体来解决这个问题：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际上，我们可以直接将枚举关联的数据嵌入其变体内，而不用像上面那样将枚举集成至结构体中。</p><p>下面的代码直接定义了 <code>IpAddr</code> 枚举，<code>V4</code> 和 <code>V6</code> 两个变体都被关联上了一个 String 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>我们直接将数据附加到枚举的每个变体中，就不需要额外地使用结构体了。</p><p>另外一个枚举替代结构体的优势在于，<strong>每个变体可以拥有不同类型和数量的关联数据，同时所有变体仍属于同一个枚举类型</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>参考下面代码中定义的一个 <code>Message</code> 枚举：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该枚举拥有 4 个内嵌了不同类型数据的变体：</p><ul><li>Quit 没有关联任何数据</li><li>Move 包含了一个匿名结构体</li><li>Write 包含了一个 String</li><li>ChangeColor 包含了 3 个 i32 值</li></ul><p>枚举有些类似于定义多个不同类型的结构体。但枚举除了不会使用 <code>struct</code> 关键字，还将变体们组合到了同一个 <code>Message</code> 类型中。<br>下面代码中的结构体可以存储与这些变体完全一样的数据：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuitMessage</span></span>; <span class="comment">// 空结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MoveMessage</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WriteMessage</span></span>(<span class="built_in">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeColorMessage</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure></p><p>两种实现方式的差别在于，如果使用了不同的结构体，则<strong>每个结构体都会拥有自己的类型</strong>，无法轻易定义一个统一处理这些类型的函数。而前面的 <strong><code>Message</code> 枚举是单独的一个类型</strong>。</p><p>正如我们可以用 <code>impl</code> 关键字定义结构体的方法一样，我们同样可以为 <code>Message</code> 定义自己的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法在这里定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Option-枚举及空值处理"><a href="#Option-枚举及空值处理" class="headerlink" title="Option 枚举及空值处理"></a>Option 枚举及空值处理</h4><p><code>Option</code> 是一种定义于标准库中的枚举类型，它描述了一种值可能不存在的情形。借助类型系统，编译器可以自动检查我们是否妥善地处理了所有应该被处理的情况。</p><p>Rust 没有像其他语言一样支持<strong>空值（Null）</strong>。空值本身是一个值，但它的含义却是没有值。<br>空值的问题在于，当你尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。由于空或非空的属性广泛散布在程序中，因此很难避免引起此类问题。<br>但空值本身所尝试表达的概念仍是有意义的，它代表了因为某种原因而变得无效或缺失的值。</p><p>Rust 中虽然没有空值，但提供了一个拥有类似概念的枚举 <code>Option&lt;T&gt;</code>，它可以用来标识一个值无效或缺失。<br><code>Option&lt;T&gt;</code> 在标准库中的定义如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Option&lt;T&gt;</code> 是一个普通的枚举类型，<code>Some&lt;T&gt;</code> 和 <code>None</code> 是该类型的变体。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></p><p>若使用 <code>None</code> 而不是 <code>Some</code> 变体来进行赋值，则需要明确声明这个 <code>Option&lt;T&gt;</code> 的具体类型，否则编译器无法进行类型推导。</p><p>当我们有了一个 <code>Some</code> 值时，就可以确定值是存在的，并且被 <code>Some</code> 所持有；当我们有了一个 <code>None</code> 值时，就知道当前并不存在一个有效的值。<br><code>Option&lt;T&gt;</code> 的设计相对于空值的优势在于，<strong><code>Option&lt;T&gt;</code> 和 <code>T</code> 是不同的类型，编译器不会允许我们像使用普通值一样直接去使用 <code>Option&lt;T&gt;</code> 的值</strong>。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = x + y;</span><br></pre></td></tr></table></figure></p><p>运行上述代码会导致编译器报错，因为 <code>i8</code> 和 <code>Option&lt;i8&gt;</code> 是不同的类型。<br>当我们持有的类型是 <code>i8</code> 时，编译器可以确保该值是有效的。但是<strong>当我们持有的类型是 <code>Option&lt;i8&gt;</code> 时，我们必须要考虑值不存在的情况，编译器会迫使我们在使用值之前正确地做出处理操作</strong>。</p><p><strong>为了持有一个可能为空的值，我们总是需要将其显式地放入对应类型的 <code>Option&lt;T&gt;</code> 值当中。当我们随后使用这个值时，也必须显式地处理它可能为空的情况</strong>。<br>即在处理 <code>Option&lt;T&gt;</code> 时，必须编写应对每个变体的代码。某些代码只会在持有 <code>Some(T)</code> 值时运行，它们可以使用变体中存储的 <code>T</code>；另外一些代码则只会在持有 <code>None</code> 值时运行，这些代码没有可用的 <code>T</code> 值。</p><p><code>match</code> 表达式就是一种可以用来处理 <code>Option&lt;T&gt;</code> 这类枚举的控制流结构。它允许我们基于枚举拥有的变体来决定运行的代码分支，并允许代码通过模式匹配来获取变体内的数据。</p><h4 id="控制流运算符-match"><a href="#控制流运算符-match" class="headerlink" title="控制流运算符 match"></a>控制流运算符 match</h4><p><code>match</code> 是 Rust 中一个强大的控制流运算符，它允许将一个值与一系列模式相比较，并根据匹配的模式执行相应的代码。这些模式可以由字面量、变量名、通配符及许多其他东西组成。</p><p>下面的代码会接收一个美国的硬币作为输入，确定硬币的类型并返回其分值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Dime;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(coin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 <code>match</code> 分支所关联的代码同时也是一个表达式，这个表达式运行的结果同时也会作为整个 <code>match</code> 表达式的结果返回。</p><h5 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h5><p>匹配分支还可以绑定匹配对象的部分值，这使得我们能够从枚举变体中提取特定的值。</p><p>比如美国的 25 美分硬币 50 个州采用了不同的设计。现在将这些信息添加至枚举中：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 方便打印输出默认不支持打印的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;."</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alaska = UsState::Alaska;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Quarter(alaska);</span><br><span class="line">    value_in_cents(coin);</span><br><span class="line">    <span class="comment">// =&gt; State quarter from Alaska.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们在模式中加入了一个名为 <code>state</code> 的变量用于匹配变体 <code>Coin::Quarter</code> 中的值。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 就会绑定到 25 美分所包含的值上。<br>比如代码中 <code>Coin::Quarter(UsState::Alaska)</code> 作为 <code>coin</code> 的值传入 <code>value_in_cents</code> 函数，最终值 <code>UsState::Alaska</code> 被绑定到变量 <code>state</code> 上。</p><h4 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 Option<t></t></h4><p>可以使用 <code>match</code> 表达式来处理 <code>Option&lt;T&gt;</code>，从 <code>Some</code> 中取出内部的 <code>T</code> 值。<br>比如编写一个接收 <code>Option&lt;i32&gt;</code> 的函数，若其中有值存在，则将这个值加 1；若其中不存在值，则直接返回 <code>None</code>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is None"</span>);</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is &#123;&#125;"</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="literal">Some</span>(i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">    <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<strong>匹配必须穷举所有的可能</strong>。尤其是 <code>Option&lt;T&gt;</code> 这个例子中，Rust 会强迫我们明确地处理值为 <code>None</code> 的情形。</p><h5 id="简单控制流-if-let"><a href="#简单控制流-if-let" class="headerlink" title="简单控制流 if let"></a>简单控制流 <code>if let</code></h5><p><code>if let</code> 能让我们通过一种不那么繁琐的语法结合使用 <code>if</code> 与 <code>let</code>，处理那些只关心某一种匹配而忽略其他匹配的情况。<br>下面的代码会匹配一个 <code>Option&lt;u32&gt;</code> 的值，并只在值为 3 时执行代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">match</span> some_number &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了满足 <code>match</code> 表达式<strong>穷尽性</strong>的要求，我们不得不在处理完 <code>Some(3)</code> 变体后额外加上一句 <code>_ =&gt; ()</code>。<br>可以使用 <code>if let</code> 以一种更简单的方式实现上述代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以在 <code>if let</code> 中搭配使用 <code>else</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"other number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举类型（&lt;strong&gt;enum&lt;/strong&gt;），通常也被简称为&lt;strong&gt;枚举&lt;/strong&gt;，它允许我们列举所有可能的值来定义一个类型。&lt;br&gt;枚举搭配 &lt;code&gt;match&lt;/code&gt; 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。&lt;br&gt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Enum" scheme="https://rollingstarky.github.io/tags/Enum/"/>
    
  </entry>
  
</feed>
