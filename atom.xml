<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2021-12-14T14:28:49.362Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 部署第一个应用</title>
    <link href="https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/"/>
    <id>https://rollingstarky.github.io/2021/12/14/kubernetes-in-action-reading-notes-deploying-first-application/</id>
    <published>2021-12-13T16:00:00.000Z</published>
    <updated>2021-12-14T14:28:49.362Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Minikube-amp-kubectl"><a href="#Minikube-amp-kubectl" class="headerlink" title="Minikube &amp; kubectl"></a>Minikube &amp; kubectl</h4><p><a href="https://github.com/kubernetes/minikube" target="_blank" rel="noopener">Minikube</a> 是一个能够在本地环境搭建 Kubernetes 集群的工具，支持 Windows、Linux 和 MacOS 等平台，由 Kubernetes 社区进行维护。<br>它通常在 Linux 虚拟机中运行 Kubernetes。如果宿主机是基于 Linux 的系统，也可以通过 Docker 实现。<br>即为了运行 Minikube，需要先安装 Hypervisor 比如 Virtualbox；对于 Linux 系统，也可以直接使用 Docker。</p><p>具体的安装配置步骤可以参考官方文档 <a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank" rel="noopener">Getting Started Guide</a>。</p><p>kubectl 是一个命令行工具，能够向 Kubernetes 集群发送命令并执行，支持的功能包括部署应用、查询和管理资源、查看日志等。<br>安装步骤可参考官方文档 <a href="https://kubernetes.io/docs/tasks/tools/" target="_blank" rel="noopener">Install Tools</a>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-cd8f312f56764487.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="kubectl"></p><h4 id="部署应用"><a href="#部署应用" class="headerlink" title="部署应用"></a>部署应用</h4><p>通常情况下，部署应用时要准备一个 JSON 或者 YAML 文件，里面包含对该应用的所有组件的描述信息，再把该描述文件应用到 Kubernetes 集群。<br>从演示的角度来看，也可以通过单行命令的方式部署简单的应用。</p><h5 id="创建-deployment"><a href="#创建-deployment" class="headerlink" title="创建 deployment"></a>创建 deployment</h5><p>可以使用 <code>kubectl create deployment</code> 命令部署应用。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl create deployment kubia --image=luksa/kubia:1.0</span></span><br><span class="line">deployment.apps/kubia created</span><br></pre></td></tr></table></figure></p><p>其中 <code>kubia</code> 表示创建的 <strong>deployment</strong> 对象的名称，<code>luksa/kubia:1.0</code> 指代需要使用的容器镜像。</p><p><code>kubia</code> 对象的存在告诉 Kubernetes <code>luksa/kubia:1.0</code> 容器必须运行在集群中。它定义了一种用户期待的状态，而 Kubernetes 负责确保实际的状态一定会满足该期望。</p><p><code>kubectl get deployment</code> 命令可以列出当前集群中存在的所有 deployment 对象及其状态。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deployment</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   0/1     1            0           5m17s</span><br></pre></td></tr></table></figure></p><h5 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h5><p>容器并不是 Kubernetes 中部署的最小单位。不同于直接部署独立的容器，Kubernetes 实际上会部署一组相互关联的容器，称为 <strong>pod</strong>。<br>pod 包含一组一个或一个以上关系密切的容器实例，同时运行在同一个工作节点上，并共享特定的 Linux 命名空间。<br>同一个 pod 中的容器共享相同的网络和 UTS 命名空间，因而共享同样的网络接口、IP 地址、端口空间和主机名等。也可以在描述文件中定义其他需要共享的命名空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8722b456a653d61a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pods"></p><p>每个 pod 都有自己的 IP、机器名、进程、网络接口以及其他资源。同一个 pod 中的容器都会将自己看作是 pod 中唯一运行的容器，它们并不能看到其他容器中的进程。</p><p>创建 Deployment 对象后就表示已经部署了 pod，Kubernetes 会基于 Deployment 对象创建一个或多个 pod。<br>可以使用 <code>kubectl get pods</code> 来列出系统中的 pod：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          41m</span><br></pre></td></tr></table></figure></p><p>如果某些 issue 导致 pod 运行失败，或者单纯想查看更多 pod 相关的信息，可以使用 <code>kubectl describe pod</code> 命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl describe pod</span></span><br><span class="line">Name:         kubia-767f9bc59d-77d2z</span><br><span class="line">Namespace:    default</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         minikube/192.168.49.2</span><br><span class="line">Start Time:   Tue, 14 Dec 2021 11:16:58 +0800</span><br><span class="line">Labels:       app=kubia</span><br><span class="line">              pod-template-hash=767f9bc59d</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           172.17.0.3</span><br><span class="line">IPs:</span><br><span class="line">  IP:           172.17.0.3</span><br><span class="line">Controlled By:  ReplicaSet/kubia-767f9bc59d</span><br><span class="line">Containers:</span><br><span class="line">  kubia:</span><br><span class="line">    Container ID:   docker://e9bd5cf8f2eb15959c08bc8f154742b7194030d8ce0f9e6290cd80fc21b48692</span><br><span class="line">    Image:          luksa/kubia:1.0</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia@sha256:a961dc8f377916936fa963508726d77cf77dcead5c97de7e5361f0875ba3bef7</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Tue, 14 Dec 2021 11:26:25 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-n9n9b (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  kube-api-access-n9n9b:</span><br><span class="line">    Type:                    Projected (a volume that contains injected data from multiple sources)</span><br><span class="line">    TokenExpirationSeconds:  3607</span><br><span class="line">    ConfigMapName:           kube-root-ca.crt</span><br><span class="line">    ConfigMapOptional:       &lt;nil&gt;</span><br><span class="line">    DownwardAPI:             true</span><br><span class="line">QoS Class:                   BestEffort</span><br><span class="line">Node-Selectors:              &lt;none&gt;</span><br><span class="line">Tolerations:                 node.kubernetes.io/not-ready:NoExecute op=Exists for 300s</span><br><span class="line">                             node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  11m   default-scheduler  Successfully assigned default/kubia-767f9bc59d-77d2z to minikube</span><br><span class="line">  Normal  Pulling    11m   kubelet            Pulling image "luksa/kubia:1.0"</span><br><span class="line">  Normal  Pulled     115s  kubelet            Successfully pulled image "luksa/kubia:1.0" in 9m24.3380576s</span><br><span class="line">  Normal  Created    113s  kubelet            Created container kubia</span><br><span class="line">  Normal  Started    113s  kubelet            Started container kubia</span><br></pre></td></tr></table></figure></p><p>输出的最后就包含 pod 创建和启动时触发的一系列事件（Events）。</p><h5 id="Pods-的创建流程"><a href="#Pods-的创建流程" class="headerlink" title="Pods 的创建流程"></a>Pods 的创建流程</h5><ul><li>运行 <code>kubectl create deployment</code> 命令，向 Kubernetes API Server 发送 HTTP 请求，创建一个新的 Deployment 对象</li><li>之后 Kubernetes 创建一个新的 Pod 对象，该 Pod 对象被分配给某个工作节点</li><li>工作节点上的 Kubelet agent 得知新的 Pod 对象被创建，且分配给了自己。于是 Kubelet 控制 Docker 拉取特定的镜像并创建、运行容器</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a4e1b15833234eb4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deployment object to a running container"></p><h4 id="向外部暴露应用"><a href="#向外部暴露应用" class="headerlink" title="向外部暴露应用"></a>向外部暴露应用</h4><p>应用已经成功运行了，接下来就是控制它如何被外部访问。每个 pod 都会获得一个专属的 IP 地址，但该地址是只有集群内部可见的。为了使 pod 能够从外部访问，还需要创建一个 <strong>Service</strong> 对象。</p><p>Service 对象有好几种类型，其中一种 LoadBalancer 会生成一个外部的负载均衡器，令服务能够从集群外部访问。<br>可以使用 <code>kubectl expose</code> 命令创建 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl expose deployment kubia --<span class="built_in">type</span>=LoadBalancer --port 8080</span></span><br><span class="line">service/kubia exposed</span><br></pre></td></tr></table></figure></p><p>使用 <code>kubectl get svc</code> 命令查看当前系统中存在的 Service：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get svc</span></span><br><span class="line">NAME         TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE</span><br><span class="line">kubernetes   ClusterIP      10.96.0.1       &lt;none&gt;        443/TCP          29d</span><br><span class="line">kubia        LoadBalancer   10.106.111.39   &lt;pending&gt;     8080:30077/TCP   2m28s</span><br></pre></td></tr></table></figure></p><p>创建 LoadBalancer 服务时，正常情况下 Kubernetes 会访问云服务提供商，令其创建负载均衡器并获取公共 IP。<br>Minikube 是本地模拟的集群环境，因而无法完成上述操作。kubia Service 的 EXTERNAL-IP 会一直处于 <pending> 状态。</pending></p><p>在没有获取到外部 IP 的情况下，minikube 可以使用下面的方法获取服务的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> minikube service kubia --url</span></span><br><span class="line">🏃  Starting tunnel for service kubia.</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| NAMESPACE | NAME  | TARGET PORT |          URL           |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">| default   | kubia |             | http://127.0.0.1:39529 |</span><br><span class="line">|-----------|-------|-------------|------------------------|</span><br><span class="line">http://127.0.0.1:39529</span><br><span class="line">❗  Because you are using a Docker driver on linux, the terminal needs to be open to run it.</span><br></pre></td></tr></table></figure></p><p>打开一个新的命令行窗口，可以成功访问上面的 url：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><h5 id="LoadBalancer-的创建流程"><a href="#LoadBalancer-的创建流程" class="headerlink" title="LoadBalancer 的创建流程"></a>LoadBalancer 的创建流程</h5><p><img src="https://upload-images.jianshu.io/upload_images/6875152-847957263408bbb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Service object to LoadBalancer"></p><h4 id="横向扩展应用"><a href="#横向扩展应用" class="headerlink" title="横向扩展应用"></a>横向扩展应用</h4><p>在容器中部署应用的一个主要好处就是，横向扩展应用变得非常简单和直观。<br>可以使用下列命令扩展 kubia 应用，令其同时运行 3 个实例副本。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl scale deployment kubia --replicas=3</span></span><br><span class="line">deployment.apps/kubia scaled</span><br><span class="line"><span class="meta">$</span><span class="bash"> kubectl get deploy</span></span><br><span class="line">NAME    READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">kubia   3/3     3            3           3h58m</span><br></pre></td></tr></table></figure></p><p>此时共有 3 个 pod 实例运行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          3h59m</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          3m56s</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          3m56s</span><br></pre></td></tr></table></figure></p><p>可以加上 <code>-o wide</code> 选项获取更详细的 pods 信息，比如 IP、运行的节点等：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP           NODE       NOMINATED NODE   READINESS GATES</span><br><span class="line">kubia-767f9bc59d-77d2z   1/1     Running   0          4h      172.17.0.3   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-rvsdq   1/1     Running   0          5m31s   172.17.0.5   minikube   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">kubia-767f9bc59d-sfn42   1/1     Running   0          5m31s   172.17.0.4   minikube   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure></p><p>再次访问 Service 的 URL，可以看到多次访问返回的信息并不一样，可以证实后台提供服务的 pod 并不是同一个，而是 3 个 pod 轮流接收请求并提供服务：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-77d2z. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-sfn42. Your IP is ::ffff:172.17.0.1.</span><br><span class="line"><span class="meta">$</span><span class="bash"> curl http://127.0.0.1:39529</span></span><br><span class="line">Hey there, this is kubia-767f9bc59d-rvsdq. Your IP is ::ffff:172.17.0.1.</span><br></pre></td></tr></table></figure></p><p>负载均衡架构示意图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2ec179df5ff6687c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Load balancing"></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>部署应用可以使用 <code>kubectl create deployment</code> 命令，暴露应用使用 <code>kubectl expose deployment</code> 命令，横向扩展应用使用 <code>kubectl scale deployment</code> 命令。</li><li>应用部署的基本单位不是容器而是 pod，一个 pod 可以包含一个或多个相互关联的容器。</li><li>Deployments、Services、Pods 和 Nodes 都是 Kubernetes 对象/资源。可以使用 <code>kubectl get</code> 命令获取这些对象的列表，或者使用 <code>kubectl describe</code> 命令获取对象的详细信息。</li><li>Deployment 对象负责部署指定数量的 pods。Services 对象则可以令这些 pods 能够通过一个单一的 IP 地址访问。</li><li>Service 在集群内部提供负载均衡。如果指定其类型为 LoadBalancer，则 Kubernetes 会请求云服务提供商令应用可以通过公共地址访问。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Minikube-amp-kubectl&quot;&gt;&lt;a href=&quot;#Minikube-amp-kubectl&quot; class=&quot;headerlink&quot; title=&quot;Minikube &amp;amp; kubectl&quot;&gt;&lt;/a&gt;Minikube &amp;amp; kubectl&lt;/
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="MicroService" scheme="https://rollingstarky.github.io/tags/MicroService/"/>
    
      <category term="Deployment" scheme="https://rollingstarky.github.io/tags/Deployment/"/>
    
      <category term="Cluster" scheme="https://rollingstarky.github.io/tags/Cluster/"/>
    
      <category term="LoadBalance" scheme="https://rollingstarky.github.io/tags/LoadBalance/"/>
    
  </entry>
  
  <entry>
    <title>Uncle Bob 的 SOLID 软件设计原则——Python 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/"/>
    <id>https://rollingstarky.github.io/2021/12/13/uncle-bob-SOLID-principles-in-python/</id>
    <published>2021-12-12T16:00:00.000Z</published>
    <updated>2021-12-13T15:27:42.347Z</updated>
    
    <content type="html"><![CDATA[<p>SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 <a href="https://en.wikipedia.org/wiki/Robert_C._Martin" target="_blank" rel="noopener">Robert C. Martin</a>（习惯上被称为 Uncle Bob）总结。可以帮助程序员写出更加灵活、容易理解、可维护性强、方便扩展的健壮代码。</p><ul><li>S 代表 <a href="https://en.wikipedia.org/wiki/Single-responsibility_principle" target="_blank" rel="noopener">Single Responsibility Principle (SRP)</a>，一个类应该只包含一种单一的职责，有且仅有一种原因能促使其变更。通俗点说，让一个类只做一件事。如果需要承担更多的工作，那么分解这个类。</li><li>O 代表 <a href="https://en.wikipedia.org/wiki/Open%E2%80%93closed_principle" target="_blank" rel="noopener">Open/Closed Principle (OCP)</a>，软件实体应该对扩展是开放的，同时对修改是封闭的。如果需要添加额外的功能，应该优先扩展某个类而不是修改它。</li><li>L 代表 <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle" target="_blank" rel="noopener">Liskov Substitution Principle (LSP)</a>，程序中的对象应该能够替换为其子类型的实例，仍不影响代码的正确性。</li><li>I 代表 <a href="https://en.wikipedia.org/wiki/Interface_segregation_principle" target="_blank" rel="noopener">Interface Segregation Principle (ISP)</a>，多个专门的基于客户端的接口要好于只有一个通用的接口。一个类对另一个类的依赖性应该建立在最小的接口上，客户端不应该被强迫实现一些他们不会使用的接口。</li><li>D 代表 <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" target="_blank" rel="noopener">Dependency Inversion Principle (DIP)</a>，抽象不应该依赖于细节，细节应当依赖于抽象。即要针对抽象（接口）编程，而不是针对实现细节编程。</li></ul><h4 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, payment_type, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> payment_type == <span class="string">"debit"</span>:</span><br><span class="line">            print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">elif</span> payment_type == <span class="string">"credit"</span>:</span><br><span class="line">            print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">            print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">            self.status = <span class="string">"paid"</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">f"Unknown payment type: <span class="subst">&#123;payment_type&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">order.pay(<span class="string">"debit"</span>, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure><p>上述 Python 代码实现了一个简单的“购物车”（订单）应用。</p><ul><li><code>add_item</code> 方法可以向订单中添加新的货物</li><li><code>total_price</code> 方法可以计算订单的总价</li><li><code>pay</code> 方法实现了订单的支付功能，支持借记卡、信用卡等支付方式</li></ul><h4 id="Single-Responsibility-Principle"><a href="#Single-Responsibility-Principle" class="headerlink" title="Single Responsibility Principle"></a>Single Responsibility Principle</h4><p>单一职能原则。<br>将支付功能从 <code>Order</code> 类中分离出来，在另一个 <code>PaymentProcessor</code> 类中实现。同时去掉 <code>pay</code> 方法中的 <code>if-else</code> 判断，分别用两个函数 <code>pay_debit</code> 和 <code>pay_credit</code> 实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_debit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_credit</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaymentProcessor()</span><br><span class="line">processor.pay_debit(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Open-Closed-Principle"><a href="#Open-Closed-Principle" class="headerlink" title="Open/Closed Principle"></a>Open/Closed Principle</h4><p>在最新的支付功能的实现中，如果我们需要添加一个新的支付方法（比如 PayPal），就必须修改 <code>PaymentProcessor</code> 类的原始代码。这就违反了 Open/Closed 原则，额外的功能应该通过扩展而不是修改原来的类来实现。<br>改进的方法是用一个基类（<code>PaymentProcessor</code>）来定义基本的支付逻辑，再通过子类（如 <code>DebitPaymentProcessor</code>）来实现具体的支付方法。这样每当添加一种新的支付方式，直接实现一个新的子类即可。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = DebitPaymentProcessor()</span><br><span class="line">processor.pay(order, <span class="string">"0372846"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="Liskov-Substitution-Principle"><a href="#Liskov-Substitution-Principle" class="headerlink" title="Liskov Substitution Principle"></a>Liskov Substitution Principle</h4><p>假设我们现在需要添加一种新的支付方式 <code>PayPalPaymentProcessor</code>，它在支付时并不依赖于 <code>security_code</code> 而是需要 <code>email_address</code> 进行验证。即 <code>pay</code> 方法的定义是 <code>pay(self, order, email_address)</code>，与基类中虚拟方法的签名冲突。<br>改进的方法是将 <code>pay</code> 方法依赖的参数 <code>security_code</code> 或 <code>email_address</code> 移动到支付类的 <code>__init__</code> 方法中，将基类和子类的 <code>pay</code> 方法签名都改为 <code>pay(self, order)</code>。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="Interface-Segregation-Principle"><a href="#Interface-Segregation-Principle" class="headerlink" title="Interface Segregation Principle"></a>Interface Segregation Principle</h4><p>假设我们需要在支付组件中添加一个验证短信的功能。直观的想法是直接在 <code>PaymentProcessor</code> 基类中添加一个 <code>auth_sms</code> 虚拟方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>对于需要验证短信的支付方式比如借记卡，改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>对于不需要短信验证的支付方式比如信用卡，就改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(</span><br><span class="line">            <span class="string">"Credit card payments don't support SMS code authorization."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br></pre></td></tr></table></figure></p><p>上述实现的问题在于，我们定义了一个通用的支付接口（<code>PaymentProcessor</code>），包含 <code>pay</code> 和 <code>auth_sms</code> 两种验证逻辑。但这两种逻辑并不总是被具体的支付方式（比如 <code>CreditPaymentProcessor</code>）所需要。<br>这违反了接口分离原则。即接口的实现应该依赖于具体的客户端（子类）需求，而不能不管客户端是否需要，就将所有的功能都放在一个胖接口中。<br>可以额外再实现一个 <code>PaymentProcessor_SMS</code> 基类来定义短信验证的逻辑，让不需要短信验证的支付方式继承 <code>PaymentProcessor</code> 基类，需要短信验证的支付方式继承 <code>PaymentProcessor_SMS</code> 基类。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor_SMS</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor_SMS)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">auth_sms</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying SMS code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.verified = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.verified:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">processor = PaypalPaymentProcessor(<span class="string">'hi@example.com'</span>)</span><br><span class="line">processor.auth_sms(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h5 id="Composition-over-Inheritance"><a href="#Composition-over-Inheritance" class="headerlink" title="Composition over Inheritance"></a>Composition over Inheritance</h5><p>在软件设计的大部分场景中，组合要优于继承。因为继承总是意味着更紧密的耦合性。<br>实际上短信认证并不一定通过继承来实现（<code>PaymentProcessor_SMS</code>），还可以通过组合来实现。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: SMSAuth)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = SMSAuth()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.verify_code(<span class="number">123456</span>)</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><p>定义一个 <code>SMS_Auth</code> 类来实现短信验证的逻辑，再通过组合的方式将其实例添加到具体的需要短信验证的支付方式中（比如 <code>DebitPaymentProcessor</code>）。</p><h4 id="Dependency-Inversion-Principle"><a href="#Dependency-Inversion-Principle" class="headerlink" title="Dependency Inversion Principle"></a>Dependency Inversion Principle</h4><p>细节应该依赖于抽象，而不是抽象依赖于细节。上述实现中就违反了这个原则。<br>比如借记卡支付方式（<code>DebitPaymentProcessor</code>）的 <code>__init__</code> 方法，签名是 <code>__init__(self, security_code, authorizer: SMSAuth)</code>。其中的 <code>SMSAuth</code> 是一个具体的短信验证类型，而不是一个通用的代表某种验证类型的抽象。<br>这样当支付方式需要的是另外一种验证方法（比如 <code>NotARobot</code>），这里的签名就需要修改。</p><p>可以创建一个 <code>Authorizer</code> 基类来代表通用的验证方式，具体的验证方式比如 <code>SMSAuth</code>、<code>NotARobot</code> 则作为 <code>Authorizer</code> 的子类来实现。<br>在支付方式的实现中，则使用 <code>Authorizer</code> 作为验证方式的类型定义。这样在使用支付类的实例时，就可以灵活地传入 <code>Authorizer</code> 的子类 <code>SMSAuth</code> 或者 <code>NotARobot</code> 进行组合。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span>:</span></span><br><span class="line">    items = []</span><br><span class="line">    quantities = []</span><br><span class="line">    prices = []</span><br><span class="line">    status = <span class="string">"open"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_item</span><span class="params">(self, name, quantity, price)</span>:</span></span><br><span class="line">        self.items.append(name)</span><br><span class="line">        self.quantities.append(quantity)</span><br><span class="line">        self.prices.append(price)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">total_price</span><span class="params">(self)</span>:</span></span><br><span class="line">        total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(self.prices)):</span><br><span class="line">            total += self.quantities[i] * self.prices[i]</span><br><span class="line">        <span class="keyword">return</span> total</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Authorizer</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SMSAuth</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">verify_code</span><span class="params">(self, code)</span>:</span></span><br><span class="line">        print(<span class="string">f"Verifying code <span class="subst">&#123;code&#125;</span>"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotARobot</span><span class="params">(Authorizer)</span>:</span></span><br><span class="line">    authorized = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">not_a_robot</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Are you a robot? Naa"</span>)</span><br><span class="line">        self.authorized = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">is_authorized</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.authorized</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaymentProcessor</span><span class="params">(ABC)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebitPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line">        self.verified = <span class="keyword">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing debit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;self.security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreditPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, security_code)</span>:</span></span><br><span class="line">        self.security_code = security_code</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order, security_code)</span>:</span></span><br><span class="line">        print(<span class="string">"Processing credit payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying security code: <span class="subst">&#123;security_code&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PaypalPaymentProcessor</span><span class="params">(PaymentProcessor)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email_address, authorizer: Authorizer)</span>:</span></span><br><span class="line">        self.email_address = email_address</span><br><span class="line">        self.authorizer = authorizer</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, order)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.authorizer.is_authorized():</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">"Not authorized"</span>)</span><br><span class="line">        print(<span class="string">"Processing paypal payment type"</span>)</span><br><span class="line">        print(<span class="string">f"Verifying email address: <span class="subst">&#123;self.email_address&#125;</span>"</span>)</span><br><span class="line">        order.status = <span class="string">"paid"</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">order = Order()</span><br><span class="line">order.add_item(<span class="string">"Keyborad"</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">order.add_item(<span class="string">"SSD"</span>, <span class="number">1</span>, <span class="number">150</span>)</span><br><span class="line">order.add_item(<span class="string">"USB cable"</span>, <span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(order.total_price())</span><br><span class="line">authorizer = NotARobot()</span><br><span class="line">processor = DebitPaymentProcessor(<span class="string">'0372846'</span>, authorizer)</span><br><span class="line">authorizer.not_a_robot()</span><br><span class="line">processor.pay(order)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=pTB30aXS77U" target="_blank" rel="noopener">Uncle Bob’s SOLID principles made easy 🍀 - in Python!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SOLID 是 5 种软件设计原则的首字母缩写，由美国的软件工程师 &lt;a href=&quot;https://en.wikipedia.org/wiki/Robert_C._Martin&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Robert C. Marti
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Interface" scheme="https://rollingstarky.github.io/tags/Interface/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Principle" scheme="https://rollingstarky.github.io/tags/Principle/"/>
    
      <category term="SOLID" scheme="https://rollingstarky.github.io/tags/SOLID/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Dependency" scheme="https://rollingstarky.github.io/tags/Dependency/"/>
    
  </entry>
  
  <entry>
    <title>Linux xargs 命令解析</title>
    <link href="https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/"/>
    <id>https://rollingstarky.github.io/2021/12/09/linux-xargs-usage-and-examples/</id>
    <published>2021-12-08T16:00:00.000Z</published>
    <updated>2021-12-09T12:37:35.469Z</updated>
    
    <content type="html"><![CDATA[<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p><code>xargs</code> 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并执行。<br><code>xargs</code> 可以帮助 <code>echo</code>、<code>rm</code>、<code>mkdir</code> 等命令接收标准输入作为参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> xargs mkdir</span></span><br><span class="line">test1 test2</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2</span><br></pre></td></tr></table></figure><p>比如执行 <code>xargs mkdir</code> 命令，输入 <code>test1 test2</code> 后回车，再按 <code>CTRL-D</code> 结束输入，等效于直接执行 <code>mkdir test1 test2</code> 命令。<br>即 <code>xarg</code> 读取了标准输入中的 <code>test1 test2</code>，并将它们作为参数传递给 <code>mkdir</code> 命令，组合成一个完整的 <code>mkdir test1 test2</code> 命令并执行。</p><p>实际上 <code>xargs</code> 很少用在上述交互式场景中，更多的是搭配管道符 <code>|</code>，通过前一个命令的输出构建新的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test3 test4 test5 | xargs mkdir</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">test1  test2  test3  test4  test5</span><br></pre></td></tr></table></figure><p><code>|</code> 和 <code>| xargs</code> 的区别：</p><ul><li>管道符 <code>|</code> 是将左边命令的输出结果作为右边命令的输入值</li><li><code>| xargs</code> 则可以将左边命令的输出结果作为右边命令的参数选项</li></ul><h4 id="find-与-xargs"><a href="#find-与-xargs" class="headerlink" title="find 与 xargs"></a>find 与 xargs</h4><p><code>xargs</code> 最常见的搭配应该就是 <code>find</code> 命令了。即通过 <code>find</code> 查找特定的文件或目录，再将结果传递给 <code>xargs</code>，对找到的结果执行特定的操作。</p><p>如删除 <code>/tmp</code> 路径下最近两周内未做改动的文件：<br><code>find /tmp -type f -mtime +14 | xargs rm</code></p><p>有一点特别需要注意：默认情况下，<code>xargs</code> 从标准输入读取命令参数时，会以空格作为分隔符来识别多个选项。<br>而文件和目录的名字有时候也会包含空格，导致一个文件名被 <code>xargs</code> 识别为两个参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> mkdir <span class="built_in">test</span>\ 6</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'   test1   test2   test3   test4   test5</span><br><span class="line"><span class="meta">$</span><span class="bash"> find . -<span class="built_in">type</span> d | xargs rmdir</span></span><br><span class="line">rmdir: failed to remove './test': No such file or directory</span><br><span class="line">rmdir: failed to remove '6': No such file or directory</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">'test 6'</span><br></pre></td></tr></table></figure><p>更安全一点的做法是使用 <code>-0</code> 选项。<code>-0</code> 选项可以指定 <code>xargs</code> 在读取标准输入时使用 <code>null</code> 作为分隔符。而 <code>find</code> 命令的 <code>-print0</code> 选项同样可以将输出指定为使用 <code>null</code> 进行分割。</p><p>即将前面的命令替换为 <strong><code>find . -type d -print0 | xargs -0 rmdir</code></strong>。</p><h5 id="find-搭配-exec-选项和搭配-xargs-命令的区别"><a href="#find-搭配-exec-选项和搭配-xargs-命令的区别" class="headerlink" title="find 搭配 -exec 选项和搭配 xargs 命令的区别"></a>find 搭配 <code>-exec</code> 选项和搭配 xargs 命令的区别</h5><p><code>find</code> 命令可以使用其 <code>-exec</code> 选项对查找到的结果执行特定的操作。同样的需求 <code>xargs</code> 也可以实现。</p><p>比如需要删除当前目录下所有的 TXT 文件：</p><ul><li>使用 <code>-exec</code>：<code>find . -type f -name &quot;*.txt&quot; -exec rm {} \;</code></li><li>使用 <code>xargs</code>：<code>find . -type f -name &quot;*.txt&quot; | xargs rm</code></li></ul><p>实际上两者的执行效率存在着很大的差距。<br>比如使用 <code>for i in {1..100}; do touch $i.txt; done</code> 命令创建 100 个 TXT 文件，再分别使用上述两个命令删除这些文件（用 <code>time</code> 命令计时），具体的效率如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">1.txt    18.txt  27.txt  36.txt  45.txt  54.txt  63.txt  72.txt  81.txt  90.txt</span><br><span class="line">10.txt   19.txt  28.txt  37.txt  46.txt  55.txt  64.txt  73.txt  82.txt  91.txt</span><br><span class="line">100.txt  2.txt   29.txt  38.txt  47.txt  56.txt  65.txt  74.txt  83.txt  92.txt</span><br><span class="line">11.txt   20.txt  3.txt   39.txt  48.txt  57.txt  66.txt  75.txt  84.txt  93.txt</span><br><span class="line">12.txt   21.txt  30.txt  4.txt   49.txt  58.txt  67.txt  76.txt  85.txt  94.txt</span><br><span class="line">13.txt   22.txt  31.txt  40.txt  5.txt   59.txt  68.txt  77.txt  86.txt  95.txt</span><br><span class="line">14.txt   23.txt  32.txt  41.txt  50.txt  6.txt   69.txt  78.txt  87.txt  96.txt</span><br><span class="line">15.txt   24.txt  33.txt  42.txt  51.txt  60.txt  7.txt   79.txt  88.txt  97.txt</span><br><span class="line">16.txt   25.txt  34.txt  43.txt  52.txt  61.txt  70.txt  8.txt   89.txt  98.txt</span><br><span class="line">17.txt   26.txt  35.txt  44.txt  53.txt  62.txt  71.txt  80.txt  9.txt   99.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> -<span class="built_in">exec</span> rm &#123;&#125; \;</span></span><br><span class="line">find . -type f -name "*.txt" -exec rm &#123;&#125; \;  0.05s user 0.02s system 104% cpu 0.060 total</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..100&#125;; <span class="keyword">do</span> touch <span class="variable">$i</span>.txt; <span class="keyword">done</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> time find . -<span class="built_in">type</span> f -name <span class="string">"*.txt"</span> | xargs rm</span></span><br><span class="line">find . -type f -name "*.txt"  0.00s user 0.00s system 80% cpu 0.001 total</span><br><span class="line">xargs rm  0.00s user 0.00s system 94% cpu 0.003 total</span><br></pre></td></tr></table></figure></p><p>前者是 0.06，后者是 0.004。使用 <code>xargs</code> 的执行效率更高。</p><h4 id="输出执行的命令"><a href="#输出执行的命令" class="headerlink" title="输出执行的命令"></a>输出执行的命令</h4><p><code>-t</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印到终端窗口中。方便对脚本进行调试。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> test1 test2 test3 | xargs -t mkdir</span></span><br><span class="line">mkdir test1 test2 test3</span><br></pre></td></tr></table></figure></p><h4 id="输出命令并提示用户确认"><a href="#输出命令并提示用户确认" class="headerlink" title="输出命令并提示用户确认"></a>输出命令并提示用户确认</h4><p><code>-p</code> 选项可以把 <code>xargs</code> 拼接后执行的命令打印出来，并等待用户进行确认。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls | xargs -p rmdir</span></span><br><span class="line">rmdir test1 test2 test3 ?...y</span><br></pre></td></tr></table></figure></p><h4 id="执行多个命令"><a href="#执行多个命令" class="headerlink" title="执行多个命令"></a>执行多个命令</h4><p>借助 <code>-I</code> 选项可以令 <code>xargs</code> 同时执行多个命令。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt</span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> cat foo.txt | xargs -I % sh -c <span class="string">'echo %; mkdir %'</span></span></span><br><span class="line">one</span><br><span class="line">two</span><br><span class="line">three</span><br><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">foo.txt  one  three  two</span><br></pre></td></tr></table></figure></p><h4 id="常用实例"><a href="#常用实例" class="headerlink" title="常用实例"></a>常用实例</h4><p><strong>查找当前路径下所有的 PNG 图片并将它们归档到 <code>images.tar.gz</code> 压缩包中</strong>：<br><code>$ find . -name &quot;*.png&quot; -type f -print0 | xargs -0 tar -cvzf images.tar.gz</code></p><p><strong>获取当前系统中所有用户的用户名，以单行列表的形式输出</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cut -d: -f1 &lt; /etc/passwd | sort | xargs <span class="built_in">echo</span></span></span><br><span class="line">_apt backup bin daemon games gnats irc landscape list lp mail man messagebus news nobody pollinate postgres proxy root sshd starky sync sys syslog systemd-network systemd-resolve systemd-timesync tcpdump tss uucp uuidd www-data</span><br></pre></td></tr></table></figure></p><p><strong>删除当前路径下名为 <code>no_use</code> 的文件</strong>：<br><code>$ find . -name &quot;no_use&quot; -type f -print0 | xargs -0 rm -v -f</code></p><p><strong>复制一个文件到多个路径下</strong>：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls</span></span><br><span class="line">dest1  dest2  test_file</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 cp -v ./test_file</span></span><br><span class="line">'./test_file' -&gt; './dest1/test_file'</span><br><span class="line">'./test_file' -&gt; './dest2/test_file'</span><br></pre></td></tr></table></figure></p><p>上面例子中 <code>xargs</code> 的 <code>-n 1</code> 选项非常重要。<code>-n</code> 选项用于指定 <code>xargs</code> 在将标准输入作为参数与命令拼接在一起时，参数的最大长度。</p><p>简单来说，当 <code>-n</code> 为 1 时，标准输入中以空格分割的每一项都与命令进行拼接，最终形成多条命令；当不存在 <code>-n 1</code> 时，标准输入中以空格分割的所有参数项直接与命令进行拼接，形成一条命令并执行。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -n 1 -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/</span><br><span class="line">cp ./test_file ./dest2/</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> ./dest1/ ./dest2/ | xargs -t cp ./test_file</span></span><br><span class="line">cp ./test_file ./dest1/ ./dest2/</span><br><span class="line">cp: -r not specified; omitting directory './dest1/'</span><br></pre></td></tr></table></figure></p><ul><li><code>echo ./dest1/ ./dest2/ | xargs -n 1 cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/</code> 和 <code>cp ./test_file ./dest2/</code> 两条命令</li><li><code>echo ./dest1/ ./dest2/ | xargs cp ./test_file</code> 等效于 <code>cp ./test_file ./dest1/ ./dest2/</code> 一条命令（语法是错的）</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://shapeshed.com/unix-xargs/" target="_blank" rel="noopener">Linux and Unix xargs command tutorial with examples</a><br><a href="https://www.tecmint.com/xargs-command-examples/" target="_blank" rel="noopener">12 Practical Examples of Linux Xargs Command for Beginners</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h4&gt;&lt;p&gt;&lt;code&gt;xargs&lt;/code&gt; 是 Linux 系统中的一个命令行工具，它可以读取标准输入并将其作为参数构建新的命令并
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Script" scheme="https://rollingstarky.github.io/tags/Script/"/>
    
      <category term="Xargs" scheme="https://rollingstarky.github.io/tags/Xargs/"/>
    
      <category term="Administration" scheme="https://rollingstarky.github.io/tags/Administration/"/>
    
      <category term="Find" scheme="https://rollingstarky.github.io/tags/Find/"/>
    
  </entry>
  
  <entry>
    <title>Python code smells 实例讲解</title>
    <link href="https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/"/>
    <id>https://rollingstarky.github.io/2021/12/06/7-python-code-smells-by-practical-example/</id>
    <published>2021-12-05T16:00:00.000Z</published>
    <updated>2021-12-06T15:38:09.787Z</updated>
    
    <content type="html"><![CDATA[<p><strong>code smells</strong> 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。<br>很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够健壮等问题。</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: str</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self, payout: bool)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday, or pay out 5 holidays."""</span></span><br><span class="line">        <span class="keyword">if</span> payout:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                            Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">                )</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">                print(</span><br><span class="line">                    <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">            <span class="keyword">except</span> Exception:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">raise</span> ValueError(</span><br><span class="line">                    <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">                )</span><br><span class="line">            self.vacation_days -= <span class="number">1</span></span><br><span class="line">            print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        managers = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"manager"</span>:</span><br><span class="line">                managers.append(employee)</span><br><span class="line">        <span class="keyword">return</span> managers</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_vice_presidents</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        vice_presidents = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"president"</span>:</span><br><span class="line">                vice_presidents.append(employee)</span><br><span class="line">        <span class="keyword">return</span> vice_presidents</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_interns</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">        interns = []</span><br><span class="line">        <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">            <span class="keyword">if</span> employee.role == <span class="string">"intern"</span>:</span><br><span class="line">                interns.append(employee)</span><br><span class="line">        <span class="keyword">return</span> interns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                            $<span class="subst">&#123;employee.hourly_rate&#125;</span> for <span class="subst">&#123;employee.amount&#125;</span> hours."</span></span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br><span class="line">    print(company.find_vice_presidents())</span><br><span class="line">    print(company.find_managers())</span><br><span class="line">    print(company.find_interns())</span><br><span class="line">    company.pay_employee(company.employees[<span class="number">0</span>])</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday(<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><p>上述代码实现了一个简单的“员工管理系统”。</p><ul><li>Employee 类代表公司里的员工，有姓名、角色、假期等属性。可以请假（<code>take_a_holiday</code>），或者单独请一天，或者以 5 天为单位将假期兑换为报酬</li><li>HourlyEmployee 和 MonthlyEmployee 分别代表以时薪或者月薪来计算工资的员工</li><li>Company 类代表公司，可以招收员工（<code>add_employee</code>）、返回特定角色的员工列表（如 <code>find_managers</code>）、发放薪资等（<code>pay_employee</code>）</li></ul><h4 id="code-smells"><a href="#code-smells" class="headerlink" title="code smells"></a>code smells</h4><p>上面的代码中存在着很多可以改进的地方。</p><h5 id="用-Enum-类型替代-str-作为员工的-role-属性"><a href="#用-Enum-类型替代-str-作为员工的-role-属性" class="headerlink" title="用 Enum 类型替代 str 作为员工的 role 属性"></a>用 Enum 类型替代 str 作为员工的 role 属性</h5><p>上面的 <code>Employee</code> 类使用了 <code>str</code> 类型来存储 <code>role</code> 属性的值，比如用 <code>&quot;manager&quot;</code> 代表经理，用 <code>&quot;intern&quot;</code> 代表实习生。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=<span class="string">"manager"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=<span class="string">"president"</span>))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=<span class="string">"intern"</span>))</span><br></pre></td></tr></table></figure></p><p>实际上 String 过于灵活，可以拥有任何含义，用来表示角色属性时不具有足够清晰的指向性。不同的拼写规则和大小写习惯都会导致出现错误的指向，比如 <code>&quot;Manager&quot;</code> 和 <code>&quot;manager&quot;</code>，<code>&quot;vice-president&quot;</code> 和 <code>&quot;vice_president&quot;</code>。<br>可以使用 Enum 替代 str。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br></pre></td></tr></table></figure></p><p>修改 <code>Employee</code> 类中 <code>role</code> 属性的定义：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br></pre></td></tr></table></figure></p><p><code>Company</code> 类中 <code>find_managers</code> 等方法也做相应的修改：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_managers</span><span class="params">(self)</span> -&gt; List[Employee]:</span></span><br><span class="line">    managers = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == Role.MANAGER:</span><br><span class="line">            managers.append(employee)</span><br><span class="line">    <span class="keyword">return</span> managers</span><br></pre></td></tr></table></figure></p><p><code>main</code> 方法中使用新的 role 创建员工对象：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="消除重复代码"><a href="#消除重复代码" class="headerlink" title="消除重复代码"></a>消除重复代码</h5><p><code>Company</code> 类中有一个功能是返回特定角色的员工列表，即 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 三个方法。<br>这三个方法实际上有着同样的逻辑，却分散在了三个不同的函数里。可以合并成一个方法来消除重复代码。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line">    employees = []</span><br><span class="line">    <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees:</span><br><span class="line">        <span class="keyword">if</span> employee.role == role:</span><br><span class="line">            employees.append(employee)</span><br><span class="line">    <span class="keyword">return</span> employees</span><br></pre></td></tr></table></figure></p><p>同时将 <code>main</code> 函数中的 <code>find_managers</code>、<code>find_vice_presidents</code>、<code>find_interns</code> 都改为如下形式：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">print(company.find_employees(Role.MANAGER))</span><br><span class="line">print(company.find_employees(Role.INTERN))</span><br></pre></td></tr></table></figure></p><h5 id="尽量使用内置函数"><a href="#尽量使用内置函数" class="headerlink" title="尽量使用内置函数"></a>尽量使用内置函数</h5><p>上面版本中的 <code>find_employees</code> 方法，包含了一个 <code>for</code> 循环。实际上该部分逻辑可以使用 Python 内置的<strong>列表推导</strong>来实现。<br>合理的使用 Python 内置函数可以使代码更短、更直观，同时内置函数针对很多场景在性能上也做了一定的优化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">    <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br></pre></td></tr></table></figure></p><h5 id="更清晰明确的变量名"><a href="#更清晰明确的变量名" class="headerlink" title="更清晰明确的变量名"></a>更清晰明确的变量名</h5><p>旧版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate: float = <span class="number">50</span></span><br><span class="line">    amount: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><p>新版本：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br></pre></td></tr></table></figure></p><h5 id="isinstance"><a href="#isinstance" class="headerlink" title="isinstance"></a>isinstance</h5><p>当你在代码的任何地方看到 <code>isinstance</code> 这个函数时，都需要特别地加以关注。它意味着代码中有可能存在某些有待提升的设计。</p><p>比如代码中的 <code>pay_employee</code> 函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pay_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> isinstance(employee, SalariedEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a monthly salary of $<span class="subst">&#123;employee.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line">    <span class="keyword">elif</span> isinstance(employee, HourlyEmployee):</span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;employee.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                        $<span class="subst">&#123;employee.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;employee.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>这里 <code>isinstance</code> 的使用，实际上在 <code>pay_employee</code> 函数中引入了对 <code>Employee</code> 的子类的依赖。这种依赖导致各部分代码之间的职责划分不够清晰，耦合性变强。<br><code>pay_employee</code> 方法需要与 <code>Employee</code> 的子类的具体实现保持同步。每新增一个新的员工类型（<code>Employee</code> 的子类），此方法中的 <code>if-else</code> 也就必须再新增一个分支。即需要同时改动不同位置的两部分代码。</p><p>可以将 <code>pay_employee</code> 的实现从 <code>Company</code> 类转移到具体的 <code>Employee</code> 子类中。即特定类型的员工拥有对应的报酬支付方法，公司在发薪时只需要调用对应员工的 <code>pay</code> 方法，无需实现自己的<code>pay_employee</code> 方法。<br>由 <code>isinstance</code> 引入的依赖关系从而被移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">@dataclass</span><br><span class="line">class HourlyEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot; Employee that&apos;s paid based on number of worked hours.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = 50</span><br><span class="line">    hours_worked: int = 10</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a hourly rate of \</span><br><span class="line">                    $&#123;self.hourly_rate_dollars&#125; for &#123;self.hours_worked&#125; hours.&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@dataclass</span><br><span class="line">class SalariedEmployee(Employee):</span><br><span class="line">    &quot;&quot;&quot;Employee that&apos;s paid based on a fixed monthly salary.&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    monthly_salary: float = 5000</span><br><span class="line"></span><br><span class="line">    def pay(self):</span><br><span class="line">        print(</span><br><span class="line">            f&quot;Paying employee &#123;self.name&#125; a monthly salary of $&#123;self.monthly_salary&#125;&quot;</span><br><span class="line">        )</span><br></pre></td></tr></table></figure></p><p>再把 <code>main</code> 函数中的 <code>company.pay_employee(company.employees[0])</code> 改为 <code>company.employees[0].pay()</code>。</p><p>由于每一个特定的 <code>Employee</code> 子类都需要实现 <code>pay</code> 方法，更好的方式是将 <code>Employee</code> 实现为虚拟基类，<code>pay</code> 成为子类必须实现的虚拟方法。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br></pre></td></tr></table></figure></p><h5 id="Bool-flag"><a href="#Bool-flag" class="headerlink" title="Bool flag"></a>Bool flag</h5><p><code>Employee</code> 类中的 <code>take_a_holiday</code> 方法有一个名为 <code>payout</code> 的参数。它是布尔类型，作为一个开关，来决定某个员工是请一天假，还是以 5 天为单位将假期兑换为报酬。<br>这个开关实际上导致了 <code>take_a_holiday</code> 方法包含了两种不同的职责，只通过一个布尔值来决定具体执行哪一个。</p><p><strong>函数原本的目的就是职责的分离</strong>。使得同一个代码块中不会包含过多不同类型的任务。<br>因此 <code>take_a_holiday</code> 方法最好分割成两个不同的方法，分别应对不同的休假方式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">"You don't have any holidays left. Now back to work, you!"</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(</span><br><span class="line">                <span class="string">f"You don't have enough holidays left over for a payout. \</span></span><br><span class="line"><span class="string">                        Remaining holidays: <span class="subst">&#123;self.vacation_days&#125;</span>"</span></span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">            print(</span><br><span class="line">                <span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception:</span><br><span class="line">            <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><h5 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h5><p><code>payout_a_holiday</code> 方法中有一步 <code>try-except</code> 代码。但该部分代码实际上对 Exception 没有做任何事。对于 Exception 而言：</p><p><strong>如果需要 catch Exception，就 catch 特定类型的某个 Exception，并对其进行处理；如果不会对该 Exception 做任何处理，就不要 catch 它</strong>。</p><p>在此处使用 <code>try-except</code> 会阻止异常向外抛出，导致外部代码在调用 <code>payout_a_holiday</code> 时获取不到异常信息。此外，使用 <code>Exception</code> 而不是某个特定类型的异常，会导致所有的异常信息都被屏蔽掉，包括语法错误、键盘中断等。<br>因此，去掉上述代码中的 <code>try-except</code>。</p><h5 id="使用自定义-Exception-替代-ValueError"><a href="#使用自定义-Exception-替代-ValueError" class="headerlink" title="使用自定义 Exception 替代 ValueError"></a>使用自定义 Exception 替代 ValueError</h5><p><code>ValueError</code> 是 Python 内置的在内部出现值错误时抛出的异常，并不适合用在自定义的场景中。最好在代码中定义自己的异常类型。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">        <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">            requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">            remaining_days=self.vacation_days,</span><br><span class="line">            message=<span class="string">"You don't have enough holidays left over for a payout."</span>)</span><br><span class="line">    self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">    print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br></pre></td></tr></table></figure><h4 id="最终版本"><a href="#最终版本" class="headerlink" title="最终版本"></a>最终版本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Very advanced Employee management system.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> List</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, auto</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="comment"># The fixed number of vacation days that can be paid out.</span></span><br><span class="line">FIXED_VACATION_DAYS_PAYOUT = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VacationDaysShortageError</span><span class="params">(Exception)</span>:</span></span><br><span class="line">    <span class="string">"""Custom error that is raised when not enough vacation days available."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, requested_days: int, remaining_days: int, message: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.requested_days = requested_days</span><br><span class="line">        self.remaining_days = remaining_days</span><br><span class="line">        self.message = message</span><br><span class="line">        super().__init__(message)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Role</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    <span class="string">"""Employee roles."""</span></span><br><span class="line">    PRESIDENT = auto()</span><br><span class="line">    VICEPRESIDENT = auto()</span><br><span class="line">    MANAGER = auto()</span><br><span class="line">    LEAD = auto()</span><br><span class="line">    WORKER = auto()</span><br><span class="line">    INTERN = auto()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span><span class="params">(ABC)</span>:</span></span><br><span class="line">    <span class="string">"""Basic representation of an employee at the company"""</span></span><br><span class="line"></span><br><span class="line">    name: str</span><br><span class="line">    role: Role</span><br><span class="line">    vacation_days: int = <span class="number">25</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">take_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee take a single holiday."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=<span class="number">1</span>,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have any holidays left. Now back to work, you!"</span>)</span><br><span class="line">        self.vacation_days -= <span class="number">1</span></span><br><span class="line">        print(<span class="string">"Have fun on your holiday. Don't forget to check your emails!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">payout_a_holiday</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Let the employee get paid for unused holidays."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.vacation_days &lt; FIXED_VACATION_DAYS_PAYOUT:</span><br><span class="line">            <span class="keyword">raise</span> VacationDaysShortageError(</span><br><span class="line">                requested_days=FIXED_VACATION_DAYS_PAYOUT,</span><br><span class="line">                remaining_days=self.vacation_days,</span><br><span class="line">                message=<span class="string">"You don't have enough holidays left over for a payout."</span></span><br><span class="line">            )</span><br><span class="line">        self.vacation_days -= FIXED_VACATION_DAYS_PAYOUT</span><br><span class="line">        print(<span class="string">f"Paying out a holiday. Holidays left: <span class="subst">&#123;self.vacation_days&#125;</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""Method to call when paying an employee"""</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HourlyEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">""" Employee that's paid based on number of worked hours."""</span></span><br><span class="line"></span><br><span class="line">    hourly_rate_dollars: float = <span class="number">50</span></span><br><span class="line">    hours_worked: int = <span class="number">10</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a hourly rate of \</span></span><br><span class="line"><span class="string">                    $<span class="subst">&#123;self.hourly_rate_dollars&#125;</span> for <span class="subst">&#123;self.hours_worked&#125;</span> hours."</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SalariedEmployee</span><span class="params">(Employee)</span>:</span></span><br><span class="line">    <span class="string">"""Employee that's paid based on a fixed monthly salary."""</span></span><br><span class="line"></span><br><span class="line">    monthly_salary: float = <span class="number">5000</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(</span><br><span class="line">            <span class="string">f"Paying employee <span class="subst">&#123;self.name&#125;</span> a monthly salary of $<span class="subst">&#123;self.monthly_salary&#125;</span>"</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Company</span>:</span></span><br><span class="line">    <span class="string">"""Represents a company with employees."""</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees: List[Employee] = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_employee</span><span class="params">(self, employee: Employee)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.employees.append(employee)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">find_employees</span><span class="params">(self, role: Role)</span> -&gt; List[Employee]:</span></span><br><span class="line">        <span class="string">"""Find all employees with a particular role."""</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> [employee <span class="keyword">for</span> employee <span class="keyword">in</span> self.employees <span class="keyword">if</span> employee.role <span class="keyword">is</span> role]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    company = Company()</span><br><span class="line">    company.add_employee(SalariedEmployee(name=<span class="string">"Louis"</span>, role=Role.MANAGER))</span><br><span class="line">    company.add_employee(HourlyEmployee(</span><br><span class="line">        name=<span class="string">"Brenda"</span>, role=Role.VICEPRESIDENT))</span><br><span class="line">    company.add_employee(HourlyEmployee(name=<span class="string">"Tim"</span>, role=Role.INTERN))</span><br><span class="line">    print(company.find_employees(Role.VICEPRESIDENT))</span><br><span class="line">    print(company.find_employees(Role.MANAGER))</span><br><span class="line">    print(company.find_employees(Role.INTERN))</span><br><span class="line">    company.employees[<span class="number">0</span>].pay()</span><br><span class="line">    company.employees[<span class="number">0</span>].take_a_holiday()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.youtube.com/watch?v=LrtnLEkOwFE" target="_blank" rel="noopener">7 Python Code Smells: Olfactory Offenses To Avoid At All Costs</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;code smells&lt;/strong&gt; 可以理解为代码中让人感觉到不舒服的地方。可能是代码规范问题，也可能是设计上的缺陷。&lt;br&gt;很多时候一段代码符合基本逻辑，能够正常运行，并不代表它是不“丑”的。代码中可能会存在诸如可读性差、结构混乱、重复代码太多、不够
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Refactoring" scheme="https://rollingstarky.github.io/tags/Refactoring/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Exception" scheme="https://rollingstarky.github.io/tags/Exception/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— Kubernetes 介绍</title>
    <link href="https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/"/>
    <id>https://rollingstarky.github.io/2021/11/30/kubernetes-in-action-reading-notes-introducing-kubernetes/</id>
    <published>2021-11-29T16:00:00.000Z</published>
    <updated>2021-11-30T11:39:02.008Z</updated>
    
    <content type="html"><![CDATA[<p>Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。</p><p><strong>Kubernetes 是一个负责自动化部署和管理应用的软件系统，主要针对由容器构成的复杂的大型应用系统</strong>。</p><h4 id="Kubernetes-的基本特性"><a href="#Kubernetes-的基本特性" class="headerlink" title="Kubernetes 的基本特性"></a>Kubernetes 的基本特性</h4><p><strong>抽象化基础设施</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8ecedf6a16f124ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Infrastructure abstraction"></p><p>Kubernetes 为用户和应用在底层的硬件之上提供了一个抽象层，底层的基础设施如计算机、网络及其他组件等对应用都是不可见的。用户通过这个抽象层部署和管理应用，不需要再面对每一台特定的机器。因此配置起来更加方便。</p><p><strong>标准化部署</strong><br>由于底层基础设施的具体细节不会再影响到应用的部署，本地数据中心和云环境都可以使用同样的部署方式。任何底层基础设施的差异都交给 Kubernetes 去处理，用户可以只关注产品及其内部逻辑。</p><p><strong>声明式部署</strong><br>Kubernetes 使用声明式的模型来定义具体的应用。用户只需要完成对应用中各组件的描述，Kubernetes 就会将这些描述转化成运行的应用。并在之后保证该应用的健康运行，在必要的时候重启或重新创建某个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-948914611a361f9e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Declarative model"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4474de5ae26d30a1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Changes in the description"></p><p>当用户修改了某些描述，Kubernetes 会根据改动自动采取必要的步骤重新配置应用，令应用满足最新的描述。</p><p><strong>接管应用的日常管理</strong><br>一旦用户通过 Kubernetes 部署了某个应用，该应用的日常管理就会被 Kubernetes 接管。假如服务停止运行，Kubernetes 会自动重启该应用；或者由于硬件失效、基础设施架构调整导致该应用需要移动到其他机器上，Kubernetes 也会自行处理。</p><p>就像之前提到的，用户类似于船长负责更高层级的决策，而 Kubernetes 则类似于舵手负责执行具体的底层任务。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e8b20e65761088c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes takes over the management of applications"></p><h4 id="Kubernetes-与微服务"><a href="#Kubernetes-与微服务" class="headerlink" title="Kubernetes 与微服务"></a>Kubernetes 与微服务</h4><p>之前的年头，绝大多数应用都是单体应用。应用里的各个组件是强耦合的，全部运行在同一个进程里。<br>当应用的容量需要提升时，水平扩展单体应用是非常困难的。只能不断升级服务器的硬件，即垂直扩展。</p><p>微服务范式是后来才出现的。单体应用被分割成数十甚至数百个独立的进程（微服务）。每一个微服务都拥有自己所独有的开发和部署周期，不同微服务的依赖会随着时间的推移差距越来越大。这使得在同一个操作系统内部运行两个微服务应用变得非常困难。<br>容器正好方便解决这个问题。但每个微服务都是一个独立的应用，需要单独进行管理。随着应用数量的上升这将会越来越困难。<br>整个应用系统的各个部分不需要部署到同一台机器上，这使得扩展起来更加方便。但同时也意味着各组件之间需要配置成能够相互通信的状态。同样增加了维护成本。<br>因此当微服务的规模变得很大时，自动化管理就显得尤为必要。Kubernetes 则正好提供了这种自动化功能。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-59ad3de50dca8dfa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Monolithic vs Microservices"></p><h4 id="Kubernetes-的架构"><a href="#Kubernetes-的架构" class="headerlink" title="Kubernetes 的架构"></a>Kubernetes 的架构</h4><p>Kubernetes 可以看作是一个面向服务器集群的操作系统。<br>操作系统用来支撑计算机的基本功能比如 CPU 调度，作为应用和计算机硬件之间沟通的接口。类似的，Kubernetes 负责在服务器集群的各台机器上调度安排分布式应用的各个组件，作为应用和集群之间的接口。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9daef5eac57b2474.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="OS vs Kubernetes"></p><p>一个 Kubernetes 集群包含两组节点：</p><ul><li>主节点：负责运行 Control Plane 组件，是系统的大脑，控制整个集群</li><li>工作节点：组成 Workload Plane，承接应用和负载</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30cd2137a1a1be44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Kubernetes cluster"></p><h5 id="控制平台"><a href="#控制平台" class="headerlink" title="控制平台"></a>控制平台</h5><p>Control Plane 负责控制整个集群。它运行在一台主节点上，或者以副本的方式运行在多个主节点上。包含 Scheduler、Controllers、Kubernetes API Server、etcd 等几个组件。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d8b81875430d46ed.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Components of Control Plane"></p><ul><li>Kubernetes API Server 负责暴露 RESTful API 接口，用户可以通过此接口创建对象</li><li>etcd 分布式数据仓库负责持久化通过 API 创建的对象，因为 API Server 本身是无状态的。Server 是唯一一个与 etcd 交互的组件</li><li>Scheduler 负责决定每个应用实例具体运行在哪个工作节点上</li><li>Controllers 负责具体化由 API 创建的对象。它们中的大部分实际上就是负责创建其他对象，有一些也会与外部系统进行交互（比如云提供商）</li></ul><h5 id="负载平台"><a href="#负载平台" class="headerlink" title="负载平台"></a>负载平台</h5><p>工作节点就是实际上运行应用的节点，它们构成了 Workload Plane。负责运行、监控各个应用，并在各应用之间提供连通性。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f0c322b076452baf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Workload Plane"></p><p>其中各组件的功能如下：</p><ul><li>Kubelet：一个与 API Server 进行交互的 agent，负责管理当前节点上运行的应用。会通过 API 向主节点报告应用的状态</li><li>Container Runtime：可以是 Docker 或其他与 Kubernetes 兼容的容器运行时，受 kubelet 指挥，负责运行应用</li><li>Kubernetes Service Proxy：在各应用的网络流量之间提供负载均衡</li></ul><h4 id="Kubernetes-的工作流程"><a href="#Kubernetes-的工作流程" class="headerlink" title="Kubernetes 的工作流程"></a>Kubernetes 的工作流程</h4><p>Kubernetes 中的所有元素都由对象表示，可以通过 API 创建和获取这些对象。用户需要几种不同的对象来定义自己的应用，通常在 YAML 或 JSON 格式的清单文件中定义。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-541fea79d28b6f43.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Deploying an application to Kubernetes"></p><p>向 Kubernetes 部署应用的具体步骤为：</p><ul><li>向 Kubernetes API 提交应用的 manifest 文件。API Server 将文件中定义的对象写入 etcd</li><li>controller 接到已经创建了新对象的通知，继续创建几个新的对象，对应不同的应用实例</li><li>Scheduler 为每一个应用实例分配工作节点</li><li>工作节点上的 Kubelet 接到通知，借助容器运行时运行应用实例</li><li>应用实例准备好接收客户端请求后，Kube Proxy 收到通知，为这些应用实例配置负载均衡</li><li>工作节点上的 Kubelets 和 Controllers 负责之后的监控工作，保证应用健康运行</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Kubernetes 这个名字来自于希腊语，意思是舵手。还是很符合这个平台的作用的。Kubernetes 负责管理部署的应用并报告它们的情况，而用户就像是船长，只需要决定想要整个系统达到怎样的状态。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 是一个负责自动化部署和
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Server" scheme="https://rollingstarky.github.io/tags/Server/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Microservice" scheme="https://rollingstarky.github.io/tags/Microservice/"/>
    
      <category term="Cloud" scheme="https://rollingstarky.github.io/tags/Cloud/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes in Action 笔记 —— 理解容器技术</title>
    <link href="https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/"/>
    <id>https://rollingstarky.github.io/2021/11/29/kubernetes-in-action-reading-notes-understanding-containers/</id>
    <published>2021-11-28T16:00:00.000Z</published>
    <updated>2021-11-29T13:55:06.259Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、容器-vs-虚拟机"><a href="#一、容器-vs-虚拟机" class="headerlink" title="一、容器 vs 虚拟机"></a>一、容器 vs 虚拟机</h4><h5 id="系统开销"><a href="#系统开销" class="headerlink" title="系统开销"></a>系统开销</h5><p>每一台虚拟机都需要安装独属于自己的操作系统，包含一系列系统进程；而同一台宿主机上的多个容器会共享宿主机的操作系统，它们的环境仍然是独立的。<br>即对于容器而言，不需要装一个独立的操作系统。不会像虚拟机那样，存在很多套重复的系统进程。因而容器更加轻量。<br><strong>容器只包含一套隔离的进程，运行在已有的宿主机操作系统上，只会消耗这套隔离进程运行所需的系统资源</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a8f80aa3c08ae7fa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="overhead VM vs Container"></p><p>由于虚拟机高额的开销，通常需要将多个关联的应用部署在同一台虚拟机上。对于开销较低的容器而言，则可以为每一个应用都创建一个独立的容器。<br>实际上也应该<strong>确保每一个容器都只包含一个应用</strong>，这样方便管理，同时 Kubernetes 等容器管理平台也是默认这个原则的。</p><h5 id="启动时间"><a href="#启动时间" class="headerlink" title="启动时间"></a>启动时间</h5><p>容器拥有更快的启动时间。因为容器只需要启动自身包含的应用进程，不需要像启动一台新的虚拟机那样，先启动一些额外的系统进程。</p><h5 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h5><p>无疑虚拟机的隔离性更好。<br>当使用虚拟机部署应用时，每台虚拟机都拥有一套独立的操作系统和内核。这些虚拟机的底层是 hypervisor，将物理硬件划分成一系列更小的虚拟资源，供给不同的虚拟机使用。</p><p>当虚拟机中运行的应用向虚拟机内核发起系统调用时，内核会先在虚拟的 CPU 上执行机器指令，再通过 hypervisor 转发给宿主机的物理 CPU 执行。<br>容器发起的系统调用则都可以直接传递给宿主机上运行的系统内核，再转化为机器指令传递给宿主机的 CPU。宿主机 CPU 不需要处理任何形式的虚拟化。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e7e28095583e19c7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="system calls"></p><p>同一台机器上的多个容器共享同一个宿主机内核，但它们之间仍然是隔离的，相互之间并不清楚其他人的存在，也只能看到一部分物理硬件。<br>这种隔离是由宿主机内核提供的。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f1b4cacdc98d0138.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Isolation"></p><h5 id="由隔离性引发的安全性"><a href="#由隔离性引发的安全性" class="headerlink" title="由隔离性引发的安全性"></a>由隔离性引发的安全性</h5><p>容器使用同一个内核。如果内核出现 bug，某个容器中的应用有可能会利用这个 bug 读取其他容器中其他应用的内存。<br>此外，容器会共享内存空间。如果不限制某个容器能够使用的内存总量，有可能会导致其他容器没有足够的内存使用。</p><h4 id="二、Docker-容器平台介绍"><a href="#二、Docker-容器平台介绍" class="headerlink" title="二、Docker 容器平台介绍"></a>二、Docker 容器平台介绍</h4><p>Docker 是一个帮助用户打包、发布和运行容器应用的平台。用户可以使用 Docker 将应用及其运行环境（可以是一些动态库等依赖，甚至操作系统提供的所有文件）打包，并可以将打包后的镜像发布到一个公共的镜像源，再部署到其他安装了 Docker 的机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-651e5432eed2654a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Docker Platform"></p><p>三个 Docker 中的基本概念：</p><ul><li>Images（镜像）：类似于一个 zip 压缩包，包含了应用及其运行环境</li><li>Registries（源）：一个方便用户和机器分发、共享镜像的站点。可以将打包好的镜像 push 到源，这样另一台机器就可以从镜像源 pull 该镜像到本地</li><li>Containers（容器）：相当于实例化的镜像。<strong>一个运行的容器相当于宿主机中一个普通的进程，只不过它的环境是隔离的</strong></li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4e505cff02f642b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker push"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-3f8802fae79fd57e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="docker pull"></p><h5 id="Image-Layers"><a href="#Image-Layers" class="headerlink" title="Image Layers"></a>Image Layers</h5><p>不同于虚拟机镜像是由整个文件系统构成的一个大的文件块，容器镜像通常是由更小的<strong>层</strong>构成。这些层可以被多个镜像所共享。<br>如果某个镜像需要的部分镜像层已经被下载到了宿主机上（在 pull 其他镜像的时候），则 pull 该镜像时只需要下载之前未 pull 的层即可。<br>镜像层使得发布镜像变得更加高效，同时也提升了宿主机的存储空间。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf0919122843a478.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Image Layers"></p><p>如上图中的三个容器，它们可以共享访问一部分共有的文件。但它们是如何同时做到隔离的呢？其中某个容器若修改了共享的文件，如何做到不对其他容器可见？<br>文件系统的隔离由 <strong>Copy-on-Write (CoW)</strong> 机制实现。<br>容器中的文件系统由从镜像而来的只读层和加在只读层上面的一个读写层构成。当某个运行的容器修改了只读层中的文件，该文件会被整个复制到容器的读写层。每个容器都拥有自己所独有的读写层，因此对共享文件的修改并不会对其他容器可见。<br>当删除某个文件，该文件只是在读写层中被标记为已删除，实际上该文件仍然存在于只读层中。因此删除文件并不会减少镜像的大小。</p><h5 id="镜像层的潜在限制"><a href="#镜像层的潜在限制" class="headerlink" title="镜像层的潜在限制"></a>镜像层的潜在限制</h5><p>理论上讲，基于 Docker 的镜像可以运行在任意一台启用了 Docker 的机器上。但是由于容器并没有自己的内核，如果一个容器需要特定版本的内核才能运行，它有可能不会运行在每一台机器上。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bedcb0dfebe1576c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="container requires specific kernel version"></p><p>此外，容器化的应用只能运行在特定的硬件架构上。比如不能把一个构建在 x86 CPU 架构上的应用，部署在 ARM 平台的 Docker 上。</p><h4 id="三、容器背后的技术"><a href="#三、容器背后的技术" class="headerlink" title="三、容器背后的技术"></a>三、容器背后的技术</h4><h5 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h5><p>Linux 命名空间可以确保每个进程都只能看到它自己视角的系统。即容器中的进程只能看到部分文件、进程、网络接口和机器名，就好像它运行在一个独立的虚拟机上。<br>内核可以创建额外的命名空间，然后将部分资源移动到该命名空间，并令其只对某一个或一组进程可见。</p><p>命名空间的类型：</p><ul><li>Mount 命名空间用来隔离挂载点（文件系统）</li><li>Process ID 命名空间用来隔离进程 ID</li><li>Network 命名空间用来隔离网络设备、端口等</li><li>ipc 命名空间用来隔离进程间的通信（包括管理消息队列、共享内存等）</li><li>UTS (UNIX Time-sharing System) 命名空间用来隔离系统的主机名和 NIS (Network Information Service) 域名</li><li>User ID 命名空间用来隔离用户和组 ID</li><li>Cgroup 命名空间用来隔离 Control Groups 根目录</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e436794540627a33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="network namespace"></p><p>有时候并不会想要将某个容器与另一个容器完全隔离，相互关联的容器之间有可能会共享特定的资源。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-120889e397b108e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="shared namespace"></p><p>比如上图中的两个容器。它们可以看见并使用相同的两个网络设备（<code>eth0</code> 和 <code>lo</code>），因为它们拥有相同的网络命名空间。它们也因此可以绑定相同的 IP 地址并通过 loopback 设备相互通信。<br>这两个容器还使用同一个 UTS 命名空间，因此它们可以见到相同的主机名。但它们的 Mount 命名空间是不同的，即拥有不同的文件系统。</p><p><strong>容器中运行的进程只是一个绑定了 7 类命名空间的普通进程</strong>。</p><h5 id="Linux-Control-Groups"><a href="#Linux-Control-Groups" class="headerlink" title="Linux Control Groups"></a>Linux Control Groups</h5><p>Linux 命名空间可以控制进程只能访问一部分系统资源，但它们不能限制每个进程消耗的资源总量。<br>Linux Control Groups (cgroups) 则可以限制进程只能使用预先分配好的固定额度的 CPU 时间、内存和网络带宽等。避免某些进程吃掉所有的系统资源。</p><h4 id="sys-calls"><a href="#sys-calls" class="headerlink" title="sys-calls"></a>sys-calls</h4><p>Linux 命名空间和 Cgroups 能够隔离容器的环境并防止某个容器消耗掉所有的计算资源。但这些容器中的进程仍然使用同一个系统内核，一个非法容器仍然可以通过一些恶意的系统调用来影响其他容器。</p><p>内核提供了一系列 sys-calls 可以被程序用来与操作系统及底层的硬件交互，包括创建进程、操作文件和设备、创建应用间的通信通道等。<br>其中有些 sys-calls 是安全的，可以被任意进程使用。其他一些则只允许具有更高权限的进程使用。比如容器中的应用应该允许访问它们的本地文件，但不能修改系统时钟或者以破坏其他容器的方式修改内核。</p><p>Linux 内核把这些权限分成了名为 capabilities 的单位。如：</p><ul><li>CAP_NET_ADMIN：允许进程执行网络相关的操作</li><li>CAP_NET_BIND_SERVICE：允许进程绑定小于 1024 的端口号</li><li>CAP_SYS_TIME：允许进程修改系统时钟</li></ul><p>Capabilities 能够在容器创建时添加或移除，每个 Capability 都代表一系列特殊权限。<br>此外，还可以使用 <strong>seccomp (Secure Computing Mode)</strong> 。创建一个 包含 seccomp 配置的 JSON 文件，在构建容器时提供给 Docker。</p><h5 id="AppArmor-amp-SELinux"><a href="#AppArmor-amp-SELinux" class="headerlink" title="AppArmor &amp; SELinux"></a>AppArmor &amp; SELinux</h5><p>容器还可以依靠两种 MAC（强制访问控制）机制 SELinux 和 AppArmor 来获得更高的安全性。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/kubernetes-in-action-second-edition" target="_blank" rel="noopener">Kubernetes in Action, Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、容器-vs-虚拟机&quot;&gt;&lt;a href=&quot;#一、容器-vs-虚拟机&quot; class=&quot;headerlink&quot; title=&quot;一、容器 vs 虚拟机&quot;&gt;&lt;/a&gt;一、容器 vs 虚拟机&lt;/h4&gt;&lt;h5 id=&quot;系统开销&quot;&gt;&lt;a href=&quot;#系统开销&quot; class=&quot;
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="Isolation" scheme="https://rollingstarky.github.io/tags/Isolation/"/>
    
      <category term="VM" scheme="https://rollingstarky.github.io/tags/VM/"/>
    
  </entry>
  
  <entry>
    <title>Python 语言实现循环的最快方式（for、while 等速度对比）</title>
    <link href="https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/"/>
    <id>https://rollingstarky.github.io/2021/11/23/the-fastest-way-to-loop-in-python/</id>
    <published>2021-11-22T16:00:00.000Z</published>
    <updated>2021-11-23T12:51:53.254Z</updated>
    
    <content type="html"><![CDATA[<p>众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。<br>假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。</p><p><code>while</code> 和 <code>for</code> 是 Python 中常用的两种实现循环的关键字，它们的运行效率实际上是有差距的。比如下面的测试代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br></pre></td></tr></table></figure></p><p>这是一个简单的求和操作，计算从 1 到 n 之间所有自然数的总和。<br>可以看到 <code>for</code> 循环相比 <code>while</code> 要快 1.5 秒。其中的差距主要在于两者的机制不同。<br>在每次循环中，<code>while</code> 实际上比 <code>for</code> 多执行了两步操作：边界检查和变量 <code>i</code> 的自增。即每进行一次循环，while 都会做一次边界检查 (<code>while i &lt; n</code>）和自增计算（<code>i +=1</code>）。这两步操作都是显式的纯 Python 代码。<br><code>for</code> 循环不需要执行边界检查和自增操作，没有增加显式的 Python 代码（纯 Python 代码效率低于底层的 C 代码）。当循环的次数足够多，就出现了明显的效率差距。</p><p>可以再增加两个函数，在 <code>for</code> 循环中加上不必要的边界检查和自增计算：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_inc</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop_with_test</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> i &lt; n:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with increment\t\t'</span>,</span><br><span class="line">          timeit.timeit(for_loop_with_inc, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop with test\t\t'</span>, timeit.timeit(for_loop_with_test, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; for loop with increment          4.602369500091299</span></span><br><span class="line"><span class="comment"># =&gt; for loop with test               4.18337869993411</span></span><br></pre></td></tr></table></figure></p><p>可以看出，增加的边界检查和自增操作确实大大影响了 <code>for</code> 循环的执行效率。</p><p>前面提到过，Python 底层的解释器和内置函数是用 C 语言实现的。而 C 语言的执行效率远大于 Python。<br>对于上面的求等差数列之和的操作，借助于 Python 内置的 <code>sum</code> 函数，可以获得远大于 <code>for</code> 或 <code>while</code> 循环的执行效率。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br></pre></td></tr></table></figure></p><p>可以看到，使用内置函数 <code>sum</code> 替代循环之后，代码的执行效率实现了成倍的增长。内置函数 <code>sum</code> 的累加操作实际上也是一种循环，但它由 C 语言实现，而 <code>for</code> 循环中的求和操作是由纯 Python 代码 <code>s += i</code> 实现的。C &gt; Python。</p><p>再拓展一下思维。小时候都听说过童年高斯巧妙地计算 1 到 100 之和的故事。1…100 之和等于 (1 + 100) * 50。这个计算方法同样可以应用到上面的求和操作中。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> timeit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">while_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; n:</span><br><span class="line">        s += i</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">for_loop</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    s = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        s += i</span><br><span class="line">    <span class="keyword">return</span> s</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_range</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sum(range(n))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">math_sum</span><span class="params">(n=<span class="number">100</span>_000_000)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> (n * (n - <span class="number">1</span>)) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'while loop\t\t'</span>, timeit.timeit(while_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'for loop\t\t'</span>, timeit.timeit(for_loop, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'sum range\t\t'</span>, timeit.timeit(sum_range, number=<span class="number">1</span>))</span><br><span class="line">    print(<span class="string">'math sum\t\t'</span>, timeit.timeit(math_sum, number=<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br><span class="line"><span class="comment"># =&gt; while loop               4.718853999860585</span></span><br><span class="line"><span class="comment"># =&gt; for loop                 3.211570399813354</span></span><br><span class="line"><span class="comment"># =&gt; sum range                0.8658821999561042</span></span><br><span class="line"><span class="comment"># =&gt; math sum                 2.400018274784088e-06</span></span><br></pre></td></tr></table></figure></p><p>最终 math sum 的执行时间约为 <code>2.4e-6</code>，缩短了上百万倍。这里的思路就是，既然循环的效率低，一段代码要重复执行上亿次。<br>索性直接不要循环，通过数学公式，把上亿次的循环操作变成只有一步操作。效率自然得到了空前的加强。</p><p>最后的结论（有点谜语人）：</p><p><strong>实现循环的最快方式</strong><br>——<br>——<br>——<br><strong>就是不用循环</strong></p><p>对于 Python 而言，则尽可能地使用内置函数，将循环中的纯 Python 代码降到最低。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://youtu.be/Qgevy75co8c" target="_blank" rel="noopener">The Fastest Way to Loop in Python - mCoding</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;众所周知，Python 不是一种执行效率较高的语言。此外在任何语言中，循环都是一种非常消耗时间的操作。&lt;br&gt;假如任意一种简单的单步操作耗费的时间为 1 个单位，将此操作重复执行上万次，最终耗费的时间也将增长上万倍。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;while&lt;/code&gt; 和 
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="loop" scheme="https://rollingstarky.github.io/tags/loop/"/>
    
      <category term="C" scheme="https://rollingstarky.github.io/tags/C/"/>
    
      <category term="big-O" scheme="https://rollingstarky.github.io/tags/big-O/"/>
    
  </entry>
  
  <entry>
    <title>Ansible 使用 lineinfile 模块修改配置文件</title>
    <link href="https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/"/>
    <id>https://rollingstarky.github.io/2021/11/16/ansible-lineinfile-module-for-modifying-configuration/</id>
    <published>2021-11-15T16:00:00.000Z</published>
    <updated>2021-11-16T14:33:03.362Z</updated>
    
    <content type="html"><![CDATA[<p>需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 <code>shell</code> 模块，<code>echo</code> 加 <code>&gt;&gt;</code> 就完事了。<br>但仔细一琢磨，很可能会引发一些意想不到的问题，比如：</p><ul><li>如果需要添加的配置已经存在，<code>echo</code> 仍会向配置文件底部添加同样的内容</li><li>如果添加配置的任务重复执行多次，则配置文件中也会多次出现重复的内容。无法做到<strong>幂等</strong></li><li>如何做到，当对应的配置已经存在，则将该配置改为期望的值；当对应的配置不存在，不做任何操作（有就修改，没有就不动。好像可以用 <code>sed</code>）</li><li>如何安全地移除指定的配置项</li></ul><p>诸如此类。运维工作常常要关系到生产环境。任何无法预期的效果都可能产生严重的影响。而单纯使用 <code>echo</code> 和 <code>&gt;&gt;</code> 向配置文件中添加内容，具有很大的不确定性。<br>当然可以形成一个 Shell 脚本，对各种边界进行足够的检查和判定，但这会导致代码量变大，结构复杂难以标准化；同时也容易出现遗漏的情况。</p><p>实际上 Ansible 内置的 <code>lineinfile</code> 就是专门用来处理上述任务的模块。</p><p>比如针对如下内容的配置文件 <code>test_conf.ini</code>：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>需要添加一行配置 <code>THIRD=3</code>。</p><p>可以运行如下内容的 playbook <code>change_config.yml</code>：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">THIRD=3</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>lineinfile</code> 模块的 <code>path</code> 参数用于指定目标配置文件的路径；<code>regexp</code> 参数则用于指定对文件内容进行匹配时使用的正则表达式；最后的 <code>line</code> 参数表示希望在目标文件中出现的内容。</p><p>具体的步骤为：</p><ul><li>检查 <code>line</code> 对应的内容是否存在于 <code>path</code> 对应的目标文件中</li><li>若已经存在。则目标文件符合要求，不对该文件做任何操作</li><li>若不存在。通过 <code>regexp</code> 指定的正则表达式对目标文件进行匹配</li><li>若 <code>regexp</code> 匹配到文本行，则将该行内容修改为 <code>line</code> 指定的内容</li><li>若 <code>regexp</code> 未匹配到文本行，则将 <code>line</code> 对应的内容作为新的一行添加到目标文件末尾</li></ul><p>运行效果：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>此时 <code>test_conf.ini</code> 配置文件的内容被修改为：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>若再次运行 <code>ansible-playbook change_config.yml</code> 命令：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">ok: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=0    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>可以看到修改配置文件的任务执行结果为 <code>ok</code>，而不同于上一次的 <code>changed</code>。这表示 <code>lineinfile</code> 模块对配置文件的内容进行了检查，发现需要添加的配置行已经存在，因此未做任何改动。符合<strong>幂等</strong>的原则。</p><p>假如将配置文件中的 <code>THIRD=3</code> 改为 <code>THIRD=false</code>，再次运行 playbook：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ ansible-playbook change_config.yml</span><br><span class="line"></span><br><span class="line">PLAY [change configuration] *********************************************************************************************************</span><br><span class="line"></span><br><span class="line">TASK [change content <span class="keyword">in</span> test_conf.ini] **********************************************************************************************</span><br><span class="line">changed: [localhost]</span><br><span class="line"></span><br><span class="line">PLAY RECAP **************************************************************************************************************************</span><br><span class="line">localhost                  : ok=1    changed=1    unreachable=0    failed=0    skipped=0    rescued=0    ignored=0</span><br></pre></td></tr></table></figure></p><p>正则表达式 <code>^THIRD</code> 会匹配到配置文件的第三行 <code>THIRD=false</code>，再将该行内容替换为 <code>THIRD=3</code>。</p><p>最终仍可以得到我们想要的内容：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br><span class="line"><span class="attr">THIRD</span>=<span class="number">3</span></span><br></pre></td></tr></table></figure></p><p>对于 Ansible playbook 而言，我们只需要关注<strong>期望达到的状态</strong>，而不用纠结<strong>为了达到该状态需要执行哪些步骤</strong>。<br>如 <code>lineinfile</code> 模块，<code>line</code> 指定的内容即为我们期望目标文件达到的状态。即该文件最终一定会包含一行与 <code>line</code> 相同的文本。<br>不管该行内容是本就已经存在的，还是通过修改 <code>regexp</code> 匹配到的文本行得到的，还是直接在目标文件末尾新增的。而我们只需要定义 <code>path</code>、<code>regexp</code>、<code>line</code> 三个参数即可。</p><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><h5 id="backrefs"><a href="#backrefs" class="headerlink" title="backrefs"></a>backrefs</h5><p><code>lineinfile</code> 默认的行为是若 <code>line</code> 指定的内容未存在，<code>regexp</code> 正则表达式也没有任何匹配，就在文件末尾添加一行 <code>line</code> 指定的内容。<br><code>backrefs</code> 参数可以修改此行为。当 <code>backrefs</code> 设定为 <code>true</code> 时，若 <code>line</code> 指定的内容不存在，正则表达式也没有匹配。则不做任何操作。</p><p>比如如下 playbook：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'THIRD=3'</span></span><br><span class="line"><span class="attr">        backrefs:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure></p><p>当目标文件的内容如下：<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">FIRST</span>=<span class="literal">true</span></span><br><span class="line"><span class="attr">SECOND</span>=<span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>playbook 实际不会对其做任何修改，不会在文件末尾添加 <code>THIRD=3</code>。只有当文件中存在如 <code>THIRD=false</code> 这类内容时，playbook 才会完成匹配并替换对应的行。</p><p>没有 <code>backrefs</code> 表示匹配就替换，不匹配就在文件末尾添加；有 <code>backrefs</code> 表示匹配就替换，不匹配就不动。</p><h5 id="删除一行内容"><a href="#删除一行内容" class="headerlink" title="删除一行内容"></a>删除一行内容</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        regexp:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        state:</span> <span class="string">absent</span></span><br></pre></td></tr></table></figure><h5 id="在匹配行前-后添加"><a href="#在匹配行前-后添加" class="headerlink" title="在匹配行前/后添加"></a>在匹配行前/后添加</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertbefore:</span> <span class="string">'^FIRST'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'ZERO=false'</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">change</span> <span class="string">configuration</span></span><br><span class="line"><span class="attr">  gather_facts:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">  hosts:</span> <span class="string">localhost</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  tasks:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">change</span> <span class="string">content</span> <span class="string">in</span> <span class="string">test_conf.ini</span></span><br><span class="line"><span class="attr">      lineinfile:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/home/starky/projects/ansible/practice/test_conf.ini</span></span><br><span class="line"><span class="attr">        insertafter:</span> <span class="string">'^THIRD'</span></span><br><span class="line"><span class="attr">        line:</span> <span class="string">'FOURTH=4'</span></span><br></pre></td></tr></table></figure><p>需要注意以下两点：</p><ul><li>当 <code>line</code> 指定的内容已经存在于目标文件中时，不管其具体在什么位置，目标文件都不会做任何修改</li><li>当 <code>insertbefore</code> 或 <code>insertafter</code> 指定的正则表达式没有任何匹配时，都会在文件末尾添加 <code>line</code> 指定的内容</li></ul><h4 id="官网示例"><a href="#官网示例" class="headerlink" title="官网示例"></a>官网示例</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Before 2.3, option 'dest', 'destfile' or 'name' was used instead of 'path'</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">SELinux</span> <span class="string">is</span> <span class="string">set</span> <span class="string">to</span> <span class="string">enforcing</span> <span class="string">mode</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/selinux/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^SELINUX='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">SELINUX=enforcing</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Make</span> <span class="string">sure</span> <span class="string">group</span> <span class="string">wheel</span> <span class="string">is</span> <span class="string">not</span> <span class="string">in</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">configuration</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">absent</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%wheel'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">with</span> <span class="string">our</span> <span class="string">own</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^127\.0\.0\.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Replace</span> <span class="string">a</span> <span class="string">localhost</span> <span class="string">entry</span> <span class="string">searching</span> <span class="string">for</span> <span class="string">a</span> <span class="string">literal</span> <span class="string">string</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">escaping</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/hosts</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'127.0.0.1'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="string">localhost</span></span><br><span class="line"><span class="attr">    owner:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    group:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    mode:</span> <span class="string">'0644'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">default</span> <span class="string">Apache</span> <span class="string">port</span> <span class="string">is</span> <span class="number">8080</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^Listen '</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^#Listen '</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">Listen</span> <span class="number">8080</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">php</span> <span class="string">extension</span> <span class="string">matches</span> <span class="string">new</span> <span class="string">pattern</span></span><br><span class="line"><span class="attr">  lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/httpd/conf/httpd.conf</span></span><br><span class="line"><span class="attr">    search_string:</span> <span class="string">'&lt;FilesMatch ".php[45]?$"&gt;'</span></span><br><span class="line"><span class="attr">    insertafter:</span> <span class="string">'^\t&lt;Location \/&gt;\n'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'        &lt;FilesMatch ".php[34]?$"&gt;'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">we</span> <span class="string">have</span> <span class="string">our</span> <span class="string">own</span> <span class="string">comment</span> <span class="string">added</span> <span class="string">to</span> <span class="string">/etc/services</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/services</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^# port for http'</span></span><br><span class="line"><span class="attr">    insertbefore:</span> <span class="string">'^www.*80/tcp'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'# port for http by default'</span></span><br><span class="line"></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Add</span> <span class="string">a</span> <span class="string">line</span> <span class="string">to</span> <span class="string">a</span> <span class="string">file</span> <span class="string">if</span> <span class="string">the</span> <span class="string">file</span> <span class="string">does</span> <span class="string">not</span> <span class="string">exist,</span> <span class="string">without</span> <span class="string">passing</span> <span class="string">regexp</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/testfile</span></span><br><span class="line"><span class="attr">    line:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.99</span> <span class="string">foo.lab.net</span> <span class="string">foo</span></span><br><span class="line"><span class="attr">    create:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Yaml requires escaping backslashes in double quotes but not in single quotes</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Ensure</span> <span class="string">the</span> <span class="string">JBoss</span> <span class="string">memory</span> <span class="string">settings</span> <span class="string">are</span> <span class="string">exactly</span> <span class="string">as</span> <span class="string">needed</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/opt/jboss-as/bin/standalone.conf</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^(.*)Xms(\d+)m(.*)$'</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'\1Xms$&#123;xms&#125;m\3'</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> Fully quoted because of the ': ' on the line. See the Gotchas in the YAML docs.</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Validate</span> <span class="string">the</span> <span class="string">sudoers</span> <span class="string">file</span> <span class="string">before</span> <span class="string">saving</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/etc/sudoers</span></span><br><span class="line"><span class="attr">    state:</span> <span class="string">present</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">'^%ADMIN ALL='</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">'%ADMIN ALL=(ALL) NOPASSWD: ALL'</span></span><br><span class="line"><span class="attr">    validate:</span> <span class="string">/usr/sbin/visudo</span> <span class="bullet">-cf</span> <span class="string">%s</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># See https://docs.python.org/3/library/re.html for further details on syntax</span></span><br><span class="line"><span class="attr">- name:</span> <span class="string">Use</span> <span class="string">backrefs</span> <span class="string">with</span> <span class="string">alternative</span> <span class="string">group</span> <span class="string">syntax</span> <span class="string">to</span> <span class="string">avoid</span> <span class="string">conflicts</span> <span class="string">with</span> <span class="string">variable</span> <span class="string">values</span></span><br><span class="line">  <span class="string">ansible.builtin.lineinfile:</span></span><br><span class="line"><span class="attr">    path:</span> <span class="string">/tmp/config</span></span><br><span class="line"><span class="attr">    regexp:</span> <span class="string">^(host=).*</span></span><br><span class="line"><span class="attr">    line:</span> <span class="string">\g&lt;1&gt;&#123;&#123;</span> <span class="string">hostname</span> <span class="string">&#125;&#125;</span></span><br><span class="line"><span class="attr">    backrefs:</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://docs.ansible.com/ansible/latest/collections/ansible/builtin/lineinfile_module.html" target="_blank" rel="noopener">ansible.builtin.lineinfile – Manage lines in text files</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;需要用 Ansible 修改配置文件，其实就是在某个文件末尾添加几行内容。直观地想，直接用 &lt;code&gt;shell&lt;/code&gt; 模块，&lt;code&gt;echo&lt;/code&gt; 加 &lt;code&gt;&amp;gt;&amp;gt;&lt;/code&gt; 就完事了。&lt;br&gt;但仔细一琢磨，很可能会引发一些意想不
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Ansible" scheme="https://rollingstarky.github.io/tags/Ansible/"/>
    
      <category term="Devops" scheme="https://rollingstarky.github.io/tags/Devops/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（Queue）</title>
    <link href="https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/"/>
    <id>https://rollingstarky.github.io/2021/10/08/effective-python-notes-concurrency-and-queue/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:08:25.436Z</updated>
    
    <content type="html"><![CDATA[<h4 id="借助-Queue-实现多线程间的协同"><a href="#借助-Queue-实现多线程间的协同" class="headerlink" title="借助 Queue 实现多线程间的协同"></a>借助 Queue 实现多线程间的协同</h4><h5 id="Pipeline"><a href="#Pipeline" class="headerlink" title="Pipeline"></a>Pipeline</h5><p>并行地执行多个任务的 Python 程序通常都需要一种协作机制，使得多个线程负责的各部分之间的工作能够相互协同。<br>其中一种协作机制称为<strong>管线</strong>（<em>pipeline</em>）。pipeline 的工作方式类似于工厂里的流水线，分为串行排列的多道工序（<em>phase</em>）。每道工序都由特定的函数处理，函数之间可以并行地执行。</p><p>比如需要创建这样一个系统，可以从相机接收持续的图片流，再将收到的图片更改尺寸，最后上传到线上的图片库中。<br>这样的系统就可以分为三道工序，分别用 <code>download</code>、<code>resize</code>、<code>upload</code> 三个函数去处理。此外还需要一个在各道工序间传递任务对象的媒介，这个可以通过线程安全的 <strong>producer-consumer</strong> 队列去实现。</p><p>具体的示例代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.items = deque()</span><br><span class="line">        self.lock = Lock()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">put</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.items.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            <span class="keyword">return</span> self.items.popleft()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line">        self.polled_count = <span class="number">0</span></span><br><span class="line">        <span class="comment"># self.work_done = 0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            self.polled_count += <span class="number">1</span></span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                item = self.in_queue.get()</span><br><span class="line">            <span class="keyword">except</span> IndexError:</span><br><span class="line">                time.sleep(<span class="number">0.01</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                result = self.func(item)</span><br><span class="line">                self.out_queue.put(result)</span><br><span class="line">                <span class="comment"># self.work_done += 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = MyQueue()</span><br><span class="line">resize_queue = MyQueue()</span><br><span class="line">upload_queue = MyQueue()</span><br><span class="line">done_queue = MyQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    Worker(download, download_queue, resize_queue),</span><br><span class="line">    Worker(resize, resize_queue, upload_queue),</span><br><span class="line">    Worker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> len(done_queue.items) &lt; <span class="number">100</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">processed = len(done_queue.items)</span><br><span class="line">polled = sum(t.polled_count <span class="keyword">for</span> t <span class="keyword">in</span> threads)</span><br><span class="line">print(<span class="string">f'Processed <span class="subst">&#123;processed&#125;</span> items after '</span></span><br><span class="line">      <span class="string">f'polling <span class="subst">&#123;polled&#125;</span> times'</span>)</span><br><span class="line"><span class="comment"># Processed 100 items after polling 308 times</span></span><br></pre></td></tr></table></figure></p><p>上述实现虽然能够处理完成输入的所有任务，但仍存在很多问题。<br>首先是 <code>polled_count</code> 值远大于任务的数量。即工作线程的 <code>run</code> 方法中定义的从队列中取项目的动作执行了太多次。<br>各个工作函数的执行速度其实是不一致的，前置位的工作函数（比如 <code>download</code>）运行缓慢，会导致后一道工序（比如 <code>resize</code>）上的函数持续不断的向其队列请求新的任务，然而队列为空导致不断地触发 <code>IndexError</code> 错误，最终导致 CPU 时间的浪费。</p><p>其次，确认所有任务是否全部完成，需要一个 <code>while</code> 循环不断地检查 <code>done_queue</code> 队列中元素的数量。</p><p>再次，工作线程中的 <code>run</code> 方法会一直处于 <code>while True</code> 的循环当中，没有一种明显的方法可以向该工作线程发送任务完成可以退出的消息。</p><p>最后，当第一道工序执行很快而第二道工序执行很慢时，处于两道工序之间的队列中的元素数量会持续增长。如果有足够多的任务和足够长的时间，程序最终会耗尽内存并崩溃。</p><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>内置的 <code>queue</code> 模块中的 <code>Queue</code> 类可以解决上述问题。</p><p><code>Queue</code> 类中的 <code>get</code> 方法是阻塞的，即在有新的项目放置到队列中以前，<code>get</code> 会一直处于等待状态，直到获取到某个项目。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">my_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">1</span>)</span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>即便线程先于主程序运行，它也会先处于等待状态，直到一个新的项目被放置到队列中，能够被 <code>get</code> 获取到。<br>这可以解决前面的程序中 <code>polled_count</code> 值过大的问题。</p><p><code>Queue</code> 类可以指定 buffer size，从而限制了两道工序间 pending 的任务的最大数量。即队列中的元素数量达到最大值后，向队列中放入新元素的 <code>put</code> 方法会阻塞，等待队列中某个元素被消耗从而为新元素腾出空间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line">my_queue = Queue(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 1'</span>)</span><br><span class="line">    my_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer got 2'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 1'</span>)</span><br><span class="line">my_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer put 2'</span>)</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Producer put 1</span></span><br><span class="line"><span class="comment"># Consumer got 1</span></span><br><span class="line"><span class="comment"># Producer put 2</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br><span class="line"><span class="comment"># Consumer got 2</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br></pre></td></tr></table></figure></p><p>Consumer 线程中的 <code>sleep</code> 应该使得主程序有足够的时间将两个对象都放置到队列中。但队列的大小是 1，就导致队列中先放入的元素必须通过 <code>get</code> 方法取出之后，才能继续使用 <code>put</code> 方法放置新的元素进去。<br>即 Producer 会等待 Consumer 线程把放置到队列中的旧元素消耗掉，才能继续向队列中添加新的元素。</p><h5 id="task-done"><a href="#task-done" class="headerlink" title="task_done"></a>task_done</h5><p><code>Queue</code> 类可以使用其 <code>task_done</code> 方法来追踪任务的进度，使得程序可以确保在某个特定的时间点，队列中的所有任务都已经被处理完成。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">in_queue = Queue()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'Consumer waiting'</span>)</span><br><span class="line">    work = in_queue.get()</span><br><span class="line">    print(<span class="string">'Consumer working'</span>)</span><br><span class="line">    print(<span class="string">'Consumer done'</span>)</span><br><span class="line">    in_queue.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">thread = Thread(target=consumer)</span><br><span class="line">thread.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Producer putting'</span>)</span><br><span class="line">in_queue.put(object())</span><br><span class="line">print(<span class="string">'Producer waiting'</span>)</span><br><span class="line">in_queue.join()</span><br><span class="line">print(<span class="string">'Producer done'</span>)</span><br><span class="line">thread.join()</span><br><span class="line"><span class="comment"># Consumer waiting</span></span><br><span class="line"><span class="comment"># Producer putting</span></span><br><span class="line"><span class="comment"># Producer waiting</span></span><br><span class="line"><span class="comment"># Consumer working</span></span><br><span class="line"><span class="comment"># Consumer done</span></span><br><span class="line"><span class="comment"># Producer done</span></span><br></pre></td></tr></table></figure></p><p>在代码中调用 <code>in_queue.join()</code> 后，只有队列 <code>in_queue</code> 中的所有元素都执行了一遍 <code>task_done</code>（即有几个元素就需要几条 <code>task_done</code>），<code>in_queue.join()</code> 之后的代码才会执行。否则就继续等待，直到 Consumer 调用了足够次数的 <code>task_done</code>。</p><p>结合前面提到的特性，可以创建一个新的 <code>Queue</code> 类，它能够告知工作线程什么时候该停止执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br></pre></td></tr></table></figure></p><p>更新后的完整代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">threads = [</span><br><span class="line">    StoppableWorker(download, download_queue, resize_queue),</span><br><span class="line">    StoppableWorker(resize, resize_queue, upload_queue),</span><br><span class="line">    StoppableWorker(upload, upload_queue, done_queue),</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">download_queue.close()</span><br><span class="line">download_queue.join()</span><br><span class="line">resize_queue.close()</span><br><span class="line">resize_queue.join()</span><br><span class="line">upload_queue.close()</span><br><span class="line">upload_queue.join()</span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><p>逻辑上就是给 <code>Queue</code> 类加了一个 <code>SENTINEL</code> 对象，用来作为队列结束的标志。工作线程通过循环读取输入队列中的任务，这些任务对象经过特定函数处理后放置到输出队列中。若读取到的任务是 <code>SENTINEL</code> 对象，则线程结束运行。</p><p><code>task_done</code> 方法和主程序中的 <code>xxx_queue.join</code> 用于确保某个队列中的所有任务都已经处理完成，转移到了下一个队列中。后面再调用下一个队列的 <code>close</code> 方法在该队列尾部添加一个 <code>SENTINEL</code> 对象，作为队列的结束标志。</p><p>上述实现的好处在于，工作线程会在读取到 <code>SENTINEL</code> 对象时自动结束运行；主程序中 <code>upload_queue.join()</code> 执行结束后就能保证三个阶段的所有任务都被处理完了，而不再需要频繁地去检查 <code>done_queue</code> 中的元素数量。</p><h5 id="最终实现"><a href="#最终实现" class="headerlink" title="最终实现"></a>最终实现</h5><p>当需要对不同的阶段（<code>download</code>、<code>resize</code>、<code>upload</code>）都分别绑定多个线程去处理时，只稍微修改下代码就可以了。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">upload</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">resize</span><span class="params">(item)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClosableQueue</span><span class="params">(Queue)</span>:</span></span><br><span class="line">    SENTINEL = object()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.put(self.SENTINEL)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            item = self.get()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> item <span class="keyword">is</span> self.SENTINEL:</span><br><span class="line">                    <span class="keyword">return</span>  <span class="comment"># Cause the thread to exit</span></span><br><span class="line">                <span class="keyword">yield</span> item</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                self.task_done()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StoppableWorker</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func, in_queue, out_queue)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.func = func</span><br><span class="line">        self.in_queue = in_queue</span><br><span class="line">        self.out_queue = out_queue</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.in_queue:</span><br><span class="line">            result = self.func(item)</span><br><span class="line">            self.out_queue.put(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">start_threads</span><span class="params">(count, *args)</span>:</span></span><br><span class="line">    threads = [StoppableWorker(*args) <span class="keyword">for</span> _ <span class="keyword">in</span> range(count)]</span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.start()</span><br><span class="line">    <span class="keyword">return</span> threads</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">stop_threads</span><span class="params">(closable_queue, threads)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> threads:</span><br><span class="line">        closable_queue.close()</span><br><span class="line"></span><br><span class="line">    closable_queue.join()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">        thread.join()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">download_queue = ClosableQueue()</span><br><span class="line">resize_queue = ClosableQueue()</span><br><span class="line">upload_queue = ClosableQueue()</span><br><span class="line">done_queue = ClosableQueue()</span><br><span class="line"></span><br><span class="line">download_threads = start_threads(</span><br><span class="line">    <span class="number">3</span>, download, download_queue, resize_queue)</span><br><span class="line">resize_threads = start_threads(</span><br><span class="line">    <span class="number">4</span>, resize, resize_queue, upload_queue)</span><br><span class="line">upload_threads = start_threads(</span><br><span class="line">    <span class="number">5</span>, upload, upload_queue, done_queue)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    download_queue.put(object())</span><br><span class="line"></span><br><span class="line">stop_threads(download_queue, download_threads)</span><br><span class="line">stop_threads(resize_queue, resize_threads)</span><br><span class="line">stop_threads(upload_queue, upload_threads)</span><br><span class="line"></span><br><span class="line">print(done_queue.qsize(), <span class="string">'items finished'</span>)</span><br><span class="line"><span class="comment"># 1000 items finished</span></span><br></pre></td></tr></table></figure></p><h4 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h4><ul><li>Pipeline 可以很好地组织流水线类型的工作，尤其是 IO 相关的 Python 多线程程序</li><li>需要特别注意构建 pipeline 时的隐藏问题：怎样告诉工作线程终止运行、busy waiting 以及潜在的内存爆炸等</li><li><code>Queue</code> 类具备构建健壮的 pipeline 所需的特性，如阻塞式操作、buffer size 和 joining 等。</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;借助-Queue-实现多线程间的协同&quot;&gt;&lt;a href=&quot;#借助-Queue-实现多线程间的协同&quot; class=&quot;headerlink&quot; title=&quot;借助 Queue 实现多线程间的协同&quot;&gt;&lt;/a&gt;借助 Queue 实现多线程间的协同&lt;/h4&gt;&lt;h5 id=&quot;P
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Queue" scheme="https://rollingstarky.github.io/tags/Queue/"/>
    
      <category term="Pipeline" scheme="https://rollingstarky.github.io/tags/Pipeline/"/>
    
      <category term="Producer" scheme="https://rollingstarky.github.io/tags/Producer/"/>
    
      <category term="Consumer" scheme="https://rollingstarky.github.io/tags/Consumer/"/>
    
  </entry>
  
  <entry>
    <title>Vim 技巧 —— 实现多行注释的几种方法</title>
    <link href="https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/"/>
    <id>https://rollingstarky.github.io/2021/10/08/vim-tricks-some-ways-to-comment-multiple-lines/</id>
    <published>2021-10-07T16:00:00.000Z</published>
    <updated>2021-10-08T15:12:59.653Z</updated>
    
    <content type="html"><![CDATA[<p>习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。<br>于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。</p><h4 id="字符串替换"><a href="#字符串替换" class="headerlink" title="字符串替换"></a>字符串替换</h4><p>命令模式下可以使用 <code>:s/old/new</code> 替换当前文本行中的指定字符串。前面还可以加上数字等用来指定范围。如：</p><ul><li><code>:n1,n2 s/old/new</code>：从 <code>n1</code> 行开始，到 <code>n2</code> 行结束，将每一行中符合 <code>old</code> 模式的内容替换为 <code>new</code></li><li><code>:% s/old/new</code>：将整个文件中的 <code>old</code> 替换为 <code>new</code></li></ul><p>类似于 Vim 中内置了一个 <code>sed</code> 工具。</p><p>对于 Python 代码，注释代码块当然可以用双 <code>&#39;&#39;&#39;</code>，临时的注释我个人比较偏向行首加 <code>#</code>。借助字符串替换可以很方便的实现。命令如下：<br><code>:n1,n2 s/^/#</code><br>将 <code>n1</code> 到 <code>n2</code> 行中的行首空白字符替换为 <code>#</code>，等同于在每一行行首插入 <code>#</code></p><p>对于如下 Python 代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30ef29b5184224b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before replace"></p><p>在 Vim 中运行 <code>:1,3 s/^/#</code>，后，效果如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># from datetime import datetime</span></span><br><span class="line"><span class="comment"># import calendar</span></span><br><span class="line"><span class="comment"># import os</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">current_time = datetime.now()</span><br><span class="line">total_days = calendar.monthrange(current_time.year, current_time.month)</span><br><span class="line">total_days = total_days[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(total_days):</span><br><span class="line">    os.mkdir(str(i + <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p><p>如果要取消注释，再运行如下命令即可：<br><code>:1,3 s/# /</code><br>将 1 - 3 行行首的 <code>#</code> 替换为空字符串（即移除行首的 <code>#</code>)</p><h5 id="visual-模式下指定文本范围"><a href="#visual-模式下指定文本范围" class="headerlink" title="visual 模式下指定文本范围"></a>visual 模式下指定文本范围</h5><p>如果不喜欢用数字行号指定施行替换的文本行，也可以在 Visual 模式下手动选择生效的文本范围。</p><p>Normal 模式下按键盘上的 <code>v</code> 键进入 visual 模式，然后就可以通过光标移动命令（如 <code>h</code>、<code>j</code>、<code>k</code>、<code>l</code>、<code>{</code>、<code>}</code> 等）选中多行文本。</p><p>接着在命令模式下运行 <code>:&#39;&lt;,&#39;&gt; s/^/#</code> 即可在选中的文本上执行文本替换。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-161da4aa97379bda.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="select &amp; replace"></p><p>其中 <code>&#39;&lt;,&#39;&gt;</code> 即代表 visual 模式下选中的文本行。一般情况下，选中文本以后再按 <code>:</code> 进入命令模式，<code>&#39;&lt;,&#39;&gt;</code> 部分内容会自动补全。</p><h4 id="多行编辑"><a href="#多行编辑" class="headerlink" title="多行编辑"></a>多行编辑</h4><p>多行编辑指同时在多行文本中每一行的相同位置插入相同的内容。只需要编辑某一行文本，其他文本行就会自动进行同样的修改。</p><p>比如需要注释 Python 代码的前 3 行，就可以同时编辑这 3 行文本，在第一行行首插入 <code>#</code>，则前 3 行会同时被注释掉。</p><p>首先光标定位到第一行行首，按下键盘上的 <code>ctrl + v</code> 组合键（Windows 下可以用 <code>ctrl + q</code>）进入 Visual Block 模式，按两次 <code>j</code> 键下移光标，选中前三行的首字符。<br>再按下键盘上 <code>I</code>（大写）键进入插入模式，在第一行行首插入 <code>#</code> 字符。<br>按下 <code>Esc</code> 退出插入模式，则后两行行首也会自动插入 <code>#</code> 字符。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-b302ab3a0626969b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VISUAL BLOCK"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e830dec31ab8eef1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="before Esc"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7546479fe2f06f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="after Esc"></p><h4 id="录制-Macro"><a href="#录制-Macro" class="headerlink" title="录制 Macro"></a>录制 Macro</h4><p>Vim 中的<strong>宏</strong>（Macro）即一系列编辑操作的合集。<br>在 Vim 中，可以把需要重复执行的多步编辑操作录制下来，绑定到某个按键上。之后就可以按下 <code>@绑定的按键</code> 重复执行录制好的步骤。<br>有点像定义和调用函数。</p><p>使用 <code>q某按键</code> 开始录制宏，执行某些编辑操作后，再按下 <code>q</code> 结束录制。随后按下 <code>@某按键</code> 调用录制好的宏。</p><p>如需要注释前 3 行 Python 代码，则可以录制包含如下步骤的宏：</p><ul><li>在当前行的行首开始插入文本（<code>I</code>）</li><li>输入注释符号（<code>#</code>）</li><li>退出插入模式（<code>Esc</code>）</li><li>移动到下一行（<code>j</code>)</li></ul><p>上述宏中的操作步骤可以首尾相接，无限循环。即注释当前行，移动到下一行；注释当前行，移动到下一行。。。</p><p>具体的操作步骤如下：</p><ul><li>在 Normal 模式下，光标移动到首行，按下 <code>qq</code> 开始录制宏（录制结束后会绑定给 <code>q</code>）</li><li>按下 <code>I</code> 键（大写），进入行首插入模式</li><li>输入 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 移动光标到下一行文本</li><li>按下 <code>q</code> 结束宏的录制</li></ul><p>宏录制结束后，即可连按两次 <code>@q</code> 连续调用两次宏，分别注释第二行和第三行内容。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-397bc3a22c028f5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="recording macro"></p><h5 id="命令"><a href="#命令" class="headerlink" title=". 命令"></a><code>.</code> 命令</h5><p><code>.</code> 命令相当于一种简化了的宏。它表示重复应用上一步中对内容的更改。<br><code>.</code> 命令无需录制，但只会重复对内容的编辑（如插入、替换等），不会重复其他操作。<br>比如前面的需要注释 Python 代码的前三行，可以执行如下操作：</p><ul><li>光标定位到首行，按 <code>I</code>（大写）在行首插入内容</li><li>输入注释符号 <code>#</code></li><li>按下 <code>Esc</code> 退出插入模式</li><li>按下 <code>j</code> 跳转到下一行，按 <code>.</code> 重复执行对上一行的编辑操作（行首插入 <code>#</code>）</li><li>重复上一步操作（<code>j.</code>），注释第三行</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>在查阅资料的时候，还发现一个 <code>norm</code> 命令。<br>比如还是需要注释前 3 行，可以执行如下命令：<br><code>:1,3 norm I #</code></p><p>其中 <code>1,3</code> 表示只对 1 - 3 行应用后面的命令；<br><code>norm</code> 表示从 Normal 模式下开始；<br><code>I #</code> 表示进入插入模式（同时光标移动到行首），插入文本 <code>#</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://stackoverflow.com/questions/9549729/vim-insert-the-same-characters-across-multiple-lines" target="_blank" rel="noopener">Vim: insert the same characters across multiple lines</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;习惯问题，一直在用 Vim。之前装的几个插件，基本上覆盖了日常使用中的绝大部分场景。只是遇到需要多行注释的时候，一直没有一套比较直接的方法。&lt;br&gt;于是上网查了些资料，也实际测试了下效果。整理出一部分方法（不借助插件），以作备忘。&lt;/p&gt;
&lt;h4 id=&quot;字符串替换&quot;&gt;&lt;a
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Tools" scheme="https://rollingstarky.github.io/tags/Tools/"/>
    
      <category term="Tricks" scheme="https://rollingstarky.github.io/tags/Tricks/"/>
    
      <category term="Vim" scheme="https://rollingstarky.github.io/tags/Vim/"/>
    
      <category term="Editor" scheme="https://rollingstarky.github.io/tags/Editor/"/>
    
      <category term="Efficiency" scheme="https://rollingstarky.github.io/tags/Efficiency/"/>
    
      <category term="Macro" scheme="https://rollingstarky.github.io/tags/Macro/"/>
    
  </entry>
  
  <entry>
    <title>Effective Python 笔记 —— 并发与并行（subprocess、Thread、Lock）</title>
    <link href="https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/"/>
    <id>https://rollingstarky.github.io/2021/09/23/effective-python-notes-concurrency-subprocess-thread-and-lock/</id>
    <published>2021-09-22T16:00:00.000Z</published>
    <updated>2021-09-23T14:32:01.125Z</updated>
    
    <content type="html"><![CDATA[<h4 id="使用-subprocess-管理子进程"><a href="#使用-subprocess-管理子进程" class="headerlink" title="使用 subprocess 管理子进程"></a>使用 <code>subprocess</code> 管理子进程</h4><p>由 Python 启动的子进程能够以<strong>并行</strong>的方式运行，从而最大化地利用 CPU 的多个核心。</p><p>可以借助 <code>subprocess</code> 内置模块调用子进程。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">result = subprocess.run(</span><br><span class="line">    [<span class="string">'echo'</span>, <span class="string">'Hello from the child!'</span>],</span><br><span class="line">    capture_output=<span class="keyword">True</span>,</span><br><span class="line">    encoding=<span class="string">'utf-8'</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">result.check_returncode()</span><br><span class="line">print(result.stdout)</span><br><span class="line"><span class="comment"># =&gt; Hello from the child!</span></span><br></pre></td></tr></table></figure></p><p>子进程相对于其父进程是独立地运行的。<br>如果使用 <code>Popen</code> 类创建一个子进程处理某个任务，则主程序能够在处理其他任务的同时，通过轮询的方式定期查看子进程的状态，确认其是否已经终止运行。<br><code>Popen</code> 中的 <code>poll</code> 方法可以实时地检查子进程的运行状态。若子进程还在运行中，则返回 <code>None</code>；若子进程执行完毕，则返回一个 <em>returncode</em> 值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line"><span class="keyword">while</span> proc.poll() <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">    print(<span class="string">'Working...'</span>)</span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># Working...</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># Exit status 0</span></span><br></pre></td></tr></table></figure><p>解耦子进程与父进程使得父进程可以同时调用多个并行执行的子程序。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">sleep_procs = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'1'</span>])</span><br><span class="line">    sleep_procs.append(proc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> proc <span class="keyword">in</span> sleep_procs:</span><br><span class="line">    proc.communicate()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Finished in <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># =&gt; Finished in 1.01 seconds</span></span><br></pre></td></tr></table></figure></p><p>代码中的 <code>communicate</code> 方法可以用来与子进程通信并等待其终止，此处用于等待所有的子进程执行完毕。<br>如果上述代码中的子进程以顺序的方式执行，最终整体的延迟会达到 10s 以上。而实际的延迟只略大于 1s，即多个子进程之间是并行的关系。</p><p>可以通过<strong>管道</strong>从 Python 程序向调用的子进程传递数据，并获取子进程的输出内容。<br>比如调用如下形式的 Shell 测试脚本：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"><span class="built_in">echo</span> input your name</span><br><span class="line"><span class="built_in">read</span> name</span><br><span class="line"><span class="built_in">echo</span> your name is <span class="variable">$name</span></span><br></pre></td></tr></table></figure></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen(<span class="string">'bash name.sh'</span>,</span><br><span class="line">                        stdin=subprocess.PIPE,</span><br><span class="line">                        stdout=subprocess.PIPE,</span><br><span class="line">                        shell=<span class="keyword">True</span>)</span><br><span class="line">proc.stdin.write(<span class="string">b'john'</span>)</span><br><span class="line">proc.stdin.flush()</span><br><span class="line"></span><br><span class="line">stdout, stderr = proc.communicate()</span><br><span class="line">print(stdout)</span><br><span class="line"><span class="comment"># b'input your name\nyour name is john\n'</span></span><br></pre></td></tr></table></figure><p>其中在初始化 <code>Popen</code> 对象时，传入了 <code>stdin=subprocess.PIPE</code> 和 <code>stdout=subprocess.PIPE</code> 两个参数，目的是将子进程的标准输入 STDIN 绑定到 <code>proc</code> 实例的 <code>stdin</code> 属性上，将标准输出 STDOUT 绑定到 <code>proc</code> 实例的 <code>stdout</code> 属性上。从而可以使用 <code>proc.stdin.write()</code> 方法向子进程传入数据。<br><code>proc</code> 实例的 <code>communicate</code> 方法会等待子进程终止，并返回 <code>stdout</code> 和 <code>stderr</code>，即子进程的标准输出和标准错误输出。<br>若初始化 <code>Popen</code> 时未传入 <code>stdout=subprocess.PIPE</code> 参数，则上面返回的 <code>stdout</code> 为 <code>None</code>。</p><p>如果担心子程序永远不会终止或者长时间阻塞了输入和输出，可以向 <code>communicate</code> 方法传入 <code>timeout</code> 参数来指定等待的最长时间。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> subprocess</span><br><span class="line"></span><br><span class="line">proc = subprocess.Popen([<span class="string">'sleep'</span>, <span class="string">'10'</span>])</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    proc.communicate(timeout=<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">except</span> subprocess.TimeoutExpired:</span><br><span class="line">    proc.terminate()</span><br><span class="line">    proc.wait()</span><br><span class="line"></span><br><span class="line">print(<span class="string">'Exit status'</span>, proc.poll())</span><br><span class="line"><span class="comment"># Exit status -15</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul><li><code>subprocess</code> 模块可以调用子进程，且能够管理子进程的输入流和输出流，达到源程序与子进程交互的目的</li><li>子进程和 Python 解释器之间是并行运行的，因而可以最大化地利用 CPU 的多个核心</li><li><code>subprocess</code> 模块提供的 <code>run</code> 函数可以完成简单的调用操作，而 <code>Popen</code> 类提供了类似 Unix 管线的高级功能</li><li><code>communicate</code> 方法的 <code>timeout</code> 参数可以避免死锁及卡住的子进程</li></ul><h4 id="使用线程处理阻塞式-IO"><a href="#使用线程处理阻塞式-IO" class="headerlink" title="使用线程处理阻塞式 IO"></a>使用线程处理阻塞式 IO</h4><p>Python 的标准实现叫做 <strong>CPython</strong>。CPython 在运行 Python 程序时，会首先解析源代码并将其编译为字节码，再通过一个基于栈的解释器来运行字节码。<br>CPython 通过一种称为 <strong>GIL</strong> 的机制来管理解释器自身的状态信息，强化其一致性。GIL 是一种可以阻止 CPython 解释器受<strong>抢占式</strong>多线程影响的<strong>互斥锁</strong>（mutex），从而使控制程序的线程不会被另一个线程意外中断，导致解释器的状态发生混乱。</p><p>但 GIL 有一个非常严重的负面影响。不像 C++ 或 Java 等语言可以利用多线程最大化多核心 CPU 的计算能力，Python 虽然支持多线程，但 <strong>GIL 会导致任一时刻实际上都只能有一个线程在推进</strong>。<br>简单来说，Python 中的多线程不是<strong>并行</strong>计算，无法同时利用 CPU 的多个核心来提升<strong>计算密集型</strong>多任务的效率。</p><p>单线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    list(factorize(number))</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end - start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.19 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理计算密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorize</span><span class="params">(number)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, number + <span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> number % i == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactorizeThread</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, number)</span>:</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.number = number</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.factors = list(factorize(self.number))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">numbers = [<span class="number">21390799</span>, <span class="number">12147599</span>, <span class="number">15166379</span>, <span class="number">18522859</span>, <span class="number">12345678</span>, <span class="number">87654321</span>]</span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> number <span class="keyword">in</span> numbers:</span><br><span class="line">    thread = FactorizeThread(number)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">end = time.time()</span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;(end -start):<span class="number">.3</span>&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.3 seconds</span></span><br></pre></td></tr></table></figure></p><p>可以看出，Python 中的单线程和多线程在应对计算密集型任务时，两者的处理时间没有相差多少。</p><p>但是对于 <strong>IO 密集</strong> 型的任务，比如从磁盘读写文件、网络传输等<strong>阻塞式 IO</strong> 操作，使用 Python 中的多线程对于效率的提升就会非常显著。<br>多线程使得 CPU 不必去等待缓慢的文件读写等 IO 操作。</p><p>单线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    get_example_page()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 6.853585243225098 seconds</span></span><br></pre></td></tr></table></figure></p><p>多线程处理 IO 密集型任务：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_example_page</span><span class="params">()</span>:</span></span><br><span class="line">    urlopen(<span class="string">'https://example.org'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">start = time.time()</span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    thread = Thread(target=get_example_page)</span><br><span class="line">    thread.start()</span><br><span class="line">    threads.append(thread)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">print(<span class="string">f'Took <span class="subst">&#123;time.time() - start&#125;</span> seconds'</span>)</span><br><span class="line"><span class="comment"># Took 0.8039891719818115 seconds</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-1"><a href="#知识点-1" class="headerlink" title="知识点"></a>知识点</h5><ul><li>由于 GIL 的存在，Python 中的线程无法并行地在多个 CPU 核心上执行</li><li>Python 中的多线程能够并行地发起多个系统调用，因而可以同时处理计算任务和阻塞式 IO</li></ul><h4 id="使用-Lock-避免数据竞争"><a href="#使用-Lock-避免数据竞争" class="headerlink" title="使用 Lock 避免数据竞争"></a>使用 Lock 避免数据竞争</h4><p>GIL 总是会阻止 Python 代码在多个 CPU 核心上并行执行，任意时刻都只能有一个 Python 线程处于活跃状态。<br>但 GIL 并不会保护代码不受数据竞争的影响。一个线程对于数据结构的操作仍有可能被 Python 解释器中邻近的字节码破坏，尤其是在通过多线程同步地去访问同一个对象的时候。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Counter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = Counter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 252472</span></span><br></pre></td></tr></table></figure></p><p>上述代码模拟了一个从传感器网络并行地读取数据并计数的过程。对任意一个传感器，其数据的读取都属于阻塞式 IO，由独立的工作线程去处理，数据读取完成后该工作线程会调用一个计数器对象来累计结果。</p><p>但程序运行后，实际得到的计数结果与预期差距很大。<br>Python 解释器在执行多个线程时会确保这些线程之间的“平等关系”，令它们获得几乎相等的处理时间。这因此需要 Python 时不时地在线程间进行切换，暂时挂起一个正在运行的线程，转而去恢复执行另一个线程。<br>一个线程甚至有可能在看似符合原子性的操作中间被暂停。</p><p>比如 <code>+=</code> 操作符在作用到实例的属性上时，类似这样的代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counter.count += <span class="number">1</span></span><br></pre></td></tr></table></figure></p><p>实际上等同于 Python 做出如下所示的三个分开的步骤：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">value = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result = value + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result)</span><br></pre></td></tr></table></figure></p><p>再加上线程切换，就有可能导致出现下面这种情况：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Running in Thread A</span></span><br><span class="line">value_a = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line"><span class="comment"># Context switch to Thread B</span></span><br><span class="line">value_b = getattr(counter, <span class="string">'count'</span>)</span><br><span class="line">result_b = value_b + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_b)</span><br><span class="line"><span class="comment"># Context switch back to Thread A</span></span><br><span class="line">result_a = value_a + <span class="number">1</span></span><br><span class="line">setattr(counter, <span class="string">'count'</span>, result_a)</span><br></pre></td></tr></table></figure></p><p>即原本应该计算两次的累加操作实际上只有一次生效了，最终导致出现错误的结果。</p><p>为避免上述情形中的数据竞争或者其他形式的数据结构损坏现象，可以借助 <code>Lock</code> 类保护特定的值不被多个线程同步访问。即任一时刻都只能有一个线程可以获得该数据的锁。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread, Lock</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LockingCounter</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.lock = Lock()</span><br><span class="line">        self.count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">increment</span><span class="params">(self, offset)</span>:</span></span><br><span class="line">        <span class="keyword">with</span> self.lock:</span><br><span class="line">            self.count += offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(sensor_index, how_many, counter)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(how_many):</span><br><span class="line">        counter.increment(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">how_many = <span class="number">10</span> ** <span class="number">5</span></span><br><span class="line">counter = LockingCounter()</span><br><span class="line"></span><br><span class="line">threads = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    thread = Thread(target=worker,</span><br><span class="line">                    args=(i, how_many, counter))</span><br><span class="line">    threads.append(thread)</span><br><span class="line">    thread.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thread <span class="keyword">in</span> threads:</span><br><span class="line">    thread.join()</span><br><span class="line"></span><br><span class="line">expected = how_many * <span class="number">5</span></span><br><span class="line">found = counter.count</span><br><span class="line">print(<span class="string">f'Counter should be <span class="subst">&#123;expected&#125;</span>, got <span class="subst">&#123;found&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># Counter should be 500000, got 500000</span></span><br></pre></td></tr></table></figure></p><h5 id="知识点-2"><a href="#知识点-2" class="headerlink" title="知识点"></a>知识点</h5><ul><li>Python 有 GIL，但在编写代码时仍需关注多线程中的数据竞争</li><li>允许多个线程修改同一个不加锁的对象，有可能会损坏数据结构</li><li><code>Lock</code> 类可以保护多线程中数据的一致性</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://effectivepython.com/" target="_blank" rel="noopener">Effective PYTHON Second Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;使用-subprocess-管理子进程&quot;&gt;&lt;a href=&quot;#使用-subprocess-管理子进程&quot; class=&quot;headerlink&quot; title=&quot;使用 subprocess 管理子进程&quot;&gt;&lt;/a&gt;使用 &lt;code&gt;subprocess&lt;/code&gt; 管理
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Process" scheme="https://rollingstarky.github.io/tags/Process/"/>
    
      <category term="Lock" scheme="https://rollingstarky.github.io/tags/Lock/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——面向对象编程</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-oop/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:18:48.184Z</updated>
    
    <content type="html"><![CDATA[<p><strong>面向对象编程（OOP）</strong>是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。</p><p><strong>对象包含数据和行为</strong></p><p>面向对象的程序由对象构成。对象包装了数据和操作这些数据的流程（称作方法)。<br>基于这个定义，Rust 是面向对象的。比如结构体和枚举都可以包含数据，而 <code>impl</code> 块则提供了可用于结构体和枚举的方法。</p><h4 id="封装实现细节"><a href="#封装实现细节" class="headerlink" title="封装实现细节"></a>封装实现细节</h4><p>封装使得调用对象的外部代码无法直接访问对象内部的实现细节，而唯一可以与对象进行交互的方法便是通过它公开的接口。<br><strong>使用对象的代码不应当深入对象的内部去改变数据或行为，封装使得开发者在修改或重构对象的内部实现时无需改变调用这个对象的外部代码</strong>。</p><p>在 Rust 中，我们可以使用 <code>pub</code> 关键字来决定代码中哪些模块、类型、函数和方法是公开的，而默认情况下所有内容都是私有的。</p><p>如下面计算移动平均值的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">AveragedCollection</span></span> &#123;</span><br><span class="line">    list: <span class="built_in">Vec</span>&lt;<span class="built_in">i32</span>&gt;,</span><br><span class="line">    average: <span class="built_in">f64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> AveragedCollection &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">add</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">i32</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.list.push(value);</span><br><span class="line">        <span class="keyword">self</span>.update_average();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">remove</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> result = <span class="keyword">self</span>.list.pop();</span><br><span class="line">        <span class="keyword">match</span> result &#123;</span><br><span class="line">            <span class="literal">Some</span>(value) =&gt; &#123;</span><br><span class="line">                <span class="keyword">self</span>.update_average();</span><br><span class="line">                <span class="literal">Some</span>(value)</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="literal">None</span> =&gt; <span class="literal">None</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">average</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f64</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.average</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">update_average</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">let</span> total: <span class="built_in">i32</span> = <span class="keyword">self</span>.list.iter().sum();</span><br><span class="line">        <span class="keyword">self</span>.average = total <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.list.len() <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> collection = AveragedCollection &#123;</span><br><span class="line">        list: <span class="built_in">vec!</span>[],</span><br><span class="line">        average: <span class="number">0.0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    collection.add(<span class="number">1</span>);</span><br><span class="line">    collection.add(<span class="number">2</span>);</span><br><span class="line">    collection.add(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The average of the collection is: &#123;&#125;"</span>, collection.average());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先是定义了一个名为 <code>AveragedCollection</code> 的结构体，其 <code>list</code> 字段包含了一个存储 <code>i32</code> 元素的动态数组；为了避免每次取元素平均值的时候重复计算，又添加了一个用于存储平均值的 <code>average</code> 字段。<br>结构体本身被标记为 <code>pub</code> 使得其他代码可以使用它，但其内部字段仍然保持私有。<br>公共方法 <code>add</code>、<code>remove</code>、<code>average</code> 是仅有的几个可以访问或修改 <code>AveragedCollection</code> 实例中数据的方法。当用户调用 <code>add</code> 方法向 <code>list</code> 中添加元素，或者调用 <code>remove</code> 从 <code>list</code> 中删除元素时，方法内部的实现都会再调用私有方法 <code>update_average</code> 来更新 <code>average</code> 字段。</p><p>由于 <code>list</code> 和 <code>average</code> 字段是私有的，外部代码无法直接读取 <code>list</code> 字段来增加或删除其中的元素。<br>一旦缺少了这样的封装，<code>average</code> 字段便无法在用户私自更新 <code>list</code> 字段时同步保持更新。</p><p>因为结构体 <code>AveragedCollection</code> 封装了内部的实现细节，我们能够在未来轻松地改变数据结构等内部实现。比如可以在 <code>list</code> 字段上使用 <code>HashSet&lt;i32&gt;</code> 替代 <code>Vec&lt;i32&gt;</code>。<br>只要 <code>add</code>、<code>remove</code>、<code>average</code> 这几个公共方法的签名保持不变，正在使用 <code>AveragedCollection</code> 的外部代码就无需进行任何修改。<br>假如将 <code>list</code> 字段声明为 <code>pub</code>，就必然会失去上面这一优势。<code>HashSet&lt;i32&gt;</code> 和 <code>Vec&lt;i32&gt;</code> 在增加或删除元素时使用的具体方法是不同的，因此若直接修改 <code>list</code>，外部代码将不得不随之发生变化。</p><h4 id="作为类型系统和代码共享机制的继承"><a href="#作为类型系统和代码共享机制的继承" class="headerlink" title="作为类型系统和代码共享机制的继承"></a>作为类型系统和代码共享机制的继承</h4><p>继承机制使得对象可以沿用另一个对象的数据与行为，而无需重复定义代码。<br>Rust 中无法定义一个继承父结构体字段和方法的子结构体。</p><p>选择继承主要有两个原因。其一是代码复用，作为替代方案，可以使用 Rust 中的默认 <code>trait</code> 方法来进行代码共享。<br>它与继承十分相似，父类中实现的方法可以被继承它的子类所拥有；子类也可以选择覆盖父类中的方法。</p><p>另一个使用继承的原因与类型系统有关，希望子类型能够被应用到一个需要父类型的地方。即<strong>多态</strong>：<strong>如果一些对象具有某些共同的特征，则这些对象就可以在运行时相互替换使用</strong>。<br>可以在 Rust 中使用泛型来构建不同类型的抽象，并使用 <code>trait</code> 约束来决定类型必须提供的具体特性。这一技术被称为<strong>限定参数化多态</strong>。</p><p>许多较为新潮的语言已经不太喜欢将继承作为内置的程序设计方案，因为<strong>使用继承意味着你会无意间共享出比所需内容更多的代码</strong>。<br>子类并不应该总是共享父类的所有特性，但使用继承机制却会始终产生这样的结果，进而使程序设计缺乏灵活性。而某些语言强制要求子类只能继承自单个父类，进一步限制了程序设计的灵活性。</p><h4 id="使用-trait-对象来存储不同类型的值"><a href="#使用-trait-对象来存储不同类型的值" class="headerlink" title="使用 trait 对象来存储不同类型的值"></a>使用 trait 对象来存储不同类型的值</h4><p>动态数组有一个限制，即只能存储同一类型的元素。有些时候的变通方案可以使用枚举。<br>比如定义一个 <code>SpreadsheetCell</code> 枚举同时包含了可以持有整数、浮点数和文本的变体。这样我们就可以在每个表格中存储不同的数据类型，且依然能够用一个动态数组来表示一整行单元格。<br>但是总有某些时候，我们希望用户能够在特定的场景下为类型的集合进行扩展。</p><p>比如需要创建一个含有 GUI 库架构的 gui 包，并在包中提供一些可供用户使用的具体类型，如 <code>Button</code> 或 <code>TextField</code> 等，这些类型都实现了 <code>draw</code> 方法用于支持将其绘制到屏幕中。<br>此外，gui 的用户也应当能够创建支持绘制的自定义类型，如某些开发者可能会添加 <code>Image</code>，另一些可能会添加 <code>SelectBox</code> 等。<br>在那些支持继承的语言中，我们可以定义出一个拥有 <code>draw</code> 方法的 <code>Component</code> 类。其他如 <code>Button</code>、<code>Image</code>、<code>SelectBox</code> 等则都需要继承 <code>Component</code> 类来获得 <code>draw</code> 方法。<br>当然也可以选择覆盖 <code>draw</code> 方法来实现自定义行为，但框架会在处理过程中将它们全部视作 <code>Component</code> 类型的实例，并以此调用 <code>draw</code> 方法。</p><h5 id="为共有行为定义一个-trait"><a href="#为共有行为定义一个-trait" class="headerlink" title="为共有行为定义一个 trait"></a>为共有行为定义一个 trait</h5><p>Rust 没有继承功能。<br>为了在 gui 中实现预期的功能，需要定义一个拥有 <code>draw</code> 方法的 <code>Draw</code> trait。trait 对象可以被用在泛型或具体类型所处的位置，无论我们在哪里使用 trait 对象，Rust 类型系统都会在编译时确保出现在相应位置上的值实现了 trait 对象中的指定方法。</p><p>Rust 有意避免将结构体和枚举称为对象，以便于与其他语言中的对象区别开。<strong>对于结构体和枚举而言，其字段中的数据与 <code>impl</code> 块中的行为是分开的；而在其他语言中，数据和行为往往被组合在名为对象的概念中</strong>。<br>trait 对象则有些类似于其他语言中的对象，它也在某种程度上组合了数据和行为。但 trait 对象被专门用于抽象某些共有行为，没有其他语言中的对象那么通用。</p><p>创建一个名为 <code>gui</code> 的 Rust 项目：<br><code>cargo new gui</code></p><p>在 <code>lib.rs</code> 中定义一个拥有 <code>draw</code> 方法的 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Draw</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义一个持有 <code>components</code> 动态数组的 <code>Screen</code> 结构体，代码中的 <code>Box&lt;dyn Draw&gt;</code> 代表所有被放置在 <code>Box</code> 中且实现了 Draw trait 的具体类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Screen</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> components: <span class="built_in">Vec</span>&lt;<span class="built_in">Box</span>&lt;dyn Draw&gt;&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Screen</code> 结构体定义了一个名为 <code>run</code> 的方法，会逐一调用 <code>components</code> 中每个元素的 <code>draw</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">impl</span> Screen &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">run</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> component <span class="keyword">in</span> <span class="keyword">self</span>.components.iter() &#123;</span><br><span class="line">            component.draw();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="实现-trait"><a href="#实现-trait" class="headerlink" title="实现 trait"></a>实现 trait</h5><p>在代码中添加一些实现了 Draw trait 的具体类型。需要注意的是，<code>draw</code> 方法不会包含任何有意义的内容，仅作为演示：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Button</span></span> &#123;</span><br><span class="line">    <span class="keyword">pub</span> width: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> height: <span class="built_in">u32</span>, </span><br><span class="line">    <span class="keyword">pub</span> label: <span class="built_in">String</span>, </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> Button &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a button, the button's label is &#123;&#125;"</span>, <span class="keyword">self</span>.label);</span><br><span class="line">        <span class="comment">// 实际绘制一个按钮的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Button</code> 中持有的 <code>width</code>、<code>height</code> 和 <code>label</code> 字段也许会不同于其他组件中的字段，比如 <code>TextField</code> 类型就可能在这些字段外额外持有一个 <code>placeholder</code> 字段。<br>每一个希望绘制在屏幕上的类型都应当实现 Draw trait，并在 <code>draw</code> 方法中使用不同的代码来自定义具体的绘制行为。<br>除了实现 Draw trait，<code>Button</code> 类型也许会在另外的 <code>impl</code> 块中实现响应用户点击按钮时的行为，这些方法并不适用于 <code>TextField</code> 等其他类型。</p><p>用户也可以在 <code>main.rs</code> 中为<code>SelectBox</code> 这种自定义类型实现 Draw trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::Draw;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SelectBox</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">    options: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Draw <span class="keyword">for</span> SelectBox &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">draw</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Drawing a selectbox, the options are &#123;:?&#125;"</span>, <span class="keyword">self</span>.options);</span><br><span class="line">        <span class="comment">// 实际绘制一个选择框的代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时就可以在编写 <code>main</code> 函数的时候创建 <code>Screen</code> 实例了。使用 <code>Box&lt;T&gt;</code> 生成 <code>SelectBox</code> 或 <code>Button</code> 的 trait 对象，再将它们添加到 <code>Screen</code> 实例中。便可以运行 <code>Screen</code> 实例的 <code>run</code> 方法来依次调用所有组件的 <code>draw</code> 实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/main.rs</span></span><br><span class="line"><span class="keyword">use</span> gui::&#123;Screen, Button&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> scrren = Screen &#123;</span><br><span class="line">        components: <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">Box</span>::new(SelectBox &#123;</span><br><span class="line">                width: <span class="number">75</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                options: <span class="built_in">vec!</span>[</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Yes"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"Maybe"</span>),</span><br><span class="line">                    <span class="built_in">String</span>::from(<span class="string">"No"</span>),</span><br><span class="line">                ],</span><br><span class="line">            &#125;),</span><br><span class="line">            <span class="built_in">Box</span>::new(Button &#123;</span><br><span class="line">                width: <span class="number">50</span>,</span><br><span class="line">                height: <span class="number">10</span>,</span><br><span class="line">                label: <span class="built_in">String</span>::from(<span class="string">"OK"</span>),</span><br><span class="line">            &#125;),</span><br><span class="line">        ],</span><br><span class="line">    &#125;;</span><br><span class="line">    scrren.run()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// =&gt; Drawing a selectbox, the options are ["Yes", "Maybe", "No"]</span></span><br><span class="line"><span class="comment">// =&gt; Drawing a button, the button's label is OK</span></span><br></pre></td></tr></table></figure></p><p>我们在编写库的时候无法得知用户是否会添加自定义的 <code>SelectBox</code> 类型，但我们的 <code>Screen</code> 实现依然能够接收新的类型并完成绘制工作。因为 <code>SelectBox</code> 实现了 Draw trait 及其 <code>draw</code> 方法。</p><p><code>run</code> 方法只关心值对行为的响应，而不在意值的具体类型。这一概念与动态类型中的 <strong>duck typing</strong> 十分相似。<br>通过在定义动态数组 <code>components</code> 时指定 <code>Box&lt;dyn Draw&gt;</code> 元素类型，<code>Screen</code> 实例只会接收那些能够调用 <code>draw</code> 方法的值，而不会去检查该值究竟是 <code>Button</code> 实例还是 <code>SelectBox</code> 实例。</p><p>使用 trait 对象与类型系统实现 duck typing 的优势在于，不需要在运行时检查某个值是否实现了指定的方法，或者担心出现调用未定义方法等运行时错误。Rust 会在编译时发现这类错误。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;面向对象编程（OOP）&lt;/strong&gt;是一种程序建模的方法。通常认为面向对象的语言需要包含命名对象、封装、继承等特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对象包含数据和行为&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;面向对象的程序由对象构成。对象包装了数据和操作这些数据
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Trait" scheme="https://rollingstarky.github.io/tags/Trait/"/>
    
      <category term="Encapsulation" scheme="https://rollingstarky.github.io/tags/Encapsulation/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
      <category term="Polymorphism" scheme="https://rollingstarky.github.io/tags/Polymorphism/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——不安全 Rust</title>
    <link href="https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/"/>
    <id>https://rollingstarky.github.io/2021/08/11/the-rust-programming-language-reading-notes-unsafe-rust/</id>
    <published>2021-08-10T16:00:00.000Z</published>
    <updated>2021-08-11T14:11:49.524Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 内部隐藏了一种不会强制实施内存安全保障的语言：<strong>不安全 Rust</strong>。<br>其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。<br>使用不安全代码的缺点在于程序员需要对自己的行为负责。若错误地使用了不安全代码，就可能引发不安全的内存问题，如空指针解引用等。</p><p>另一个原因在于底层计算机硬件固有的不安全性。若 Rust 不允许进行不安全的操作，则某些底层任务可能根本就完成不了。</p><p>不安全 Rust 允许你执行 4 种在安全 Rust 中不被允许的操作：</p><ul><li>解引用裸指针</li><li>调用不安全的函数或方法</li><li>访问或修改可变的静态变量</li><li>实现不安全 trait</li></ul><p>可以在代码块前使用关键字 <code>unsafe</code> 来切换到不安全模式。<code>unsafe</code> 关键字并不会关闭借用检查器或禁用任何其他 Rust 安全检查。<code>unsafe</code> 仅仅令你可以访问上述 4 种不会被编译器检查的特性。因此即便处于不安全的代码块中，也仍然可以获得一定程度的安全性。</p><p><code>unsafe</code> 并不意味着块中的代码一定就是危险的或一定会导致内存安全问题，它仅仅是将责任转移到了程序员的肩上。<br>通过对 4 种不安全操作标记上 <code>unsafe</code>，可以在出现内存相关的错误时快速地将问题定位到 <code>unsafe</code> 代码块中。<br><strong>应当尽量避免使用 <code>unsafe</code> 代码块</strong>。</p><p>为了尽可能地隔离不安全代码，可以将其封装在一个安全的抽象中并提供一套安全的 API。实际上某些标准库功能同样使用了不安全代码，并以此为基础提供了安全的抽象接口。</p><h4 id="解引用裸指针"><a href="#解引用裸指针" class="headerlink" title="解引用裸指针"></a>解引用裸指针</h4><p>不安全 Rust 拥有两种类似于引用的新指针类型，都被叫做<strong>裸指针（raw pointer）</strong>。与引用类似，裸指针要么是可变的，要么是不可变的，分别写作 <code>*const T</code> 和 <code>*mut T</code>。这里的星号 <code>*</code> 是类型名的一部分而不代表解引用操作。</p><p>裸指针与引用、智能指针的区别：</p><ul><li>允许忽略借用规则，可以同时拥有指向同一个内存地址的可变和不可变指针，或者拥有指向同一个地址的多个可变指针</li><li>不能保证自己总是指向了有效的内存地址</li><li>允许为空</li><li>没有实现任何自动清理机制</li></ul><p>在避免 Rust 强制执行某些保障后，就能够以放弃安全保障为代价换取更好的性能，或者与其他语言、硬件进行交互的能力。</p><p><strong>通过引用创建裸指针</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中并没有使用 <code>unsafe</code> 关键字。你可以在安全代码内合法地创建裸指针，但不能在不安全代码块外解引用裸指针。</p><p>创建一个指向任意内存地址的裸指针，这个地址可能有数据，也可能没有数据，因此无法确定其有效性。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> address = <span class="number">0x012345usize</span>;</span><br><span class="line"><span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br></pre></td></tr></table></figure></p><p>为了使用 <code>*</code> 解引用裸指针，需要添加一个 <code>unsafe</code> 块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> num = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;num <span class="keyword">as</span> *<span class="keyword">const</span> <span class="built_in">i32</span>;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> num <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r1 is: &#123;&#125;"</span>, *r1);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"r2 is: &#123;&#125;"</span>, *r2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在使用裸指针时，我们可以创建同时指向同一地址的可变指针和不可变指针，并通过可变指针来修改数据。这样的修改操作会导致潜在的数据竞争。<br>裸指针主要用来与 C 代码接口进行交互，或者构造一些借用检查器无法理解的安全抽象。</p><h4 id="调用不安全函数或方法"><a href="#调用不安全函数或方法" class="headerlink" title="调用不安全函数或方法"></a>调用不安全函数或方法</h4><p>除了在定义前面要标记 <code>unsafe</code>，不安全函数或方法看上去与正常的函数或方法几乎一模一样。<br>这里的 <code>unsafe</code> 关键字意味着我们需要在调用该函数时手动满足一些先决条件，因为 Rust 无法对这些条件进行验证。通过在 <code>unsafe</code> 代码块中调用不安全函数，我们向 Rust 表明自己确实理解并实现了相关约定。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="function"><span class="keyword">fn</span> <span class="title">dangerous</span></span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> &#123;</span><br><span class="line">    dangerous();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为不安全函数的函数体也是 <code>unsafe</code> 代码块，你可以直接在一个不安全函数中执行其他不安全操作而无需添加额外的 <code>unsafe</code> 代码块。</p><h5 id="创建不安全代码的安全抽象"><a href="#创建不安全代码的安全抽象" class="headerlink" title="创建不安全代码的安全抽象"></a>创建不安全代码的安全抽象</h5><p>函数中包含不安全代码并不意味着我们需要将整个函数都标记为不安全的。实际上，将不安全代码封装在安全函数中是一种十分常见的抽象。</p><p>比如标准库中使用了不安全代码的 <code>split_at_mut</code> 函数。这个安全方法被定义在可变切片上，它接收一个切片并从给定的索引参数处将其分割为两个切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = r.split_at_mut(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们无法仅仅使用安全 Rust 来实现这个函数。比如尝试用安全代码将 <code>split_at_mut</code> 实现为函数，并只处理 i32 类型的切片：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    (&amp;<span class="keyword">mut</span> slice[..mid], &amp;<span class="keyword">mut</span> slice[mid..])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这个函数会首先取得整个切片的长度，并通过断言检查给定的参数是否小于或等于当前切片的长度。若大于则会在尝试使用该索引前触发 panic。<br>我们会返回一个包含两个可变切片的元组，一个从原切片的起始位置到 <code>mid</code> 索引的位置，另一个则从 <code>mid</code> 索引的位置到原切片的末尾。</p><p>尝试编译上述代码会触发 <code>error[E0499]: cannot borrow `*slice` as mutable more than once at a time</code> 错误。<br>Rust 的借用检查器无法理解我们正在借用一个切片的不同部分，它只知道我们借用了两次同一个切片。借用一个切片的不同部分从原理上来讲是没有任何问题的，因为没有交叉的地方。但 Rust 没有足够智能到理解这些信息。此类场景即适用于不安全代码。</p><p>使用 <code>unsafe</code>、裸指针及一些不安全函数实现 <code>split_at_mut</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">split_at_mut</span></span>(slice: &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], mid: <span class="built_in">usize</span>) -&gt; (&amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>], &amp;<span class="keyword">mut</span> [<span class="built_in">i32</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = slice.len();</span><br><span class="line">    <span class="keyword">let</span> ptr = slice.as_mut_ptr();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert!</span>(mid &lt;= len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        (</span><br><span class="line">            slice::from_raw_parts_mut(ptr, mid),</span><br><span class="line">            slice::from_raw_parts_mut(ptr.offset(mid <span class="keyword">as</span> <span class="built_in">isize</span>), len - mid),</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="keyword">let</span> r = &amp;<span class="keyword">mut</span> v[..];</span><br><span class="line">    <span class="keyword">let</span> (a, b) = split_at_mut(r, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(a, &amp;<span class="keyword">mut</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(b, &amp;<span class="keyword">mut</span> [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 unsafe 代码中，<code>slice::from_raw_parts_mut</code> 函数接收一个裸指针和长度来创建一个切片。这里使用该函数从 <code>ptr</code> 处创建了一个拥有 <code>mid</code> 个元素的切片，接着又在 <code>ptr</code> 上使用 <code>mid</code> 作为偏移量参数调用 <code>offset</code> 方法得到了一个从 <code>mid</code> 处开始的裸指针，并基于它创建了另外一个起始于 <code>mid</code> 处且拥有剩余所有元素的切片。</p><p>函数 <code>slice::from_raw_parts_mut</code> 接收一个裸指针作为参数并默认该参数的合法性，所以它是不安全的。裸指针的 <code>offset</code> 方法默认此地址的偏移量也是一个有效的指针，它也是不安全的。<br>因此我们必须在 <code>unsafe</code> 代码块中调用上述两个函数。通过审查代码并添加断言，我们可以确定 <code>unsafe</code> 中的裸指针都会指向有效的切片数据且不会产生数据竞争。这就是一个恰当的 <code>unsafe</code> 使用场景。</p><p>代码没有将 <code>split_at_mut</code> 函数标记为 <code>unsafe</code>，因此我们可以在安全 Rust 中调用该函数。这就是对不安全代码的安全抽象。</p><p>与上述代码相反，下面对 <code>slice::from_raw_parts_mut</code> 函数的调用就很有可能导致崩溃。其试图用一个随意的内存地址来创建拥有 10000 个元素的切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::slice;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> address = <span class="number">0x01234usize</span>;</span><br><span class="line">    <span class="keyword">let</span> r = address <span class="keyword">as</span> *<span class="keyword">mut</span> <span class="built_in">i32</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> slice: &amp;[<span class="built_in">i32</span>] = <span class="keyword">unsafe</span> &#123; slice::from_raw_parts_mut(r, <span class="number">10000</span>) &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, slice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-extern-函数调用外部代码"><a href="#使用-extern-函数调用外部代码" class="headerlink" title="使用 extern 函数调用外部代码"></a>使用 <code>extern</code> 函数调用外部代码</h5><p>Rust 代码可能需要与另外一种语言编写的代码进行交互。Rust 为此提供了 <code>extern</code> 关键字来简化创建和使用<strong>外部函数接口（FFI）</strong>的过程。<br>任何 <code>extern</code> 块中声明的函数都是不安全的。因为其他语言不会强制执行 Rust 遵守的规则，Rust 又无法对它们进行检查。因此保证安全的责任就落到了开发者身上。</p><p>下面的代码集成了 C 标准库中的 <code>abs</code> 函数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">abs</span></span>(input: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Absolute value of -3: &#123;&#125;"</span>, abs(-<span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="访问或修改静态变量"><a href="#访问或修改静态变量" class="headerlink" title="访问或修改静态变量"></a>访问或修改静态变量</h4><p>Rust 支持全局变量，但在使用的过程中可能因为所有权机制而产生某些问题。如果两个线程同时访问同一个可变的全局变量，就会产生数据竞争。<br>全局变量也被称为<strong>静态（static）变量</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> HELLO_WORLD: &amp;<span class="built_in">str</span> = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"name is: &#123;&#125;"</span>, HELLO_WORLD);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>静态变量必须要标注类型，访问一个不可变的静态变量是安全的。<br>静态变量的值在内存中拥有固定的地址，使用它的值总会访问到同样的数据。而常量则允许在任何被使用到的时候复制其数据。<br>与常量不同的是，静态变量是可变的。但访问和修改可变的静态变量是不安全的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">mut</span> COUNTER: <span class="built_in">u32</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">add_to_count</span></span>(inc: <span class="built_in">u32</span>) &#123;</span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        COUNTER += inc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    add_to_count(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsafe</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"COUNTER: &#123;&#125;"</span>, COUNTER);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，任何读写静态变量 <code>COUNTER</code> 的代码都必须位于 <code>unsafe</code> 代码块中。</p><h4 id="实现不安全-trait"><a href="#实现不安全-trait" class="headerlink" title="实现不安全 trait"></a>实现不安全 trait</h4><p>当某个 trait 中存在至少一个方法拥有编译器无法校验的不安全因素时，我们就称这个 trait 是不安全的。可以在 trait 定义的前面加上 <code>unsafe</code> 关键字来声明一个不安全 trait，同时该 trait 也只能在 <code>unsafe</code> 代码块中实现。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsafe</span> <span class="class"><span class="keyword">trait</span> <span class="title">Foo</span></span> &#123;</span><br><span class="line">    <span class="comment">// 某些方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">unsafe</span> <span class="keyword">impl</span> Foo <span class="keyword">for</span> <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="comment">// 对应的方法实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过使用 <code>unsafe impl</code>，我们向 Rust 保证我们会手动维护好那些编译器无法验证的不安全因素。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 内部隐藏了一种不会强制实施内存安全保障的语言：&lt;strong&gt;不安全 Rust&lt;/strong&gt;。&lt;br&gt;其之所以存在，是因为静态分析从本质上讲是保守的，它宁可错杀一些合法程序也不会接受可能非法的代码。&lt;br&gt;使用不安全代码的缺点在于程序员需要对自己的行为负责。若
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
      <category term="Unsafe" scheme="https://rollingstarky.github.io/tags/Unsafe/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——并发</title>
    <link href="https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/"/>
    <id>https://rollingstarky.github.io/2021/07/29/the-rust-programming-language-reading-notes-concurrency/</id>
    <published>2021-07-28T16:00:00.000Z</published>
    <updated>2021-07-28T16:58:34.590Z</updated>
    
    <content type="html"><![CDATA[<p><strong>并发编程（concurrent programming）</strong>允许程序中的不同部分相互独立地运行，而<strong>并行编程（parallel programming）</strong>则允许程序中的不同部分同时执行。<br>Rust 中的所有权和类型系统能够同时帮助开发者管理内存安全及并发问题。</p><p>高级语言往往通过放弃部分控制能力来获得有益于用户的抽象，因此只支持全部解决方案的一部分是可以理解的设计策略。比如 Erlang 提供了一套优雅的消息传递并发特性，但没有提供可以在线程间共享状态的简单方法。<br>底层语言被期望在任意场景下都可以提供一套性能最佳的解决方案，并对硬件建立尽可能少的抽象，因此 Rust 提供了多种建模并发问题的工具。</p><h4 id="使用线程同时运行代码"><a href="#使用线程同时运行代码" class="headerlink" title="使用线程同时运行代码"></a>使用线程同时运行代码</h4><p>多个线程可以同时运行，因此将程序中的计算操作拆分至多个线程可以提高性能。但也增加了程序的复杂度，因为<strong>不同线程在执行过程中的具体顺序是无法确定的</strong>。可能导致下列问题：</p><ul><li>当多个线程以不一致的顺序访问数据或资源时产生的<strong>竞争状态（race condition）</strong></li><li>当两个线程同时尝试获取对方持有的资源时产生的<strong>死锁（deadlock）</strong>，会导致这两个线程都无法继续运行</li><li>只会出现在特定情形下且难以稳定复现和修复的 bug</li></ul><h5 id="使用-spawn-创建新线程"><a href="#使用-spawn-创建新线程" class="headerlink" title="使用 spawn 创建新线程"></a>使用 <code>spawn</code> 创建新线程</h5><p>可以调用 <code>thread::spawn</code> 函数来创建线程，它接收一个闭包作为参数，该闭包会包含我们想要在新线程中运行的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>主线程首先打印出了文本，即便新线程的打印语句出现得更早一些。这些线程可能会交替执行，执行顺序由操作系统的线程调度策略决定。<br>需要注意的是，只要上述程序中的主线程运行结束，创建出的新线程也会停止，不管其打印任务是否完成。<br>虽然我们要求新线程不停打印文本直到 <code>i</code> 迭代到 9，但它在主线程停止前仅迭代到了 5。</p><h5 id="使用-join-句柄等待所有线程结束"><a href="#使用-join-句柄等待所有线程结束" class="headerlink" title="使用 join 句柄等待所有线程结束"></a>使用 <code>join</code> 句柄等待所有线程结束</h5><p><code>thread::spawn</code> 的返回类型是一个自持有所有权的 <code>joinHandle</code>，调用它的 <code>join</code> 方法可以阻塞当前线程直到对应的新线程运行结束。</p><p>调用 <code>join</code> 方法保证新线程能够在 <code>main</code> 函数退出前执行完毕：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>输出结果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the main thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br></pre></td></tr></table></figure></p><p>假如将 <code>handle.join()</code> 放置到 <code>main</code> 函数的 <code>for</code> 循环之前，即：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">10</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the spawned thread!"</span>, i);</span><br><span class="line">            thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"hi number &#123;&#125; from the main thread!"</span>, i);</span><br><span class="line">        thread::sleep(Duration::from_millis(<span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，由于主线程会等待新线程执行完毕后才开始执行自己的 <code>for</code> 循环，程序的输出将不再出现交替的情形：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">hi number 1 from the spawned thread!</span><br><span class="line">hi number 2 from the spawned thread!</span><br><span class="line">hi number 3 from the spawned thread!</span><br><span class="line">hi number 4 from the spawned thread!</span><br><span class="line">hi number 5 from the spawned thread!</span><br><span class="line">hi number 6 from the spawned thread!</span><br><span class="line">hi number 7 from the spawned thread!</span><br><span class="line">hi number 8 from the spawned thread!</span><br><span class="line">hi number 9 from the spawned thread!</span><br><span class="line">hi number 1 from the main thread!</span><br><span class="line">hi number 2 from the main thread!</span><br><span class="line">hi number 3 from the main thread!</span><br><span class="line">hi number 4 from the main thread!</span><br></pre></td></tr></table></figure></p><p>在并发编程中，诸如在哪里调用 <code>join</code> 等微小细节也会影响到多个线程是否能够同时运行。</p><h5 id="在线程中使用-move-闭包"><a href="#在线程中使用-move-闭包" class="headerlink" title="在线程中使用 move 闭包"></a>在线程中使用 <code>move</code> 闭包</h5><p><code>move</code> 闭包常被用来与 <code>thread::spawn</code> 函数配合使用，允许在某个线程中使用来自另一个线程的数据。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(|| &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在编译上述代码时会报出 <code>error[E0373]: closure may outlive the current function, but it borrows `v`, which is owned by the current function</code> 错误。<br>Rust 在推导出如何捕获 <code>v</code> 后决定让闭包借用 <code>v</code>，因为闭包中的 <code>println!</code> 只需要使用 <code>v</code> 的引用。但 Rust 不知道新线程会运行多久，因此它无法确定 <code>v</code> 的引用是否一直有效。</p><p>通过在闭包前添加 <code>move</code> 关键字，会强制闭包获得它所需值的所有权，而不仅仅是基于 Rust 的推导来获得值的借用。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Here's a vector: &#123;:?&#125;"</span>, v);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    handle.join().unwrap();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="使用消息传递在线程间转移数据"><a href="#使用消息传递在线程间转移数据" class="headerlink" title="使用消息传递在线程间转移数据"></a>使用消息传递在线程间转移数据</h4><p>使用消息传递（message passing）机制来保证并发安全正变得越来越流行。Go 语言文档中的口号正体现了这样的思路：<strong>不要通过共享内存来通信，而是通过通信来共享内存</strong>。</p><p>Rust 的标准库中实现了一个名为<strong>通道（channel）</strong>的编程概念，可以被用来实现基于消息传递的并发机制。<br>通道由发送者（transmitter）和接收者（receiver）两部分组成。发送者位于通道的上游，接收者位于下游。<br>某一处的代码可以通过调用发送者的方法来传送数据，另一处代码则可以通过检查接收者来获取数据。<br>当发送者或接收者的任何一端被丢弃，则相应的通道被关闭。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> val = <span class="built_in">String</span>::from(<span class="string">"hi"</span>);</span><br><span class="line">        tx.send(val).unwrap();</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> received = rx.recv().unwrap();</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br></pre></td></tr></table></figure><p>上述代码使用 <code>mpsc::channel</code> 函数创建了一个新的通道。<strong>mpsc</strong> 是英文 <strong>multiple producer, single consum</strong>（多个生产者，单个消费者）的缩写。<br><code>mpsc::channel</code> 会返回一个含有发送端与接收端的元组。<br>再使用 <code>thread::spawn</code> 生成一个新线程。为了令新线程拥有发送端 <code>tx</code> 的所有权，使用 <code>move</code> 关键字将 <code>tx</code> 移动到了闭包的环境中。<br>新线程必须拥有通道发送端的所有权才能通过通道来发送消息。<br>发送端提供了 <code>send</code> 方法来处理我们想要发送的值，该方法会返回 <code>Result&lt;T, E&gt;</code> 类型作为结果。当接收端已经被丢弃而无法继续传递内容时，执行发送操作会返回一个错误。</p><p>通道的接收端有两个可用于获取消息的方法。其中 <code>recv</code> 会阻塞主线程的执行直到有值被传入通道。一旦有值传入通道，<code>recv</code> 就会将其包裹在 <code>Result&lt;T, E&gt;</code> 中返回。若通道的发送端全部关闭了，<code>recv</code> 会返回一个错误来表明当前通道再也没有可接收的值。<br><code>try_recv</code> 方法不会阻塞线程，它会立即返回 <code>Result&lt;T, E&gt;</code>。当通道中存在消息时，返回包含该消息的 <code>Ok</code> 变体；否则返回 <code>Err</code> 变体。可以编写一个不断调用 <code>try_recv</code> 方法的循环，并在有消息时对其进行处理，没有消息时执行其他指令。</p><h5 id="发送多个值"><a href="#发送多个值" class="headerlink" title="发送多个值"></a>发送多个值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure><p>上述代码会迭代新线程中的动态数组来逐个发送其中的字符串，并在每次发送后调用 <code>thread::sleep</code> 函数来稍作暂停。<br>在主线程中，我们会将 <code>rx</code> 视作迭代器，不再显式地调用 <code>recv</code> 函数。迭代中的代码会打印出每个接收到的值，并在通道关闭时退出循环。<br>代码执行时每次打印后都会出现 1 秒的时间间隔。但我们并没有在主线程的 <code>for</code> 循环中执行延迟指令，表明主线程确实在等待接收新线程中传递过来的值。</p><h5 id="通过克隆发送者创建多个生产者"><a href="#通过克隆发送者创建多个生产者" class="headerlink" title="通过克隆发送者创建多个生产者"></a>通过克隆发送者创建多个生产者</h5><p>通过克隆通道的发送端来创建出多个能够发送值到同一个接收端的线程：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::mpsc;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"><span class="keyword">use</span> std::time::Duration;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> (tx, rx) = mpsc::channel();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> tx1 = mpsc::Sender::clone(&amp;tx);</span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"hi"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"from"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"the"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"thread"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx1.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">        <span class="keyword">let</span> vals = <span class="built_in">vec!</span>[</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"more"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"messages"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"for"</span>),</span><br><span class="line">            <span class="built_in">String</span>::from(<span class="string">"you"</span>),</span><br><span class="line">        ];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> val <span class="keyword">in</span> vals &#123;</span><br><span class="line">            tx.send(val).unwrap();</span><br><span class="line">            thread::sleep(Duration::from_secs(<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> received <span class="keyword">in</span> rx &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Got: &#123;&#125;"</span>, received);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Got: hi</span></span><br><span class="line"><span class="comment">// =&gt; Got: more</span></span><br><span class="line"><span class="comment">// =&gt; Got: from</span></span><br><span class="line"><span class="comment">// =&gt; Got: messages</span></span><br><span class="line"><span class="comment">// =&gt; Got: for</span></span><br><span class="line"><span class="comment">// =&gt; Got: the</span></span><br><span class="line"><span class="comment">// =&gt; Got: you</span></span><br><span class="line"><span class="comment">// =&gt; Got: thread</span></span><br></pre></td></tr></table></figure></p><h4 id="共享状态的并发"><a href="#共享状态的并发" class="headerlink" title="共享状态的并发"></a>共享状态的并发</h4><p>从某种程度上来说，任何编程语言中的通道都有些类似于<strong>单一所有权</strong>的概念。因为用户不应该在值传递给通道后再次使用它。<br>基于共享内存的并发通信机制更类似于<strong>多重所有权</strong>概念，多个线程可以同时访问相同的内存地址。<br>我们可以通过智能指针实现多重所有权，但由于需要同时管理多个所有者，会为系统增加额外的复杂性。当然，Rust 的类型系统和所有权规则有助于正确地管理这些所有权。</p><h5 id="互斥体（mutex）"><a href="#互斥体（mutex）" class="headerlink" title="互斥体（mutex）"></a>互斥体（mutex）</h5><p><strong>互斥体在任意时刻只允许一个线程访问数据</strong>。为了访问互斥体中的数据，线程必须首先发出信号来获取互斥体的锁（lock）。<br>锁是互斥体的一部分，这种数据结构被用来记录当前谁拥有数据的唯一访问权。</p><p>关于互斥体必须牢记以下两条规则：</p><ul><li>必须在使用数据前尝试获取锁</li><li>必须在使用完互斥体守护的数据后释放锁，这样其他线程才能继续执行获取锁的操作</li></ul><p>在单线程环境中使用互斥体：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Mutex::new(<span class="number">5</span>);</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> num = m.lock().unwrap();</span><br><span class="line">        *num = <span class="number">6</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"m = &#123;:?&#125;"</span>, m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; m = Mutex &#123; data: 6 &#125;</span></span><br></pre></td></tr></table></figure></p><p>为了访问 <code>Mutex&lt;T&gt;</code> 实例中的数据，我们首先需要调用其 <code>lock</code> 方法来获取锁。此调用会阻塞当前线程直到我们取得锁为止。<br>当前线程对于 <code>lock</code> 函数的调用会在其他某个持有锁的线程发生 <code>panic</code> 时失败，因此上述代码选择使用 <code>unwrap</code> 在意外发生时触发当前线程的 <code>panic</code>。</p><p>一旦获取了锁，便可以将它的返回值 <code>num</code> 视作一个指向内部数据的可变引用。<br>Rust 的类型系统会确保我们在使用 <code>m</code> 的值之前执行加锁操作。因为 <code>Mutex&lt;i32&gt;</code> 并不是 <code>i32</code> 类型，我们必须获取锁才能使用其内部的 <code>i32</code> 值。</p><p>实际上对 <code>lock</code> 的调用会返回一个名为 <code>MutexGuard</code> 的智能指针。该智能指针通过实现 <code>Deref</code> 来指向存储在内部的数据，通过实现 <code>Drop</code> 完成自己离开作用域时的自动解锁操作。<br>这种释放过程会发生在内部作用域的结尾处，因此我们不会因为忘记释放锁而导致其他线程无法继续使用该互斥体。</p><h5 id="多个线程间共享-Mutex-lt-T-gt"><a href="#多个线程间共享-Mutex-lt-T-gt" class="headerlink" title="多个线程间共享 Mutex&lt;T&gt;"></a>多个线程间共享 <code>Mutex&lt;T&gt;</code></h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Mutex::new(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码会依次启动 10 个线程，并在每个线程中分别为共享的计数器的值加 1。<br>但代码目前无法通过编译，会报出 <strong>error[E0382]: use of moved value: <code>counter</code></strong> 错误。<br>原因是变量 <code>counter</code> 被移动进了 <code>handle</code> 指代的线程中，这一移动行为阻止我们在另一个线程中调用 <code>lock</code> 来再次捕获 <code>counter</code>。</p><h5 id="多线程与多重所有权"><a href="#多线程与多重所有权" class="headerlink" title="多线程与多重所有权"></a>多线程与多重所有权</h5><p>智能指针 <code>Rc&lt;T&gt;</code> 提供的引用计数能够为单个值赋予多个所有者。<br>现在尝试使用 <code>Rc&lt;T&gt;</code> 来包裹 <code>Mutex&lt;T&gt;</code>，并在每次需要移动所有权至线程时克隆 <code>Rc&lt;T&gt;</code>。看改进后的程序能否编译通过。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"><span class="keyword">use</span> std::sync::Mutex;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Rc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Rc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再次尝试编译代码，报出另外一个错误：<code>error[E0277]: `Rc&lt;Mutex&lt;i32&gt;&gt;` cannot be sent between threads safely</code>。<br>原因是 <code>Rc&lt;T&gt;</code> 在跨线程使用时并不安全。<code>Rc&lt;T&gt;</code> 会在每次调用 <code>clone</code> 的过程中增加引用计数，在克隆出的实例被丢弃后减少引用计数。但它并没有使用任何并发原语来保证修改计数的过程中不会被另一个线程所打断。这极有可能导致计数错误并产生诡异的 bug。</p><h5 id="原子引用计数-Arc-lt-T-gt"><a href="#原子引用计数-Arc-lt-T-gt" class="headerlink" title="原子引用计数 Arc&lt;T&gt;"></a>原子引用计数 <code>Arc&lt;T&gt;</code></h5><p><code>Arc&lt;T&gt;</code> 类型既拥有类似于 <code>Rc&lt;T&gt;</code> 的行为，又保证自己可以被安全地用于并发场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::sync::&#123;Arc, Mutex&#125;;</span><br><span class="line"><span class="keyword">use</span> std::thread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = Arc::new(Mutex::new(<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> handles = <span class="built_in">vec!</span>[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> counter = Arc::clone(&amp;counter);</span><br><span class="line">        <span class="keyword">let</span> handle = thread::spawn(<span class="keyword">move</span> || &#123;</span><br><span class="line">            <span class="keyword">let</span> <span class="keyword">mut</span> num = counter.lock().unwrap();</span><br><span class="line">            *num += <span class="number">1</span>;</span><br><span class="line">        &#125;);</span><br><span class="line">        handles.push(handle);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> handle <span class="keyword">in</span> handles &#123;</span><br><span class="line">        handle.join().unwrap();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Result: &#123;&#125;"</span>, *counter.lock().unwrap());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; Result: 10</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>Arc&lt;T&gt;</code> 替换掉代码中的 <code>Rc&lt;T&gt;</code> 后，代码可以编译通过。</p><p>需要注意的是，Rust 并不能使你完全避免使用 <code>Mutex&lt;T&gt;</code> 过程中所有的逻辑错误。使用 <code>Mutex&lt;T&gt;</code> 也会有产生死锁（deadlock）的风险。当某个操作需要同时锁住两个资源，而两个线程分别持有其中一个锁并相互请求另外一个锁时，这两个线程就会陷入无穷尽的等待过程。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;并发编程（concurrent programming）&lt;/strong&gt;允许程序中的不同部分相互独立地运行，而&lt;strong&gt;并行编程（parallel programming）&lt;/strong&gt;则允许程序中的不同部分同时执行。&lt;br&gt;Rust 中的所有权
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Deadlock" scheme="https://rollingstarky.github.io/tags/Deadlock/"/>
    
      <category term="Channel" scheme="https://rollingstarky.github.io/tags/Channel/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——智能指针</title>
    <link href="https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/"/>
    <id>https://rollingstarky.github.io/2021/07/26/the-rust-programming-language-reading-notes-smart-pointer/</id>
    <published>2021-07-25T16:00:00.000Z</published>
    <updated>2021-07-26T15:34:22.264Z</updated>
    
    <content type="html"><![CDATA[<p><strong>指针（pointer）</strong>是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。<br>Rust 中最常见的指针是<strong>引用</strong>，会<strong>借用</strong>它所指向的数据。除此之外，引用没有任何其他功能和额外的开销。<br><strong>智能指针（smart pointer）</strong>是一种数据结构，它的行为类似于指针但<strong>拥有额外的元数据和附加功能</strong>。</p><p>在拥有所有权和借用概念的 Rust 中：<strong>引用只是用来借用数据的指针；而大多数智能指针本身就拥有它们指向的值</strong>。<br>比如 <code>String</code> 和 <code>Vec&lt;T&gt;</code> 类型就都可以被算作智能指针。它们都拥有一片内存区域并允许用户对其进行操作，拥有元数据（如容量等），能提供额外的功能或保障（如 <code>String</code> 会保证其中的数据必是合法的 <code>UTF-8</code> 编码）。</p><p>通常使用结构体来实现智能指针。区别于普通的结构体，智能指针会实现 <code>Deref</code> 与 <code>Drop</code> 这两个 <code>trait</code>。Deref trait 使得智能指针的实例拥有与引用一致的行为；Drop trait 使得用户可以自定义智能指针离开作用域时运行的代码。</p><p>标准库中最为常见的智能指针如下：</p><ul><li><code>Box&lt;T&gt;</code>：可用于在堆上分配数据</li><li><code>Rc&lt;T&gt;</code>：具备多重所有权的<strong>引用计数类型</strong></li><li><code>Ref&lt;T&gt;</code> 和 <code>ReMut&lt;T&gt;</code>：可以通过 <code>RefCell&lt;T&gt;</code> 访问，是一种可以在运行时而不是编译时执行借用规则的类型</li></ul><h4 id="使用-Box-lt-T-gt-在堆上分配数据"><a href="#使用-Box-lt-T-gt-在堆上分配数据" class="headerlink" title="使用 Box&lt;T&gt; 在堆上分配数据"></a>使用 <code>Box&lt;T&gt;</code> 在堆上分配数据</h4><p><strong>装箱（box）</strong>是最简单的一种智能指针，其类型为 <code>Box&lt;T&gt;</code>。它使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针。</p><p>装箱常被用于以下场景：</p><ul><li>拥有一个无法在编译时确定大小的类型，但又想在一个要求固定尺寸的上下文环境中使用这个类型</li><li>需要传递大量数据的所有权，但又不希望产生大量数据的复制行为</li><li>希望拥有一个实现了指定 trait 的类型值，但又不关心具体的类型</li></ul><p>使用装箱在堆上存储一个 <code>i32</code> 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Box</span>::new(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b = &#123;&#125;"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将单一值存放在堆上没有太大用处，大部分情况下都可以将类似的单个 <code>i32</code> 值默认放置在栈上。</p><h5 id="使用装箱定义递归类型"><a href="#使用装箱定义递归类型" class="headerlink" title="使用装箱定义递归类型"></a>使用装箱定义递归类型</h5><p>Rust 必须在编译时知道每一种类型占据的空间大小，但有一种被称为<strong>递归</strong>的类型无法在编译时确定具体大小。<br>递归类型的值可以在自身中存储另一个相同类型的值，这种嵌套理论上可以无穷无尽地进行下去，根本无法计算出具体的空间大小。</p><p>链接列表（cons list）是一种在函数式语言中非常常见的数据类型。<code>cons</code> 函数会将两个参数组成一个二元组，而这个元组通常由一个值和另一个二元组组成，通过这种不断嵌套元组的形式最终组成一个列表。<br>使用枚举来定义一个链接列表：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, List),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, Cons(<span class="number">2</span>, Cons(<span class="number">3</span>, Nil)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码在编译时会报出 <code>error[E0072]: recursive type `List` has infinite size</code> 错误。</p><p>Rust 在计算枚举类型需要的空间大小时，会遍历枚举中的每一个成员来找到需要最大空间的那个变体。因为在每个时间点，只会有一个变体存在。<br>对于递归类型大小的计算，以前面的 <code>List</code> 为例，编译器会先检查 <code>Cons</code> 变体，它持有一个 <code>i32</code> 类型的值及另外一个 <code>List</code> 类型；为了确定此处<code>List</code> 的大小，编译器又会从 <code>Cons</code> 开始遍历其下的所有变体，这样的检查将永远进行下去。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-23761fd6dc9ac77d.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="包含无穷多 Cons 变体的无穷 List"></p><p>可以使用 <code>Box&lt;T&gt;</code> 将递归类型的大小固定下来。<br><code>Box&lt;T&gt;</code> 是一个指针，其大小总是恒定的，不会因为指向数据的大小而发生变化。我们可以在 <code>Cons</code> 变体中存放一个 <code>Box&lt;T&gt;</code> 指针，<code>Box&lt;T&gt;</code> 指向下一个存储在堆上的 <code>List</code>。即嵌套的 <code>List</code> 并没有直接存放在 <code>Cons</code> 变体中，而是放置在堆上，打破了无限递归的过程。<br>此时任意的 <code>List</code> 值都只需要占用一个 <code>i32</code> 值加上一个装箱指针的大小。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-688437fa1045d8cb.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Box in Cons"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> list = Cons(<span class="number">1</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">2</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(Nil))))));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装箱除了间接访问内存和堆分配，没有提供任何其他的特殊功能，也没有这些特殊功能附带的性能开销。因此正好能被用在类似于链接列表这类只是需要间接访问的场景中。</p><h4 id="通过-Deref-trait-将智能指针视作常规引用"><a href="#通过-Deref-trait-将智能指针视作常规引用" class="headerlink" title="通过 Deref trait 将智能指针视作常规引用"></a>通过 <code>Deref trait</code> 将智能指针视作常规引用</h4><p>实现 <code>Deref trait</code> 使我们可以自定义解引用运算符 <code>*</code> 的行为，这意味着原本用于处理引用的代码可以不加修改地用于处理智能指针。</p><h5 id="使用解引用跳转到指针指向的值"><a href="#使用解引用跳转到指针指向的值" class="headerlink" title="使用解引用跳转到指针指向的值"></a>使用解引用跳转到指针指向的值</h5><p>指针可以被理解为一种箭头，会指向存储在别处的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;x;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>数字和引用是两种不同的类型，所以不能直接比较 <code>5</code> 和 <code>y</code>。必须使用 <code>*y</code> 来跳转到引用指向的值。</p><h5 id="把-Box-lt-T-gt-当成引用来操作"><a href="#把-Box-lt-T-gt-当成引用来操作" class="headerlink" title="把 Box&lt;T&gt; 当成引用来操作"></a>把 <code>Box&lt;T&gt;</code> 当成引用来操作</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = <span class="built_in">Box</span>::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="自定义智能指针"><a href="#自定义智能指针" class="headerlink" title="自定义智能指针"></a>自定义智能指针</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = MyBox::new(x);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">5</span>, *y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的 <code>MyBox</code> 是一个拥有 <code>T</code> 类型的元组结构体，其关联函数 <code>MyBox::new</code> 接收一个 <code>T</code> 类型的参数，并返回一个存储有传入值的 <code>MyBox</code> 实例作为结果。</p><p>为了为 <code>MyBox&lt;T&gt;</code> 类型实现解引用功能，代码中实现了 <code>Deref trait</code>。<br>标准库中的 Deref trait 要求我们实现一个 <code>deref</code> 方法，该方法会借用 <code>self</code> 并返回一个指向内部数据的引用。<br><code>deref</code> 方法体中的 <code>&amp;self.0</code> 意味着 <code>deref</code> 会返回一个指向值的引用，进而允许调用者通过 <code>*</code> 运算符访问值。<br>代码中的 <code>*y</code> 会被 Rust 隐式地展开为 <code>*(y.deref())</code>。使得我们可以用完全相同的方式编写代码来处理常规引用及实现了 Deref trait 的类型。</p><h4 id="函数和方法的隐式解引用转换"><a href="#函数和方法的隐式解引用转换" class="headerlink" title="函数和方法的隐式解引用转换"></a>函数和方法的隐式解引用转换</h4><p>解引用转换是 Rust 为函数和方法的参数提供的一种编程特性。当某个类型 T 实现了 Deref trait 时，它能够将 T 的引用转换为 T 经过 Deref 操作后生成的引用。<br>当我们将某个类型的值引用作为参数传递给类型或方法，但传入的类型与参数类型不一致时，解引用转换就会自动发生。编译器会插入一系列的 deref 方法来将我们提供的类型转换为参数所需的类型。</p><p>解引用转换使程序员在调用函数或方法时无需多次显式地使用 <code>&amp;</code> 和 <code>*</code> 操作符来进行引用和解引用操作。我们因而可以更多地编写出能够同时作用于常规引用和智能指针的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyBox</span></span>&lt;T&gt;(T);</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T) -&gt; MyBox&lt;T&gt; &#123;</span><br><span class="line">        MyBox(x)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> std::ops::Deref;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Deref <span class="keyword">for</span> MyBox&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Target</span></span> = T;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">deref</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.<span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">hello</span></span>(name: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, &#123;&#125;!"</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = MyBox::new(<span class="built_in">String</span>::from(<span class="string">"Rust"</span>));</span><br><span class="line">    hello(&amp;m);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">    hello(&amp;(*m)[..]);</span><br><span class="line">    <span class="comment">// =&gt; Hello, Rust!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&amp;m</code> 是一个指向 <code>MyBox&lt;String&gt;</code> 值的引用。因为 <code>MyBox&lt;T&gt;</code> 实现了 Deref trait，Rust 可以通过调用 deref 将 <code>&amp;MyBox&lt;String&gt;</code> 转换为 <code>String</code>；因为标准库为 <code>String</code> 提供的 Deref 实现会返回字符串切片，所以 Rust 可以继续调用 deref 将 <code>&amp;String</code> 转换为 <code>&amp;str</code>，最终与 <code>hello</code> 函数的定义匹配。</p><h5 id="解引用转换与可变性"><a href="#解引用转换与可变性" class="headerlink" title="解引用转换与可变性"></a>解引用转换与可变性</h5><p>使用 <code>Deref trait</code> 能够重载不可变引用的 <code>*</code> 运算符，使用 <code>DerefMut trait</code> 能够重载可变引用的 <code>*</code> 运算符。</p><p>Rust 会在类型与 trait 满足下面 3 种情况时执行解引用转换：</p><ul><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;T</code> 转换为 <code>&amp;U</code></li><li>当 <code>T: DerefMut&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;mut U</code></li><li>当 <code>T: Deref&lt;Target=U&gt;</code> 时，允许 <code>&amp;mut T</code> 转换为 <code>&amp;U</code></li></ul><h4 id="借助-Drop-trait-在清理时运行代码"><a href="#借助-Drop-trait-在清理时运行代码" class="headerlink" title="借助 Drop trait 在清理时运行代码"></a>借助 <strong>Drop trait</strong> 在清理时运行代码</h4><p>Drop trait 允许我们在变量离开作用域时执行某些自定义操作。可以为任意类型实现一个 Drop trait，它常常被用来释放诸如文件、网络连接等资源。<br>几乎每一种智能指针的实现都会用到这一 trait，比如 <code>Box&lt;T&gt;</code> 通过自定义 Drop 来释放装箱指针指向的堆内存空间。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"my stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> d = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"other stuff"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `other stuff`!</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `my stuff`!</span></span><br></pre></td></tr></table></figure><h5 id="使用-std-mem-drop-提前丢弃值"><a href="#使用-std-mem-drop-提前丢弃值" class="headerlink" title="使用 std::mem::drop 提前丢弃值"></a>使用 <code>std::mem::drop</code> 提前丢弃值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">CustomSmartPointer</span></span> &#123;</span><br><span class="line">    data: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> <span class="built_in">Drop</span> <span class="keyword">for</span> CustomSmartPointer &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">drop</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Dropping CustomSmartPointer with data `&#123;&#125;`!"</span>, <span class="keyword">self</span>.data)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> c = CustomSmartPointer &#123;</span><br><span class="line">        data: <span class="built_in">String</span>::from(<span class="string">"some data"</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer created."</span>);</span><br><span class="line">    <span class="built_in">drop</span>(c);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"CustomSmartPointer dropped before the end of main"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer created.</span></span><br><span class="line"><span class="comment">// =&gt; Dropping CustomSmartPointer with data `some data`!</span></span><br><span class="line"><span class="comment">// =&gt; CustomSmartPointer dropped before the end of main</span></span><br></pre></td></tr></table></figure><h4 id="基于引用计数的智能指针-Rc"><a href="#基于引用计数的智能指针-Rc" class="headerlink" title="基于引用计数的智能指针 Rc"></a>基于引用计数的智能指针 <strong>Rc<t></t></strong></h4><p>所有权在大多数情况下都是清晰的，对于一个给定的值，可以准确地判断出哪个变量拥有它。<br>但在某些场景中，单个值也可能同时被多个所有者持有。<br>比如在图数据结构中，多个边可能会指向相同的节点，这个节点同时属于所有指向它的边。一个节点只要在任意指向它的边还存在时就不应该被清理掉。<br>Rust 提供了一种名为 <code>Rc&lt;T&gt;</code> 的类型来支持多重所有权。<code>Rc&lt;T&gt;</code> 类型的实例会在内部维护一个用于记录值引用次数的计数器，从而确认这个值是否仍在使用。若对一个值的引用次数为零，就意味着这个值可以被安全地清理掉。</p><p>当你希望将堆上的一些数据分享给程序的多个部分同时使用，而又无法在编译期确定哪个部分会最后释放这些数据时，就可以使用 <code>Rc&lt;T&gt;</code> 类型。<br>相反地，若我们能够在编译期确定哪一部分最后会释放数据，那么就只需要让这部分代码成为数据的所有者即可。<br><strong><code>Rc&lt;T&gt;</code> 只能被用于单线程场景中</strong>。</p><h5 id="使用-Rc-lt-T-gt-共享数据"><a href="#使用-Rc-lt-T-gt-共享数据" class="headerlink" title="使用 Rc&lt;T&gt; 共享数据"></a>使用 <code>Rc&lt;T&gt;</code> 共享数据</h5><p>创建两个链接列表，并让它们同时持有第三个列表的所有权。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-46c80b946fd197b3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Cons List"></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, <span class="built_in">Box</span>&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Cons(<span class="number">5</span>, <span class="built_in">Box</span>::new(Cons(<span class="number">10</span>, <span class="built_in">Box</span>::new(Nil))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, <span class="built_in">Box</span>::new(a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尝试编译上述代码会报出 <strong>error[E0382]: use of moved value: <code>a</code></strong> 错误。原因是 <code>a</code> 列表会在创建 <code>b</code> 列表时被移动至 <code>b</code> 中。即 <code>b</code> 列表持有了 <code>a</code> 列表的所有权。随后再次尝试使用 <code>a</code> 来创建 <code>c</code> 列表时就会出现编译错误，因为 <code>a</code> 已经被移走了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">3</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中，每个 <code>Cons</code> 变体都持有一个值及一个指向 List 的 <code>Rc&lt;T&gt;</code>。我们只需要在创建 <code>b</code> 的过程中克隆 <code>a</code> 的 <code>Rc&lt;List&gt;</code> 智能指针即可，无需获取 <code>a</code> 的所有权。<br>这使得 <code>a</code> 和 <code>b</code> 可以共享 <code>Rc&lt;List&gt;</code> 数据的所有权，并使智能指针中的引用计数从 1 增加到 2。随后创建 <code>c</code> 时也会同样克隆 <code>a</code> 并将引用计数从 2 增加到 3。<br>每次调用 <code>Rc::clone</code> 都会使引用计数增加，而 <code>Rc&lt;List&gt;</code> 中的数据只有在引用计数器减少到 0 时才会被真正清理掉。</p><h5 id="克隆-Rc-lt-T-gt-会增加引用计数"><a href="#克隆-Rc-lt-T-gt-会增加引用计数" class="headerlink" title="克隆 Rc&lt;T&gt; 会增加引用计数"></a>克隆 <code>Rc&lt;T&gt;</code> 会增加引用计数</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(<span class="built_in">i32</span>, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(<span class="number">5</span>, Rc::new(Cons(<span class="number">10</span>, Rc::new(Nil)))));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating a = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after creating b = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> c = Cons(<span class="number">4</span>, Rc::clone(&amp;a));</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"count after creating c = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"count after c goes out of scope = &#123;&#125;"</span>, Rc::strong_count(&amp;a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; count after creating a = 1</span></span><br><span class="line"><span class="comment">// =&gt; count after creating b = 2</span></span><br><span class="line"><span class="comment">// =&gt; count after creating c = 3</span></span><br><span class="line"><span class="comment">// =&gt; count after c goes out of scope = 2</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，<code>a</code> 存储的 <code>Rc&lt;List&gt;</code> 拥有初始引用计数 1，并在随后每次调用 <code>clone</code> 时增加 1。当 <code>c</code> 离开作用域被丢弃时，引用计数减少 1。<code>Rc&lt;T&gt;</code> 的 <code>Drop</code> 实现会在 <code>Rc&lt;T&gt;</code> 离开作用域时自动将引用计数减 1。</p><p>使用 <code>Rc&lt;T&gt;</code> 可以使单个值拥有多个所有者，而引用计数机制则保证了这个值会在其所有者存活时一直有效，并在所有者全部离开作用域时被自动清理。<br><code>Rc&lt;T&gt;</code> 通过不可变引用使你可以在程序的不同部分之间共享只读数据。但如果 <code>Rc&lt;T&gt;</code> 也允许持有多个可变引用的话，就会违反一个借用原则：多个指向同一区域的可变借用会导致数据竞争及数据不一致。<br>但在实际开发中，允许数据可变是非常有用的。实际上可以通过 <code>RefCell&lt;T&gt;</code> 与 <code>Rc&lt;T&gt;</code> 联合使用来绕开不可变的限制。</p><h4 id="RefCell-和内部可变性模式"><a href="#RefCell-和内部可变性模式" class="headerlink" title="RefCell 和内部可变性模式"></a>RefCell<t> 和内部可变性模式</t></h4><p><strong>内部可变性</strong> 是 Rust 的设计模式之一，它允许你在只持有不可变引用的前提下对数据进行修改。为了能够改变数据，此模式在它的数据结构中使用了 <code>unsafe</code> 代码来绕过 Rust 正常的可变性和借用规则。<br>假如我们能够保证自己的代码在运行时符合借用规则，就可以在即使编译器无法在编译阶段保证符合借用规则的前提下，使用那些采用了内部可变性模式的类型。实现过程中涉及的那些不安全代码会被妥善地封装在安全的 API 内，而类型本身从外部看依然是不可变的。</p><h5 id="使用-RefCell-lt-T-gt-在运行时检查借用规则"><a href="#使用-RefCell-lt-T-gt-在运行时检查借用规则" class="headerlink" title="使用 RefCell&lt;T&gt; 在运行时检查借用规则"></a>使用 <code>RefCell&lt;T&gt;</code> 在运行时检查借用规则</h5><p>Rust 中的借用规则如下：</p><ul><li>在任何给定的时间内，只能拥有一个可变引用或者任意数量的不可变引用</li><li>引用总是有效的</li></ul><p>对于一般引用和 <code>Box&lt;T&gt;</code> 的代码，Rust 会在<strong>编译阶段</strong>强制代码遵守这些借用规则。而对于使用 <code>RefCell&lt;T&gt;</code> 的代码，Rust 只会在<strong>运行时</strong>检查这些规则，并在违反的时候触发 panic 来提前终止程序。</p><p>借用规则的检查放在编译阶段不仅会帮助我们在开发阶段尽早暴露问题，并且不会带来任何运行时开销。对于大多数场景都是最佳的选择。<br>在运行时检查借用规则可以使我们实现某些特定的内存安全场景，即便这些场景无法通过编译时检查。因为某些静态分析是根本无法完成的。这类编译器无法理解代码，但开发者可以保证借用规则能够满足的场景，就适用于 <code>RefCell&lt;T&gt;</code>。</p><h5 id="可变地借用一个不可变的值"><a href="#可变地借用一个不可变的值" class="headerlink" title="可变地借用一个不可变的值"></a>可变地借用一个不可变的值</h5><p><strong>内部可变性模式允许用户更改一个不可变值的内部数据</strong>。<br>借用规则限制用户可变地借用一个不可变的值，如下面的代码无法通过编译：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &amp;<span class="keyword">mut</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是在某些情况下，我们也需要一个值对外保持不可变性的同时能够在方法内部修改自身。除了这个值本身的方法，其余的代码仍不能修改这个值。<br>使用 <code>RefCell&lt;T&gt;</code> 可以获得这种内部可变性。<br>这种内部可变性的机制把借用规则的检查从编译期延后到了运行阶段，若违反了借用规则，只会在运行时触发 <strong>panic!</strong>。</p><p><strong>内部可变性的应用场景：模拟对象</strong><br><strong>测试替代</strong>是一种通用的编程概念，代表了那些在测试工作中被用作其他类型替代品的类型。而<strong>模拟对象</strong>则指代了测试替代中某些特定的类型，会承担起记录测试过程的工作。</p><p>Rust 没有和其他语言中类似的对象概念，也没有在标准库中提供模拟对象的测试功能。但是可以自定义一个结构体来实现与模拟对象相同的效果。<br>比如我们希望开发一个库，会基于当前值与最大值之间的接近程度向外传递信息。比如可以记录用户调用不同 API 的次数，并与设置的调用限额作比较。<br>使用这个库的应用程序需要自行实现发送消息的功能，例如在应用程序中打印信息、发送邮件、发送文字短信等。<br>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: <span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: <span class="built_in">vec!</span>[],</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>Messenger</code> trait 的 <code>send</code> 方法可以接收 <code>self</code> 的不可变引用及一条文本消息作为参数。我们需要在测试中确定的是，当某段程序使用一个实现了 Messenger trait 的模拟对象与一个 max 值来创建 <code>LimitTracker</code> 实例时，传入的不同 value 值能够触发 messenger 发送不同的信息。<br>此处的模拟对象 <code>MockMessenger</code> 在调用 <code>send</code> 时只需要将收到的消息存档记录即可，不需要真的去发送邮件或短信。使用模拟对象创建 <code>LimitTracker</code> 实例后，就可以通过调用 <code>set_value</code> 方法检查模拟对象中是否存储了我们希望见到的消息。</p><p>尝试编译（<code>cargo test</code>）上述代码会报出如下错误：<br><code>error[E0596]: cannot borrow `self.sent_messages` as mutable, as it is behind a `&amp;` reference</code></p><p><code>send</code> 方法接收了 <code>self</code> 的不可变引用，因此我们无法通过修改 <code>MockMessenger</code> 的内容来记录消息。我们也不能将函数签名修改为 <code>&amp;mut self</code>，因为修改后的签名与 Messenger trait 定义的 <code>send</code> 签名不符。<br>此时就是一个非常适合内部可变性的场景。只要在 <code>RefCell&lt;T&gt;</code> 中存入 <code>sent_messages</code>，<code>send</code> 方法就能够修改 <code>sent_messages</code>。</p><p>修改后的代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">trait</span> <span class="title">Messenger</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, msg: &amp;<span class="built_in">str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">LimitTracker</span></span>&lt;<span class="symbol">'a</span>, T: <span class="symbol">'a</span> + Messenger&gt; &#123;</span><br><span class="line">    messenger: &amp;<span class="symbol">'a</span> T,</span><br><span class="line">    value: <span class="built_in">usize</span>,</span><br><span class="line">    max: <span class="built_in">usize</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;<span class="symbol">'a</span>, T&gt; LimitTracker&lt;<span class="symbol">'a</span>, T&gt;</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    T: Messenger,</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(messenger: &amp;T, max: <span class="built_in">usize</span>) -&gt; LimitTracker&lt;T&gt; &#123;</span><br><span class="line">        LimitTracker &#123;</span><br><span class="line">            messenger,</span><br><span class="line">            value: <span class="number">0</span>,</span><br><span class="line">            max,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">set_value</span></span>(&amp;<span class="keyword">mut</span> <span class="keyword">self</span>, value: <span class="built_in">usize</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.value = value;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">let</span> percentage_of_max = <span class="keyword">self</span>.value <span class="keyword">as</span> <span class="built_in">f64</span> / <span class="keyword">self</span>.max <span class="keyword">as</span> <span class="built_in">f64</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">1.0</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger.send(<span class="string">"Error: You're over your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.9</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Urgent warning: You've used 90% of your quota!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> percentage_of_max &gt;= <span class="number">0.75</span> &#123;</span><br><span class="line">            <span class="keyword">self</span>.messenger</span><br><span class="line">                .send(<span class="string">"Warning: You've used 75% of your quota!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[cfg(test)]</span></span><br><span class="line"><span class="keyword">mod</span> tests &#123;</span><br><span class="line">    <span class="keyword">use</span> super::*;</span><br><span class="line">    <span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">MockMessenger</span></span> &#123;</span><br><span class="line">        sent_messages: RefCell&lt;<span class="built_in">Vec</span>&lt;<span class="built_in">String</span>&gt;&gt;,</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>() -&gt; MockMessenger &#123;</span><br><span class="line">            MockMessenger &#123;</span><br><span class="line">                sent_messages: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">impl</span> Messenger <span class="keyword">for</span> MockMessenger &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">send</span></span>(&amp;<span class="keyword">self</span>, message: &amp;<span class="built_in">str</span>) &#123;</span><br><span class="line">            <span class="keyword">self</span>.sent_messages.borrow_mut().push(<span class="built_in">String</span>::from(message));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#[test]</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">it_sends_an_over_75_percent_warning_message</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> mock_messenger = MockMessenger::new();</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> limit_tracker = LimitTracker::new(&amp;mock_messenger, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        limit_tracker.set_value(<span class="number">80</span>);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">assert_eq!</span>(mock_messenger.sent_messages.borrow().len(), <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>sent_messages</code> 字段的类型变为了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code>。对于 <code>send</code> 方法的实现，其第一个参数依然是 <code>self</code> 的不可变借用，与 trait 的定义保持一致。后面的代码调用 <code>self.messages.borrow_mut</code> 方法获取 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 内部值（也就是动态数组）的可变引用，再调用其 <code>push</code> 方法存入数据。<br>在断言语句中，调用了 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 的 <code>borrow</code> 方法来取得动态数组的不可变引用。</p><p>对于 <code>RefCell&lt;T&gt;</code> 而言，我们可以使用 <code>borrow</code> 与 <code>borrow_mut</code> 分别创建不可变和可变引用。这两个方法会分别返回 <code>Ref&lt;T&gt;</code> 与 <code>RefMut&lt;T&gt;</code> 两种智能指针，可以被当作一般的引用来对待。<br><code>RefCell&lt;T&gt;</code> 会记录当前存在多少个活跃的 <code>Ref&lt;T&gt;</code> 和 <code>RefMut&lt;T&gt;</code>，维护和编译器同样的借用规则：任何给定的时间都只允许拥有多个不可变借用或一个可变借用。<br>当借用规则被违背时，<code>RefCell&lt;T&gt;</code> 会在<strong>运行时</strong>触发 panic。</p><h4 id="Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据"><a href="#Rc-lt-T-gt-和-RefCell-lt-T-gt-实现一个拥有多重所有权的可变数据" class="headerlink" title="Rc&lt;T&gt; 和 RefCell&lt;T&gt; 实现一个拥有多重所有权的可变数据"></a><code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 实现一个拥有多重所有权的可变数据</h4><p><code>Rc&lt;T&gt;</code> 允许多个所有者持有同一数据，但只能提供针对数据的不可变访问。若在 <code>Rc&lt;T&gt;</code> 内存储了 <code>RefCell&lt;T&gt;</code>，就可以定义出拥有多个所有者且能够进行修改的值了。</p><p>在 <code>Cons</code> 定义中使用 <code>RefCell&lt;T&gt;</code> 来实现修改现有列表内数值的功能：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">List</span></span> &#123;</span><br><span class="line">    Cons(Rc&lt;RefCell&lt;<span class="built_in">i32</span>&gt;&gt;, Rc&lt;List&gt;),</span><br><span class="line">    Nil,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> crate::List::&#123;Cons, Nil&#125;;</span><br><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> value = Rc::new(RefCell::new(<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">let</span> a = Rc::new(Cons(Rc::clone(&amp;value), Rc::new(Nil)));</span><br><span class="line">    <span class="keyword">let</span> b = Cons(Rc::new(RefCell::new(<span class="number">6</span>)), Rc::clone(&amp;a));</span><br><span class="line">    <span class="keyword">let</span> c = Cons(Rc::new(RefCell::new(<span class="number">10</span>)), Rc::clone(&amp;a));</span><br><span class="line"></span><br><span class="line">    *value.borrow_mut() += <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"a after = &#123;:?&#125;"</span>, a);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"b after = &#123;:?&#125;"</span>, b);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"c after = &#123;:?&#125;"</span>, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="循环引用与内存泄漏"><a href="#循环引用与内存泄漏" class="headerlink" title="循环引用与内存泄漏"></a>循环引用与内存泄漏</h4><p>与数据竞争不同，在编译期彻底防止内存泄漏并不是 Rust 做出的保证。这意味着内存泄漏在 Rust 中是一种内存安全行为。<br>可以通过使用 <code>Rc&lt;T&gt;</code> 和 <code>RefCell&lt;T&gt;</code> 创建出相互引用成环状的实例。由于环中每一个指针的引用计数都不可能减少到 0，对应的值也不会被释放丢弃，最终造成内存泄漏。</p><p>代码中先创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>a</code>，其中的 List 初始值为 <code>5, Nil</code>。<br>之后又创建了一个 <code>Rc&lt;List&gt;</code> 实例并存储至变量 <code>b</code>，其中的 List 包含数值 10 及指向列表 <code>a</code> 的指针。<br>接着将 <code>a</code> 指向的下一个元素 <code>Nil</code> 修改为 <code>b</code>，此时即创建出了循环引用。</p><p>在完成 <code>a</code> 指向 <code>b</code> 的操作后，这两个 <code>Rc&lt;List&gt;</code> 实例的引用计数都变为了 2。而在 <code>main</code> 函数结尾处，Rust 会首先释放 <code>b</code>，并使 <code>b</code> 存储的 <code>Rc&lt;List&gt;</code> 实例的引用计数减少 1。<br>但由于 <code>a</code> 仍然有一个指向 <code>b</code> 中 <code>Rc&lt;List&gt;</code> 的引用，这个 <code>Rc&lt;List&gt;</code> 的引用计数仍然是 1 而不是 0。因此该 <code>Rc&lt;List&gt;</code> 在堆上的内存不会被释放，这块内存会永远以引用计数为 1 的状态保留在堆上。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-55a8d6b393cb625e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="a 和 b 相互指向的循环引用"></p><p>假如去除最后一行 <code>println!</code> 的注释并再次运行程序，Rust 会在尝试将循环引用打印出来的过程中反复地从 <code>a</code> 跳转到 <code>b</code>，再从 <code>b</code> 跳转至 <code>a</code>，直到发生栈溢出为止。</p><p>如果程序中存在 <code>RefCell&lt;T&gt;</code> 包含 <code>Rc&lt;T&gt;</code> 或其他联用了内部可变性与引用计数指针的情形，就需要自行确保不会在代码中创建出循环引用。<br>创建出循环引用意味着代码逻辑有 bug，可以通过自动化测试及其他软件开发手段来尽可能地避免。</p><h4 id="使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用"><a href="#使用-Weak-lt-T-gt-替代-Rc-lt-T-gt-来避免循环引用" class="headerlink" title="使用 Weak&lt;T&gt; 替代 Rc&lt;T&gt; 来避免循环引用"></a>使用 <code>Weak&lt;T&gt;</code> 替代 <code>Rc&lt;T&gt;</code> 来避免循环引用</h4><p>调用 <code>Rc::clone</code> 会增加 <code>Rc&lt;T&gt;</code> 实例的 <code>strong_count</code> 引用计数，而 <code>Rc&lt;T&gt;</code> 实例只有在 <code>strong_count</code> 为 0 时才会被清理。<br>除此之外，我们还可以调用 <code>Rc::downgrade</code> 函数来创建 <code>Rc&lt;T&gt;</code> 实例中值的弱引用。使用 <code>Rc&lt;T&gt;</code> 的引用来调用 <code>Rc::downgrade</code> 会返回一个类型为 <code>Weak&lt;T&gt;</code> 的智能指针，这一操作会让 <code>Rc&lt;T&gt;</code> 的 <code>weak_count</code> 计数增加 1。<code>Rc&lt;T&gt;</code> 类型使用 <code>weak_count</code> 来记录当前存在多少个 <code>Weak&lt;T&gt;</code> 引用，但不会在执行清理操作前要求 <code>weak_count</code> 必须为 0。<br>强引用可以被用来共享一个 <code>Rc&lt;T&gt;</code> 实例的所有权，而弱引用则不会表达所有权关系。一旦强引用计数为 0，任何由弱引用组成的循环就会被打破。<strong>弱引用不会造成循环引用</strong>。<br>我们无法确定 <code>Weak&lt;T&gt;</code> 引用的值是否已经被释放，因此需要在使用 <code>Weak&lt;T&gt;</code> 指向的值之前确保它依然存在。可以调用 <code>Weak&lt;T&gt;</code> 实例的 <code>upgrade</code> 方法来完成这一验证。此函数返回的 <code>Option&lt;Rc&lt;T&gt;&gt;</code> 会在 <code>Rc&lt;T&gt;</code> 值依然存在时表达为 <code>Some</code>，在 <code>Rc&lt;T&gt;</code> 值被释放时表达为 <code>None</code>。Rust 能够保证 <code>Some</code> 和 <code>None</code> 两个分支都得到妥善的处理，不会产生无效指针之类的问题。</p><h5 id="创建树状结构体：带有子节点的-Node"><a href="#创建树状结构体：带有子节点的-Node" class="headerlink" title="创建树状结构体：带有子节点的 Node"></a>创建树状结构体：带有子节点的 Node</h5><p>源代码如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::Rc;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们希望 Node 持有自身所有子节点并通过变量来共享它们的所有权，从而可以直接访问树中的每个 Node。因此将 <code>Vec&lt;T&gt;</code> 的元素定义为 <code>Rc&lt;Node&gt;</code> 类型的值。<br>我们还希望在 <code>children</code> 字段中使用 <code>RefCell&lt;T&gt;</code> 包裹 <code>Vec&lt;Rc&lt;Node&gt;&gt;</code> 来实现内部可变性。<br>我们使用上述结构体定义一个值为 3 且没有子节点的 Node 实例，并将其作为叶子节点存入 <code>leaf</code> 变量。再定义一个值为 5 且将 <code>leaf</code> 作为子节点的 <code>branch</code> 实例。接着克隆 <code>leaf</code> 的 <code>Rc&lt;Node&gt;</code> 实例，并将其存入 <code>branch</code>。<br>此时我们可以使用 <code>branch.children</code> 来从 <code>branch</code> 访问 <code>leaf</code>，但是反之则不行。因为 <code>leaf</code> 并不持有 <code>branch</code> 的引用，它甚至对两个节点之间存在父子关系一无所知。</p><h5 id="增加子节点指向父节点的引用"><a href="#增加子节点指向父节点的引用" class="headerlink" title="增加子节点指向父节点的引用"></a>增加子节点指向父节点的引用</h5><p>为了让子节点意识到父节点的存在，可以为 <code>Node</code> 结构体添加一个 <code>parent</code> 字段。但 <code>parent</code> 的类型不能是 <code>Rc&lt;T&gt;</code>，会创建循环引用。<code>branch.children</code> 指向 <code>leaf</code> 的同时使 <code>leaf.parent</code> 指向 <code>branch</code> 会导致两者的 <code>strong_count</code> 都无法清零。</p><p>父节点自然拥有子节点的所有权，因为父节点被丢弃时，子节点也应该随之被丢弃；但子节点却不应该拥有父节点的所有权，即父节点的存在不会因为丢弃子节点而受到影响。<br>这恰好是使用弱引用的场景。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::cell::RefCell;</span><br><span class="line"><span class="keyword">use</span> std::rc::&#123;Rc, Weak&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span> &#123;</span><br><span class="line">    value: <span class="built_in">i32</span>,</span><br><span class="line">    parent: RefCell&lt;Weak&lt;Node&gt;&gt;,</span><br><span class="line">    children: RefCell&lt;<span class="built_in">Vec</span>&lt;Rc&lt;Node&gt;&gt;&gt;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> leaf = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">3</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[]),</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> branch = Rc::new(Node &#123;</span><br><span class="line">        value: <span class="number">5</span>,</span><br><span class="line">        parent: RefCell::new(Weak::new()),</span><br><span class="line">        children: RefCell::new(<span class="built_in">vec!</span>[Rc::clone(&amp;leaf)]),</span><br><span class="line">    &#125;);</span><br><span class="line">    *leaf.parent.borrow_mut() = Rc::downgrade(&amp;branch);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"leaf parent = &#123;:?&#125;"</span>, leaf.parent.borrow().upgrade());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// =&gt; leaf parent = None</span></span><br><span class="line"><span class="comment">// =&gt; leaf parent = Some(Node &#123; value: 5, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [Node &#123; value: 3, parent: RefCell &#123; value: (Weak) &#125;, children: RefCell &#123; value: [] &#125; &#125;] &#125; &#125;)</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>branch</code> 创建完毕后，我们通过 <code>RefCell&lt;Weak&lt;Node&gt;&gt;</code> 的 <code>borrow_mut</code> 方法取出 <code>leaf</code> 中 <code>parent</code> 字段的可变借用，再使用 <code>Rc::downgrade</code> 函数获取 <code>branch</code> 中 <code>Rc&lt;Node&gt;</code> 的 <code>Weak&lt;Node&gt;</code> 引用，将其存入 <code>leaf</code> 的 <code>parent</code> 字段中。<br>最后在打印 <code>leaf</code> 的父节点时，便可以看到一个包含了 <code>branch</code> 实际内容的 <code>Some</code> 变体，即表明 <code>leaf</code> 可以访问其父节点。另外，此时打印 <code>leaf</code> 还可以避免之前因循环引用导致的栈溢出故障，因为 <code>Weak&lt;Node&gt;</code> 引用会被直接打印为 <code>(Weak)</code>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;指针（pointer）&lt;/strong&gt;是一个通用概念，用来指代那些包含内存地址的变量。这些地址“指向”内存中的其他数据。&lt;br&gt;Rust 中最常见的指针是&lt;strong&gt;引用&lt;/strong&gt;，会&lt;strong&gt;借用&lt;/strong&gt;它所指向的数据。除此之
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="https://rollingstarky.github.io/tags/Ownership/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
      <category term="Memory" scheme="https://rollingstarky.github.io/tags/Memory/"/>
    
      <category term="Heap" scheme="https://rollingstarky.github.io/tags/Heap/"/>
    
      <category term="Stack" scheme="https://rollingstarky.github.io/tags/Stack/"/>
    
      <category term="Borrow" scheme="https://rollingstarky.github.io/tags/Borrow/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——枚举类型</title>
    <link href="https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/"/>
    <id>https://rollingstarky.github.io/2021/07/13/the-rust-programming-language-reading-notes-enum-and-match/</id>
    <published>2021-07-12T16:00:00.000Z</published>
    <updated>2021-07-13T13:02:39.454Z</updated>
    
    <content type="html"><![CDATA[<p>枚举类型（<strong>enum</strong>），通常也被简称为<strong>枚举</strong>，它允许我们列举所有可能的值来定义一个类型。<br>枚举搭配 <code>match</code> 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。<br>Rust 中的枚举更类似于 Haskell 这类函数式编程语言中的<strong>代数数据类型（ADT）</strong>。</p><h4 id="定义枚举"><a href="#定义枚举" class="headerlink" title="定义枚举"></a>定义枚举</h4><p>假设我们需要对 IP 地址进行处理。目前只有两种广泛被使用的 IP 地址标准：IPv4 和 IPv6。<br>我们只需要处理这两种情形，且一个地址要么是 IPv4，要么是 IPv6，因此可以使用枚举将所有可能的值（IPv4 和 IPv6）列举出来，作为一种新的数据类型。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，<code>IpAddrKind</code> 就是一个可以在代码中随处使用的自定义数据类型了。</p><h5 id="枚举值"><a href="#枚举值" class="headerlink" title="枚举值"></a>枚举值</h5><p>可以参照下面的代码使用 <code>IpAddrKind</code> 中的两个变体（<code>V4</code> 和 <code>V6</code>）创建实例：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> four = IpAddrKind::V4;</span><br><span class="line"><span class="keyword">let</span> six = IpAddrKind::V6;</span><br></pre></td></tr></table></figure></p><p>由于 <code>IpAddrKind:V4</code> 和 <code>IpAddrKind:V6</code> 拥有相同的类型（都是 <code>IpAddrKind</code>），我们可以定义一个接收 <code>IpAddrKind</code> 类型参数的函数来统一处理它们：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">route</span></span>(ip_type: IpAddrKind) &#123; &#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们可以使用任意一个变体来调用这个函数了：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route(IpAddrKind::V4);</span><br><span class="line">route(IpAddrKind::V6);</span><br></pre></td></tr></table></figure></p><p>当前定义的枚举类型 <code>IpAddrKind</code>，还只能区分 IP 地址的种类，没有办法去存储实际的 IP 地址数据。<br>可以使用结构体来解决这个问题：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddrKind</span></span> &#123;</span><br><span class="line">    V4,</span><br><span class="line">    V6,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    kind: IpAddrKind,</span><br><span class="line">    address: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V4,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>),</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr &#123;</span><br><span class="line">    kind: IpAddrKind::V6,</span><br><span class="line">    address: <span class="built_in">String</span>::from(<span class="string">"::1"</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>实际上，我们可以直接将枚举关联的数据嵌入其变体内，而不用像上面那样将枚举集成至结构体中。</p><p>下面的代码直接定义了 <code>IpAddr</code> 枚举，<code>V4</code> 和 <code>V6</code> 两个变体都被关联上了一个 String 值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">String</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="built_in">String</span>::from(<span class="string">"127.0.0.1"</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>我们直接将数据附加到枚举的每个变体中，就不需要额外地使用结构体了。</p><p>另外一个枚举替代结构体的优势在于，<strong>每个变体可以拥有不同类型和数量的关联数据，同时所有变体仍属于同一个枚举类型</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">IpAddr</span></span> &#123;</span><br><span class="line">    V4(<span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>, <span class="built_in">u8</span>),</span><br><span class="line">    V6(<span class="built_in">String</span>),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> home = IpAddr::V4(<span class="number">127</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> loopback = IpAddr::V6(<span class="built_in">String</span>::from(<span class="string">"::1"</span>));</span><br></pre></td></tr></table></figure></p><p>参考下面代码中定义的一个 <code>Message</code> 枚举：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Message</span></span> &#123;</span><br><span class="line">    Quit,</span><br><span class="line">    Move &#123; x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span> &#125;,</span><br><span class="line">    Write(<span class="built_in">String</span>),</span><br><span class="line">    ChangeColor(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该枚举拥有 4 个内嵌了不同类型数据的变体：</p><ul><li>Quit 没有关联任何数据</li><li>Move 包含了一个匿名结构体</li><li>Write 包含了一个 String</li><li>ChangeColor 包含了 3 个 i32 值</li></ul><p>枚举有些类似于定义多个不同类型的结构体。但枚举除了不会使用 <code>struct</code> 关键字，还将变体们组合到了同一个 <code>Message</code> 类型中。<br>下面代码中的结构体可以存储与这些变体完全一样的数据：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QuitMessage</span></span>; <span class="comment">// 空结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MoveMessage</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WriteMessage</span></span>(<span class="built_in">String</span>); <span class="comment">// 元组结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ChangeColorMessage</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>); <span class="comment">// 元组结构体</span></span><br></pre></td></tr></table></figure></p><p>两种实现方式的差别在于，如果使用了不同的结构体，则<strong>每个结构体都会拥有自己的类型</strong>，无法轻易定义一个统一处理这些类型的函数。而前面的 <strong><code>Message</code> 枚举是单独的一个类型</strong>。</p><p>正如我们可以用 <code>impl</code> 关键字定义结构体的方法一样，我们同样可以为 <code>Message</code> 定义自己的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Message &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">call</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="comment">// 方法在这里定义</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> m = Message::Write(<span class="built_in">String</span>::from(<span class="string">"hello"</span>));</span><br><span class="line">    m.call();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Option-枚举及空值处理"><a href="#Option-枚举及空值处理" class="headerlink" title="Option 枚举及空值处理"></a>Option 枚举及空值处理</h4><p><code>Option</code> 是一种定义于标准库中的枚举类型，它描述了一种值可能不存在的情形。借助类型系统，编译器可以自动检查我们是否妥善地处理了所有应该被处理的情况。</p><p>Rust 没有像其他语言一样支持<strong>空值（Null）</strong>。空值本身是一个值，但它的含义却是没有值。<br>空值的问题在于，当你尝试像使用非空值那样使用空值时，就会触发某种程度上的错误。由于空或非空的属性广泛散布在程序中，因此很难避免引起此类问题。<br>但空值本身所尝试表达的概念仍是有意义的，它代表了因为某种原因而变得无效或缺失的值。</p><p>Rust 中虽然没有空值，但提供了一个拥有类似概念的枚举 <code>Option&lt;T&gt;</code>，它可以用来标识一个值无效或缺失。<br><code>Option&lt;T&gt;</code> 在标准库中的定义如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Option</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="literal">Some</span>(T),</span><br><span class="line">    <span class="literal">None</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>Option&lt;T&gt;</code> 是一个普通的枚举类型，<code>Some&lt;T&gt;</code> 和 <code>None</code> 是该类型的变体。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">let</span> some_string = <span class="literal">Some</span>(<span class="string">"a string"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> absent_number: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; = <span class="literal">None</span>;</span><br></pre></td></tr></table></figure></p><p>若使用 <code>None</code> 而不是 <code>Some</code> 变体来进行赋值，则需要明确声明这个 <code>Option&lt;T&gt;</code> 的具体类型，否则编译器无法进行类型推导。</p><p>当我们有了一个 <code>Some</code> 值时，就可以确定值是存在的，并且被 <code>Some</code> 所持有；当我们有了一个 <code>None</code> 值时，就知道当前并不存在一个有效的值。<br><code>Option&lt;T&gt;</code> 的设计相对于空值的优势在于，<strong><code>Option&lt;T&gt;</code> 和 <code>T</code> 是不同的类型，编译器不会允许我们像使用普通值一样直接去使用 <code>Option&lt;T&gt;</code> 的值</strong>。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">i8</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y: <span class="built_in">Option</span>&lt;<span class="built_in">i8</span>&gt; = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sum = x + y;</span><br></pre></td></tr></table></figure></p><p>运行上述代码会导致编译器报错，因为 <code>i8</code> 和 <code>Option&lt;i8&gt;</code> 是不同的类型。<br>当我们持有的类型是 <code>i8</code> 时，编译器可以确保该值是有效的。但是<strong>当我们持有的类型是 <code>Option&lt;i8&gt;</code> 时，我们必须要考虑值不存在的情况，编译器会迫使我们在使用值之前正确地做出处理操作</strong>。</p><p><strong>为了持有一个可能为空的值，我们总是需要将其显式地放入对应类型的 <code>Option&lt;T&gt;</code> 值当中。当我们随后使用这个值时，也必须显式地处理它可能为空的情况</strong>。<br>即在处理 <code>Option&lt;T&gt;</code> 时，必须编写应对每个变体的代码。某些代码只会在持有 <code>Some(T)</code> 值时运行，它们可以使用变体中存储的 <code>T</code>；另外一些代码则只会在持有 <code>None</code> 值时运行，这些代码没有可用的 <code>T</code> 值。</p><p><code>match</code> 表达式就是一种可以用来处理 <code>Option&lt;T&gt;</code> 这类枚举的控制流结构。它允许我们基于枚举拥有的变体来决定运行的代码分支，并允许代码通过模式匹配来获取变体内的数据。</p><h4 id="控制流运算符-match"><a href="#控制流运算符-match" class="headerlink" title="控制流运算符 match"></a>控制流运算符 match</h4><p><code>match</code> 是 Rust 中一个强大的控制流运算符，它允许将一个值与一系列模式相比较，并根据匹配的模式执行相应的代码。这些模式可以由字面量、变量名、通配符及许多其他东西组成。</p><p>下面的代码会接收一个美国的硬币作为输入，确定硬币的类型并返回其分值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter =&gt; <span class="number">25</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Dime;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, value_in_cents(coin));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>每个 <code>match</code> 分支所关联的代码同时也是一个表达式，这个表达式运行的结果同时也会作为整个 <code>match</code> 表达式的结果返回。</p><h5 id="绑定值的模式"><a href="#绑定值的模式" class="headerlink" title="绑定值的模式"></a>绑定值的模式</h5><p>匹配分支还可以绑定匹配对象的部分值，这使得我们能够从枚举变体中提取特定的值。</p><p>比如美国的 25 美分硬币 50 个州采用了不同的设计。现在将这些信息添加至枚举中：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Debug)]</span> <span class="comment">// 方便打印输出默认不支持打印的类型</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">UsState</span></span> &#123;</span><br><span class="line">    Alabama,</span><br><span class="line">    Alaska,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Coin</span></span> &#123;</span><br><span class="line">    Penny,</span><br><span class="line">    Nickel,</span><br><span class="line">    Dime,</span><br><span class="line">    Quarter(UsState),</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">value_in_cents</span></span>(coin: Coin) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    <span class="keyword">match</span> coin &#123;</span><br><span class="line">        Coin::Penny =&gt; <span class="number">1</span>,</span><br><span class="line">        Coin::Nickel =&gt; <span class="number">5</span>,</span><br><span class="line">        Coin::Dime =&gt; <span class="number">10</span>,</span><br><span class="line">        Coin::Quarter(state) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"State quarter from &#123;:?&#125;."</span>, state);</span><br><span class="line">            <span class="number">25</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> alaska = UsState::Alaska;</span><br><span class="line">    <span class="keyword">let</span> coin = Coin::Quarter(alaska);</span><br><span class="line">    value_in_cents(coin);</span><br><span class="line">    <span class="comment">// =&gt; State quarter from Alaska.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，我们在模式中加入了一个名为 <code>state</code> 的变量用于匹配变体 <code>Coin::Quarter</code> 中的值。当匹配到 <code>Coin::Quarter</code> 时，变量 <code>state</code> 就会绑定到 25 美分所包含的值上。<br>比如代码中 <code>Coin::Quarter(UsState::Alaska)</code> 作为 <code>coin</code> 的值传入 <code>value_in_cents</code> 函数，最终值 <code>UsState::Alaska</code> 被绑定到变量 <code>state</code> 上。</p><h4 id="匹配-Option"><a href="#匹配-Option" class="headerlink" title="匹配 Option"></a>匹配 Option<t></t></h4><p>可以使用 <code>match</code> 表达式来处理 <code>Option&lt;T&gt;</code>，从 <code>Some</code> 中取出内部的 <code>T</code> 值。<br>比如编写一个接收 <code>Option&lt;i32&gt;</code> 的函数，若其中有值存在，则将这个值加 1；若其中不存在值，则直接返回 <code>None</code>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt;) -&gt; <span class="built_in">Option</span>&lt;<span class="built_in">i32</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">None</span> =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is None"</span>);</span><br><span class="line">            <span class="literal">None</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="literal">Some</span>(i) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The result is &#123;&#125;"</span>, i + <span class="number">1</span>);</span><br><span class="line">            <span class="literal">Some</span>(i + <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> five = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> six = plus_one(five);</span><br><span class="line">    <span class="keyword">let</span> none = plus_one(<span class="literal">None</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<strong>匹配必须穷举所有的可能</strong>。尤其是 <code>Option&lt;T&gt;</code> 这个例子中，Rust 会强迫我们明确地处理值为 <code>None</code> 的情形。</p><h5 id="简单控制流-if-let"><a href="#简单控制流-if-let" class="headerlink" title="简单控制流 if let"></a>简单控制流 <code>if let</code></h5><p><code>if let</code> 能让我们通过一种不那么繁琐的语法结合使用 <code>if</code> 与 <code>let</code>，处理那些只关心某一种匹配而忽略其他匹配的情况。<br>下面的代码会匹配一个 <code>Option&lt;u32&gt;</code> 的值，并只在值为 3 时执行代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">match</span> some_number &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">3</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了满足 <code>match</code> 表达式<strong>穷尽性</strong>的要求，我们不得不在处理完 <code>Some(3)</code> 变体后额外加上一句 <code>_ =&gt; ()</code>。<br>可以使用 <code>if let</code> 以一种更简单的方式实现上述代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以在 <code>if let</code> 中搭配使用 <code>else</code>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_number = <span class="literal">Some</span>(<span class="number">8</span>);</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(<span class="number">3</span>) = some_number &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"three"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"other number"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;枚举类型（&lt;strong&gt;enum&lt;/strong&gt;），通常也被简称为&lt;strong&gt;枚举&lt;/strong&gt;，它允许我们列举所有可能的值来定义一个类型。&lt;br&gt;枚举搭配 &lt;code&gt;match&lt;/code&gt; 表达式使用模式匹配，可以根据不同的枚举值来执行不同的代码。&lt;br&gt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Enum" scheme="https://rollingstarky.github.io/tags/Enum/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——包（package）、单元包（crate）与模块系统</title>
    <link href="https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/"/>
    <id>https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/</id>
    <published>2021-07-08T16:00:00.000Z</published>
    <updated>2021-07-08T16:40:32.519Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实现指定功能的代码片段，确定哪些地方需要修改。</p><p>除了对功能进行分组，对实现的细节进行封装可以使开发者在更高的层次上复用代码：一旦实现了某个功能，其他代码就可以通过公共接口调用这个操作，而无需了解具体的实现细节。</p><p>Rust 提供了一系列的功能来管理代码，包括决定哪些细节是暴露的，那些细节是私有的，以及不同的作用域内存在哪些名称。这些功能被统称为<strong>模块系统</strong>：</p><ul><li><strong>包（package）</strong>：一个用于构建、测试并分享单元包的 Cargo 特性</li><li><strong>单元包（crate）</strong>：一个用于生成库或可执行文件的树形模块结构</li><li><strong>模块（module）</strong>及 <strong>use 关键字</strong>：用于控制文件结构、作用域及路径的私有性</li><li><strong>路径（path）</strong>：一种用于命名条目的方法，这些条目包括结构体、函数和模块等</li></ul><h4 id="包与单元包"><a href="#包与单元包" class="headerlink" title="包与单元包"></a>包与单元包</h4><p>当我们使用 <code>cargo new</code> 命令创建新项目时，如：<br><code>cargo new restaurant</code></p><p>Cargo 会自动创建如下结构的 Rust 项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>Cargo 默认会将自动生成的 <code>src/main.rs</code> 源文件视作一个二进制单元包（crate）的根节点，与包（package）拥有相同的名称（即 <code>restaurant</code>）。<br>假设包的目录中包含文件 <code>src/lib.rs</code>，Cargo 也会自动将其视作与包同名的库单元包的根节点。<br>可以在路径 <code>src/bin</code> 下添加源文件来创建更多的二进制单元包，这些源文件都会被视作独立的二进制单元包。</p><p>自动生成的 <code>src/main.rs</code> 源文件内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以创建一个 <code>src/lib.rs</code> 源文件，把上面的打印输出的操作作为公共函数定义在 <code>lib.rs</code> 中，再在 <code>main.rs</code> 中调用该公共函数，效果与之前是一致的。</p><p><code>src/lib.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>src/main.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::greeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 <code>lib.rs</code> 默认会作为一个与包同名（都叫 <code>restaurant</code>）的库单元包（crate）存在，且其中的 <code>greeting</code> 函数已被声明为公开的（<code>pub</code>），因此可以直接在 <code>main.rs</code> 中使用 <code>restaurant::greeting()</code> 调用 <code>lib.rs</code> 中定义的 <code>greeting</code> 函数。</p><p>使用 <code>cargo run</code> 命令运行项目后，<code>target/debug</code> 路径下除了像之前一样生成 <code>restaurant</code> 可执行文件外，还会额外生成 <code>librestaurant.rlib</code> 库文件。</p><p>单元包可以将相关的功能分组，并放到<strong>同一作用域</strong>下，这样便可以使这些功能轻松地在多个项目中共享。<br>将单元包的功能保留在它们自己的作用域中有助于指明某个特定功能来源于哪个单元包，并避免可能的命名冲突。<br>比如 <code>rand</code> 包提供了一个名为 <code>Rng</code> 的 trait，我们同样也可以在自己的单元包中定义一个名为 <code>Rng</code> 的结构体。正是由于这些功能被放置在了各自的作用域中，我们能够使用 <code>rng::Rng</code> 访问 rand 包中提供的 <code>Rng</code> trait，而 <code>Rng</code> 则指向刚刚创建的 <code>Rng</code> 结构体。</p><h5 id="通过定义模块来控制作用域及私有性"><a href="#通过定义模块来控制作用域及私有性" class="headerlink" title="通过定义模块来控制作用域及私有性"></a>通过定义模块来控制作用域及私有性</h5><p>假设我们需要编写一个提供就餐服务的库单元包。一个现实的店面常常会划分为前厅与后厨两个部分，前厅负责点单和结账等，后厨则负责制作料理。</p><p>为了按照餐厅的实际工作方式来组织单元包，可以将函数放置在嵌套的模块中。修改 <code>src/lib.rs</code> 源代码文件，内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以使用 <code>mod</code> 关键字来定义一个模块（如本例中的 <code>front_of_house</code>），模块内还可以继续定义其他模块（如本例中的 <code>hosting</code> 和 <code>serving</code>）。模块内同样也可以包含其他条目的定义，如结构体、枚举、常量、trait 或函数等。</p><p><code>src/main.rs</code> 与 <code>src/lib.rs</code> 被称作单元包（crate）的根节点，它们的内容各自组成了一个名为 <code>crate</code> 的模块。这个模块的结构也被称为模块树。<br>上面 <code>src/lib.rs</code> 形成的树状模块结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure></p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>类似于在文件系统中使用路径进行导航，在 Rust 的模块树中定位某个条目同样需要使用路径。</p><p>路径有两种形式：</p><ul><li>使用单元包名或字面量 crate 从根节点开始的绝对路径</li><li>使用 <code>self</code>、<code>super</code> 或内部标识符从当前模块开始的相对路径</li></ul><p>绝对路径与相对路径都至少由一个标识符组成，标识符之间使用双冒号（<code>::</code>）分隔。</p><p>现在尝试在模块外部调用模块中定义的函数。在 <code>src/lib.rs</code> 末尾添加一个公共函数 <code>eat_at_restaurant</code>，调用模块 <code>front_of_house</code> 中定义的函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改 <code>src/main.rs</code>，在 <code>main</code> 函数中调用上一步中定义的公共函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::eat_at_restaurant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试编译项目，会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">error[E0603]: module `serving` is private</span><br></pre></td></tr></table></figure></p><p>即模块 <code>hosting</code> 和 <code>serving</code> 是私有的，Rust 不允许我们访问。<br>Rust 中的模块不仅仅用于组织代码，同时也定义了<strong>私有边界</strong>：外部代码无法知晓、调用或依赖那些由私有边界封装了的实现细节。<br><strong>Rust 中的所有条目（函数、方法、结构体、枚举、模块及常量）默认都是私有的，处于父级模块中的条目无法使用子模块中的私有条目，但子模块中的条目可以使用其祖先模块中的条目</strong>。<br>Rust 希望默认隐藏内部的实现细节，这样用户就能明确地知道修改哪些内容不会破坏外部代码。</p><h5 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 pub 关键字暴露路径</h5><p>可以使用 <code>pub</code> 关键字将某些条目标记为公共的，从而使子模块中的这些部分可以被暴露到祖先模块中。<br>接上面的例子，为了使父模块中的 <code>eat_at_restaurant</code> 函数能够正常访问子模块中定义的函数，可以使用 <code>pub</code> 关键字来标记 <code>hosting</code> 和 <code>serving</code> 模块。<br>需要注意的是，模块被 <code>pub</code> 标记，其效果仅限于模块本身，并不会影响到它内部条目的状态，模块中的内容依旧是私有的。为了使前面的代码正常工作，还必须在需要公开的函数前面添加 <code>pub</code> 关键字。</p><p>编辑 <code>src/lib.rs</code> 中，内容改动如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时程序即可以正常运行。</p><h5 id="将结构体声明为公共的"><a href="#将结构体声明为公共的" class="headerlink" title="将结构体声明为公共的"></a>将结构体声明为公共的</h5><p>当我们在结构体定义前使用 <code>pub</code> 关键字时，结构体本身就成为了公共结构体，但是它的字段依旧保持私有状态。<br>我们可以逐一决定是否将某个字段公开。</p><p>下面的代码定义了一个公共的 <code>back_of_house::Breakfast</code> 结构体，并令其 <code>toast</code> 字段公开，而 <code>seasonal_fruit</code> 字段保持私有。使得客户可以自行选择想要的面包，而只有厨师才能根据季节与存货决定配餐水果。</p><p>编辑 <code>src/lib.rs</code> 源文件，添加如下 <code>back_of_house</code> 模块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">"peaches"</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了测试新添加的代码能否正常工作，修改 <code>src/lib.rs</code> 中的 <code>eat_at_restaurant</code> 函数如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 选择黑麦面包作为夏季早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">"Rye"</span>);</span><br><span class="line">    <span class="comment">// 修改我们想要的面包类型</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">"Wheat"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I'd like &#123;&#125; toast please"</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的这一行无法通过编译，我们不能看到或更换附带的季节性水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from("blueberries");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>back_of_house::Breakfast</code> 结构体中的 <code>toast</code> 字段是公共的，我们因此能够在 <code>eat_at_restaurant</code> 中使用点号读写 <code>toast</code> 字段。<br>同样由于 <code>seasonal_fruit</code> 字段是私有的，我们不能在 <code>eat_at_restaurant</code> 中访问它。<br>另外，由于 <code>back_of_house::Breakfast</code> 拥有一个私有字段，这个结构体必须提供一个公共的关联函数来构造 <code>Breakfast</code> 实例（本例中的 <code>summer</code>），否则我们将无法在结构体外部创建任何的 <code>Breakfast</code> 实例。</p><h4 id="用-use-关键字将路径导入作用域"><a href="#用-use-关键字将路径导入作用域" class="headerlink" title="用 use 关键字将路径导入作用域"></a>用 <code>use</code> 关键字将路径导入作用域</h4><p>基于路径来调用函数的写法看上去会有些重复与冗长。无论我们使用绝对路径还是相对路径来指定 <code>seat_at_table</code> 函数，都必须在每次调用时指定路径上的 <code>front_of_house</code> 和 <code>hosting</code> 节点。<br>可以借助 <code>use</code> 关键字将路径引入作用域，简化上述步骤。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在作用域中使用 <code>use</code> 引入路径有点类似于在文件系统中创建符号链接。通过在单元包的根节点下添加上述两条 <code>use</code> 语句，<code>hosting</code> 和 <code>serving</code> 成了该作用域下的一个有效名称，就如同这两个模块被定义在根节点下一样。</p><p>这里使用了 <code>use crate::front_of_house::hosting</code> 并接着调用 <code>hosting::seat_at_table</code>，而没有使用 <code>use crate::front_of_house::hosting::seat_at_table</code> 来直接引入 <code>seat_at_table</code> 函数。<br>相对而言，前者的方式更常用一些。使用 <code>use</code> 将函数的父模块引入作用域，意味着我们必须在调用函数时指定这个父模块，从而更清晰地表明当前函数没有被定义在当前作用域中。</p><p>不同于函数，使用 <code>use</code> 将结构体、枚举或其他条目引入作用域时，我们习惯于通过指定完整路径的方式引入。</p><h5 id="使用-as-提供新的名称"><a href="#使用-as-提供新的名称" class="headerlink" title="使用 as 提供新的名称"></a>使用 <code>as</code> 提供新的名称</h5><p>使用 use 将多个同名类型引入作用域时，还可以在路径后使用 <code>as</code> 关键字为类型指定一个新的本地名称，也就是别名。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure></p><h5 id="使用-pub-use-重导出名称"><a href="#使用-pub-use-重导出名称" class="headerlink" title="使用 pub use 重导出名称"></a>使用 <code>pub use</code> 重导出名称</h5><p>当我们使用 <code>use</code> 关键字将名称引入作用域时，这个名称会以私有的方式在新的作用域中生效。为了让外部代码能够访问到这些名称，可以通过组合使用 <code>pub</code> 和 <code>use</code> 修饰其路径。<br>这项技术也被称作重导出。</p><p>比如使用 <code>pub</code> 修饰前面 <code>src/lib.rs</code> 中的某条 <code>use</code> 语句：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure></p><p>于是在另一个文件 <code>src/main.rs</code> 中也就可以使用 <code>restaurant::hosting::seat_at_table()</code> 形式的代码调用 <code>hosting</code> 模块中的函数了。<br>通过使用 <code>pub use</code>，我们可以在编写代码时使用一种结构，在对外暴露时使用另外一种不同的结构。这一方法可以让我们的代码库对编写者和调用者同时保持良好的组织结构。</p><h4 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h4><p>当模块规模逐渐增大时，我们可以将它们的定义移动到新的文件中。<br>比如我们需要将 <code>src/lib.rs</code> 中定义的 <code>front_of_house</code> 模块移动到它自己的文件 <code>src/front_of_house.rs</code> 中。首先将根节点文件 <code>lib.rs</code> 中的代码改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>mod front_of_house</code> 后使用分号而不是代码块，会让 Rust 前往与当前模块同名的文件中加载模块内容。因此可以将 <code>front_of_house</code> 模块的具体定义转移到 <code>src/front_of_house.rs</code> 文件中，效果是一样的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上还可以更进一步，继续拆解 <code>front_of_house</code> 模块到其他文件中。首先将 <code>src/front_of_house.rs</code> 文件的内容改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure></p><p>接着创建一个 <code>src/front_of_house</code> 目录，以及一个 <code>src/front_of_house/hosting.rs</code> 文件用来存放 <code>hosting</code> 模块的定义，一个 <code>src/front_of_house/serving.rs</code> 文件存放 <code>serving</code> 模块的定义：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/serving.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果与前两种版本也是一致的。<br>此时 <code>restaurant</code> 项目的目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── front_of_house</span><br><span class="line">    │   ├── hosting.rs</span><br><span class="line">    │   └── serving.rs</span><br><span class="line">    ├── front_of_house.rs</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>所有的修改都没有改变原有的模块树结构，尽管这些定义被放置到了不同的文件中，<code>eat_at_restaurant</code> 中的函数调用依旧有效。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;模块系统&quot;&gt;&lt;a href=&quot;#模块系统&quot; class=&quot;headerlink&quot; title=&quot;模块系统&quot;&gt;&lt;/a&gt;模块系统&lt;/h4&gt;&lt;p&gt;在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Package" scheme="https://rollingstarky.github.io/tags/Package/"/>
    
      <category term="Project" scheme="https://rollingstarky.github.io/tags/Project/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Module" scheme="https://rollingstarky.github.io/tags/Module/"/>
    
      <category term="Crate" scheme="https://rollingstarky.github.io/tags/Crate/"/>
    
      <category term="Scope" scheme="https://rollingstarky.github.io/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（五）自定义 Types</title>
    <link href="https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/"/>
    <id>https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-07-06T14:50:37.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ADT-Algebraic-data-types"><a href="#ADT-Algebraic-data-types" class="headerlink" title="ADT (Algebraic data types)"></a>ADT (Algebraic data types)</h4><p>类似 <code>Bool</code>、<code>Int</code>、<code>Char</code> 这些都是内置的数据类型，我们可以使用 <strong><code>data</code></strong> 关键字创建自己的类型。</p><p>标准库中的 <code>Bool</code> 类型实际上是这样定义的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br></pre></td></tr></table></figure></p><p>其中 <code>=</code> 左边部分指定类型的名称，右边部分叫做 <strong>value constructors</strong>，用来指定当前类型能够拥有的不同数值。<br>整个语句可以读作“<code>Bool</code> 类型可以使用 <code>True</code> 或者 <code>False</code> 作为它的值”。</p><p>现在思考下应该用怎样的形式表示一种形状。可以使用元组，比如圆圈可以表示为 <code>(43.1, 55.0, 10.4)</code>。前两项表示圆心的坐标，最后一项表示半径。<br>但这种形式的元组也同样可以表示一个三维向量或者其他对象。更好一点的方法是创建自定义的数据类型。</p><p>假设一个形状对象可以是圆或者矩形，则可以定义如下形式的 <code>Shape</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure></p><p>可以这样理解，<code>Circle</code> value constructor 包含三个 Float 类型的字段，前两个字段是圆心的坐标，最后一个字段表示半径；<code>Rectangle</code> value constructor 包含四个 Float 类型的字段，前两个字段表示左上角顶点的坐标，后两个字段表示右下角的坐标。</p><p>Value constructor 实际上是一种函数，所谓的“字段”是函数的参数，最终返回特定的数据类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Circle</span></span><br><span class="line"><span class="type">Circle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Rectangle</span></span><br><span class="line"><span class="type">Rectangle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br></pre></td></tr></table></figure></p><p>接下来就可以针对 <code>Shape</code> 类型定义一个 <code>surface</code> 函数，用来计算某个 Shape 的面积：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| surface :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">10</span>)</span><br><span class="line"><span class="number">314.15927</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span> <span class="number">100</span>)</span><br><span class="line"><span class="number">10000.0</span></span><br></pre></td></tr></table></figure><p>但是当我们在 <code>ghci</code> 中像调用函数那样直接执行如 <code>Circle 10 20 5</code> 这类命令时，会报出如下错误：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:<span class="number">14</span>:<span class="number">1</span>: error:</span><br><span class="line">    • <span class="type">No</span> <span class="keyword">instance</span> for (<span class="type">Show</span> <span class="type">Shape</span>) arising from a use <span class="keyword">of</span> ‘print’</span><br><span class="line">    • <span class="type">In</span> a stmt <span class="keyword">of</span> an interactive <span class="type">GHCi</span> command: print it</span><br></pre></td></tr></table></figure></p><p>原因是 Haskell 不清楚如何将此处的自定义类型表示为字符串。当在 <code>ghci</code> 中打印一个值时，实际上 Haskell 调用了 <code>show</code> 函数用来获取对应值的字符串形式，并输出到命令行。<br>为了使我们的 <code>Shape</code> 类型支持打印输出，需要令其实现 <code>Show</code> typeclass。语法如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时 <code>Shape</code> 类型即可支持打印输出操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Rectangle</span> <span class="number">50</span> <span class="number">230</span> <span class="number">60</span> <span class="number">90</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="number">50.0</span> <span class="number">230.0</span> <span class="number">60.0</span> <span class="number">90.0</span></span><br></pre></td></tr></table></figure></p><p>Value constructor 实际上就是函数，也因此支持 <code>map</code>、partially apply 等操作。<br>比如可以使用如下代码创建一系列半径不同的同心圆：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span>) [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">4.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure></p><p>让我们再定义一个 <code>Point</code> 类型，并令其成为 <code>Shape</code> 类型的一部分，从而更加容易理解：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时的 <code>Circle</code> 类型拥有两个字段，用 <code>Point</code> 类型表示圆圈的圆心，再加一个 <code>Float</code> 类型表示半径。</p><p>重新实现下之前的 <code>surface</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><p>只需要重新定义模式匹配的部分即可。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> <span class="number">100</span> <span class="number">100</span>))</span><br><span class="line"><span class="number">10000.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) <span class="number">24</span>)</span><br></pre></td></tr></table></figure></p><p>还可以创建一个 <code>nudge</code> 函数用来移动某个形状对象的位置。它接收一个形状及其在 x 轴和 y 轴上的偏移量作为参数，返回一个同样大小、不同位置的形状对象。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nudge</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="title">nudge</span> (<span class="type">Circle</span> (<span class="type">Point</span> x y) r) a b = <span class="type">Circle</span> (<span class="type">Point</span> (x+a) (y+b)) r</span><br><span class="line"><span class="title">nudge</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) a b = <span class="type">Rectangle</span> (<span class="type">Point</span> (x1+a) (y1+b)) (<span class="type">Point</span> (x2+a) (y2+b))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; nudge (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">34</span> <span class="number">34</span>) <span class="number">10</span>) <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="type">Circle</span> (<span class="type">Point</span> <span class="number">39.0</span> <span class="number">44.0</span>) <span class="number">10.0</span></span><br></pre></td></tr></table></figure><h4 id="Record-语法"><a href="#Record-语法" class="headerlink" title="Record 语法"></a>Record 语法</h4><p>假设创建一个名为 <code>Person</code> 的自定义数据类型。它需要包含名字、姓氏、年龄、身高、手机号和最喜欢的冰淇淋种类等字段。<br>可以使用如下代码实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Float</span> <span class="type">String</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> guy = <span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; guy</span><br><span class="line"><span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br></pre></td></tr></table></figure></p><p>上述代码是可以运行的，但可读性却很差。<br>当我们需要创建函数来获取 Person 对象中的某个字段的值时，可能就需要借助如下形式的代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">firstName</span> (<span class="type">Person</span> firstname _ _ _ _ _) = firstname</span><br><span class="line">  </span><br><span class="line"><span class="title">lastName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lastName</span> (<span class="type">Person</span> _ lastname _ _ _ _) = lastname</span><br><span class="line">  </span><br><span class="line"><span class="title">age</span> :: <span class="type">Person</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">age</span> (<span class="type">Person</span> _ _ age _ _ _) = age</span><br><span class="line">  </span><br><span class="line"><span class="title">height</span> :: <span class="type">Person</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">height</span> (<span class="type">Person</span> _ _ _ height _ _) = height</span><br><span class="line">  </span><br><span class="line"><span class="title">phoneNumber</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">phoneNumber</span> (<span class="type">Person</span> _ _ _ _ number _) = number</span><br><span class="line">  </span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">flavor</span> (<span class="type">Person</span> _ _ _ _ _ flavor) = flavor</span><br></pre></td></tr></table></figure></p><p>鉴于上述场景中的代码实现有诸多不方便的地方，Haskell 提供了另外一种创建数据类型的方法，即 Record 语法。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">flavor</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>通过上述语法，Haskell 会自动创建 <code>firstName</code>、<code>lastName</code>、<code>age</code>、<code>height</code>、<code>phoneNumber</code>、<code>flavor</code> 等函数，用于访问该类型对象中的对应字段。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t flavor</span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t firstName</span><br><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure></p><p>Record 语法的另一个好处在于，Value constructor 中涉及到的所有字段都可以拥有一个有意义的名称，方便各字段之间的相互区分。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Car</span> = <span class="type">Car</span> &#123;<span class="title">company</span> :: <span class="type">String</span>, <span class="title">model</span> :: <span class="type">String</span>, <span class="title">year</span> :: <span class="type">Int</span>&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> car = <span class="type">Car</span> &#123;company=<span class="string">"Ford"</span>, model=<span class="string">"Mustang"</span>, year=<span class="number">1967</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; car</span><br><span class="line"><span class="type">Car</span> &#123;company = <span class="string">"Ford"</span>, model = <span class="string">"Mustang"</span>, year = <span class="number">1967</span>&#125;</span><br></pre></td></tr></table></figure></p><p>比如创建一个用于表示三维向量的数据类型，可以使用 <code>data Vector = Vector Int Int Int</code> 语句。但这样的语法对于前面的 <code>Person</code> 和 <code>Car</code> 来讲，其含义就不如使用 Record 语法来得清晰。</p><h4 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h4><p>Value constructor 可以接收特定数量的参数来生成一个特定类型的值。比如前面的 <code>Car</code> 接收 3 个参数生成一个新的 car。<br><strong>Type constructor</strong> 则可以接收 type 作为参数来生成一个新的类型。</p><p>比如内置的 <code>Maybe</code> 的实现：<br><code>data Maybe a = Nothing | Just a</code></p><p>其中 <code>a</code> 表示类型参数，<code>Maybe</code> 即为 type constructor。我们可以向 <code>Maybe</code> 传入一个 <code>Char</code> 作为类型参数，就可以得到一个新的 <code>Maybe Char</code> 类型。比如值 <code>Just &#39;a&#39;</code> 就属于 <code>Maybe Char</code> 类型。<br>同样的方式可以得到类型 <code>Maybe Int</code>、<code>Maybe String</code> 等等。</p><p><code>Maybe</code> 实际上表示一种<strong>可选项</strong>，它可以是任意某种特定类型的值，也可以什么值都不包含（<code>Nothing</code>）。比如 <code>Maybe Int</code> 类型就表示该类型的值可能包含 <code>Int</code>（值 <code>Just 5</code>），也可能不包含任意类型（<code>Nothing</code>）。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="number">84</span></span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">10</span> :: <span class="type">Maybe</span> <span class="type">Double</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure><p>实际上还有一种类型涉及到了类型参数，只不过借助了语法糖，其形式稍有不同。该类型就是 list。<br>list 类型可以接收一个类型参数生成更具体的类型。比如 <code>[Int]</code>、<code>[Char]</code> 甚至 <code>[[String]]</code> 等等。<br>但是没有任何值的类型可以是 <code>[]</code>。空列表实际上可以表现得像任意类型的列表，其类型是 <code>[a]</code>，也因此可以使用如下形式的表达式：<code>[1,2,3] ++ []</code>、<code>[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;] ++ []</code>。</p><p>下面的代码实现了一种三维的向量类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="title">vplus</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vplus` (<span class="type">Vector</span> l m n) = <span class="type">Vector</span> (i+l) (j+m) (k+n)</span><br><span class="line">  </span><br><span class="line"><span class="title">vectMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vectMult` m = <span class="type">Vector</span> (i*m) (j*m) (k*m)</span><br><span class="line">  </span><br><span class="line"><span class="title">scalarMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `scalarMult` (<span class="type">Vector</span> l m n) = i*l + j*m + k*n</span><br></pre></td></tr></table></figure></p><p>上述函数可以作用在 <code>Vector Int</code>、<code>Vector Integer</code>、<code>Vector  Float</code> 类型上，只要类型 <code>Vector a</code> 中的 <code>a</code> 属于 <code>Num</code> typeclass。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> `vplus` <span class="type">Vector</span> <span class="number">9</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">12</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">9</span> <span class="number">7</span> `vectMult` <span class="number">10.0</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">30.0</span> <span class="number">90.0</span> <span class="number">70.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">4</span> <span class="number">9</span> <span class="number">5</span> `scalarMult` <span class="type">Vector</span> <span class="number">9.0</span> <span class="number">2.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="number">74.0</span></span><br></pre></td></tr></table></figure></p><p>类型参数通常用在当 type constructor 中包含的类型对该类型的正常工作并不产生影响时。即我们的自定义类型表现得像某种“盒子”，里面可以放任意的特定类型的值。</p><h4 id="派生实例"><a href="#派生实例" class="headerlink" title="派生实例"></a>派生实例</h4><p><strong>typeclass 是一种定义了某种行为的接口</strong>。若某个类型支持 typeclass 定义的行为，则该类型成为 typeclass 的实例。<br>比如 <code>Eq</code> typeclass 定义了可以被测试是否相等的行为，而整数之间可以比较是否相等，因此 <code>Int</code> 类型是 <code>Eq</code> typeclass 的实例。与此同时，作为 <code>Eq</code> 接口的函数如 <code>==</code> 和 <code>/=</code>，则可以直接调用 <code>Int</code> 类型的值，测试它们是否相等（或不相等）。</p><p>typeclass 经常会与其他语言如 Java 中的类相混淆。实际上在其他语言中，类可以看作创建对象（包含自身状态和行为）的蓝图；而 typeclass 则更像是接口。<br>在 Haskell 中，我们先创建某个数据类型，然后考虑该类型有怎样的行为。若该类型可以被排序，则令其成为 <code>Ord</code> typeclass 的实例。这之后该类型的值就可以被 <code>&gt;</code>、<code>&lt;</code>、<code>compare</code> 等比较大小的函数调用了。</p><p>现在假设两个人可以有相同的姓氏、名字和年龄，则这两个人就是“相等”的。由此创建一个可以比较是否相等的 <code>Person</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>)</span></span><br></pre></td></tr></table></figure></p><p>当我们使用 <code>==</code> 比较两个实现了 <code>Eq</code> typeclass  的类型实例时，Haskell 会先用 <code>==</code> 比较两个类型实例的 value constructor 是否相等，再比较类型实例中包含的所有字段的值是否都相等。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> adRock = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Horovitz"</span>, age = <span class="number">41</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mca = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Yauch"</span>, age = <span class="number">44</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mca == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == mikeD</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>Person</code> 类型现在是 <code>Eq</code> typeclass 的实例，因此我们可以将其传给类型约束是 <code>Eq a</code> 的函数，比如 <code>elem</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> beastieBoys = [mca, adRock, mikeD]</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD `elem` beastieBoys</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p><code>Show</code> 和 <code>Read</code> typeclass 与类型值的字符串转换有关。<code>Show</code> 表示将类型值转换为 String，<code>Read</code> 则表示将 String 转换为特定类型的值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Read</span>)</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD</span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="string">"mikeD is: "</span> ++ show mikeD</span><br><span class="line"><span class="string">"mikeD is: Person &#123;firstName = \"Michael\", lastName = \"Diamond\", age = 43&#125;"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Person &#123;firstName =\"Michael\", lastName =\"Diamond\", age = 43&#125;"</span> :: <span class="type">Person</span></span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br></pre></td></tr></table></figure></p><p>对于实现了 <code>Ord</code> typeclass 的类型，我们可以根据 value constructor 中值出现的顺序比较同一类型不同值的大小。value constructor 中左侧的值总小于右侧的值。内置的 Bool 类型可以大概视作有如下实现：<br><code>data Bool = False | True deriving (Ord)</code><br>则在比较 <code>False</code> 和 <code>True</code> 时，<code>False</code> 总小于 <code>True</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">False</span> &lt; <span class="type">True</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>借助 <code>Enum</code> 和 <code>Bounded</code> typeclass，可以很轻松地实现枚举类型的 ADT。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br></pre></td></tr></table></figure></p><p>由于 <code>Day</code> 类型实现了 <code>Show</code> 和 <code>Read</code> typeclass，则可以在此类型与字符串之间进行转换：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Wednesday</span></span><br><span class="line"><span class="type">Wednesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; show <span class="type">Wednesday</span></span><br><span class="line"><span class="string">"Wednesday"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Saturday"</span> :: <span class="type">Day</span></span><br><span class="line"><span class="type">Saturday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Eq</code> 和 <code>Ord</code> typeclass，则可以在 <code>Day</code> 类型的值之间进行比较：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Sunday</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Saturday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> &gt; <span class="type">Friday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Monday</span> `compare` <span class="type">Wednesday</span></span><br><span class="line"><span class="type">LT</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Bounded</code> typeclass，我们可以获取“最低”和最高的 <code>Day</code> 类型值：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Monday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Sunday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Enum</code>，因此我们可以对其进行序列类型的操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; succ <span class="type">Monday</span></span><br><span class="line"><span class="type">Tuesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; pred <span class="type">Saturday</span></span><br><span class="line"><span class="type">Friday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="type">Thursday</span> .. <span class="type">Sunday</span>]</span><br><span class="line">[<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [minBound .. maxBound] :: [<span class="type">Day</span>]</span><br><span class="line">[<span class="type">Monday</span>,<span class="type">Tuesday</span>,<span class="type">Wednesday</span>,<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ADT-Algebraic-data-types&quot;&gt;&lt;a href=&quot;#ADT-Algebraic-data-types&quot; class=&quot;headerlink&quot; title=&quot;ADT (Algebraic data types)&quot;&gt;&lt;/a&gt;ADT (Algebra
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Typeclass" scheme="https://rollingstarky.github.io/tags/Typeclass/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（四）高阶函数</title>
    <link href="https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/"/>
    <id>https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-06-30T12:33:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做<strong>高阶函数（high order functions）</strong>。<br>想要通过<strong>定义是什么</strong>而不是<strong>定义一系列可以改变程序状态的步骤</strong>来完成计算过程，高阶函数是必不可少的。</p><h4 id="Curried-functions"><a href="#Curried-functions" class="headerlink" title="Curried functions"></a>Curried functions</h4><p><strong>Haskell 中的函数实际上都只接收一个参数</strong>。前面遇到的接收多个参数的函数是一种 <strong>Curried functions</strong>，可以看作某种特殊形式。<br>比如 <code>max 4 5</code>，看上去是向函数 <code>max</code> 传入两个参数 <code>4</code> 和 <code>5</code>，返回数值较大的 <code>5</code>。实际的计算过程是 <code>(max 4) 5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>首先将参数 <code>4</code> 传递给函数 <code>max</code>，<strong>会返回另一个函数，该函数接收任意一个参数，将该参数与数字 4 比较，返回较大的数</strong>。所以后面将 <code>5</code> 传给函数 <code>(max 4)</code> 后，得到最终的结果 <code>5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> maxWithFour = max <span class="number">4</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxWithFour <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>那么这种形式的函数究竟有什么好处呢？</p><p>当我们使用部分参数调用某个函数的时候，并不会直接得到结果，而是返回一个<strong>部分应用（partially applied）</strong>的函数。这个部分应用的函数可以继续接收剩余的参数，最终得到计算结果。</p><p>partially applied 机制可以方便我们简单地实现动态地创建函数、将函数作为参数传入、用特定数据初始化函数等需求。</p><p>对于函数 <code>multThree</code>：<br><code>let multThree x y z = x * y * z</code><br>它可以接收三个数字作为参数，并计算这三个参数的乘积作为返回值。</p><p>如 <code>multThree 3 5 9</code>，实际上的执行流程为 <code>((multThree 3) 5) 9</code>。</p><ul><li>将数字 3 传递给 <code>multThree</code>，它会返回一个函数 <code>(multThree 3)</code>。该函数接收任意两个数字，并计算它们和 3 的乘积</li><li>将数字 5 传递给 <code>(multThree 3)</code>，返回另一个函数 <code>((multThree 3) 5)</code>。该函数接收任意一个数字，并计算它和 15 的乘积</li><li>将数字 9 传递给 <code>((multThree 3) 5)</code>，返回 9 和 15 的乘积作为结果</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multThreeNums x y z = x * y * z</span><br><span class="line"><span class="type">Prelude</span>&gt; multThreeNums <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multTwoNumsWithNine = multThreeNums <span class="number">9</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multTwoNumsWithNine <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multOneNumWithEighteen = multTwoNumsWithNine <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multOneNumWithEighteen <span class="number">10</span></span><br><span class="line"><span class="number">180</span></span><br></pre></td></tr></table></figure><p>中缀函数如 <code>+ - * /</code> 等也可以 partially applied。</p><p>比如可以将数字 5 传递给中缀函数 <code>+</code> 生成一个新的函数 <code>(5+)</code>，而新函数 <code>(5+)</code> 可以接收一个数字作为参数，返回该参数与 5 的和。<br>即函数 <code>(5+)</code> 其实是中缀函数 <code>+</code> 固定一个参数 5 之后生成的新函数，这个新函数接收任何一个数字作为另一个加数并求和。</p><p>使用 <code>/</code> 固定除数生成新函数 <code>divideByTen</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideByTen = (/<span class="number">10</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideByTen <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (/<span class="number">10</span>) <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">200</span> / <span class="number">10</span></span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure></p><p><code>divideByTen 200</code> 等同于 <code>(/10) 200</code> 等同于 <code>200 / 10</code>。</p><p>同样的方式还可以定义 <code>divideTen</code> 固定被除数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideTen = (<span class="number">10</span>/)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideTen <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (<span class="number">10</span>/) <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">10</span> / <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure></p><p>检查输入的字符是否是大写字母：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> isUpperAlphanum = (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>])</span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum '<span class="type">D'</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum 'a'</span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure></p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> applyTwice f x = f (f x)</span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (+<span class="number">3</span>) <span class="number">10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (++ <span class="string">" HAHA"</span>) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HEY HAHA HAHA"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="string">"HAHA "</span> ++) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HAHA HAHA HEY"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="number">3</span>:) [<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="zipWith-的自定义实现"><a href="#zipWith-的自定义实现" class="headerlink" title="zipWith 的自定义实现"></a>zipWith 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">ith'</span> f <span class="type">Prelude</span>| zipWith' _ [] _ = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' _ _ [] = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (++) [<span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span>] [<span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span>]</span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h5 id="flip-的自定义实现"><a href="#flip-的自定义实现" class="headerlink" title="flip 的自定义实现"></a>flip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">flip'</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="title">flip'</span> f y x = f x y</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="type">Prelude</span>| flip' f y x = f x y</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; flip' zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">"hello"</span></span><br><span class="line">[('h',<span class="number">1</span>),('e',<span class="number">2</span>),('l',<span class="number">3</span>),('l',<span class="number">4</span>),('o',<span class="number">5</span>)]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith (flip' div) [<span class="number">2</span>,<span class="number">2.</span>.] [<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="Maps-amp-Filters"><a href="#Maps-amp-Filters" class="headerlink" title="Maps &amp; Filters"></a>Maps &amp; Filters</h4><p><code>map</code> 接收一个函数和一个列表作为参数，可以将函数应用到列表的每一项元素上。</p><p><code>map</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  </span><br><span class="line"><span class="title">map</span> _ [] = []  </span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (++ <span class="string">"!"</span>) [<span class="string">"BIFF"</span>, <span class="string">"BANG"</span>, <span class="string">"POW"</span>]</span><br><span class="line">[<span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (replicate <span class="number">3</span>) [<span class="number">3.</span><span class="number">.6</span>]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (map (^<span class="number">2</span>)) [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>],[<span class="number">49</span>,<span class="number">64</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map fst [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><code>filter</code> 接收一个判断函数和一个列表作为参数，返回列表中所有使判断函数为真的元素。</p><p><code>filter</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> p (x:xs)</span><br><span class="line">    | p x       = x : filter p xs</span><br><span class="line">    | otherwise = filter p xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; filter (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (==<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> notNull x = not (null x) <span class="keyword">in</span> filter notNull [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[],[],[]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['a'..'z']) <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span></span><br><span class="line"><span class="string">"uagameasadifeent"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"i lauGh At You BecAuse u r aLL the Same"</span></span><br><span class="line"><span class="string">"GAYBALLS"</span></span><br></pre></td></tr></table></figure><p>借助 filter 实现 quicksort：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort (filter (&lt;=x) xs)</span><br><span class="line">        biggerSorted = quicksort (filter (&gt;x) xs)</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure></p><p>找出 100000 以内能够被 3829 整除的最大的数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largestDivisible</span> :: (<span class="type">Integral</span> a) =&gt; a</span><br><span class="line"><span class="title">largestDivisible</span> = head (filter p [<span class="number">100000</span>,<span class="number">99999.</span>.])</span><br><span class="line">    <span class="keyword">where</span> p x = x `mod` <span class="number">3829</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>p x = x `mod` 3829 == 0</code> 定义了函数 <code>p</code> 作为 <code>filter</code> 的判断函数，而列表 <code>[100000, 99999..]</code> 实际上是一个逆序的无穷列表。<br>借助 Haskell 的<strong>惰性计算</strong>机制，函数获取的是最大的可被整除的数，获得该值后就不会再继续计算下去。</p><p>实际上还可以这样使用 <code>map</code> 函数：<br><code>map (*) [0..]</code><br>将函数 <code>*</code> 映射到列表 <code>[0..]</code>，会返回一个包含一系列函数的新列表。新列表的形式类似 <code>[(0*),(1*),(2*),(3*),(4*),(5*)..]</code>。<br>其中的任何一个函数如 <code>(4*)</code>，都是接收两个参数的函数 <code>*</code> 固定了一个参数后的形式，再向其传入一个参数即可完成乘法运算。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> listOfFuns = map (*) [<span class="number">0.</span>.]</span><br><span class="line"><span class="type">Prelude</span>&gt; (listOfFuns !! <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><code>!!</code> 函数可以从指定列表中根据索引值获取特定的元素。<code>(listOfFuns !! 4)</code> 即为 <code>(4*)</code>。</p><h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>Lambda 基本上是代码中只使用一次的匿名函数。<br>由 <code>\</code> 反斜杠符号指定参数，<code>-&gt;</code> 符号指定函数体。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; zipWith (\a b -&gt; a * b - <span class="number">1</span>) [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>和通常的函数类似，lambda 中也可以应用模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (\(a,b) -&gt; a + b) [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>不同的是，lambda 不支持对同一个参数定义多个模式。</p><h4 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h4><p>Fold 有点类似于 <code>map</code> 函数，只不过 fold 操作最终会将列表中的元素归并（<strong>reduce</strong>）到单个值。</p><p>Fold 函数接收三个参数：</p><ul><li>binary function：接收两个参数的函数</li><li>初始值：称作累加器（accumulator）</li><li>需要被折叠的列表</li></ul><p>首先是 binary function 接收 accumulator 和列表的第一个元素作为参数，执行特定的计算后返回一个新的 accumulator；<br>binary function 继续接收刚返回的新 accumulator 和列表中剩余元素中的第一个作为参数，执行计算并返回新的 accumulator；<br>若干次循环过后，列表中的最后一个元素被传入 binary function，返回的 accumulator 即为整个列表归并（折叠）后的最终结果。</p><h5 id="左折叠-foldl"><a href="#左折叠-foldl" class="headerlink" title="左折叠 foldl"></a>左折叠 <code>foldl</code></h5><p>运用左折叠（从左侧开始折叠）实现自定义的 <code>sum</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> sum' xs = foldl (\acc x -&gt; acc + x) <span class="number">0</span> xs</span><br><span class="line"><span class="type">Prelude</span>&gt; sum' [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>对应到前面提到的概念，lambda 函数 <code>(\acc x -&gt; acc + x)</code> 即为 binary function，<code>0</code> 是初始值（accumulator），<code>xs</code> 为传入的待折叠列表。</p><p>借助 curried function，甚至可以写出更简单的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> sum' = foldl (+) <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>lambda 函数 <code>(\acc x -&gt; acc + x)</code> 实际上等效于 <code>(+)</code>。<br>对于 <code>xs</code> 参数的化简，原因是通常情况下，若函数具有 <code>foo a = bar b a</code> 这样的形式，则该函数可以简化为 <code>foo = bar b</code>。</p><p>运用左折叠实现自定义的 <code>elem</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> elem' y ys = foldl (\acc x -&gt; <span class="keyword">if</span> x == y <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> ys</span><br><span class="line"><span class="type">Prelude</span>&gt; elem' <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><h5 id="右折叠-foldr"><a href="#右折叠-foldr" class="headerlink" title="右折叠 foldr"></a>右折叠 <code>foldr</code></h5><p>运用右折叠（从右侧开始折叠）实现自定义的 <code>map</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> map' f xs = foldr (\x acc -&gt; f x : acc) [] xs</span><br><span class="line"><span class="type">Prelude</span>&gt; map' (+<span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>此外还有两个折叠函数 <code>foldl1</code> 和 <code>foldr1</code>。它们与 <code>foldl</code> 和 <code>foldr</code> 的功能基本相同，只不过不需要显式地提供初始值。而是会自动地将列表的第一个值（不管从左起还是从右起）作为初始值。</p><p>以下是几个通过 fold 操作实现的标准库函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> = foldr1 (\x acc -&gt; <span class="keyword">if</span> x &gt; acc <span class="keyword">then</span> x <span class="keyword">else</span> acc)</span><br><span class="line">  </span><br><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> = foldl (\acc x -&gt; x : acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">product'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">product'</span> = foldr1 (*)</span><br><span class="line">  </span><br><span class="line"><span class="title">filter'</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter'</span> p = foldr (\x acc -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : acc <span class="keyword">else</span> acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">head'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head'</span> = foldr1 (\x _ -&gt; x)</span><br><span class="line">  </span><br><span class="line"><span class="title">last'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">last'</span> = foldl1 (\_ x -&gt; x)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做&lt;strong&gt;高阶函数（high order functions）&lt;/strong&gt;。&lt;br&gt;想要通过&lt;strong&gt;定义是什么&lt;/strong&gt;而不是&lt;strong&gt;定义一系列可以改变程序状态的步骤&lt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Map" scheme="https://rollingstarky.github.io/tags/Map/"/>
    
      <category term="Reduce" scheme="https://rollingstarky.github.io/tags/Reduce/"/>
    
      <category term="Filter" scheme="https://rollingstarky.github.io/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（三）递归</title>
    <link href="https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/"/>
    <id>https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-06-29T12:12:17.348Z</updated>
    
    <content type="html"><![CDATA[<p>递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。</p><p>数学中的定义很多时候都会用到递归，比如 fibonacci 数列：</p><ul><li><code>F(0) = 1</code></li><li><code>F(1) = 1</code></li><li><code>F(n) = F(n - 1) + F(n - 2)</code></li></ul><p>于是有 <code>F(3) = F(2) + F(1) = (F(1) + F(0)) + F(1) = 2</code>。</p><p>递归函数的定义中，并不只是包含调用自身的代码，常常还需要非递归形式的定义，如上面的 <code>F(0) = 1</code> 和 <code>F(1) = 1</code>。这样的代码称作<strong>边缘条件（edge condition）</strong>。<br>边缘条件对于递归函数的终止至关重要。假如上面的 <code>F(0)</code> 和 <code>F(1)</code> 未定义，则任何一个输入都会导致函数无限调用自身，永远不会终止。</p><p>递归是 Haskell 中很重要的概念。不同于命令式的语言，在 Haskell 中需要<strong>定义计算本身是什么</strong>，而不是<strong>定义怎样一步步得出结果</strong>。</p><h5 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs)</span><br><span class="line">    | x &gt; maxTail = x</span><br><span class="line">    | otherwise = maxTail</span><br><span class="line">    <span class="keyword">where</span> maxTail = maximum' xs</span><br></pre></td></tr></table></figure><p>使用 <code>max</code> 函数（返回两个输入值中较大的那个）编写更短的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs) = max x (maximum' xs)</span><br></pre></td></tr></table></figure></p><p>当输入为 <code>[2, 5, 1]</code> 时，计算过程如下：<br><code>maximum&#39; [2, 5, 1]</code> -&gt; <code>max 2 (maximum&#39; [5, 1])</code> -&gt; <code>max 2 (max 5 (maximum&#39; [1]))</code> -&gt; <code>max 2 (max 5 1)</code> -&gt; <code>max 2 5</code> -&gt; <code>5</code>。</p><h5 id="生成由固定数量的同一元素构成的列表"><a href="#生成由固定数量的同一元素构成的列表" class="headerlink" title="生成由固定数量的同一元素构成的列表"></a>生成由固定数量的同一元素构成的列表</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicate'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">replicate'</span> n x</span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []</span><br><span class="line">    | otherwise = x:replicate' (n<span class="number">-1</span>) x</span><br></pre></td></tr></table></figure><p>如 <code>replicate&#39; 3 5</code> -&gt; <code>5:(replicate&#39; 2 5)</code> -&gt; <code>5:(5:(replicate&#39; 1 5))</code> -&gt; <code>5:(5:(5:(replicate&#39; 0 5)))</code> -&gt; <code>5:(5:(5:[]))</code> -&gt; <code>[5, 5, 5]</code>。</p><h5 id="取出列表中的前几个元素"><a href="#取出列表中的前几个元素" class="headerlink" title="取出列表中的前几个元素"></a>取出列表中的前几个元素</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">take'</span> n _</span><br><span class="line">    | n &lt;= <span class="number">0</span>   = []</span><br><span class="line"><span class="title">take'</span> _ []     = []</span><br><span class="line"><span class="title">take'</span> n (x:xs) = x : take' (n<span class="number">-1</span>) xs</span><br></pre></td></tr></table></figure><p>其中 <code>take&#39; n _</code> 和 <code>take&#39; _ []</code> 分别作为两种不同情况下的终止条件。<br>第一个模式 <code>take&#39; n _</code> 表示当 <code>n</code> 小于等于 0 时，不管输入的是什么样的列表都返回空列表 <code>[]</code>。<br>可以作为如 <code>take&#39; 2 [1, 2, 3]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后 <code>n</code> 等于 0，满足第一个模式，递归终止。<br>第二个模式 <code>take _ []</code> 表示当输入的列表是空列表时，不管 <code>n</code> 是多少都返回空列表。<br>可以作为如 <code>take&#39; 3 [1, 2]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后，n 为 1，但列表成为空列表，满足第二个模式，递归终止。<br>第三个模式 <code>take&#39; n (x:xs)</code> 则用来定义从输入的列表头部逐个取出 n 个元素并拼接成新列表的递归逻辑。</p><h5 id="reverse-的自定义实现"><a href="#reverse-的自定义实现" class="headerlink" title="reverse 的自定义实现"></a>reverse 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> [] = []</span><br><span class="line"><span class="title">reverse'</span> (x:xs) = reverse' xs ++ [x]</span><br></pre></td></tr></table></figure><h5 id="zip-的自定义实现"><a href="#zip-的自定义实现" class="headerlink" title="zip 的自定义实现"></a>zip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip'</span> :: [a] -&gt; [b] -&gt; [(a,b)]</span><br><span class="line"><span class="title">zip'</span> _ [] = []</span><br><span class="line"><span class="title">zip'</span> [] _ = []</span><br><span class="line"><span class="title">zip'</span> (x:xs) (y:ys) = (x,y):zip' xs ys</span><br></pre></td></tr></table></figure><h5 id="elem-的自定义实现（判断某个元素是否属于某个列表）"><a href="#elem-的自定义实现（判断某个元素是否属于某个列表）" class="headerlink" title="elem 的自定义实现（判断某个元素是否属于某个列表）"></a>elem 的自定义实现（判断某个元素是否属于某个列表）</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">elem'</span> a [] = <span class="type">False</span></span><br><span class="line"><span class="title">elem'</span> a (x:xs)</span><br><span class="line">    | a == x    = <span class="type">True</span></span><br><span class="line">    | otherwise = a `elem'` xs</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]</span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure><h5 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h5><p>递归函数的定义通常遵循如下模式：</p><ul><li>定义边缘条件（edge conditon）用于在特定条件下终止递归的执行</li><li>取出部分元素执行特定操作，再调用递归函数本身处理剩余的元素</li></ul><p>某个列表中所有元素之和等于该列表的第一个元素加上剩余的所有元素之和；某个列表的长度等于尾部（去除头部第一个元素）所有元素的长度加 1。</p><p>通常情况下，edge condition 就是令递归函数无实际意义的条件。对于列表来说，最常见的 edge condition 就是空列表。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。&lt;/p&gt;
&lt;p&gt;数学中的定义很多时候都会用到递归，比如 fibonacci 数列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F(0) = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F(
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Recursion" scheme="https://rollingstarky.github.io/tags/Recursion/"/>
    
      <category term="Computation" scheme="https://rollingstarky.github.io/tags/Computation/"/>
    
  </entry>
  
</feed>
