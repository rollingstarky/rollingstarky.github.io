<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2021-07-08T16:40:32.519Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>The Rust programming language 读书笔记——包（package）、单元包（crate）与模块系统</title>
    <link href="https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/"/>
    <id>https://rollingstarky.github.io/2021/07/09/the-rust-programming-language-reading-notes-package-crate-and-module-system/</id>
    <published>2021-07-08T16:00:00.000Z</published>
    <updated>2021-07-08T16:40:32.519Z</updated>
    
    <content type="html"><![CDATA[<h4 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h4><p>在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实现指定功能的代码片段，确定哪些地方需要修改。</p><p>除了对功能进行分组，对实现的细节进行封装可以使开发者在更高的层次上复用代码：一旦实现了某个功能，其他代码就可以通过公共接口调用这个操作，而无需了解具体的实现细节。</p><p>Rust 提供了一系列的功能来管理代码，包括决定哪些细节是暴露的，那些细节是私有的，以及不同的作用域内存在哪些名称。这些功能被统称为<strong>模块系统</strong>：</p><ul><li><strong>包（package）</strong>：一个用于构建、测试并分享单元包的 Cargo 特性</li><li><strong>单元包（crate）</strong>：一个用于生成库或可执行文件的树形模块结构</li><li><strong>模块（module）</strong>及 <strong>use 关键字</strong>：用于控制文件结构、作用域及路径的私有性</li><li><strong>路径（path）</strong>：一种用于命名条目的方法，这些条目包括结构体、函数和模块等</li></ul><h4 id="包与单元包"><a href="#包与单元包" class="headerlink" title="包与单元包"></a>包与单元包</h4><p>当我们使用 <code>cargo new</code> 命令创建新项目时，如：<br><code>cargo new restaurant</code></p><p>Cargo 会自动创建如下结构的 Rust 项目：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>Cargo 默认会将自动生成的 <code>src/main.rs</code> 源文件视作一个二进制单元包（crate）的根节点，与包（package）拥有相同的名称（即 <code>restaurant</code>）。<br>假设包的目录中包含文件 <code>src/lib.rs</code>，Cargo 也会自动将其视作与包同名的库单元包的根节点。<br>可以在路径 <code>src/bin</code> 下添加源文件来创建更多的二进制单元包，这些源文件都会被视作独立的二进制单元包。</p><p>自动生成的 <code>src/main.rs</code> 源文件内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, world!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以创建一个 <code>src/lib.rs</code> 源文件，把上面的打印输出的操作作为公共函数定义在 <code>lib.rs</code> 中，再在 <code>main.rs</code> 中调用该公共函数，效果与之前是一致的。</p><p><code>src/lib.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">greeting</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Hello, World!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>src/main.rs</code> 代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::greeting();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>因为 <code>lib.rs</code> 默认会作为一个与包同名（都叫 <code>restaurant</code>）的库单元包（crate）存在，且其中的 <code>greeting</code> 函数已被声明为公开的（<code>pub</code>），因此可以直接在 <code>main.rs</code> 中使用 <code>restaurant::greeting()</code> 调用 <code>lib.rs</code> 中定义的 <code>greeting</code> 函数。</p><p>使用 <code>cargo run</code> 命令运行项目后，<code>target/debug</code> 路径下除了像之前一样生成 <code>restaurant</code> 可执行文件外，还会额外生成 <code>librestaurant.rlib</code> 库文件。</p><p>单元包可以将相关的功能分组，并放到<strong>同一作用域</strong>下，这样便可以使这些功能轻松地在多个项目中共享。<br>将单元包的功能保留在它们自己的作用域中有助于指明某个特定功能来源于哪个单元包，并避免可能的命名冲突。<br>比如 <code>rand</code> 包提供了一个名为 <code>Rng</code> 的 trait，我们同样也可以在自己的单元包中定义一个名为 <code>Rng</code> 的结构体。正是由于这些功能被放置在了各自的作用域中，我们能够使用 <code>rng::Rng</code> 访问 rand 包中提供的 <code>Rng</code> trait，而 <code>Rng</code> 则指向刚刚创建的 <code>Rng</code> 结构体。</p><h5 id="通过定义模块来控制作用域及私有性"><a href="#通过定义模块来控制作用域及私有性" class="headerlink" title="通过定义模块来控制作用域及私有性"></a>通过定义模块来控制作用域及私有性</h5><p>假设我们需要编写一个提供就餐服务的库单元包。一个现实的店面常常会划分为前厅与后厨两个部分，前厅负责点单和结账等，后厨则负责制作料理。</p><p>为了按照餐厅的实际工作方式来组织单元包，可以将函数放置在嵌套的模块中。修改 <code>src/lib.rs</code> 源代码文件，内容如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我们可以使用 <code>mod</code> 关键字来定义一个模块（如本例中的 <code>front_of_house</code>），模块内还可以继续定义其他模块（如本例中的 <code>hosting</code> 和 <code>serving</code>）。模块内同样也可以包含其他条目的定义，如结构体、枚举、常量、trait 或函数等。</p><p><code>src/main.rs</code> 与 <code>src/lib.rs</code> 被称作单元包（crate）的根节点，它们的内容各自组成了一个名为 <code>crate</code> 的模块。这个模块的结构也被称为模块树。<br>上面 <code>src/lib.rs</code> 形成的树状模块结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">crate</span><br><span class="line"> └── front_of_house</span><br><span class="line">     ├── hosting</span><br><span class="line">     │   └── seat_at_table</span><br><span class="line">     └── serving</span><br><span class="line">         ├── take_order</span><br><span class="line">         └── take_payment</span><br></pre></td></tr></table></figure></p><h4 id="路径"><a href="#路径" class="headerlink" title="路径"></a>路径</h4><p>类似于在文件系统中使用路径进行导航，在 Rust 的模块树中定位某个条目同样需要使用路径。</p><p>路径有两种形式：</p><ul><li>使用单元包名或字面量 crate 从根节点开始的绝对路径</li><li>使用 <code>self</code>、<code>super</code> 或内部标识符从当前模块开始的相对路径</li></ul><p>绝对路径与相对路径都至少由一个标识符组成，标识符之间使用双冒号（<code>::</code>）分隔。</p><p>现在尝试在模块外部调用模块中定义的函数。在 <code>src/lib.rs</code> 末尾添加一个公共函数 <code>eat_at_restaurant</code>，调用模块 <code>front_of_house</code> 中定义的函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>修改 <code>src/main.rs</code>，在 <code>main</code> 函数中调用上一步中定义的公共函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    restaurant::eat_at_restaurant();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试编译项目，会报出如下错误：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">error[E0603]: module `hosting` is private</span><br><span class="line">error[E0603]: module `serving` is private</span><br></pre></td></tr></table></figure></p><p>即模块 <code>hosting</code> 和 <code>serving</code> 是私有的，Rust 不允许我们访问。<br>Rust 中的模块不仅仅用于组织代码，同时也定义了<strong>私有边界</strong>：外部代码无法知晓、调用或依赖那些由私有边界封装了的实现细节。<br><strong>Rust 中的所有条目（函数、方法、结构体、枚举、模块及常量）默认都是私有的，处于父级模块中的条目无法使用子模块中的私有条目，但子模块中的条目可以使用其祖先模块中的条目</strong>。<br>Rust 希望默认隐藏内部的实现细节，这样用户就能明确地知道修改哪些内容不会破坏外部代码。</p><h5 id="使用-pub-关键字暴露路径"><a href="#使用-pub-关键字暴露路径" class="headerlink" title="使用 pub 关键字暴露路径"></a>使用 pub 关键字暴露路径</h5><p>可以使用 <code>pub</code> 关键字将某些条目标记为公共的，从而使子模块中的这些部分可以被暴露到祖先模块中。<br>接上面的例子，为了使父模块中的 <code>eat_at_restaurant</code> 函数能够正常访问子模块中定义的函数，可以使用 <code>pub</code> 关键字来标记 <code>hosting</code> 和 <code>serving</code> 模块。<br>需要注意的是，模块被 <code>pub</code> 标记，其效果仅限于模块本身，并不会影响到它内部条目的状态，模块中的内容依旧是私有的。为了使前面的代码正常工作，还必须在需要公开的函数前面添加 <code>pub</code> 关键字。</p><p>编辑 <code>src/lib.rs</code> 中，内容改动如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 绝对路径</span></span><br><span class="line">    crate::front_of_house::hosting::seat_at_table();</span><br><span class="line">    <span class="comment">// 相对路径</span></span><br><span class="line">    front_of_house::serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此时程序即可以正常运行。</p><h5 id="将结构体声明为公共的"><a href="#将结构体声明为公共的" class="headerlink" title="将结构体声明为公共的"></a>将结构体声明为公共的</h5><p>当我们在结构体定义前使用 <code>pub</code> 关键字时，结构体本身就成为了公共结构体，但是它的字段依旧保持私有状态。<br>我们可以逐一决定是否将某个字段公开。</p><p>下面的代码定义了一个公共的 <code>back_of_house::Breakfast</code> 结构体，并令其 <code>toast</code> 字段公开，而 <code>seasonal_fruit</code> 字段保持私有。使得客户可以自行选择想要的面包，而只有厨师才能根据季节与存货决定配餐水果。</p><p>编辑 <code>src/lib.rs</code> 源文件，添加如下 <code>back_of_house</code> 模块：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> back_of_house &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Breakfast</span></span> &#123;</span><br><span class="line">        <span class="keyword">pub</span> toast: <span class="built_in">String</span>,</span><br><span class="line">        seasonal_fruit: <span class="built_in">String</span>,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">impl</span> Breakfast &#123;</span><br><span class="line">        <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">summer</span></span>(toast: &amp;<span class="built_in">str</span>) -&gt; Breakfast &#123;</span><br><span class="line">            Breakfast &#123;</span><br><span class="line">                toast: <span class="built_in">String</span>::from(toast),</span><br><span class="line">                seasonal_fruit: <span class="built_in">String</span>::from(<span class="string">"peaches"</span>),</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了测试新添加的代码能否正常工作，修改 <code>src/lib.rs</code> 中的 <code>eat_at_restaurant</code> 函数如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 选择黑麦面包作为夏季早餐</span></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> meal = back_of_house::Breakfast::summer(<span class="string">"Rye"</span>);</span><br><span class="line">    <span class="comment">// 修改我们想要的面包类型</span></span><br><span class="line">    meal.toast = <span class="built_in">String</span>::from(<span class="string">"Wheat"</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"I'd like &#123;&#125; toast please"</span>, meal.toast);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接下来的这一行无法通过编译，我们不能看到或更换附带的季节性水果</span></span><br><span class="line">    <span class="comment">// meal.seasonal_fruit = String::from("blueberries");</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>back_of_house::Breakfast</code> 结构体中的 <code>toast</code> 字段是公共的，我们因此能够在 <code>eat_at_restaurant</code> 中使用点号读写 <code>toast</code> 字段。<br>同样由于 <code>seasonal_fruit</code> 字段是私有的，我们不能在 <code>eat_at_restaurant</code> 中访问它。<br>另外，由于 <code>back_of_house::Breakfast</code> 拥有一个私有字段，这个结构体必须提供一个公共的关联函数来构造 <code>Breakfast</code> 实例（本例中的 <code>summer</code>），否则我们将无法在结构体外部创建任何的 <code>Breakfast</code> 实例。</p><h4 id="用-use-关键字将路径导入作用域"><a href="#用-use-关键字将路径导入作用域" class="headerlink" title="用 use 关键字将路径导入作用域"></a>用 <code>use</code> 关键字将路径导入作用域</h4><p>基于路径来调用函数的写法看上去会有些重复与冗长。无论我们使用绝对路径还是相对路径来指定 <code>seat_at_table</code> 函数，都必须在每次调用时指定路径上的 <code>front_of_house</code> 和 <code>hosting</code> 节点。<br>可以借助 <code>use</code> 关键字将路径引入作用域，简化上述步骤。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/lib.rs</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// 绝对路径</span></span><br><span class="line"><span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在作用域中使用 <code>use</code> 引入路径有点类似于在文件系统中创建符号链接。通过在单元包的根节点下添加上述两条 <code>use</code> 语句，<code>hosting</code> 和 <code>serving</code> 成了该作用域下的一个有效名称，就如同这两个模块被定义在根节点下一样。</p><p>这里使用了 <code>use crate::front_of_house::hosting</code> 并接着调用 <code>hosting::seat_at_table</code>，而没有使用 <code>use crate::front_of_house::hosting::seat_at_table</code> 来直接引入 <code>seat_at_table</code> 函数。<br>相对而言，前者的方式更常用一些。使用 <code>use</code> 将函数的父模块引入作用域，意味着我们必须在调用函数时指定这个父模块，从而更清晰地表明当前函数没有被定义在当前作用域中。</p><p>不同于函数，使用 <code>use</code> 将结构体、枚举或其他条目引入作用域时，我们习惯于通过指定完整路径的方式引入。</p><h5 id="使用-as-提供新的名称"><a href="#使用-as-提供新的名称" class="headerlink" title="使用 as 提供新的名称"></a>使用 <code>as</code> 提供新的名称</h5><p>使用 use 将多个同名类型引入作用域时，还可以在路径后使用 <code>as</code> 关键字为类型指定一个新的本地名称，也就是别名。如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::<span class="built_in">Result</span>;</span><br><span class="line"><span class="keyword">use</span> std::io::<span class="built_in">Result</span> <span class="keyword">as</span> IoResult;</span><br></pre></td></tr></table></figure></p><h5 id="使用-pub-use-重导出名称"><a href="#使用-pub-use-重导出名称" class="headerlink" title="使用 pub use 重导出名称"></a>使用 <code>pub use</code> 重导出名称</h5><p>当我们使用 <code>use</code> 关键字将名称引入作用域时，这个名称会以私有的方式在新的作用域中生效。为了让外部代码能够访问到这些名称，可以通过组合使用 <code>pub</code> 和 <code>use</code> 修饰其路径。<br>这项技术也被称作重导出。</p><p>比如使用 <code>pub</code> 修饰前面 <code>src/lib.rs</code> 中的某条 <code>use</code> 语句：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br></pre></td></tr></table></figure></p><p>于是在另一个文件 <code>src/main.rs</code> 中也就可以使用 <code>restaurant::hosting::seat_at_table()</code> 形式的代码调用 <code>hosting</code> 模块中的函数了。<br>通过使用 <code>pub use</code>，我们可以在编写代码时使用一种结构，在对外暴露时使用另外一种不同的结构。这一方法可以让我们的代码库对编写者和调用者同时保持良好的组织结构。</p><h4 id="将模块拆分为不同的文件"><a href="#将模块拆分为不同的文件" class="headerlink" title="将模块拆分为不同的文件"></a>将模块拆分为不同的文件</h4><p>当模块规模逐渐增大时，我们可以将它们的定义移动到新的文件中。<br>比如我们需要将 <code>src/lib.rs</code> 中定义的 <code>front_of_house</code> 模块移动到它自己的文件 <code>src/front_of_house.rs</code> 中。首先将根节点文件 <code>lib.rs</code> 中的代码改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mod</span> front_of_house;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> self::front_of_house::serving;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">use</span> crate::front_of_house::hosting;</span><br><span class="line"></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">eat_at_restaurant</span></span>() &#123;</span><br><span class="line">    hosting::seat_at_table();</span><br><span class="line">    serving::take_order();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 <code>mod front_of_house</code> 后使用分号而不是代码块，会让 Rust 前往与当前模块同名的文件中加载模块内容。因此可以将 <code>front_of_house</code> 模块的具体定义转移到 <code>src/front_of_house.rs</code> 文件中，效果是一样的。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving &#123;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>事实上还可以更进一步，继续拆解 <code>front_of_house</code> 模块到其他文件中。首先将 <code>src/front_of_house.rs</code> 文件的内容改为如下版本：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> hosting;</span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">mod</span> serving;</span><br></pre></td></tr></table></figure></p><p>接着创建一个 <code>src/front_of_house</code> 目录，以及一个 <code>src/front_of_house/hosting.rs</code> 文件用来存放 <code>hosting</code> 模块的定义，一个 <code>src/front_of_house/serving.rs</code> 文件存放 <code>serving</code> 模块的定义：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/hosting.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seat_at_table</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Seat at table."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// src/front_of_house/serving.rs</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_order</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking order."</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">take_payment</span></span>() &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Taking payment."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果与前两种版本也是一致的。<br>此时 <code>restaurant</code> 项目的目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">restaurant</span><br><span class="line">├── Cargo.lock</span><br><span class="line">├── Cargo.toml</span><br><span class="line">└── src</span><br><span class="line">    ├── front_of_house</span><br><span class="line">    │   ├── hosting.rs</span><br><span class="line">    │   └── serving.rs</span><br><span class="line">    ├── front_of_house.rs</span><br><span class="line">    ├── lib.rs</span><br><span class="line">    └── main.rs</span><br></pre></td></tr></table></figure></p><p>所有的修改都没有改变原有的模块树结构，尽管这些定义被放置到了不同的文件中，<code>eat_at_restaurant</code> 中的函数调用依旧有效。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;模块系统&quot;&gt;&lt;a href=&quot;#模块系统&quot; class=&quot;headerlink&quot; title=&quot;模块系统&quot;&gt;&lt;/a&gt;模块系统&lt;/h4&gt;&lt;p&gt;在编写较为复杂的项目时，合理地对代码进行组织与管理非常重要。只有按照不同的特性来组织或分割相关功能的代码，才能够清晰地找到实
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Package" scheme="https://rollingstarky.github.io/tags/Package/"/>
    
      <category term="Project" scheme="https://rollingstarky.github.io/tags/Project/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Module" scheme="https://rollingstarky.github.io/tags/Module/"/>
    
      <category term="Crate" scheme="https://rollingstarky.github.io/tags/Crate/"/>
    
      <category term="Scope" scheme="https://rollingstarky.github.io/tags/Scope/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（五）自定义 Types</title>
    <link href="https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/"/>
    <id>https://rollingstarky.github.io/2021/07/06/basic-haskell-user-defined-types/</id>
    <published>2021-07-05T16:00:00.000Z</published>
    <updated>2021-07-06T14:50:37.604Z</updated>
    
    <content type="html"><![CDATA[<h4 id="ADT-Algebraic-data-types"><a href="#ADT-Algebraic-data-types" class="headerlink" title="ADT (Algebraic data types)"></a>ADT (Algebraic data types)</h4><p>类似 <code>Bool</code>、<code>Int</code>、<code>Char</code> 这些都是内置的数据类型，我们可以使用 <strong><code>data</code></strong> 关键字创建自己的类型。</p><p>标准库中的 <code>Bool</code> 类型实际上是这样定义的：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Bool</span> = <span class="type">False</span> | <span class="type">True</span></span></span><br></pre></td></tr></table></figure></p><p>其中 <code>=</code> 左边部分指定类型的名称，右边部分叫做 <strong>value constructors</strong>，用来指定当前类型能够拥有的不同数值。<br>整个语句可以读作“<code>Bool</code> 类型可以使用 <code>True</code> 或者 <code>False</code> 作为它的值”。</p><p>现在思考下应该用怎样的形式表示一种形状。可以使用元组，比如圆圈可以表示为 <code>(43.1, 55.0, 10.4)</code>。前两项表示圆心的坐标，最后一项表示半径。<br>但这种形式的元组也同样可以表示一个三维向量或者其他对象。更好一点的方法是创建自定义的数据类型。</p><p>假设一个形状对象可以是圆或者矩形，则可以定义如下形式的 <code>Shape</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span></span></span><br></pre></td></tr></table></figure></p><p>可以这样理解，<code>Circle</code> value constructor 包含三个 Float 类型的字段，前两个字段是圆心的坐标，最后一个字段表示半径；<code>Rectangle</code> value constructor 包含四个 Float 类型的字段，前两个字段表示左上角顶点的坐标，后两个字段表示右下角的坐标。</p><p>Value constructor 实际上是一种函数，所谓的“字段”是函数的参数，最终返回特定的数据类型。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Circle</span></span><br><span class="line"><span class="type">Circle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Rectangle</span></span><br><span class="line"><span class="type">Rectangle</span> :: <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br></pre></td></tr></table></figure></p><p>接下来就可以针对 <code>Shape</code> 类型定义一个 <code>surface</code> 函数，用来计算某个 Shape 的面积：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span>  </span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| surface :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Circle</span> _ _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>| surface (<span class="type">Rectangle</span> x1 y1 x2 y2) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">10</span>)</span><br><span class="line"><span class="number">314.15927</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> <span class="number">0</span> <span class="number">0</span> <span class="number">100</span> <span class="number">100</span>)</span><br><span class="line"><span class="number">10000.0</span></span><br></pre></td></tr></table></figure><p>但是当我们在 <code>ghci</code> 中像调用函数那样直接执行如 <code>Circle 10 20 5</code> 这类命令时，会报出如下错误：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&lt;interactive&gt;:<span class="number">14</span>:<span class="number">1</span>: error:</span><br><span class="line">    • <span class="type">No</span> <span class="keyword">instance</span> for (<span class="type">Show</span> <span class="type">Shape</span>) arising from a use <span class="keyword">of</span> ‘print’</span><br><span class="line">    • <span class="type">In</span> a stmt <span class="keyword">of</span> an interactive <span class="type">GHCi</span> command: print it</span><br></pre></td></tr></table></figure></p><p>原因是 Haskell 不清楚如何将此处的自定义类型表示为字符串。当在 <code>ghci</code> 中打印一个值时，实际上 Haskell 调用了 <code>show</code> 函数用来获取对应值的字符串形式，并输出到命令行。<br>为了使我们的 <code>Shape</code> 类型支持打印输出，需要令其实现 <code>Show</code> typeclass。语法如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时 <code>Shape</code> 类型即可支持打印输出操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span> <span class="number">5</span></span><br><span class="line"><span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Rectangle</span> <span class="number">50</span> <span class="number">230</span> <span class="number">60</span> <span class="number">90</span></span><br><span class="line"><span class="type">Rectangle</span> <span class="number">50.0</span> <span class="number">230.0</span> <span class="number">60.0</span> <span class="number">90.0</span></span><br></pre></td></tr></table></figure></p><p>Value constructor 实际上就是函数，也因此支持 <code>map</code>、partially apply 等操作。<br>比如可以使用如下代码创建一系列半径不同的同心圆：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (<span class="type">Circle</span> <span class="number">10</span> <span class="number">20</span>) [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">4.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">5.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>,<span class="type">Circle</span> <span class="number">10.0</span> <span class="number">20.0</span> <span class="number">6.0</span>]</span><br></pre></td></tr></table></figure></p><p>让我们再定义一个 <code>Point</code> 类型，并令其成为 <code>Shape</code> 类型的一部分，从而更加容易理解：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Point</span> = <span class="type">Point</span> <span class="type">Float</span> <span class="type">Float</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Shape</span> = <span class="type">Circle</span> <span class="type">Point</span> <span class="type">Float</span> | <span class="type">Rectangle</span> <span class="type">Point</span> <span class="type">Point</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>此时的 <code>Circle</code> 类型拥有两个字段，用 <code>Point</code> 类型表示圆圈的圆心，再加一个 <code>Float</code> 类型表示半径。</p><p>重新实现下之前的 <code>surface</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">surface</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Circle</span> _ r) = pi * r ^ <span class="number">2</span></span><br><span class="line"><span class="title">surface</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) = (abs (x2 - x1)) * (abs (y2 - y1))</span><br></pre></td></tr></table></figure></p><p>只需要重新定义模式匹配的部分即可。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Rectangle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) (<span class="type">Point</span> <span class="number">100</span> <span class="number">100</span>))</span><br><span class="line"><span class="number">10000.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; surface (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">0</span> <span class="number">0</span>) <span class="number">24</span>)</span><br></pre></td></tr></table></figure></p><p>还可以创建一个 <code>nudge</code> 函数用来移动某个形状对象的位置。它接收一个形状及其在 x 轴和 y 轴上的偏移量作为参数，返回一个同样大小、不同位置的形状对象。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">nudge</span> :: <span class="type">Shape</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Float</span> -&gt; <span class="type">Shape</span></span><br><span class="line"><span class="title">nudge</span> (<span class="type">Circle</span> (<span class="type">Point</span> x y) r) a b = <span class="type">Circle</span> (<span class="type">Point</span> (x+a) (y+b)) r</span><br><span class="line"><span class="title">nudge</span> (<span class="type">Rectangle</span> (<span class="type">Point</span> x1 y1) (<span class="type">Point</span> x2 y2)) a b = <span class="type">Rectangle</span> (<span class="type">Point</span> (x1+a) (y1+b)) (<span class="type">Point</span> (x2+a) (y2+b))</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; nudge (<span class="type">Circle</span> (<span class="type">Point</span> <span class="number">34</span> <span class="number">34</span>) <span class="number">10</span>) <span class="number">5</span> <span class="number">10</span></span><br><span class="line"><span class="type">Circle</span> (<span class="type">Point</span> <span class="number">39.0</span> <span class="number">44.0</span>) <span class="number">10.0</span></span><br></pre></td></tr></table></figure><h4 id="Record-语法"><a href="#Record-语法" class="headerlink" title="Record 语法"></a>Record 语法</h4><p>假设创建一个名为 <code>Person</code> 的自定义数据类型。它需要包含名字、姓氏、年龄、身高、手机号和最喜欢的冰淇淋种类等字段。<br>可以使用如下代码实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> <span class="type">String</span> <span class="type">String</span> <span class="type">Int</span> <span class="type">Float</span> <span class="type">String</span> <span class="type">String</span> <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> guy = <span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; guy</span><br><span class="line"><span class="type">Person</span> <span class="string">"Buddy"</span> <span class="string">"Finklestein"</span> <span class="number">43</span> <span class="number">184.2</span> <span class="string">"526-2928"</span> <span class="string">"Chocolate"</span></span><br></pre></td></tr></table></figure></p><p>上述代码是可以运行的，但可读性却很差。<br>当我们需要创建函数来获取 Person 对象中的某个字段的值时，可能就需要借助如下形式的代码：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">firstName</span> (<span class="type">Person</span> firstname _ _ _ _ _) = firstname</span><br><span class="line">  </span><br><span class="line"><span class="title">lastName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">lastName</span> (<span class="type">Person</span> _ lastname _ _ _ _) = lastname</span><br><span class="line">  </span><br><span class="line"><span class="title">age</span> :: <span class="type">Person</span> -&gt; <span class="type">Int</span></span><br><span class="line"><span class="title">age</span> (<span class="type">Person</span> _ _ age _ _ _) = age</span><br><span class="line">  </span><br><span class="line"><span class="title">height</span> :: <span class="type">Person</span> -&gt; <span class="type">Float</span></span><br><span class="line"><span class="title">height</span> (<span class="type">Person</span> _ _ _ height _ _) = height</span><br><span class="line">  </span><br><span class="line"><span class="title">phoneNumber</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">phoneNumber</span> (<span class="type">Person</span> _ _ _ _ number _) = number</span><br><span class="line">  </span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">flavor</span> (<span class="type">Person</span> _ _ _ _ _ flavor) = flavor</span><br></pre></td></tr></table></figure></p><p>鉴于上述场景中的代码实现有诸多不方便的地方，Haskell 提供了另外一种创建数据类型的方法，即 Record 语法。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     , <span class="title">height</span> :: <span class="type">Float</span></span></span><br><span class="line"><span class="class">                     , <span class="title">phoneNumber</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">flavor</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br></pre></td></tr></table></figure></p><p>通过上述语法，Haskell 会自动创建 <code>firstName</code>、<code>lastName</code>、<code>age</code>、<code>height</code>、<code>phoneNumber</code>、<code>flavor</code> 等函数，用于访问该类型对象中的对应字段。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t flavor</span><br><span class="line"><span class="title">flavor</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>&gt; :t firstName</span><br><span class="line"><span class="title">firstName</span> :: <span class="type">Person</span> -&gt; <span class="type">String</span></span><br></pre></td></tr></table></figure></p><p>Record 语法的另一个好处在于，Value constructor 中涉及到的所有字段都可以拥有一个有意义的名称，方便各字段之间的相互区分。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="class"><span class="keyword">data</span> <span class="type">Car</span> = <span class="type">Car</span> &#123;<span class="title">company</span> :: <span class="type">String</span>, <span class="title">model</span> :: <span class="type">String</span>, <span class="title">year</span> :: <span class="type">Int</span>&#125; <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> car = <span class="type">Car</span> &#123;company=<span class="string">"Ford"</span>, model=<span class="string">"Mustang"</span>, year=<span class="number">1967</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; car</span><br><span class="line"><span class="type">Car</span> &#123;company = <span class="string">"Ford"</span>, model = <span class="string">"Mustang"</span>, year = <span class="number">1967</span>&#125;</span><br></pre></td></tr></table></figure></p><p>比如创建一个用于表示三维向量的数据类型，可以使用 <code>data Vector = Vector Int Int Int</code> 语句。但这样的语法对于前面的 <code>Person</code> 和 <code>Car</code> 来讲，其含义就不如使用 Record 语法来得清晰。</p><h4 id="参数化类型"><a href="#参数化类型" class="headerlink" title="参数化类型"></a>参数化类型</h4><p>Value constructor 可以接收特定数量的参数来生成一个特定类型的值。比如前面的 <code>Car</code> 接收 3 个参数生成一个新的 car。<br><strong>Type constructor</strong> 则可以接收 type 作为参数来生成一个新的类型。</p><p>比如内置的 <code>Maybe</code> 的实现：<br><code>data Maybe a = Nothing | Just a</code></p><p>其中 <code>a</code> 表示类型参数，<code>Maybe</code> 即为 type constructor。我们可以向 <code>Maybe</code> 传入一个 <code>Char</code> 作为类型参数，就可以得到一个新的 <code>Maybe Char</code> 类型。比如值 <code>Just &#39;a&#39;</code> 就属于 <code>Maybe Char</code> 类型。<br>同样的方式可以得到类型 <code>Maybe Int</code>、<code>Maybe String</code> 等等。</p><p><code>Maybe</code> 实际上表示一种<strong>可选项</strong>，它可以是任意某种特定类型的值，也可以什么值都不包含（<code>Nothing</code>）。比如 <code>Maybe Int</code> 类型就表示该类型的值可能包含 <code>Int</code>（值 <code>Just 5</code>），也可能不包含任意类型（<code>Nothing</code>）。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="string">"Haha"</span></span><br><span class="line"><span class="type">Just</span> <span class="string">"Haha"</span> :: <span class="type">Maybe</span> [<span class="type">Char</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Just</span> <span class="number">84</span></span><br><span class="line"><span class="type">Just</span> <span class="number">84</span> :: <span class="type">Num</span> a =&gt; <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; :t <span class="type">Nothing</span></span><br><span class="line"><span class="type">Nothing</span> :: <span class="type">Maybe</span> a</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Just</span> <span class="number">10</span> :: <span class="type">Maybe</span> <span class="type">Double</span></span><br><span class="line"><span class="type">Just</span> <span class="number">10.0</span></span><br></pre></td></tr></table></figure><p>实际上还有一种类型涉及到了类型参数，只不过借助了语法糖，其形式稍有不同。该类型就是 list。<br>list 类型可以接收一个类型参数生成更具体的类型。比如 <code>[Int]</code>、<code>[Char]</code> 甚至 <code>[[String]]</code> 等等。<br>但是没有任何值的类型可以是 <code>[]</code>。空列表实际上可以表现得像任意类型的列表，其类型是 <code>[a]</code>，也因此可以使用如下形式的表达式：<code>[1,2,3] ++ []</code>、<code>[&quot;ha&quot;,&quot;ha&quot;,&quot;ha&quot;] ++ []</code>。</p><p>下面的代码实现了一种三维的向量类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Vector</span> a = <span class="type">Vector</span> a a a <span class="keyword">deriving</span> (<span class="type">Show</span>)</span></span><br><span class="line">  </span><br><span class="line"><span class="title">vplus</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vplus` (<span class="type">Vector</span> l m n) = <span class="type">Vector</span> (i+l) (j+m) (k+n)</span><br><span class="line">  </span><br><span class="line"><span class="title">vectMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; t -&gt; <span class="type">Vector</span> t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `vectMult` m = <span class="type">Vector</span> (i*m) (j*m) (k*m)</span><br><span class="line">  </span><br><span class="line"><span class="title">scalarMult</span> :: (<span class="type">Num</span> t) =&gt; <span class="type">Vector</span> t -&gt; <span class="type">Vector</span> t -&gt; t  </span><br><span class="line">(<span class="type">Vector</span> i j k) `scalarMult` (<span class="type">Vector</span> l m n) = i*l + j*m + k*n</span><br></pre></td></tr></table></figure></p><p>上述函数可以作用在 <code>Vector Int</code>、<code>Vector Integer</code>、<code>Vector  Float</code> 类型上，只要类型 <code>Vector a</code> 中的 <code>a</code> 属于 <code>Num</code> typeclass。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">5</span> <span class="number">8</span> `vplus` <span class="type">Vector</span> <span class="number">9</span> <span class="number">2</span> <span class="number">8</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">12</span> <span class="number">7</span> <span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">3</span> <span class="number">9</span> <span class="number">7</span> `vectMult` <span class="number">10.0</span></span><br><span class="line"><span class="type">Vector</span> <span class="number">30.0</span> <span class="number">90.0</span> <span class="number">70.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Vector</span> <span class="number">4</span> <span class="number">9</span> <span class="number">5</span> `scalarMult` <span class="type">Vector</span> <span class="number">9.0</span> <span class="number">2.0</span> <span class="number">4.0</span></span><br><span class="line"><span class="number">74.0</span></span><br></pre></td></tr></table></figure></p><p>类型参数通常用在当 type constructor 中包含的类型对该类型的正常工作并不产生影响时。即我们的自定义类型表现得像某种“盒子”，里面可以放任意的特定类型的值。</p><h4 id="派生实例"><a href="#派生实例" class="headerlink" title="派生实例"></a>派生实例</h4><p><strong>typeclass 是一种定义了某种行为的接口</strong>。若某个类型支持 typeclass 定义的行为，则该类型成为 typeclass 的实例。<br>比如 <code>Eq</code> typeclass 定义了可以被测试是否相等的行为，而整数之间可以比较是否相等，因此 <code>Int</code> 类型是 <code>Eq</code> typeclass 的实例。与此同时，作为 <code>Eq</code> 接口的函数如 <code>==</code> 和 <code>/=</code>，则可以直接调用 <code>Int</code> 类型的值，测试它们是否相等（或不相等）。</p><p>typeclass 经常会与其他语言如 Java 中的类相混淆。实际上在其他语言中，类可以看作创建对象（包含自身状态和行为）的蓝图；而 typeclass 则更像是接口。<br>在 Haskell 中，我们先创建某个数据类型，然后考虑该类型有怎样的行为。若该类型可以被排序，则令其成为 <code>Ord</code> typeclass 的实例。这之后该类型的值就可以被 <code>&gt;</code>、<code>&lt;</code>、<code>compare</code> 等比较大小的函数调用了。</p><p>现在假设两个人可以有相同的姓氏、名字和年龄，则这两个人就是“相等”的。由此创建一个可以比较是否相等的 <code>Person</code> 类型：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class">                     , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class">                     &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>)</span></span><br></pre></td></tr></table></figure></p><p>当我们使用 <code>==</code> 比较两个实现了 <code>Eq</code> typeclass  的类型实例时，Haskell 会先用 <code>==</code> 比较两个类型实例的 value constructor 是否相等，再比较类型实例中包含的所有字段的值是否都相等。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> adRock = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Horovitz"</span>, age = <span class="number">41</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mca = <span class="type">Person</span> &#123;firstName = <span class="string">"Adam"</span>, lastName = <span class="string">"Yauch"</span>, age = <span class="number">44</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mca == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == adRock</span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == mikeD</span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD == <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>由于 <code>Person</code> 类型现在是 <code>Eq</code> typeclass 的实例，因此我们可以将其传给类型约束是 <code>Eq a</code> 的函数，比如 <code>elem</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> beastieBoys = [mca, adRock, mikeD]</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD `elem` beastieBoys</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p><code>Show</code> 和 <code>Read</code> typeclass 与类型值的字符串转换有关。<code>Show</code> 表示将类型值转换为 String，<code>Read</code> 则表示将 String 转换为特定类型的值。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| <span class="class"><span class="keyword">data</span> <span class="type">Person</span> = <span class="type">Person</span> &#123; <span class="title">firstName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">lastName</span> :: <span class="type">String</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      , <span class="title">age</span> :: <span class="type">Int</span></span></span><br><span class="line"><span class="class"><span class="type">Prelude</span>|                      &#125; <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Show</span>, <span class="type">Read</span>)</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> mikeD = <span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; mikeD</span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="string">"mikeD is: "</span> ++ show mikeD</span><br><span class="line"><span class="string">"mikeD is: Person &#123;firstName = \"Michael\", lastName = \"Diamond\", age = 43&#125;"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Person &#123;firstName =\"Michael\", lastName =\"Diamond\", age = 43&#125;"</span> :: <span class="type">Person</span></span><br><span class="line"><span class="type">Person</span> &#123;firstName = <span class="string">"Michael"</span>, lastName = <span class="string">"Diamond"</span>, age = <span class="number">43</span>&#125;</span><br></pre></td></tr></table></figure></p><p>对于实现了 <code>Ord</code> typeclass 的类型，我们可以根据 value constructor 中值出现的顺序比较同一类型不同值的大小。value constructor 中左侧的值总小于右侧的值。内置的 Bool 类型可以大概视作有如下实现：<br><code>data Bool = False | True deriving (Ord)</code><br>则在比较 <code>False</code> 和 <code>True</code> 时，<code>False</code> 总小于 <code>True</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">False</span> &lt; <span class="type">True</span></span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><p>借助 <code>Enum</code> 和 <code>Bounded</code> typeclass，可以很轻松地实现枚举类型的 ADT。比如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">data</span> <span class="type">Day</span> = <span class="type">Monday</span> | <span class="type">Tuesday</span> | <span class="type">Wednesday</span> | <span class="type">Thursday</span> | <span class="type">Friday</span> | <span class="type">Saturday</span> | <span class="type">Sunday</span></span></span><br><span class="line">           <span class="keyword">deriving</span> (<span class="type">Eq</span>, <span class="type">Ord</span>, <span class="type">Show</span>, <span class="type">Read</span>, <span class="type">Bounded</span>, <span class="type">Enum</span>)</span><br></pre></td></tr></table></figure></p><p>由于 <code>Day</code> 类型实现了 <code>Show</code> 和 <code>Read</code> typeclass，则可以在此类型与字符串之间进行转换：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Wednesday</span></span><br><span class="line"><span class="type">Wednesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; show <span class="type">Wednesday</span></span><br><span class="line"><span class="string">"Wednesday"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; read <span class="string">"Saturday"</span> :: <span class="type">Day</span></span><br><span class="line"><span class="type">Saturday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Eq</code> 和 <code>Ord</code> typeclass，则可以在 <code>Day</code> 类型的值之间进行比较：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Sunday</span></span><br><span class="line"><span class="type">False</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> == <span class="type">Saturday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Saturday</span> &gt; <span class="type">Friday</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="type">Monday</span> `compare` <span class="type">Wednesday</span></span><br><span class="line"><span class="type">LT</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Bounded</code> typeclass，我们可以获取“最低”和最高的 <code>Day</code> 类型值：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; minBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Monday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxBound :: <span class="type">Day</span></span><br><span class="line"><span class="type">Sunday</span></span><br></pre></td></tr></table></figure></p><p>又由于 <code>Day</code> 类型实现了 <code>Enum</code>，因此我们可以对其进行序列类型的操作：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; succ <span class="type">Monday</span></span><br><span class="line"><span class="type">Tuesday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; pred <span class="type">Saturday</span></span><br><span class="line"><span class="type">Friday</span></span><br><span class="line"><span class="type">Prelude</span>&gt; [<span class="type">Thursday</span> .. <span class="type">Sunday</span>]</span><br><span class="line">[<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; [minBound .. maxBound] :: [<span class="type">Day</span>]</span><br><span class="line">[<span class="type">Monday</span>,<span class="type">Tuesday</span>,<span class="type">Wednesday</span>,<span class="type">Thursday</span>,<span class="type">Friday</span>,<span class="type">Saturday</span>,<span class="type">Sunday</span>]</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;ADT-Algebraic-data-types&quot;&gt;&lt;a href=&quot;#ADT-Algebraic-data-types&quot; class=&quot;headerlink&quot; title=&quot;ADT (Algebraic data types)&quot;&gt;&lt;/a&gt;ADT (Algebra
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Typeclass" scheme="https://rollingstarky.github.io/tags/Typeclass/"/>
    
      <category term="ADT" scheme="https://rollingstarky.github.io/tags/ADT/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（四）高阶函数</title>
    <link href="https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/"/>
    <id>https://rollingstarky.github.io/2021/06/30/basic-haskell-high-order-function/</id>
    <published>2021-06-29T16:00:00.000Z</published>
    <updated>2021-06-30T12:33:08.138Z</updated>
    
    <content type="html"><![CDATA[<p>Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做<strong>高阶函数（high order functions）</strong>。<br>想要通过<strong>定义是什么</strong>而不是<strong>定义一系列可以改变程序状态的步骤</strong>来完成计算过程，高阶函数是必不可少的。</p><h4 id="Curried-functions"><a href="#Curried-functions" class="headerlink" title="Curried functions"></a>Curried functions</h4><p><strong>Haskell 中的函数实际上都只接收一个参数</strong>。前面遇到的接收多个参数的函数是一种 <strong>Curried functions</strong>，可以看作某种特殊形式。<br>比如 <code>max 4 5</code>，看上去是向函数 <code>max</code> 传入两个参数 <code>4</code> 和 <code>5</code>，返回数值较大的 <code>5</code>。实际的计算过程是 <code>(max 4) 5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; max <span class="number">4</span> <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (max <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>首先将参数 <code>4</code> 传递给函数 <code>max</code>，<strong>会返回另一个函数，该函数接收任意一个参数，将该参数与数字 4 比较，返回较大的数</strong>。所以后面将 <code>5</code> 传给函数 <code>(max 4)</code> 后，得到最终的结果 <code>5</code>。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> maxWithFour = max <span class="number">4</span></span><br><span class="line"><span class="type">Prelude</span>&gt; maxWithFour <span class="number">5</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure></p><p>那么这种形式的函数究竟有什么好处呢？</p><p>当我们使用部分参数调用某个函数的时候，并不会直接得到结果，而是返回一个<strong>部分应用（partially applied）</strong>的函数。这个部分应用的函数可以继续接收剩余的参数，最终得到计算结果。</p><p>partially applied 机制可以方便我们简单地实现动态地创建函数、将函数作为参数传入、用特定数据初始化函数等需求。</p><p>对于函数 <code>multThree</code>：<br><code>let multThree x y z = x * y * z</code><br>它可以接收三个数字作为参数，并计算这三个参数的乘积作为返回值。</p><p>如 <code>multThree 3 5 9</code>，实际上的执行流程为 <code>((multThree 3) 5) 9</code>。</p><ul><li>将数字 3 传递给 <code>multThree</code>，它会返回一个函数 <code>(multThree 3)</code>。该函数接收任意两个数字，并计算它们和 3 的乘积</li><li>将数字 5 传递给 <code>(multThree 3)</code>，返回另一个函数 <code>((multThree 3) 5)</code>。该函数接收任意一个数字，并计算它和 15 的乘积</li><li>将数字 9 传递给 <code>((multThree 3) 5)</code>，返回 9 和 15 的乘积作为结果</li></ul><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multThreeNums x y z = x * y * z</span><br><span class="line"><span class="type">Prelude</span>&gt; multThreeNums <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></span><br><span class="line"><span class="number">24</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multTwoNumsWithNine = multThreeNums <span class="number">9</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multTwoNumsWithNine <span class="number">2</span> <span class="number">3</span></span><br><span class="line"><span class="number">54</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> multOneNumWithEighteen = multTwoNumsWithNine <span class="number">2</span></span><br><span class="line"><span class="type">Prelude</span>&gt; multOneNumWithEighteen <span class="number">10</span></span><br><span class="line"><span class="number">180</span></span><br></pre></td></tr></table></figure><p>中缀函数如 <code>+ - * /</code> 等也可以 partially applied。</p><p>比如可以将数字 5 传递给中缀函数 <code>+</code> 生成一个新的函数 <code>(5+)</code>，而新函数 <code>(5+)</code> 可以接收一个数字作为参数，返回该参数与 5 的和。<br>即函数 <code>(5+)</code> 其实是中缀函数 <code>+</code> 固定一个参数 5 之后生成的新函数，这个新函数接收任何一个数字作为另一个加数并求和。</p><p>使用 <code>/</code> 固定除数生成新函数 <code>divideByTen</code>：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideByTen = (/<span class="number">10</span>)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideByTen <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (/<span class="number">10</span>) <span class="number">200</span></span><br><span class="line"><span class="number">20.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">200</span> / <span class="number">10</span></span><br><span class="line"><span class="number">20.0</span></span><br></pre></td></tr></table></figure></p><p><code>divideByTen 200</code> 等同于 <code>(/10) 200</code> 等同于 <code>200 / 10</code>。</p><p>同样的方式还可以定义 <code>divideTen</code> 固定被除数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> divideTen = (<span class="number">10</span>/)</span><br><span class="line"><span class="type">Prelude</span>&gt; divideTen <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; (<span class="number">10</span>/) <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="number">10</span> / <span class="number">2</span></span><br><span class="line"><span class="number">5.0</span></span><br></pre></td></tr></table></figure></p><p>检查输入的字符是否是大写字母：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> isUpperAlphanum = (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>])</span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum '<span class="type">D'</span></span><br><span class="line"><span class="type">True</span></span><br><span class="line"><span class="type">Prelude</span>&gt; isUpperAlphanum 'a'</span><br><span class="line"><span class="type">False</span></span><br></pre></td></tr></table></figure></p><h4 id="函数作为参数"><a href="#函数作为参数" class="headerlink" title="函数作为参数"></a>函数作为参数</h4><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> applyTwice f x = f (f x)</span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (+<span class="number">3</span>) <span class="number">10</span></span><br><span class="line"><span class="number">16</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (++ <span class="string">" HAHA"</span>) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HEY HAHA HAHA"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="string">"HAHA "</span> ++) <span class="string">"HEY"</span></span><br><span class="line"><span class="string">"HAHA HAHA HEY"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; applyTwice (<span class="number">3</span>:) [<span class="number">1</span>]</span><br><span class="line">[<span class="number">3</span>,<span class="number">3</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h5 id="zipWith-的自定义实现"><a href="#zipWith-的自定义实现" class="headerlink" title="zipWith 的自定义实现"></a>zipWith 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zipWith'</span> :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">zipWith'</span> _ [] _ = []</span><br><span class="line"><span class="title">zipWith'</span> _ _ [] = []</span><br><span class="line"><span class="title">zipWith'</span> f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| zipWith' :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</span><br><span class="line"><span class="title">ith'</span> f <span class="type">Prelude</span>| zipWith' _ [] _ = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' _ _ [] = []</span><br><span class="line"><span class="type">Prelude</span>| zipWith' f (x:xs) (y:ys) = f x y : zipWith' f xs ys</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (+) [<span class="number">4</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">6</span>] [<span class="number">2</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">[<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (++) [<span class="string">"foo "</span>, <span class="string">"bar "</span>, <span class="string">"baz "</span>] [<span class="string">"fighters"</span>, <span class="string">"hoppers"</span>, <span class="string">"aldrin"</span>]</span><br><span class="line">[<span class="string">"foo fighters"</span>,<span class="string">"bar hoppers"</span>,<span class="string">"baz aldrin"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith' (*) (replicate <span class="number">5</span> <span class="number">2</span>) [<span class="number">1.</span>.]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br></pre></td></tr></table></figure><h5 id="flip-的自定义实现"><a href="#flip-的自定义实现" class="headerlink" title="flip 的自定义实现"></a>flip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">flip'</span> :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="title">flip'</span> f y x = f x y</span><br></pre></td></tr></table></figure><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| flip' :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</span><br><span class="line"><span class="type">Prelude</span>| flip' f y x = f x y</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; flip' zip [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>] <span class="string">"hello"</span></span><br><span class="line">[('h',<span class="number">1</span>),('e',<span class="number">2</span>),('l',<span class="number">3</span>),('l',<span class="number">4</span>),('o',<span class="number">5</span>)]</span><br><span class="line"><span class="type">Prelude</span>&gt; zipWith (flip' div) [<span class="number">2</span>,<span class="number">2.</span>.] [<span class="number">10</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">2</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br></pre></td></tr></table></figure><h4 id="Maps-amp-Filters"><a href="#Maps-amp-Filters" class="headerlink" title="Maps &amp; Filters"></a>Maps &amp; Filters</h4><p><code>map</code> 接收一个函数和一个列表作为参数，可以将函数应用到列表的每一项元素上。</p><p><code>map</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">map</span> :: (a -&gt; b) -&gt; [a] -&gt; [b]  </span><br><span class="line"><span class="title">map</span> _ [] = []  </span><br><span class="line"><span class="title">map</span> f (x:xs) = f x : map f xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (+<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">6</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">9</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (++ <span class="string">"!"</span>) [<span class="string">"BIFF"</span>, <span class="string">"BANG"</span>, <span class="string">"POW"</span>]</span><br><span class="line">[<span class="string">"BIFF!"</span>,<span class="string">"BANG!"</span>,<span class="string">"POW!"</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (replicate <span class="number">3</span>) [<span class="number">3.</span><span class="number">.6</span>]</span><br><span class="line">[[<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">4</span>,<span class="number">4</span>],[<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>],[<span class="number">6</span>,<span class="number">6</span>,<span class="number">6</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map (map (^<span class="number">2</span>)) [[<span class="number">1</span>,<span class="number">2</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],[<span class="number">7</span>,<span class="number">8</span>]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">4</span>],[<span class="number">9</span>,<span class="number">16</span>,<span class="number">25</span>,<span class="number">36</span>],[<span class="number">49</span>,<span class="number">64</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; map fst [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">1</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p><code>filter</code> 接收一个判断函数和一个列表作为参数，返回列表中所有使判断函数为真的元素。</p><p><code>filter</code> 函数的定义如下：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">filter</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter</span> _ [] = []</span><br><span class="line"><span class="title">filter</span> p (x:xs)</span><br><span class="line">    | p x       = x : filter p xs</span><br><span class="line">    | otherwise = filter p xs</span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; filter (&gt;<span class="number">3</span>) [<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>]</span><br><span class="line">[<span class="number">5</span>,<span class="number">6</span>,<span class="number">4</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (==<span class="number">3</span>) [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">3</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter even [<span class="number">1.</span><span class="number">.10</span>]</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">10</span>]</span><br><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> notNull x = not (null x) <span class="keyword">in</span> filter notNull [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>],[],[],[]]</span><br><span class="line">[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],[<span class="number">2</span>,<span class="number">2</span>]]</span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['a'..'z']) <span class="string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span></span><br><span class="line"><span class="string">"uagameasadifeent"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; filter (`elem` ['<span class="type">A'</span>..'<span class="type">Z'</span>]) <span class="string">"i lauGh At You BecAuse u r aLL the Same"</span></span><br><span class="line"><span class="string">"GAYBALLS"</span></span><br></pre></td></tr></table></figure><p>借助 filter 实现 quicksort：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort (filter (&lt;=x) xs)</span><br><span class="line">        biggerSorted = quicksort (filter (&gt;x) xs)</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure></p><p>找出 100000 以内能够被 3829 整除的最大的数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">largestDivisible</span> :: (<span class="type">Integral</span> a) =&gt; a</span><br><span class="line"><span class="title">largestDivisible</span> = head (filter p [<span class="number">100000</span>,<span class="number">99999.</span>.])</span><br><span class="line">    <span class="keyword">where</span> p x = x `mod` <span class="number">3829</span> == <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>p x = x `mod` 3829 == 0</code> 定义了函数 <code>p</code> 作为 <code>filter</code> 的判断函数，而列表 <code>[100000, 99999..]</code> 实际上是一个逆序的无穷列表。<br>借助 Haskell 的<strong>惰性计算</strong>机制，函数获取的是最大的可被整除的数，获得该值后就不会再继续计算下去。</p><p>实际上还可以这样使用 <code>map</code> 函数：<br><code>map (*) [0..]</code><br>将函数 <code>*</code> 映射到列表 <code>[0..]</code>，会返回一个包含一系列函数的新列表。新列表的形式类似 <code>[(0*),(1*),(2*),(3*),(4*),(5*)..]</code>。<br>其中的任何一个函数如 <code>(4*)</code>，都是接收两个参数的函数 <code>*</code> 固定了一个参数后的形式，再向其传入一个参数即可完成乘法运算。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> listOfFuns = map (*) [<span class="number">0.</span>.]</span><br><span class="line"><span class="type">Prelude</span>&gt; (listOfFuns !! <span class="number">4</span>) <span class="number">5</span></span><br><span class="line"><span class="number">20</span></span><br></pre></td></tr></table></figure><p><code>!!</code> 函数可以从指定列表中根据索引值获取特定的元素。<code>(listOfFuns !! 4)</code> 即为 <code>(4*)</code>。</p><h4 id="Lambdas"><a href="#Lambdas" class="headerlink" title="Lambdas"></a>Lambdas</h4><p>Lambda 基本上是代码中只使用一次的匿名函数。<br>由 <code>\</code> 反斜杠符号指定参数，<code>-&gt;</code> 符号指定函数体。</p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; zipWith (\a b -&gt; a * b - <span class="number">1</span>) [<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>] [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>和通常的函数类似，lambda 中也可以应用模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; map (\(a,b) -&gt; a + b) [(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">5</span>),(<span class="number">6</span>,<span class="number">3</span>),(<span class="number">2</span>,<span class="number">6</span>),(<span class="number">2</span>,<span class="number">5</span>)]</span><br><span class="line">[<span class="number">3</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>]</span><br></pre></td></tr></table></figure></p><p>不同的是，lambda 不支持对同一个参数定义多个模式。</p><h4 id="Fold"><a href="#Fold" class="headerlink" title="Fold"></a>Fold</h4><p>Fold 有点类似于 <code>map</code> 函数，只不过 fold 操作最终会将列表中的元素归并（<strong>reduce</strong>）到单个值。</p><p>Fold 函数接收三个参数：</p><ul><li>binary function：接收两个参数的函数</li><li>初始值：称作累加器（accumulator）</li><li>需要被折叠的列表</li></ul><p>首先是 binary function 接收 accumulator 和列表的第一个元素作为参数，执行特定的计算后返回一个新的 accumulator；<br>binary function 继续接收刚返回的新 accumulator 和列表中剩余元素中的第一个作为参数，执行计算并返回新的 accumulator；<br>若干次循环过后，列表中的最后一个元素被传入 binary function，返回的 accumulator 即为整个列表归并（折叠）后的最终结果。</p><h5 id="左折叠-foldl"><a href="#左折叠-foldl" class="headerlink" title="左折叠 foldl"></a>左折叠 <code>foldl</code></h5><p>运用左折叠（从左侧开始折叠）实现自定义的 <code>sum</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> sum' xs = foldl (\acc x -&gt; acc + x) <span class="number">0</span> xs</span><br><span class="line"><span class="type">Prelude</span>&gt; sum' [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">1</span>]</span><br><span class="line"><span class="number">11</span></span><br></pre></td></tr></table></figure></p><p>对应到前面提到的概念，lambda 函数 <code>(\acc x -&gt; acc + x)</code> 即为 binary function，<code>0</code> 是初始值（accumulator），<code>xs</code> 为传入的待折叠列表。</p><p>借助 curried function，甚至可以写出更简单的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">let</span> sum' = foldl (+) <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>lambda 函数 <code>(\acc x -&gt; acc + x)</code> 实际上等效于 <code>(+)</code>。<br>对于 <code>xs</code> 参数的化简，原因是通常情况下，若函数具有 <code>foo a = bar b a</code> 这样的形式，则该函数可以简化为 <code>foo = bar b</code>。</p><p>运用左折叠实现自定义的 <code>elem</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> elem' y ys = foldl (\acc x -&gt; <span class="keyword">if</span> x == y <span class="keyword">then</span> <span class="type">True</span> <span class="keyword">else</span> acc) <span class="type">False</span> ys</span><br><span class="line"><span class="type">Prelude</span>&gt; elem' <span class="number">2</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="type">True</span></span><br></pre></td></tr></table></figure></p><h5 id="右折叠-foldr"><a href="#右折叠-foldr" class="headerlink" title="右折叠 foldr"></a>右折叠 <code>foldr</code></h5><p>运用右折叠（从右侧开始折叠）实现自定义的 <code>map</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> map' f xs = foldr (\x acc -&gt; f x : acc) [] xs</span><br><span class="line"><span class="type">Prelude</span>&gt; map' (+<span class="number">3</span>) [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]</span><br></pre></td></tr></table></figure></p><p>此外还有两个折叠函数 <code>foldl1</code> 和 <code>foldr1</code>。它们与 <code>foldl</code> 和 <code>foldr</code> 的功能基本相同，只不过不需要显式地提供初始值。而是会自动地将列表的第一个值（不管从左起还是从右起）作为初始值。</p><p>以下是几个通过 fold 操作实现的标准库函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> = foldr1 (\x acc -&gt; <span class="keyword">if</span> x &gt; acc <span class="keyword">then</span> x <span class="keyword">else</span> acc)</span><br><span class="line">  </span><br><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> = foldl (\acc x -&gt; x : acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">product'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">product'</span> = foldr1 (*)</span><br><span class="line">  </span><br><span class="line"><span class="title">filter'</span> :: (a -&gt; <span class="type">Bool</span>) -&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">filter'</span> p = foldr (\x acc -&gt; <span class="keyword">if</span> p x <span class="keyword">then</span> x : acc <span class="keyword">else</span> acc) []</span><br><span class="line">  </span><br><span class="line"><span class="title">head'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">head'</span> = foldr1 (\x _ -&gt; x)</span><br><span class="line">  </span><br><span class="line"><span class="title">last'</span> :: [a] -&gt; a</span><br><span class="line"><span class="title">last'</span> = foldl1 (\_ x -&gt; x)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Haskell 中的函数可以作为另一个函数的参数或返回值，这类函数叫做&lt;strong&gt;高阶函数（high order functions）&lt;/strong&gt;。&lt;br&gt;想要通过&lt;strong&gt;定义是什么&lt;/strong&gt;而不是&lt;strong&gt;定义一系列可以改变程序状态的步骤&lt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Map" scheme="https://rollingstarky.github.io/tags/Map/"/>
    
      <category term="Reduce" scheme="https://rollingstarky.github.io/tags/Reduce/"/>
    
      <category term="Filter" scheme="https://rollingstarky.github.io/tags/Filter/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（三）递归</title>
    <link href="https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/"/>
    <id>https://rollingstarky.github.io/2021/06/29/basic-haskell-recursion/</id>
    <published>2021-06-28T16:00:00.000Z</published>
    <updated>2021-06-29T12:12:17.348Z</updated>
    
    <content type="html"><![CDATA[<p>递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。</p><p>数学中的定义很多时候都会用到递归，比如 fibonacci 数列：</p><ul><li><code>F(0) = 1</code></li><li><code>F(1) = 1</code></li><li><code>F(n) = F(n - 1) + F(n - 2)</code></li></ul><p>于是有 <code>F(3) = F(2) + F(1) = (F(1) + F(0)) + F(1) = 2</code>。</p><p>递归函数的定义中，并不只是包含调用自身的代码，常常还需要非递归形式的定义，如上面的 <code>F(0) = 1</code> 和 <code>F(1) = 1</code>。这样的代码称作<strong>边缘条件（edge condition）</strong>。<br>边缘条件对于递归函数的终止至关重要。假如上面的 <code>F(0)</code> 和 <code>F(1)</code> 未定义，则任何一个输入都会导致函数无限调用自身，永远不会终止。</p><p>递归是 Haskell 中很重要的概念。不同于命令式的语言，在 Haskell 中需要<strong>定义计算本身是什么</strong>，而不是<strong>定义怎样一步步得出结果</strong>。</p><h5 id="求最大值"><a href="#求最大值" class="headerlink" title="求最大值"></a>求最大值</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs)</span><br><span class="line">    | x &gt; maxTail = x</span><br><span class="line">    | otherwise = maxTail</span><br><span class="line">    <span class="keyword">where</span> maxTail = maximum' xs</span><br></pre></td></tr></table></figure><p>使用 <code>max</code> 函数（返回两个输入值中较大的那个）编写更短的形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">maximum'</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">maximum'</span> [] = error <span class="string">"maximum of empty list"</span></span><br><span class="line"><span class="title">maximum'</span> [x] = x</span><br><span class="line"><span class="title">maximum'</span> (x:xs) = max x (maximum' xs)</span><br></pre></td></tr></table></figure></p><p>当输入为 <code>[2, 5, 1]</code> 时，计算过程如下：<br><code>maximum&#39; [2, 5, 1]</code> -&gt; <code>max 2 (maximum&#39; [5, 1])</code> -&gt; <code>max 2 (max 5 (maximum&#39; [1]))</code> -&gt; <code>max 2 (max 5 1)</code> -&gt; <code>max 2 5</code> -&gt; <code>5</code>。</p><h5 id="生成由固定数量的同一元素构成的列表"><a href="#生成由固定数量的同一元素构成的列表" class="headerlink" title="生成由固定数量的同一元素构成的列表"></a>生成由固定数量的同一元素构成的列表</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">replicate'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; a -&gt; [a]</span><br><span class="line"><span class="title">replicate'</span> n x</span><br><span class="line">    | n &lt;= <span class="number">0</span>    = []</span><br><span class="line">    | otherwise = x:replicate' (n<span class="number">-1</span>) x</span><br></pre></td></tr></table></figure><p>如 <code>replicate&#39; 3 5</code> -&gt; <code>5:(replicate&#39; 2 5)</code> -&gt; <code>5:(5:(replicate&#39; 1 5))</code> -&gt; <code>5:(5:(5:(replicate&#39; 0 5)))</code> -&gt; <code>5:(5:(5:[]))</code> -&gt; <code>[5, 5, 5]</code>。</p><h5 id="取出列表中的前几个元素"><a href="#取出列表中的前几个元素" class="headerlink" title="取出列表中的前几个元素"></a>取出列表中的前几个元素</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">take'</span> :: (<span class="type">Num</span> i, <span class="type">Ord</span> i) =&gt; i -&gt; [a] -&gt; [a]  </span><br><span class="line"><span class="title">take'</span> n _</span><br><span class="line">    | n &lt;= <span class="number">0</span>   = []</span><br><span class="line"><span class="title">take'</span> _ []     = []</span><br><span class="line"><span class="title">take'</span> n (x:xs) = x : take' (n<span class="number">-1</span>) xs</span><br></pre></td></tr></table></figure><p>其中 <code>take&#39; n _</code> 和 <code>take&#39; _ []</code> 分别作为两种不同情况下的终止条件。<br>第一个模式 <code>take&#39; n _</code> 表示当 <code>n</code> 小于等于 0 时，不管输入的是什么样的列表都返回空列表 <code>[]</code>。<br>可以作为如 <code>take&#39; 2 [1, 2, 3]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后 <code>n</code> 等于 0，满足第一个模式，递归终止。<br>第二个模式 <code>take _ []</code> 表示当输入的列表是空列表时，不管 <code>n</code> 是多少都返回空列表。<br>可以作为如 <code>take&#39; 3 [1, 2]</code> 的终止条件。即前两个元素被取出并拼接成 <code>[1, 2]</code> 后，n 为 1，但列表成为空列表，满足第二个模式，递归终止。<br>第三个模式 <code>take&#39; n (x:xs)</code> 则用来定义从输入的列表头部逐个取出 n 个元素并拼接成新列表的递归逻辑。</p><h5 id="reverse-的自定义实现"><a href="#reverse-的自定义实现" class="headerlink" title="reverse 的自定义实现"></a>reverse 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">reverse'</span> :: [a] -&gt; [a]</span><br><span class="line"><span class="title">reverse'</span> [] = []</span><br><span class="line"><span class="title">reverse'</span> (x:xs) = reverse' xs ++ [x]</span><br></pre></td></tr></table></figure><h5 id="zip-的自定义实现"><a href="#zip-的自定义实现" class="headerlink" title="zip 的自定义实现"></a>zip 的自定义实现</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">zip'</span> :: [a] -&gt; [b] -&gt; [(a,b)]</span><br><span class="line"><span class="title">zip'</span> _ [] = []</span><br><span class="line"><span class="title">zip'</span> [] _ = []</span><br><span class="line"><span class="title">zip'</span> (x:xs) (y:ys) = (x,y):zip' xs ys</span><br></pre></td></tr></table></figure><h5 id="elem-的自定义实现（判断某个元素是否属于某个列表）"><a href="#elem-的自定义实现（判断某个元素是否属于某个列表）" class="headerlink" title="elem 的自定义实现（判断某个元素是否属于某个列表）"></a>elem 的自定义实现（判断某个元素是否属于某个列表）</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">elem'</span> :: (<span class="type">Eq</span> a) =&gt; a -&gt; [a] -&gt; <span class="type">Bool</span></span><br><span class="line"><span class="title">elem'</span> a [] = <span class="type">False</span></span><br><span class="line"><span class="title">elem'</span> a (x:xs)</span><br><span class="line">    | a == x    = <span class="type">True</span></span><br><span class="line">    | otherwise = a `elem'` xs</span><br></pre></td></tr></table></figure><h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">quicksort</span> :: (<span class="type">Ord</span> a) =&gt; [a] -&gt; [a]</span><br><span class="line"><span class="title">quicksort</span> [] = []</span><br><span class="line"><span class="title">quicksort</span> (x:xs) =</span><br><span class="line">    <span class="keyword">let</span> smallerSorted = quicksort [a | a &lt;- xs, a &lt;= x]</span><br><span class="line">        biggerSorted = quicksort [a | a &lt;- xs, a &gt; x]</span><br><span class="line">    <span class="keyword">in</span>  smallerSorted ++ [x] ++ biggerSorted</span><br></pre></td></tr></table></figure><h5 id="递归思维"><a href="#递归思维" class="headerlink" title="递归思维"></a>递归思维</h5><p>递归函数的定义通常遵循如下模式：</p><ul><li>定义边缘条件（edge conditon）用于在特定条件下终止递归的执行</li><li>取出部分元素执行特定操作，再调用递归函数本身处理剩余的元素</li></ul><p>某个列表中所有元素之和等于该列表的第一个元素加上剩余的所有元素之和；某个列表的长度等于尾部（去除头部第一个元素）所有元素的长度加 1。</p><p>通常情况下，edge condition 就是令递归函数无实际意义的条件。对于列表来说，最常见的 edge condition 就是空列表。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;递归是一种定义函数的方式，在该方式下，函数的定义中调用了该函数本身。有点像俄罗斯套娃。&lt;/p&gt;
&lt;p&gt;数学中的定义很多时候都会用到递归，比如 fibonacci 数列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;F(0) = 1&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;F(
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Recursion" scheme="https://rollingstarky.github.io/tags/Recursion/"/>
    
      <category term="Computation" scheme="https://rollingstarky.github.io/tags/Computation/"/>
    
  </entry>
  
  <entry>
    <title>Haskell 基本语法（二）模式匹配</title>
    <link href="https://rollingstarky.github.io/2021/06/25/basic-haskell-pattern-match/"/>
    <id>https://rollingstarky.github.io/2021/06/25/basic-haskell-pattern-match/</id>
    <published>2021-06-24T16:00:00.000Z</published>
    <updated>2021-06-25T14:53:30.547Z</updated>
    
    <content type="html"><![CDATA[<p>式匹配包含一系列特定的模式，用来判断数据是否符合规则，且能够通过这些模式把符合要求的数据<strong>解构</strong>出来。<br>Haskell 中的模式匹配可以应用到任意的数据类型上（数字、字符、列表、元组等等）。</p><h4 id="函数中的模式匹配"><a href="#函数中的模式匹配" class="headerlink" title="函数中的模式匹配"></a>函数中的模式匹配</h4><p>可以在函数体的定义中，用不同的代码行分别指定不同的模式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| lucky :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>| lucky <span class="number">7</span> = <span class="string">"LUCKY NUMBER SEVEN!"</span></span><br><span class="line"><span class="type">Prelude</span>| lucky x = <span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">1</span></span><br><span class="line"><span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">10</span></span><br><span class="line"><span class="string">"Sorry, you're out of luck!"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; lucky <span class="number">7</span></span><br><span class="line"><span class="string">"LUCKY NUMBER SEVEN!"</span></span><br></pre></td></tr></table></figure></p><p><strong>PS</strong>：上述代码是在 Haskell 的交互式解释器（REPL) <code>ghci</code> 中定义和执行函数的效果。<br>像 <code>lucky</code> 这种包含多行代码的函数，在 ghci 解释器中直接定义时，需要把整个函数体用 <code>:{</code> 和 <code>:}</code> 括起来（否则解释器会报错）。实际的 <code>lucky</code> 函数代码应为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lucky</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">lucky</span> <span class="number">7</span> = <span class="string">"LUCKY NUMBER SEVEN!"</span>  </span><br><span class="line"><span class="title">lucky</span> x = <span class="string">"Sorry, you're out of luck, pal!"</span></span><br></pre></td></tr></table></figure></p><p>即 <code>:{</code> 和 <code>:}</code> 从代码的角度讲是多余的，只是 <code>ghci</code> 解释器的缘故，导致必须加上这两个分隔符。若在文件中编写代码，则应该使用第二种形式。</p><p>代码的第一行 <code>lucky :: (Integral a) =&gt; a -&gt; String</code> 是函数的类型签名，也可以省略，解释器会自行推导。<br><code>lucky 7</code> 和 <code>lucky x</code> 两行代码则指定了具体的两个模式：<br>当函数输入为数字 7 时匹配第一个模式，任何其他的数字输入则匹配第二个模式并将该输入值绑定给变量 <code>x</code>。</p><p>一个包含更多个模式的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sayMe</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; <span class="type">String</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">1</span> = <span class="string">"One!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">2</span> = <span class="string">"Two!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">3</span> = <span class="string">"Three!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">4</span> = <span class="string">"Four!"</span>  </span><br><span class="line"><span class="title">sayMe</span> <span class="number">5</span> = <span class="string">"Five!"</span>  </span><br><span class="line"><span class="title">sayMe</span> x = <span class="string">"Not between 1 and 5"</span></span><br></pre></td></tr></table></figure></p><p>需要注意的是，最后一行代码 <code>sayMe x</code> 必须作为最后一个模式。<br>函数体中的模式会按照<strong>自顶而下</strong>的顺序检查是否匹配，若当前的模式已完成匹配，则忽略后面的检查；若当前模式不匹配，则继续向下逐个进行检查。<br>若 <code>sayMe x</code> 作为顶部的第一个模式（它实际上会匹配所有合法值），则任何输入值都会在第一步就完成匹配，进而忽略后面的 <code>sayMe 1</code>、<code>sayMe 2</code> 等模式，不再进行判断。即输入任何数字都会先匹配 <code>x</code> 并输出 Not between 1 and 5。</p><p>使用模式匹配和递归实现阶乘函数<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">factorial</span> :: (<span class="type">Integral</span> a) =&gt; a -&gt; a  </span><br><span class="line"><span class="title">factorial</span> <span class="number">0</span> = <span class="number">1</span>  </span><br><span class="line"><span class="title">factorial</span> n = n * factorial (n - <span class="number">1</span>)</span><br></pre></td></tr></table></figure></p><p>比如当输入为 3 时，<code>factorial</code> 函数会匹配第二个模式，结果为 <code>3 * (factorial 2)</code>。继续迭代，进一步计算结果中的 <code>factorial 2</code>，得到 <code>3 * (2 * (factorial 1))</code>、<code>3 * (2 * (1 * (factorial 0)))</code>。<br>而 <code>factorial 0</code> 会匹配第一个模式得到结果 1，迭代终止，再和前面的数字相乘后得到最终结果。</p><p>假如将 <code>factorial n = n * factorial (n - 1)</code> 作为第一个模式，则 <code>factorial n</code> 会匹配包含数字 0 在内的所有数字，另一个模式 <code>factorial 0 = 1</code> 就永远不会触发。从而导致迭代没有终止条件，一直进行下去。<br>因此，<strong>在模式匹配中，更精确更有指向性的模式总是放在相对通用和宽泛的模式前面</strong>。</p><p>在使用模式匹配时，应该总是包含一个 catch-all 模式，这样就不会出现所有模式都不匹配的情况。若程序的输入与所有模式都不匹配，程序会崩溃掉。<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| charName :: <span class="type">Char</span> -&gt; <span class="type">String</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'a' = <span class="string">"Albert"</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'b' = <span class="string">"Broseph"</span></span><br><span class="line"><span class="type">Prelude</span>| charName 'c' = <span class="string">"Cecil"</span></span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'a'</span><br><span class="line"><span class="string">"Albert"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'b'</span><br><span class="line"><span class="string">"Broseph"</span></span><br><span class="line"><span class="type">Prelude</span>&gt; charName 'h'</span><br><span class="line">*** <span class="type">Exception</span>: &lt;interactive&gt;:(<span class="number">3</span>,<span class="number">1</span>)-(<span class="number">5</span>,<span class="number">22</span>): <span class="type">Non</span>-exhaustive patterns <span class="keyword">in</span> function charName</span><br></pre></td></tr></table></figure></p><h4 id="元组中的模式匹配"><a href="#元组中的模式匹配" class="headerlink" title="元组中的模式匹配"></a>元组中的模式匹配</h4><p>在不使用模式匹配的情况下，实现一个计算两个向量之和的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">addVectors</span> :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)</span><br><span class="line"><span class="title">addVectors</span> a b = (fst a + fst b, snd a + snd b)</span><br></pre></td></tr></table></figure></p><p>通过模式匹配实现上述功能：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| addVectors :: (<span class="type">Num</span> a) =&gt; (a, a) -&gt; (a, a) -&gt; (a, a)</span><br><span class="line"><span class="type">Prelude</span>| addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2)</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; addVectors (<span class="number">1</span>, <span class="number">2</span>) (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">(<span class="number">4</span>,<span class="number">6</span>)</span><br></pre></td></tr></table></figure></p><p><code>fst</code> 和 <code>snd</code> 函数可以分别用来获取元组中的第一个和第二个元素（但是只针对包含两个元素的元组）。<br>对于有 3 个元素的元组，实际上可以借助模式匹配自己实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">first</span> :: (a, b, c) -&gt; a</span><br><span class="line"><span class="title">first</span> (x, _, _) = x</span><br><span class="line">  </span><br><span class="line"><span class="title">second</span> :: (a, b, c) -&gt; b</span><br><span class="line"><span class="title">second</span> (_, y, _) = y</span><br><span class="line">  </span><br><span class="line"><span class="title">third</span> :: (a, b, c) -&gt; c</span><br><span class="line"><span class="title">third</span> (_, _, z) = z</span><br></pre></td></tr></table></figure></p><p>可以在<strong>列表推导</strong>中使用模式匹配：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; <span class="keyword">let</span> xs = [(<span class="number">1</span>,<span class="number">3</span>), (<span class="number">4</span>,<span class="number">3</span>), (<span class="number">2</span>,<span class="number">4</span>), (<span class="number">5</span>,<span class="number">3</span>), (<span class="number">5</span>,<span class="number">6</span>), (<span class="number">3</span>,<span class="number">1</span>)]</span><br><span class="line"><span class="type">Prelude</span>&gt; [a+b | (a,b) &lt;- xs]</span><br><span class="line">[<span class="number">4</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">11</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure></p><p>甚至列表本身也可以用于模式匹配。<br>如模式 <code>x:xs</code> 会将列表的第一个元素绑定给变量 <code>x</code>，把其余元素绑定给 <code>xs</code>。此模式的应用非常普遍，尤其是在递归函数中。<br>如果想提取列表的前 3 个元素并将它们绑定给指定变量，可以使用 <code>x:y:z:zs</code> 形式的模式。</p><p>利用对列表的模式匹配实现自定义的 <code>head</code> 函数（获取列表中的第一个元素）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; :&#123;</span><br><span class="line"><span class="type">Prelude</span>| head' :: [a] -&gt; a</span><br><span class="line"><span class="type">Prelude</span>| head' [] = error <span class="string">"Can't call head on an empty list!"</span></span><br><span class="line"><span class="type">Prelude</span>| head' (x:_) = x</span><br><span class="line"><span class="type">Prelude</span>| :&#125;</span><br><span class="line"><span class="type">Prelude</span>&gt;</span><br><span class="line"><span class="type">Prelude</span>&gt; head' [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="type">Prelude</span>&gt; head' <span class="string">"Hello"</span></span><br><span class="line">'<span class="type">H'</span></span><br></pre></td></tr></table></figure></p><p>借助递归和模式匹配实现自定义的 <code>length</code> 函数（获取列表的长度）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">length'</span> :: (<span class="type">Num</span> b) =&gt; [a] -&gt; b</span><br><span class="line"><span class="title">length'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">length'</span> (_:xs) = <span class="number">1</span> + length' xs</span><br></pre></td></tr></table></figure></p><p>对于任何一个合法的输入如 <code>&quot;ham&quot;</code>，<code>length&#39;</code> 函数的计算过程如下：<br><code>length&#39; &quot;ham&quot;</code> =&gt; <code>1 + length&#39; &quot;am&quot;</code> =&gt; <code>1 + (1 + length&#39; &quot;m&quot;)</code> =&gt; <code>1 + (1 + (1 + length&#39; []))</code> =&gt; <code>1 + (1 + (1 + 0))</code></p><p>实现自定义的 <code>sum</code> 函数（求列表中各元素之和）：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">sum'</span> :: (<span class="type">Num</span> a) =&gt; [a] -&gt; a</span><br><span class="line"><span class="title">sum'</span> [] = <span class="number">0</span></span><br><span class="line"><span class="title">sum'</span> (x:xs) = x + sum' xs</span><br></pre></td></tr></table></figure></p><h4 id="守卫（guards）"><a href="#守卫（guards）" class="headerlink" title="守卫（guards）"></a>守卫（guards）</h4><p>守卫一般用来测试某个（些）值的特定属性是否为真，很像 if 语句。守卫和模式整合得非常好。</p><p>以下是一个求 BMI（体重指数）的函数定义：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> bmi</span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise   = <span class="string">"You're a whale, congratulations!"</span></span><br></pre></td></tr></table></figure></p><p>管道符（<code>|</code>）后面的布尔表达式即为守卫的定义。若该表达式计算结果为 True，则对应的代码被执行。<br>若该表达式计算结果为 False，则继续测试下一个守卫。</p><p>通常情况下，最后一个守卫是 <code>otherwise</code>。它其实是 <code>otherwise = True</code> 的简写形式，会捕获所有剩余的情况。</p><p>守卫可以配合有多个参数的函数使用：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | weight / height ^ <span class="number">2</span> &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise                 = <span class="string">"You're a whale, congratulations!"</span></span><br></pre></td></tr></table></figure></p><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Prelude</span>&gt; bmiTell <span class="number">65</span> <span class="number">1.75</span></span><br><span class="line"><span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br></pre></td></tr></table></figure><p>通过守卫自定义 <code>max</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">max'</span> :: (<span class="type">Ord</span> a) =&gt; a -&gt; a -&gt; a</span><br><span class="line"><span class="title">max'</span> a b</span><br><span class="line">    | a &gt; b     = a</span><br><span class="line">    | otherwise = b</span><br></pre></td></tr></table></figure></p><p><strong>where</strong><br>可以通过 <code>where</code> 关键字优化上面的 <code>bmiTell</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= <span class="number">18.5</span> = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">25.0</span> = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= <span class="number">30.0</span> = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise   = <span class="string">"You're a whale, congratulations!"</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>变量 <code>bmi</code> 在这里只计算了一次，不同于之前的 <code>weight / height ^ 2</code> 有可能会被重复计算 3 次。</p><p>更进一步，<code>bmiTell</code> 函数还可以改为如下形式：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">bmiTell</span> :: (<span class="type">RealFloat</span> a) =&gt; a -&gt; a -&gt; <span class="type">String</span></span><br><span class="line"><span class="title">bmiTell</span> weight height</span><br><span class="line">    | bmi &lt;= skinny = <span class="string">"You're underweight, you emo, you!"</span></span><br><span class="line">    | bmi &lt;= normal = <span class="string">"You're supposedly normal. Pffft, I bet you're ugly!"</span></span><br><span class="line">    | bmi &lt;= fat    = <span class="string">"You're fat! Lose some weight, fatty!"</span></span><br><span class="line">    | otherwise     = <span class="string">"You're a whale, congratulations!"</span></span><br><span class="line">    <span class="keyword">where</span> bmi = weight / height ^ <span class="number">2</span></span><br><span class="line">          skinny = <span class="number">18.5</span></span><br><span class="line">          normal = <span class="number">25.0</span></span><br><span class="line">          fat = <span class="number">30.0</span></span><br></pre></td></tr></table></figure></p><p><code>where</code> 语句中也可以定义函数，比如通过由多个包含身高体重的元组组成的列表，计算一系列 BMI 值：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">calcBmis</span> :: (<span class="type">RealFloat</span> a) =&gt; [(a, a)] -&gt; [a]</span><br><span class="line"><span class="title">calcBmis</span> xs = [bmi w h | (w, h) &lt;- xs]</span><br><span class="line">    <span class="keyword">where</span> bmi weight height = weight / height ^ <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="http://learnyouahaskell.com/" target="_blank" rel="noopener">Learn You a Haskell for Great Good!</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;式匹配包含一系列特定的模式，用来判断数据是否符合规则，且能够通过这些模式把符合要求的数据&lt;strong&gt;解构&lt;/strong&gt;出来。&lt;br&gt;Haskell 中的模式匹配可以应用到任意的数据类型上（数字、字符、列表、元组等等）。&lt;/p&gt;
&lt;h4 id=&quot;函数中的模式匹配&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Haskell" scheme="https://rollingstarky.github.io/tags/Haskell/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="GHC" scheme="https://rollingstarky.github.io/tags/GHC/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Recursion" scheme="https://rollingstarky.github.io/tags/Recursion/"/>
    
      <category term="Deconstruction" scheme="https://rollingstarky.github.io/tags/Deconstruction/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——模式匹配</title>
    <link href="https://rollingstarky.github.io/2021/06/23/the-rust-programming-language-reading-notes-pattern-match/"/>
    <id>https://rollingstarky.github.io/2021/06/23/the-rust-programming-language-reading-notes-pattern-match/</id>
    <published>2021-06-22T16:00:00.000Z</published>
    <updated>2021-06-23T12:15:54.396Z</updated>
    
    <content type="html"><![CDATA[<p><strong>模式</strong>是 Rust 中一种用来匹配类型结构的特殊语法，将其与 match 表达式或其他工具配合使用可以更好地控制程序流程。<br>模式被用来与某个特定的值进行匹配，若匹配成功，则可以继续使用这个值的某些部分；若匹配失败，模式对应的代码就被简单地略过。</p><h4 id="模式的应用场景"><a href="#模式的应用场景" class="headerlink" title="模式的应用场景"></a>模式的应用场景</h4><h5 id="match-分支"><a href="#match-分支" class="headerlink" title="match 分支"></a>match 分支</h5><p>模式可以被应用在 match 表达式的分支中。<br>match 表达式由 match 关键字、待匹配的值以及至少一个匹配分支组成。匹配分支则由某个模式及模式匹配成功后应当执行的表达式组成。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">match</span> 值 &#123; </span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">    模式 =&gt; 表达式,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>match 表达式必须穷尽匹配值的所有可能性</strong>。为了确保代码满足要求，可以在最后的分支处使用<strong>全匹配模式</strong>。例如变量名可以被用来覆盖所有剩余的可能性。<br>还有一个特殊的 <code>_</code> 模式可以被用来匹配所有可能的值，且不将它们绑定到任何一个变量上。即忽略所有未被指定的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> some_value = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">match</span> some_value &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"five"</span>),</span><br><span class="line">        <span class="number">7</span> =&gt; <span class="built_in">println!</span>(<span class="string">"seven"</span>),</span><br><span class="line">        _ =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="if-let-表达式"><a href="#if-let-表达式" class="headerlink" title="if let 表达式"></a>if let 表达式</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> favorite_color: <span class="built_in">Option</span>&lt;&amp;<span class="built_in">str</span>&gt; = <span class="literal">None</span>;</span><br><span class="line">    <span class="keyword">let</span> age: <span class="built_in">Result</span>&lt;<span class="built_in">u8</span>, _&gt; = <span class="string">"34"</span>.parse();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Some</span>(color) = favorite_color &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Using your favorite color &#123;&#125; as the background"</span>, color);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">let</span> <span class="literal">Ok</span>(age) = age &#123;</span><br><span class="line">        <span class="keyword">if</span> age &gt; <span class="number">30</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Using purple as the background color"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Using orange as the background color"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"Using blue as the background color"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码通过执行一系列的条件检查来确定使用的背景颜色。其中的变量已经被赋予了硬编码值，但现实中应当通过用户输入来获取这些值。</p><p>和 match 分支类似，if let 分支能够以同样的方式对变量进行覆盖。<code>if let Ok(age) = age</code> 这句代码中引入了新的变量 <code>age</code> 来存储 Ok 变体中的值，并覆盖了右侧的同名变量。</p><h5 id="while-let-循环"><a href="#while-let-循环" class="headerlink" title="while let 循环"></a>while let 循环</h5><p>while let 会反复执行同一个模式匹配直到出现失败的情形。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> stack = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">    stack.push(<span class="number">1</span>);</span><br><span class="line">    stack.push(<span class="number">2</span>);</span><br><span class="line">    stack.push(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">let</span> <span class="literal">Some</span>(top) = stack.pop() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, top);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码会依次打印 3、2、1。其中的 <code>pop</code> 方法会尝试取出动态数组的最后一个元素并将它包裹在 <code>Some(value)</code> 中返回。若动态数组为空，则 pop 返回 None。<code>while</code> 循环会在 pop 返回 Some 时执行循环体中的代码，pop 返回 None 时结束循环。</p><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p><strong>for 语句中紧随关键字 <code>for</code> 之后的值就是一个模式。</strong>比如 <code>for x in y</code> 中的 <code>x</code> 就是一个模式。</p><p>在 for 循环中使用模式来解构元组：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (index, value) <span class="keyword">in</span> v.iter().enumerate() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125; is at index &#123;&#125;"</span>, value, index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码使用 <code>enumerate</code> 方法作为迭代器的适配器，会在每次迭代过程中生成一个包含值本身及其索引的元组。如首次调用 <code>enumerate</code> 会产生元组 <code>(0, &#39;a&#39;)</code>。当这个值与模式 <code>(index, value)</code> 进行匹配时，index 就会被赋值为 0，value 就会被赋值为 ‘a’。</p><h5 id="let-语句"><a href="#let-语句" class="headerlink" title="let 语句"></a>let 语句</h5><p>最基本的 <code>let</code> 赋值语句中也同样用到了模式。更正式的 let 语句的定义如下：<br><code>let PATTERN = EXPRESSION;</code></p><p>在类似于 <code>let x = 5;</code> 这样的语句中，单独的变量名成为最朴素的模式。其中 <code>x</code> 作为模式表达的含义是，将此处匹配到的所有内容绑定至变量 x，因为 x 就是整个模式本身。</p><p>用 let 模式匹配来解构元组：<br><code>let (x, y, z) = (1, 2, 3);</code></p><p>如果模式中元素的数量与元组中元素的数量不同，则整个类型会匹配失败，导致编译错误。</p><h5 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h5><p>函数的参数同样也是模式。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">print_coordinates</span></span>(&amp;(x, y): &amp;(<span class="built_in">i32</span>, <span class="built_in">i32</span>)) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Current location: (&#123;&#125;, &#123;&#125;)"</span>, x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> point = (<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    print_coordinates(&amp;point);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>模式 <code>&amp;(x, y)</code> 能够和值 <code>&amp;(3, 5)</code> 匹配，因此 x 的值为 3，y 的值为 5。</p><h4 id="可失败性"><a href="#可失败性" class="headerlink" title="可失败性"></a>可失败性</h4><p><strong>模式可以被分为不可失败（irrefutable）和可失败（refutable）两种类型</strong>。<br>不可失败的模式能够匹配任何传入的值。如语句 <code>let x = 5;</code> 中的 x，因为 x 能够匹配右侧表达式所有可能的返回值。<br>可失败模式则可能因为某些特定的值而匹配失败。如表达式 <code>if let Some(x) = a_value</code> 中的 <code>Some(x)</code>。若 <code>a_value</code> 变量的值是 None 而不是 Some，则左边的 <code>Some(x)</code> 模式就会出现不匹配的情况。</p><p><strong>函数参数、let 语句及 for 循环只接收不可失败模式</strong>。因为这些场合下，程序无法在值不匹配时执行任何有意义的行为。<br><strong>if let 和 while let 表达式则只接收可失败模式</strong>。因为它们在被设计时就将匹配失败的情形考虑在内了，条件表达式的功能就是根据条件的成功与否执行不同的操作。</p><h4 id="模式语法"><a href="#模式语法" class="headerlink" title="模式语法"></a>模式语法</h4><h5 id="匹配字面量"><a href="#匹配字面量" class="headerlink" title="匹配字面量"></a>匹配字面量</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one"</span>),</span><br><span class="line">        <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"two"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="匹配命名变量"><a href="#匹配命名变量" class="headerlink" title="匹配命名变量"></a>匹配命名变量</h5><p>命名变量是一种可以匹配任何值的不可失败模式。需要注意的是，当我们在 match 表达式中使用命名变量时，由于 match 开启了一个新的作用域，所以被定义在 match 表达式内作为模式一部分的变量会覆盖掉 match 结构外的同名变量。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="literal">Some</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">let</span> y = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="literal">Some</span>(<span class="number">50</span>) =&gt; <span class="built_in">println!</span>(<span class="string">"Got 50"</span>),</span><br><span class="line">        <span class="literal">Some</span>(y) =&gt; <span class="built_in">println!</span>(<span class="string">"Matched, y = &#123;:?&#125;"</span>, y),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"Default case, x = &#123;:?&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// =&gt; Matched, y = 5</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"at the end: x = &#123;:?&#125;, y = &#123;:?&#125;"</span>, x, y);</span><br><span class="line">    <span class="comment">// =&gt; at the end: x = Some(5), y = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述代码中，第二个匹配分支的模式引入了新的变量 y，它会匹配 Some 变体中携带的任何值。因为处在 match 表达式创建的新作用域中，这里的 y 是一个新的变量，而不是程序起始处声明的那个存储了 10 的 y。<br>新的 y 绑定能够匹配 Some 中的任意值，即匹配 x 变量中 Some 内部的值 5。</p><p>match 表达式创建的作用域会随着当前表达式的结束而结束，其内部的 y 也无法幸免。因此代码最后的 <code>println!</code> 会输出 <code>at the end: x = Some(5), y = 10</code>。</p><h5 id="多重模式"><a href="#多重模式" class="headerlink" title="多重模式"></a>多重模式</h5><p>可以在 match 表达式的分支匹配中使用 <code>|</code> 来表示或的意思，从而一次性地匹配多个模式。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span> | <span class="number">2</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one or two"</span>),</span><br><span class="line">        <span class="number">3</span> =&gt; <span class="built_in">println!</span>(<span class="string">"three"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"anything"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="使用-来匹配区间"><a href="#使用-来匹配区间" class="headerlink" title="使用 ..= 来匹配区间"></a>使用 <code>..=</code> 来匹配区间</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> x &#123;</span><br><span class="line">        <span class="number">1</span>..=<span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"one through five"</span>),</span><br><span class="line">        _ =&gt; <span class="built_in">println!</span>(<span class="string">"something else"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用解构来分解值"><a href="#使用解构来分解值" class="headerlink" title="使用解构来分解值"></a>使用解构来分解值</h5><p>可以使用模式来分解结构体、枚举、元组或引用，从而使用这些值中的不同部分。</p><p><strong>解构结构体</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x: a, y: b &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, a);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码创建了 a 和 b 两个变量，分别匹配了 p 结构体中字段 x 和 y 的值。<br>采用与字段名相同的变量名在实践中非常常见，为了避免写出类似于 <code>let Point { x: x, y: y } = p</code> 这样冗余的代码，Rust 允许采用如下形式的代码解构结构体：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> Point &#123; x, y &#125; = p;</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">0</span>, x);</span><br><span class="line">    <span class="built_in">assert_eq!</span>(<span class="number">7</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>除了为所有字段创建变量，还可以在结构体模式中使用字面量来进行解构。这一技术使我们可以在某些特定字段符合要求的前提下再对其他字段进行解构。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">0</span>, y: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> p &#123;</span><br><span class="line">        Point &#123; x, y: <span class="number">0</span> &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On the x axis at &#123;&#125;"</span>, x),</span><br><span class="line">        Point &#123; x: <span class="number">0</span>, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On the y axis at &#123;&#125;"</span>, y),</span><br><span class="line">        Point &#123; x, y &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"On neither axis: (&#123;&#125;, &#123;&#125;)"</span>, x, y),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>通过在第一个分支中要求 y 字段匹配字面量 0，从而匹配到所有位于 x 轴上的点，同时创建了一个可以在随后代码块中使用的 x 变量。<br>类似的第二个分支匹配 y 轴上的点，第三个分支匹配所有剩余的点。</p><p>甚至可以按照某种更为复杂的方式来将模式混合、匹配或嵌套在一起。<br><code>let ((feet, inches), Point {x, y}) = ((3, 10), Point { x: 3, y: -10 });</code></p><h5 id="忽略模式中的值"><a href="#忽略模式中的值" class="headerlink" title="忽略模式中的值"></a>忽略模式中的值</h5><p><strong>使用 _ 忽略整个值</strong><br>可以使用下划线 <code>_</code> 作为通配符来匹配任意可能的值而不绑定值本身。虽然 <code>_</code> 模式最常被用在 match 表达式的最后一个分支中，实际上我们可以把它用于包括函数参数在内的一切模式中。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(_: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"This code only uses the y parameter: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    foo(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码会忽略传给第一个参数的值 3。忽略函数参数在某些情况下会变得有用。比如正在实现一个 trait，而这个 trait 的方法包含了你不需要的某些参数。此时就可以借助忽略模式避免编译器产生未使用变量的警告。</p><p><strong>使用 <code>..</code> 忽略值的剩余部分</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span> &#123;</span><br><span class="line">    x: <span class="built_in">i32</span>,</span><br><span class="line">    y: <span class="built_in">i32</span>,</span><br><span class="line">    z: <span class="built_in">i32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> origin = Point &#123; x: <span class="number">0</span>, y: <span class="number">0</span>, z: <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> origin &#123;</span><br><span class="line">        Point &#123; x, .. &#125; =&gt; <span class="built_in">println!</span>(<span class="string">"x is &#123;&#125;"</span>, x),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>..</code> 语法会自动展开并填充任意多个所需的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = (<span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> numbers &#123;</span><br><span class="line">        (first, .., last) =&gt; &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"Some numbers: &#123;&#125;, &#123;&#125;"</span>, first, last);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码使用 <code>first</code> 和 <code>last</code> 分别匹配了元组中的第一个值和最后一个值，而它们之间的 <code>..</code> 模式则会匹配并忽略中间的值。</p><h5 id="使用匹配守卫添加额外条件"><a href="#使用匹配守卫添加额外条件" class="headerlink" title="使用匹配守卫添加额外条件"></a>使用匹配守卫添加额外条件</h5><p>匹配守卫（match guard）是附加在 match 分支模式后的 if 条件语句，分支中的模式只有在该条件被同时满足时才能匹配成功。<br>匹配守卫的条件可以使用模式中创建的变量。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> num = <span class="literal">Some</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> num &#123;</span><br><span class="line">        <span class="literal">Some</span>(x) <span class="keyword">if</span> x &lt; <span class="number">5</span> =&gt; <span class="built_in">println!</span>(<span class="string">"less than five: &#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">Some</span>(x) =&gt; <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, x),</span><br><span class="line">        <span class="literal">None</span> =&gt; (),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中，<code>num</code> 能够与第一个分支中的模式匹配成功，随后的匹配守卫则会检查模式中创建的变量 x 是否小于 5。由于 num 同样满足这一条件，最终执行了第一个分支中的代码。<br>假设 num 的值是 <code>Some(10)</code>，则第一个匹配分支中的匹配守卫无法成立，Rust 会进入第二个分支继续比较最终匹配成功。</p><p>我们无法通过模式表达类似于 <code>if x &lt; 5</code> 这样的条件，匹配守卫增强了语句中表达相关逻辑的能力。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;模式&lt;/strong&gt;是 Rust 中一种用来匹配类型结构的特殊语法，将其与 match 表达式或其他工具配合使用可以更好地控制程序流程。&lt;br&gt;模式被用来与某个特定的值进行匹配，若匹配成功，则可以继续使用这个值的某些部分；若匹配失败，模式对应的代码就被简单
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Match" scheme="https://rollingstarky.github.io/tags/Match/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——泛型与 trait（特征）</title>
    <link href="https://rollingstarky.github.io/2021/06/20/the-rust-programming-language-reading-notes-generics-and-trait/"/>
    <id>https://rollingstarky.github.io/2021/06/20/the-rust-programming-language-reading-notes-generics-and-trait/</id>
    <published>2021-06-19T16:00:00.000Z</published>
    <updated>2021-06-20T13:18:29.320Z</updated>
    
    <content type="html"><![CDATA[<p>所有的编程语言都会致力于高效地处理重复概念，Rust 中的泛型（generics）就是这样一种工具。<strong>泛型是具体类型或其他属性的抽象替代</strong>。比如 <code>Option&lt;T&gt;</code>、<code>Vec&lt;T&gt;</code>、<code>Hash&lt;K, V&gt;</code> 等。</p><h4 id="将代码提取为函数以减少重复工作"><a href="#将代码提取为函数以减少重复工作" class="headerlink" title="将代码提取为函数以减少重复工作"></a>将代码提取为函数以减少重复工作</h4><p>下面的代码可以用来在数字列表中找到最大值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = number_list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> number_list &#123;</span><br><span class="line">        <span class="keyword">if</span> number &gt; largest &#123;</span><br><span class="line">            largest = number;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, largest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了消除重复代码，可以通过定义函数来创建抽象，令该函数可以接收任意整数列表作为参数并进行求值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>(list: &amp;[<span class="built_in">i32</span>]) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假设我们拥有两个不同的函数：一个用于在 i32 切片中搜索最大值；另一个用于在 char 切片中搜索最大值。代码可能是下面这个样子：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest_i32</span></span>(list: &amp;[<span class="built_in">i32</span>]) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest_char</span></span>(list: &amp;[<span class="built_in">char</span>]) -&gt; <span class="built_in">char</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest_i32(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest_char(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="泛型数据类型"><a href="#泛型数据类型" class="headerlink" title="泛型数据类型"></a>泛型数据类型</h5><p><strong>在函数定义中使用</strong><br>当使用泛型来定义一个函数时，我们需要将泛型放置在函数签名中用于指定参数和返回值类型的地方。<br>以这种方式编写的代码更加灵活，可以在不引入重复代码的同时向函数调用者提供更多的功能。</p><p>上面代码中的 <code>largest_i32</code> 和 <code>largest_char</code> 是两个只在名称和签名上有所区别的函数。<code>largest_i32</code> 作用于 i32 类型的切片，而 <code>largest_char</code> 作用于 char 类型的切片。<br>这两个函数拥有完全相同的代码，因此可以通过在一个函数中使用泛型来消除重复代码。</p><p>在函数签名中使用泛型合并不同的 largest 函数：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">largest</span></span>&lt;T: <span class="built_in">PartialOrd</span> + <span class="built_in">Copy</span>&gt;(list: &amp;[T]) -&gt; T &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> largest = list[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &amp;item <span class="keyword">in</span> list.iter() &#123;</span><br><span class="line">        <span class="keyword">if</span> item &gt; largest &#123;</span><br><span class="line">            largest = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    largest</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number_list = <span class="built_in">vec!</span>[<span class="number">34</span>, <span class="number">50</span>, <span class="number">25</span>, <span class="number">100</span>, <span class="number">65</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;number_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest number is &#123;&#125;"</span>, result);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> char_list = <span class="built_in">vec!</span>[<span class="string">'y'</span>, <span class="string">'m'</span>, <span class="string">'a'</span>, <span class="string">'q'</span>];</span><br><span class="line">    <span class="keyword">let</span> result = largest(&amp;char_list);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The largest char is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>largest&lt;T: PartialOrd + Copy&gt;</code> 部分的 <code>PartialOrd</code> 和 <code>Copy</code> 是为类型 T 指定的两个 <strong>trait 约束</strong>（后面会提到）。</p><p><strong>在结构体定义中使用</strong><br>同样地，也可以使用 <code>&lt;&gt;</code> 语法来定义在一个或多个字段中使用泛型的结构体。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上面的代码，在结构名后的一对尖括号中声明泛型参数后，就可以在结构体定义中用于指定具体数据类型的位置使用泛型了。</p><p>在定义 <code>Point&lt;T&gt;</code> 结构体时仅使用了一个泛型参数，表明该结构体对某个类型 <code>T</code> 是通用的。但无论 <code>T</code> 具体的类型是什么，字段 <code>x</code> 和 <code>y</code> 都同时属于这个类型。即 <code>x</code> 和 <code>y</code> 只能是同一类型。</p><p>为了使结构体 Point 中的 x 和 y 能够被实例化为不同的类型，可以使用多个泛型参数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> both_integer = Point &#123; x: <span class="number">5</span>, y: <span class="number">1</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> both_float = Point &#123; x: <span class="number">1.0</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> integer_and_float = Point &#123; x: <span class="number">5</span>, y: <span class="number">4.0</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>在方法定义中使用</strong><br>方法也可以在自己的定义中使用泛型：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Point&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">x</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;T &#123;</span><br><span class="line">        &amp;<span class="keyword">self</span>.x</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p = Point &#123; x: <span class="number">5</span>, y: <span class="number">10</span> &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p.x = &#123;&#125;"</span>, p.x());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码为结构体  <code>Point&lt;T&gt;</code> 实现了名为 <code>x</code> 的方法，返回一个指向 x 字段中 T 类型值的引用。</p><p>紧跟着 impl 关键字声明 T 是必须的。通过在 impl 之后将 T 声明为泛型，Rust 能够识别出 <code>Point&lt;T&gt;</code> 中尖括号内的类型是泛型而不是具体的类型。</p><p>实际上，可以单独为 <code>Point&lt;f32&gt;</code> 实例而不是所有的 <code>Point&lt;T&gt;</code> 泛型实例来实现特定的方法。<br>当在 <code>Point&lt;32&gt;</code> 声明中使用了明确的类型 f32，也意味着无需在 impl 之后附带任何类型声明了。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Point&lt;<span class="built_in">f32</span>&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">distance_from_origin</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">f32</span> &#123;</span><br><span class="line">        (<span class="keyword">self</span>.x.powi(<span class="number">2</span>) + <span class="keyword">self</span>.y.powi(<span class="number">2</span>)).sqrt()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码意味着，类型 <code>Point&lt;f32&gt;</code> 将会拥有一个名为 <code>distance_from_origin</code> 的方法，而其他的 <code>Point&lt;T&gt;</code> 实例则没有该方法的定义。</p><p>结构体定义中的泛型参数并不总是与方法签名中使用的类型参数一致。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>&lt;T, U&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: U,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, U&gt; Point&lt;T, U&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">mixup</span></span>&lt;V, W&gt;(<span class="keyword">self</span>, other: Point&lt;V, W&gt;) -&gt; Point&lt;T, W&gt; &#123;</span><br><span class="line">        Point &#123;</span><br><span class="line">            x: <span class="keyword">self</span>.x,</span><br><span class="line">            y: other.y,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> p1 = Point &#123; x: <span class="number">5</span>, y: <span class="number">10.4</span> &#125;;</span><br><span class="line">    <span class="keyword">let</span> p2 = Point &#123; x: <span class="string">"Hello"</span>, y: <span class="string">'c'</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> p3 = p1.mixup(p2);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"p3.x = &#123;&#125;, p3.y = &#123;&#125;"</span>, p3.x, p3.y);</span><br><span class="line">    <span class="comment">// =&gt; p3.x = 5, p3.y = c</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="trait：定义共享行为"><a href="#trait：定义共享行为" class="headerlink" title="trait：定义共享行为"></a>trait：定义共享行为</h4><p><strong>trait</strong> 用来向 Rust 编译器描述某些特定类型拥有的且能够被其他类型共享的功能，使我们可以以一种抽象的方式来定义共享行为。</p><p>trait 与其他语言中的接口（interface）功能类似，但也不尽相同。<br><strong>类型的行为由该类型本身可供调用的方法组成</strong>。当我们可以在不同的类型上调用相同的方法时，就称这些类型共享了相同的行为。<br><strong>trait 提供了一种将特定方法组合起来的途径，定义了为达成某种目的所必须的方法（行为）集合</strong>。</p><h5 id="定义-trait"><a href="#定义-trait" class="headerlink" title="定义 trait"></a>定义 trait</h5><p>假如我们拥有多个结构体（struct），分别持有不同类型、不同数量的文本字段。其中 NewsArticle 结构体存放新闻故事，Tweet 结构体存放推文。<br>我们还想要方便地获取存储在 NewsArticle 和 Tweet 实例中的数据摘要。因此需要为每个结构体类型都实现摘要行为，从而可以在这些实例上统一地调用 <code>summarize</code> 方法来请求摘要内容。</p><p>可以定义如下形式的 Summary trait：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在大括号中声明了用于定义类型行为的方法签名，即 <code>fn summarize(&amp;self) -&gt; String;</code>。<br>方法签名后省略了大括号及方法的具体实现。<strong>任何想要实现这个 trait 的类型都需要为上述方法提供自定义行为。编译器会确保每一个实现了 Summary trait 的类型都定义了与这个签名完全一致的 summarize 方法</strong>。<br>一个 trait 可以包含多个方法，每个方法签名占据单独一行并以分号结尾。</p><p><strong>为类型实现 trait</strong></p><p>完整代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NewsArticle</span></span> &#123;</span><br><span class="line">    headline: <span class="built_in">String</span>,</span><br><span class="line">    location: <span class="built_in">String</span>,</span><br><span class="line">    author: <span class="built_in">String</span>,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> NewsArticle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;, by &#123;&#125; (&#123;&#125;)"</span>, <span class="keyword">self</span>.headline, <span class="keyword">self</span>.author, <span class="keyword">self</span>.location)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Tweet</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    content: <span class="built_in">String</span>,</span><br><span class="line">    reply: <span class="built_in">bool</span>,</span><br><span class="line">    retweet: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, <span class="keyword">self</span>.username, <span class="keyword">self</span>.content)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">    <span class="comment">// =&gt; 1 new tweet: horse_ebooks: of course, as you probably already know, people</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>impl Summary for NewsArticle</code> 和 <code>impl Summary for Tweet</code> 部分负责为 NewsArticle 和 Tweet 两个结构体类型定义 Summary trait 中指定的 <code>summarize</code> 方法，并为该方法实现具体的行为。</p><h5 id="默认实现"><a href="#默认实现" class="headerlink" title="默认实现"></a>默认实现</h5><p>某些时候，为 trait 中的某些或所有方法都提供默认行为非常有用，使我们无需为每一个类型的 trait 实现都提供自定义行为。<br>当我们为某个特定类型实现 trait 时，可以选择保留或重载每个方法的默认行为。</p><p>如为 Summary trait 中的 <code>summarize</code> 方法指定一个默认的字符串返回值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">String</span>::from(<span class="string">"(Read More...)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如需要在 NewsArticle 的实例中使用上述默认实现，而不是自定义实现，可以指定一个空的 impl 代码块：<br><code>impl Summary for NewsArticle {}</code></p><p>此时虽然没有直接为 NewsArticle 定义 <code>summarize</code> 方法，依然可以在 NewsArticle 实例上调用 <code>summarize</code> 方法。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> article = NewsArticle &#123;</span><br><span class="line">        headline: <span class="built_in">String</span>::from(<span class="string">"Penguins win the Stanley Cup Championship!"</span>),</span><br><span class="line">        location: <span class="built_in">String</span>::from(<span class="string">"Pittsburgh, PA, USA"</span>),</span><br><span class="line">        author: <span class="built_in">String</span>::from(<span class="string">"Iceburgh"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(</span><br><span class="line">            <span class="string">"The Pittsburgh Penguins once again are the best</span></span><br><span class="line"><span class="string">    hockey team in the NHL."</span>,</span><br><span class="line">        ),</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"New article available! &#123;&#125;"</span>, article.summarize());</span><br><span class="line">    <span class="comment">// =&gt; New article available! (Read More...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>可以在默认实现中调用同一 trait 中的其他方法，哪怕这些被调用的方法没有默认实现</strong>。例如，可以为 Summary trait 定义一个<strong>需要被实现</strong>的方法 <code>summarize_author</code>（即 trait 中没有该方法的默认实现，需要在后续的类型中实现），再通过调用 <code>summarize_author</code> 为 <code>summarize</code> 方法提供一个默认实现：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Summary</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"(Read more from &#123;&#125;...)"</span>, <span class="keyword">self</span>.summarize_author())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使用这个版本的 Summary，只需要在后续类型实现这一 trait 时定义 <code>summarize_author</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Summary <span class="keyword">for</span> Tweet &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">summarize_author</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">        <span class="built_in">format!</span>(<span class="string">"@&#123;&#125;"</span>, <span class="keyword">self</span>.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>定义了 <code>summarize_author</code> 之后，就可以在 Tweet 实例上调用 <code>summarize</code> 了。<code>summarize</code> 的默认实现会进一步调用我们提供的 <code>summarize_author</code> 的定义。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tweet = Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"1 new tweet: &#123;&#125;"</span>, tweet.summarize());</span><br><span class="line">    <span class="comment">// =&gt; 1 new tweet: (Read more from @horse_ebooks...)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="trait-作为参数"><a href="#trait-作为参数" class="headerlink" title="trait 作为参数"></a>trait 作为参数</h5><p>前面的代码中为 NewsArticle 和 Tweet 类型实现了 Summary trait，我们还可以定义一个 notify 函数来调用这些类型的 <code>summarize</code> 方法。语法如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>(item: <span class="keyword">impl</span> Summary) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码没有为 <code>item</code> 参数指定具体的类型，而是使用了 <code>impl</code> 关键字及对应的 trait 名称。<br>这意味着 <code>item</code> 参数可以接收任何实现了指定 trait 的类型。在 <code>notify</code> 函数体内，则可以调用来自 Summary trait 的任何方法。<br>尝试使用其他类型（如 <code>String</code> 或 <code>i32</code>）来调用 <code>notify</code> 函数则无法通过编译，因为这些类型没有实现 Summary trait。</p><p>上述代码其实只是 <strong>trait 约束</strong>的一种语法糖，完整形式如下：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">notify</span></span>&lt;T: Summary&gt;(item: T) &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"Breaking news! &#123;&#125;"</span>, item.summarize());</span><br></pre></td></tr></table></figure></p><p><strong>通过 + 语法来指定多个 trait 约束</strong><br>如果 notify 函数需要在调用 summarize 方法的同时显示格式化后的 item，则此处的 item 就必须实现两个不同的 trait：Summary 和 Display。<br><code>fn notify(item: impl Summary + Display) {</code></p><p>这一语法在泛型的 trait 约束中同样有效：<br><code>fn notify&lt;T: Summary + Display&gt;(item: T) {</code></p><p><strong>where 从句简化 trait 约束</strong><br>因为每个泛型都拥有自己的 trait 约束，定义多个类型参数的函数可能会有大量的 trait 约束信息需要被填写在函数名与参数列表之间。Rust 提供了一种替代语法。</p><p>如 <code>fn some_function&lt;T: Display + Clone, U: Clone + Debug&gt;(t: T, u: U) -&gt; i32 {</code></p><p>可以改写成如下形式：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">some_function</span></span>&lt;T, U&gt;(t: T, u: U) -&gt; <span class="built_in">i32</span></span><br><span class="line">    <span class="keyword">where</span> T: Display + <span class="built_in">Clone</span>,</span><br><span class="line">          U: <span class="built_in">Clone</span> + <span class="built_in">Debug</span></span><br><span class="line">&#123;</span><br></pre></td></tr></table></figure></p><h5 id="返回实现了-trait-的类型"><a href="#返回实现了-trait-的类型" class="headerlink" title="返回实现了 trait 的类型"></a>返回实现了 trait 的类型</h5><p>同样可以在返回值中使用 impl Trait 语法，用于返回某种实现了特定 trait 的类型。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">returns_summarizable</span></span>() -&gt; <span class="keyword">impl</span> Summary &#123;</span><br><span class="line">    Tweet &#123;</span><br><span class="line">        username: <span class="built_in">String</span>::from(<span class="string">"horse_ebooks"</span>),</span><br><span class="line">        content: <span class="built_in">String</span>::from(<span class="string">"of course, as you probably already know, people"</span>),</span><br><span class="line">        reply: <span class="literal">false</span>,</span><br><span class="line">        retweet: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>之前在介绍泛型时编写的 <code>largest</code> 函数就通过 trait 约束来限定泛型参数的具体类型。<br>在 <code>largest</code> 函数中，我们想要使用大于号运算符来比较两个 T 类型的值。这一运算符被定义为标准库 <code>std::cmp::PartialOrd</code> 的一个默认方法，因此需要在 T 的 trait  约束中指定 <code>PartialOrd</code>，才能够使 <code>largest</code> 函数用于任何可比较类型的切片上。</p><p>我们在编写 <code>largest</code> 函数的非泛型版本时，只尝试过搜索 <code>i32</code> 和 <code>char</code> 类型的最大值。这两种都是拥有确定大小并存储在栈上的类型，实现了 Copy trait。<br>但当我们尝试将 <code>largest</code> 函数泛型化时，list 参数中的类型有可能是没有实现 Copy trait 的。为了确保这个函数只会被那些实现了 Copy trait 的类型所调用，还需要把 Copy 加入到 T 的 trait 约束中。</p><p>所以最终的 <code>largest</code> 函数采用如下声明：<br><code>fn largest&lt;T: PartialOrd + Copy&gt;(list: &amp;[T]) -&gt; T {</code></p><h5 id="使用-trait-约束有条件地实现方法"><a href="#使用-trait-约束有条件地实现方法" class="headerlink" title="使用 trait 约束有条件地实现方法"></a>使用 trait 约束有条件地实现方法</h5><p>通过在带有泛型参数的 impl 代码块中使用 trait 约束，我们可以单独为实现了指定 trait 的类型编写方法。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::fmt::Display;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pair</span></span>&lt;T&gt; &#123;</span><br><span class="line">    x: T,</span><br><span class="line">    y: T,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">new</span></span>(x: T, y: T) -&gt; <span class="keyword">Self</span> &#123;</span><br><span class="line">        <span class="keyword">Self</span> &#123; x, y &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T: Display + <span class="built_in">PartialOrd</span>&gt; Pair&lt;T&gt; &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">cmp_display</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.x &gt;= <span class="keyword">self</span>.y &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is x = &#123;&#125;"</span>, <span class="keyword">self</span>.x);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">println!</span>(<span class="string">"The largest member is y = &#123;&#125;"</span>, <span class="keyword">self</span>.y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> pair = Pair::new(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">    pair.cmp_display()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码中，所有的 <code>Pair&lt;T&gt;</code> 类型都会实现 <code>new</code> 方法，但只有在内部类型 <code>T</code> 实现了 <code>PartialOrd</code>（用于比较）和  <code>Display</code>（用于打印）这两个 trait 的前提下，才会实现 <code>cmd_display</code> 方法。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>借助于 trait 和 trait 约束，我们可以在使用泛型参数消除重复代码的同时，向编译器指明自己希望泛型拥有的功能。而编译器则可以利用这些 trait 约束信息来确保代码中使用的具体类型提供了正确的行为</strong>。<br>在动态语言中，尝试调用类型没有实现的方法会导致在运行时出现错误。Rust 将这些错误出现的时机转移到了编译期，我们无需编写那些用于在运行时检查类型的代码，这一机制在保留泛型灵活性的同时提升了代码性能。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;所有的编程语言都会致力于高效地处理重复概念，Rust 中的泛型（generics）就是这样一种工具。&lt;strong&gt;泛型是具体类型或其他属性的抽象替代&lt;/strong&gt;。比如 &lt;code&gt;Option&amp;lt;T&amp;gt;&lt;/code&gt;、&lt;code&gt;Vec&amp;lt;T&amp;gt;&lt;/
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Generics" scheme="https://rollingstarky.github.io/tags/Generics/"/>
    
      <category term="Interface" scheme="https://rollingstarky.github.io/tags/Interface/"/>
    
      <category term="Trait" scheme="https://rollingstarky.github.io/tags/Trait/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——通用集合类型</title>
    <link href="https://rollingstarky.github.io/2021/06/14/the-rust-programming-language-reading-notes-collections/"/>
    <id>https://rollingstarky.github.io/2021/06/14/the-rust-programming-language-reading-notes-collections/</id>
    <published>2021-06-13T16:00:00.000Z</published>
    <updated>2021-06-14T14:54:05.591Z</updated>
    
    <content type="html"><![CDATA[<p>Rust 标准库包含了一系列被称为集合的数据结构。<strong>与内置的数组和元组不同，集合将自己持有的数据存储在堆上。这使得数据的大小不需要在编译时确定，且可以随着程序的运行按需扩大或缩小数据占用的空间</strong>。</p><p>Rust 中有 3 种最常用的集合类型：</p><ul><li>动态数组（vector）</li><li>字符串（string）</li><li>哈希映射（hash map）</li></ul><h4 id="使用动态数组存储多个值"><a href="#使用动态数组存储多个值" class="headerlink" title="使用动态数组存储多个值"></a>使用动态数组存储多个值</h4><p>动态数组（<code>Vec&lt;T&gt;</code>）支持在单个数据结构中存储多个<strong>相同类型</strong>的值，这些值会彼此相邻地排布在内存中。</p><p>可以调用函数 <code>Vec::new</code> 来创建一个空的动态数组：<br><code>let v: Vec&lt;i32&gt; = Vec::new();</code></p><p>上述代码会创建一个用来存储 <code>i32</code> 数据地的空的动态数组。由于并未在这个动态数组中插入任何值，因此需要显式地添加类型标记（<code>Vec&lt;i32&gt;</code>）。</p><p>用初始值去创建动态数组的场景也十分常见，因此 Rust 特意提供了一个用于简化代码的 <code>vec!</code> 宏。<br><code>let v = vec![1, 2, 3]</code></p><p>更新动态数组：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">Vec</span>::new();</span><br><span class="line"></span><br><span class="line">v.push(<span class="number">5</span>);</span><br><span class="line">v.push(<span class="number">6</span>);</span><br><span class="line">v.push(<span class="number">7</span>);</span><br><span class="line">v.push(<span class="number">8</span>);</span><br></pre></td></tr></table></figure></p><p><strong>销毁动态数组时也会销毁其中的元素</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  执行与 v 相关的操作</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="comment">//  &lt;- v 在这里离开作用域并随之被销毁</span></span><br></pre></td></tr></table></figure></p><p>可以使用索引和 <code>get</code> 两种方法读取动态数组中的元素。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">    <span class="keyword">let</span> third: &amp;<span class="built_in">i32</span> = &amp;v[<span class="number">2</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The third element is &#123;&#125;"</span>, third);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">match</span> v.get(<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="literal">Some</span>(third) =&gt; <span class="built_in">println!</span>(<span class="string">"The third number is &#123;&#125;"</span>, third),</span><br><span class="line">        <span class="literal">None</span> =&gt; <span class="built_in">println!</span>(<span class="string">"There is no third element"</span>),</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是：</p><ul><li>动态数组使用数字进行索引，索引值从 0 开始</li><li>使用 <code>&amp;</code> 与 <code>[]</code> 会直接返回元素的引用</li><li>接收索引作为参数的 get 方法会返回一个 <code>Option&lt;T&gt;</code> 类型</li></ul><p>当尝试使用不存在的索引值去访问动态数组时，上述两种引用方法会导致程序触发不同的响应方式。比如对于某个持有 5 个元素的动态数组，尝试访问其索引为 100 的元素。</p><p><code>[]</code> 方法会因为索引指向了不存在的元素而触发 panic，假如希望在尝试越界访问元素时令程序直接崩溃，此方法就很适用。<br><code>get</code> 方法会在检测到索引越界时直接返回 <code>None</code>，而不会导致程序崩溃。当偶尔越界访问动态数组的元素是一种正常行为时，可以使用此方法。此外，<strong>代码应该合乎逻辑地处理 <code>Some(&amp;element)</code> 与 <code>None</code> 两种不同的情形</strong>。</p><p><strong>在存在指向动态数组元素的引用时，尝试向动态数组中添加元素会导致编译器报错</strong>。比如下面的代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">    <span class="keyword">let</span> first = &amp;v[<span class="number">0</span>];</span><br><span class="line">    v.push(<span class="number">6</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The first element is &#123;&#125;"</span>, first);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对第一个元素的引用需要关心动态数组结尾处的变化，这与动态数组的机制有关。<br>动态数组中的元素是连续地存储在堆中的，插入新的元素也许会没有足够多的空间将所有元素依次相邻地放下。这就需要分配新的内存空间，再将旧的元素移动到新的空间上，旧的空间被释放。<br>也就是说，动态数组末尾插入数据有可能导致上面代码中第一个元素的引用指向了被释放的内存。</p><h5 id="遍历动态数组"><a href="#遍历动态数组" class="headerlink" title="遍历动态数组"></a>遍历动态数组</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;v &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以遍历可变的动态数组，获得元素的可变引用，并修改其中的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> v = <span class="built_in">vec!</span>[<span class="number">100</span>, <span class="number">32</span>, <span class="number">57</span>];</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> &amp;<span class="keyword">mut</span> v &#123;</span><br><span class="line">        *i += <span class="number">50</span>;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为了使 <code>+=</code> 运算符修改可变引用的值，需要使用解引用运算符 <code>*</code> 来获取 <code>i</code> 绑定的值。</p><h4 id="使用字符串存储-UTF-8-文本"><a href="#使用字符串存储-UTF-8-文本" class="headerlink" title="使用字符串存储 UTF-8 文本"></a>使用字符串存储 UTF-8 文本</h4><p>Rust 在语言核心部分只有一种字符串类型，即<strong>字符串切片 str</strong>，通常以借用的形式（<code>&amp;str</code>）出现。<strong>字符串切片是一些指向存储在别处的 UTF-8 编码的字符串的引用</strong>。</p><p>String 类型被定义在 Rust 标准库中，没有内置在语言的核心部分。它也采用了 UTF-8 编码。</p><h5 id="创建字符串"><a href="#创建字符串" class="headerlink" title="创建字符串"></a>创建字符串</h5><p>许多对于 <code>Vec&lt;T&gt;</code> 的操作同样可用于 String，比如可以从 <code>new</code> 函数创建一个新的空字符串：<br><code>let mut s = String::new();</code></p><p>可以对那些实现了 Display trait 的类型调用 <code>to_string</code> 方法，创建有初始数据的字符串：<br><code>let s = &quot;initial contents&quot;.to_string();</code></p><p>也可以使用 <code>String::from</code> 函数基于字符串字面量生成 String：<br><code>let s = String::from(&quot;initial contents&quot;);</code></p><p>字符串是基于 UTF-8 编码的，因此可以将任何合法的数据编码进字符串：<br><code>let hello = String::from(&quot;你好&quot;);</code></p><h5 id="更新字符串"><a href="#更新字符串" class="headerlink" title="更新字符串"></a>更新字符串</h5><p>可以使用 <code>push_str</code> 方法来向 String 中添加一段字符串切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"foo"</span>);</span><br><span class="line">s.push_str(<span class="string">"bar"</span>);</span><br></pre></td></tr></table></figure></p><p><code>push</code> 方法接收单个字符作为参数，并将它添加到 String 中。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"lo"</span>);</span><br><span class="line">s.push(<span class="string">'l'</span>);</span><br></pre></td></tr></table></figure></p><p>使用 <code>+</code> 运算符将两个 String 合并到一个新的 String 中：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"Hello, "</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"world!"</span>);</span><br><span class="line">    <span class="keyword">let</span> s3 = s1 + &amp;s2;  <span class="comment">// 这里的 s1 已经被移动且再也不能被使用</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>需要注意的是，上面的加法操作中只对变量 s2 采用了引用，而 s1 由于所有权的移动在加法操作之后不再有效。<br>这里的 <code>+</code> 运算符会调用一个 <code>add</code> 方法，其签名类似于：<br><code>fn add(self, s: &amp;str) -&gt; String {</code></p><p>由于函数签名中的 <code>self</code> 并没有使用 <code>&amp;</code> 标记，因此 add 函数会取得 self 的所有权，导致 s1 被移动至 add 函数调用中，在调用后失效。<br>这种实现要比单纯的复制更加高效。</p><p>对于复杂一些的比如多个字符串的合并，可以使用 <code>format!</code> 宏：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"tic"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"tac"</span>);</span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">String</span>::from(<span class="string">"toe"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">format!</span>(<span class="string">"&#123;&#125;-&#123;&#125;-&#123;&#125;"</span>, s1, s2, s3);</span><br></pre></td></tr></table></figure></p><p><code>format!</code> 宏与 <code>println!</code> 宏的工作原理完全相同，只不过 <code>format!</code> 会将结果包含在一个 String 中返回。这使得用 <code>format!</code> 的代码更加易读，且不会夺取任何参数的所有权。</p><h5 id="字符串索引"><a href="#字符串索引" class="headerlink" title="字符串索引"></a>字符串索引</h5><p><strong>Rust 中的字符串不支持索引</strong>。比如下面的代码会导致编译器报错：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> h = s1[<span class="number">0</span>];</span><br></pre></td></tr></table></figure></p><p>String 实际上是一个基于 <code>Vec&lt;u8&gt;</code> 的封装类型。<br><code>let len = String::from(&quot;Hola&quot;).len();</code> 中，变量 <code>len</code> 的值为 4，意味着动态数组所存储的字符串 Hola 占用了 4 个字节。<br>而 <code>let len = String::from(&quot;你好&quot;).len();</code> 中，Rust 返回的结果却并不是 2，而是 6。这就是使用 UTF-8 编码来存储“你好”所需要的字节数。<br>因此<strong>对于字符串中字节的索引并不总是能对应到一个有效的 Unicode 标量值</strong>。</p><p>还有一个原因，索引操作的复杂度往往会被预期为常数时间 O(1)，但在 String 中，Rust 必须要从头遍历至索引位置来确定究竟有多少合法字符存在，这无法保障常数时间的性能。</p><h5 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h5><p>字符串切片是指向 String 对象中某个连续部分的<strong>引用</strong>：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">let</span> hello = &amp;s[<span class="number">0</span>..<span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> world = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure></p><p>向函数传入字符串切片并不会导致切片指向的原始 String 因为所有权的移动而失效。</p><p>字符串字面量就是切片。<br><code>let s = &quot;Hello, world!&quot;;</code><br>变量 s 的类型其实是 <code>&amp;str</code>，是一个指向二进制程序特定位置的切片。正是由于 <code>&amp;str</code> 是一个不可变引用，字符串字面量才是不可变的。</p><p>尝试通过索引引用字符串通常是一个坏主意，因为该操作应当返回的类型是不明确的：究竟应该是字节、字符、字形簇还是切片呢？<br>Rust 要求程序员做出更加明确的标记，在索引的 <code>[]</code> 中填写范围来指定所需的<strong>字节内容</strong>，即明确其类型为字符串切片。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="keyword">let</span> s = &amp;hello[<span class="number">0</span>..<span class="number">3</span>];</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);</span><br><span class="line">    <span class="comment">// =&gt; 你</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，<code>s</code> 将会是一个包含了字符串前 3 个字节的 <code>&amp;str</code>，即 <code>你</code>。若尝试在代码中使用 <code>&amp;hello[0..2]</code>，则程序运行时会发生 panic：<br><code>thread &#39;main&#39; panicked at &#39;byte index 2 is not a char boundary; it is inside &#39;你&#39; (bytes 0..3) of `你好`&#39;</code></p><p><strong>切记要小心谨慎地使用范围语法创建字符串切片</strong>。</p><p>假如确实需要对每一个 Unicode 标量值都进行处理，最好的办法是使用 <code>chars</code> 方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> hello = <span class="built_in">String</span>::from(<span class="string">"你好"</span>);</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> hello.chars() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, c);</span><br><span class="line">        <span class="comment">// =&gt; 你</span></span><br><span class="line">        <span class="comment">// =&gt; 好</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="在映射中存储键值对"><a href="#在映射中存储键值对" class="headerlink" title="在映射中存储键值对"></a>在映射中存储键值对</h4><p>哈希映射 <code>HashMap&lt;K, V&gt;</code> 存储了从 K 类型键关联到 V 类型值之间的映射关系。</p><h5 id="创建哈希映射"><a href="#创建哈希映射" class="headerlink" title="创建哈希映射"></a>创建哈希映射</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p>和动态数组一样，哈希映射也将其数据存储在堆上。它同样也是同质的，即所有键必须拥有相同的类型，所有的值也必须拥有相同的类型。</p><p>另一种构建哈希映射的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> teams  = <span class="built_in">vec!</span>[<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)];</span><br><span class="line"><span class="keyword">let</span> initial_scores = <span class="built_in">vec!</span>[<span class="number">10</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> scores: HashMap&lt;_, _&gt; = teams.iter().zip(initial_scores.iter()).collect();</span><br></pre></td></tr></table></figure></p><h5 id="哈希映射与所有权"><a href="#哈希映射与所有权" class="headerlink" title="哈希映射与所有权"></a>哈希映射与所有权</h5><p>对于那些实现了 Copy trait 的类型如 i32，它们的值会被简单地复制到哈希映射中。而对于 String 这种持有所有权的值，其所有权会转移给哈希映射：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> field_name = <span class="built_in">String</span>::from(<span class="string">"Favorite color"</span>);</span><br><span class="line"><span class="keyword">let</span> field_value = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">map.insert(field_name, field_value);</span><br><span class="line"><span class="comment">// filed_name 和 field_value 从这一刻开始失效，若尝试使用它们则会导致编译错误！</span></span><br></pre></td></tr></table></figure></p><p>在调用 <code>insert</code> 方法后，field_name 和 field_value 变量会被移动到哈希映射中，之后就无法再使用这两个变量了。</p><h5 id="访问哈希映射中的值"><a href="#访问哈希映射中的值" class="headerlink" title="访问哈希映射中的值"></a>访问哈希映射中的值</h5><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> team_name = <span class="built_in">String</span>::from(<span class="string">"Blue"</span>);</span><br><span class="line"><span class="keyword">let</span> score = scores.get(&amp;team_name);</span><br></pre></td></tr></table></figure><p><code>get</code> 返回的是一个 <code>Option&lt;&amp;V&gt;</code> 类型。因此上面代码中的 <code>score</code> 将会是与蓝队相关联的值，即 <code>Some(&amp;10)</code>。<br>若哈希映射中没有指定键所对应的值，<code>get</code> 方法就会返回 <code>None</code>。</p><p>可以使用 <code>for</code> 循环遍历哈希映射：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>), <span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (key, value) <span class="keyword">in</span> &amp;scores &#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;: &#123;&#125;"</span>, key, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="更新哈希映射"><a href="#更新哈希映射" class="headerlink" title="更新哈希映射"></a>更新哈希映射</h5><p><strong>替换旧值</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line"></span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br></pre></td></tr></table></figure></p><p>原来的值 10 会被新值 25 替换掉。</p><p><strong>只在某个键没有对应值时才插入数据</strong><br>即若某个键对应的值存在，保持原状；若该值不存在，将参数作为新值插入。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> scores = HashMap::new();</span><br><span class="line">    scores.insert(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>), <span class="number">10</span>);</span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">"Yellow"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line">    scores.entry(<span class="built_in">String</span>::from(<span class="string">"Blue"</span>)).or_insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, scores);</span><br><span class="line">    <span class="comment">// =&gt; &#123;"Blue": 10, "Yellow": 50&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>基于旧值更新值</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">use</span> std::collections::HashMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> text = <span class="string">"hello world wonderful world"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> map = HashMap::new();</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> text.split_whitespace() &#123;</span><br><span class="line">        <span class="keyword">let</span> count = map.entry(word).or_insert(<span class="number">0</span>);</span><br><span class="line">        *count += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;:?&#125;"</span>, map);</span><br><span class="line">    <span class="comment">// =&gt; &#123;"hello": 1, "world": 2, "wonderful": 1&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Rust 标准库包含了一系列被称为集合的数据结构。&lt;strong&gt;与内置的数组和元组不同，集合将自己持有的数据存储在堆上。这使得数据的大小不需要在编译时确定，且可以随着程序的运行按需扩大或缩小数据占用的空间&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Rust 中有 3 种最常用的集
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="List" scheme="https://rollingstarky.github.io/tags/List/"/>
    
      <category term="String" scheme="https://rollingstarky.github.io/tags/String/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Collection" scheme="https://rollingstarky.github.io/tags/Collection/"/>
    
      <category term="Vector" scheme="https://rollingstarky.github.io/tags/Vector/"/>
    
      <category term="HashMap" scheme="https://rollingstarky.github.io/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——结构体（Struct）</title>
    <link href="https://rollingstarky.github.io/2021/06/09/the-rust-programming-language-reading-notes-struct/"/>
    <id>https://rollingstarky.github.io/2021/06/09/the-rust-programming-language-reading-notes-struct/</id>
    <published>2021-06-08T16:00:00.000Z</published>
    <updated>2021-06-09T15:29:10.952Z</updated>
    
    <content type="html"><![CDATA[<p><strong>结构（Struct）是一种自定义数据类型</strong>。允许我们命名多个相关的值并将它们组成一个有机的结合体。</p><h4 id="定义与实例化"><a href="#定义与实例化" class="headerlink" title="定义与实例化"></a>定义与实例化</h4><p>关键字 <code>struct</code> 被用来定义并命名结构体，一个良好的结构体名称需反映出自身数据组合的意义。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    username: <span class="built_in">String</span>,</span><br><span class="line">    email: <span class="built_in">String</span>,</span><br><span class="line">    sign_in_count: <span class="built_in">u64</span>,</span><br><span class="line">    active: <span class="built_in">bool</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>结构体就像是类型的通用模板，将具体的数据填入模板时就创建了新的实例</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在创建了结构体实例后，可以通过点号来访问实例中的特定字段。假如这个实例是可变的，还可以通过点号来修改字段的值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> user1 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"someone@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"someusername123"</span>),</span><br><span class="line">    active: <span class="literal">true</span>,</span><br><span class="line">    sign_in_count: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">user1.email = <span class="built_in">String</span>::from(<span class="string">"anotheremail@example.com"</span>);</span><br></pre></td></tr></table></figure></p><p>需要注意的是，<strong>一旦结构体实例定义为可变，那么实例中的所有字段都将是可变的</strong>。</p><p>可以在函数体的最后一个表达式中构建结构体实例，来隐式的将这个实例作为结果返回。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email: email,</span><br><span class="line">        username: username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在变量名与字段名相同时，可以使用简化版的字段初始化方法重构上面的 <code>build_user</code> 函数。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">build_user</span></span>(email: <span class="built_in">String</span>, username: <span class="built_in">String</span>) -&gt; User &#123;</span><br><span class="line">    User &#123;</span><br><span class="line">        email,</span><br><span class="line">        username,</span><br><span class="line">        active: <span class="literal">true</span>,</span><br><span class="line">        sign_in_count: <span class="number">1</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在许多情况下，新创建的实例中，除了需要修改的小部分字段以外，其余字段的值与旧实例完全相同。可以使用<strong>结构体更新语法</strong>快速实现此类新实例的创建。</p><p>使用结构体更新语法来为一个 User 实例设置新的 email 和 username 字段的值，并从 user1 实例中获取剩余字段的值：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> user2 = User &#123;</span><br><span class="line">    email: <span class="built_in">String</span>::from(<span class="string">"another@example.com"</span>),</span><br><span class="line">    username: <span class="built_in">String</span>::from(<span class="string">"anotherusername567"</span>),</span><br><span class="line">    ..user1</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p><code>..</code> 表示剩下的那些还未被显式赋值的字段都与给定实例拥有相同的值。</p><h5 id="元组结构体"><a href="#元组结构体" class="headerlink" title="元组结构体"></a>元组结构体</h5><p>可以使用一种类似元组的方式定义结构体，这种结构体也被称作元组结构体。元组结构体同样拥有表明自身含义的名称，但无需在声明时对其字段进行命名，只标注类型即可。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Color</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span>(<span class="built_in">i32</span>, <span class="built_in">i32</span>, <span class="built_in">i32</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> black = Color(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">let</span> origin = Point(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><p>这里的 black 和 origin 是不同的类型，因为它们两个分别是不同元组结构体的实例。<br><strong>每一个结构体都拥有自己的类型</strong>。</p><h4 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h4><p>使用 cargo 命令创建一个名为 rectangles 的项目：<br><code>cargo new rectangles</code><br>这个程序会接收以像素为单位的宽度和高度作为输入，并计算出对应的长方形面积。</p><p>编辑项目中的 <code>src/main.rs</code> 源代码文件：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> width1 = <span class="number">30</span>;</span><br><span class="line">    <span class="keyword">let</span> height1 = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(width1, height1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(width: <span class="built_in">u32</span>, height: <span class="built_in">u32</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    width * height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>运行 <code>cargo run</code> 命令查看输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 2.53s</span><br><span class="line">     Running `target/debug/rectangle`</span><br><span class="line">The area of the rectangle is 1500</span><br></pre></td></tr></table></figure></p><p><code>area</code> 函数用来计算长方形的面积，接收宽和高两个参数。这两个参数是相互关联的，但程序中没有任何地方可以体现这一点。将宽和高放在一起能够使代码更加易懂和易于维护。</p><p><strong>使用元组关联长方形的宽和高</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = (<span class="number">30</span>, <span class="number">50</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(rect1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(dimensions: (<span class="built_in">u32</span>, <span class="built_in">u32</span>)) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    dimensions.<span class="number">0</span> * dimensions.<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，元组使输入的参数结构化了，现在只需要传递一个参数就可以调用函数 <code>area</code>。<br>但元组不会给出自身元素的名称，只能通过索引访问。这使得程序变得难以阅读。<br>比如当需要将该长方形绘制到屏幕上时，混淆宽度和高度就容易出现问题。</p><p><strong>使用结构体增加有意义的描述信息</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, area(&amp;rect1));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(rectangle: &amp;Rectangle) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">    rectangle.width * rectangle.height</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Rectangle 结构体表明了宽度和高度是相互关联的两个值，并为这些值提供了描述性的名字。因此代码看起来会更加清晰。</p><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><p>方法与函数十分相似，它们都使用 <code>fn</code> 关键字及一个名称进行声明；它们都可以拥有参数和返回值；它们都包含了一段在调用时执行的代码。<br>但<strong>方法总是被定义在某个结构体（或者枚举类型、trait 对象）的上下文中，且它们的第一个参数都是 <code>self</code>，用于指代调用该方法的结构体实例</strong>。</p><p>将 <code>area</code> 函数定义为 Rectangle 结构体中的方法：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The area of the rectangle is &#123;&#125;"</span>, rect1.area());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于方法的声明被放置在 <code>impl Rectangle</code> 块中，因此 Rust 能够将 <code>self</code> 的类型推导为 Rectangle，我们才可以在 <code>area</code> 的签名中使用 <code>&amp;self</code> 来替代 <code>&amp;Rectangle</code>。<br>使用方法替代函数不仅能够避免在每个方法的签名中重复编写 self 的类型，还有助于程序员组织代码的结构。可以将某个类型的实例需要的功能放置在同一个 impl 块中，避免用户在代码库中盲目地搜索它们。</p><p>添加 <code>can_hold</code> 方法检测当前的 Rectangle 实例能否完整地包含传入的另一个 Rectangle 实例：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u32</span>,</span><br><span class="line">    height: <span class="built_in">u32</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u32</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width * <span class="keyword">self</span>.height</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_hold</span></span>(&amp;<span class="keyword">self</span>, other: &amp;Rectangle) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">self</span>.width &gt; other.width &amp;&amp; <span class="keyword">self</span>.height &gt; other.height</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> rect1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">30</span>,</span><br><span class="line">        height: <span class="number">50</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect2 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">10</span>,</span><br><span class="line">        height: <span class="number">40</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> rect3 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">60</span>,</span><br><span class="line">        height: <span class="number">45</span>,</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"Can rect1 hold rect2? &#123;&#125;"</span>, rect1.can_hold(&amp;rect2));</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"Can rect1 hold rect3? &#123;&#125;"</span>, rect1.can_hold(&amp;rect3));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="关联函数"><a href="#关联函数" class="headerlink" title="关联函数"></a>关联函数</h5><p>除了方法，impl 块还允许我们定义不用接收 self 作为参数的函数。这类函数与结构体（而不是实例）相互关联，因此也被称为关联函数。<br>它们不会作用于某个具体的结构体实例。<br>之前用到的 <code>String::from</code> 就是关联函数的一种。</p><p>关联函数常被用作构造器来返回一个结构体的新实例。例如可以编写一个 <code>square</code> 关联函数，只接收一个参数，该参数同时用作宽度与高度来构造正方形实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">square</span></span>(size: <span class="built_in">u32</span>) -&gt; Rectangle &#123;</span><br><span class="line">        Rectangle &#123; width: size, height: size &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就可以使用 <code>let sq = Rectangle::square(3);</code> 类似的语法来创建正方形实例。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><strong>结构体可以让我们基于特定领域的规则创建有意义的自定义类型</strong>。<br>通过使用结构体，可以将相互关联的数据组合起来，并为每条数据赋予有含义的名称，从而使代码更加清晰。<br>方法可以让我们为结构体实例指定特殊的行为，而关联函数则可以将那些不需要实例的特定功能放置到结构体的命名空间中。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;结构（Struct）是一种自定义数据类型&lt;/strong&gt;。允许我们命名多个相关的值并将它们组成一个有机的结合体。&lt;/p&gt;
&lt;h4 id=&quot;定义与实例化&quot;&gt;&lt;a href=&quot;#定义与实例化&quot; class=&quot;headerlink&quot; title=&quot;定义与实例化&quot;
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Struct" scheme="https://rollingstarky.github.io/tags/Struct/"/>
    
      <category term="Method" scheme="https://rollingstarky.github.io/tags/Method/"/>
    
  </entry>
  
  <entry>
    <title>Vim 配置光标形状和颜色（Windows Terminal、xterm）</title>
    <link href="https://rollingstarky.github.io/2021/06/08/change-vim-cursor-shape-and-color-in-xterm-or-windows-terminal/"/>
    <id>https://rollingstarky.github.io/2021/06/08/change-vim-cursor-shape-and-color-in-xterm-or-windows-terminal/</id>
    <published>2021-06-07T16:00:00.000Z</published>
    <updated>2021-06-08T13:15:37.593Z</updated>
    
    <content type="html"><![CDATA[<p>Windows Terminal 里的 Vim 设置了浅的配色，刚好光标默认是白色的竖线，不容易看出来。很有点费眼睛。</p><p>想把光标改成其他颜色的方块样式。因为不是 gvim，<code>guicursor</code> 之类的配置不起作用。<br>上网查了些资料，测试如下配置可以正常生效（貌似这个 Terminal 是属于 <code>xterm</code> 那一类）：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Set cursor shape and color</span></span><br><span class="line"><span class="keyword">if</span> &amp;term =~ <span class="string">"xterm"</span></span><br><span class="line">    <span class="comment">" INSERT mode</span></span><br><span class="line">    <span class="keyword">let</span> &amp;t_SI = <span class="string">"\&lt;Esc&gt;[6 q"</span> . <span class="string">"\&lt;Esc&gt;]12;blue\x7"</span></span><br><span class="line">    <span class="comment">" REPLACE mode</span></span><br><span class="line">    <span class="keyword">let</span> &amp;t_SR = <span class="string">"\&lt;Esc&gt;[3 q"</span> . <span class="string">"\&lt;Esc&gt;]12;black\x7"</span></span><br><span class="line">    <span class="comment">" NORMAL mode</span></span><br><span class="line">    <span class="keyword">let</span> &amp;t_EI = <span class="string">"\&lt;Esc&gt;[2 q"</span> . <span class="string">"\&lt;Esc&gt;]12;green\x7"</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"><span class="comment">" 1 -&gt; blinking block  闪烁的方块</span></span><br><span class="line"><span class="comment">" 2 -&gt; solid block  不闪烁的方块</span></span><br><span class="line"><span class="comment">" 3 -&gt; blinking underscore  闪烁的下划线</span></span><br><span class="line"><span class="comment">" 4 -&gt; solid underscore  不闪烁的下划线</span></span><br><span class="line"><span class="comment">" 5 -&gt; blinking vertical bar  闪烁的竖线</span></span><br><span class="line"><span class="comment">" 6 -&gt; solid vertical bar  不闪烁的竖线</span></span><br></pre></td></tr></table></figure></p><p>其中各配置项的含义如下：</p><ul><li><code>&amp;t_SI</code> 表示插入模式</li><li><code>&amp;t_SR</code> 表示替换模式</li><li><code>&amp;t_EI</code> 表示 Normal 模式</li><li><code>.</code> 号左边的 <code>&quot;\&lt;Esc&gt;[6 q&quot;</code> 用来配置光标的形状。其中 <code>6</code> 的取值可以是 <code>1 - 6</code>，分别指代不同的光标样式（参考前面的注释）</li><li><code>.</code> 号右边的 <code>&quot;\&lt;Esc&gt;]12;blue\x7&quot;</code> 用来配置光标颜色，其中的 <code>blue</code> 可以替换为其他颜色名词</li></ul><p>设置光标颜色时也可以使用 RGB 颜色，格式为 <code>rgb:RR/GG/BB</code>。比如纯白色的光标即为 <code>&quot;\&lt;Esc&gt;]12;rgb:FF/FF/FF\x7&quot;</code>。</p><p>若只想设置光标形状，直接去掉 <code>.</code> 号以及右边的颜色配置部分即可。如 <code>let &amp;t_SR = &quot;\&lt;Esc&gt;[3 q&quot;</code>。<br>同理，只想修改颜色时也可以将 <code>.</code> 号左边的形状配置部分删掉。<br><code>.</code> 号在这里的作用其实是字符串拼接，方便区分形状配置部分和颜色配置部分而已。去掉 <code>.</code> 号直接将两部分配置写在一个字符串里也是可以的。<br>即 <code>let &amp;t_SR = &quot;\&lt;Esc&gt;[3 q&quot; . &quot;\&lt;Esc&gt;]12;black\x7&quot;</code> 等同于 <code>let &amp;t_SR = &quot;\&lt;Esc&gt;[3 q\&lt;Esc&gt;]12;black\x7&quot;</code></p><p>Normal 模式（绿色方块）：<img src="https://upload-images.jianshu.io/upload_images/6875152-ae01d0d4a9671096.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Normal"></p><p>插入模式（蓝色竖线）：<img src="https://upload-images.jianshu.io/upload_images/6875152-4fa8045616982bdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Insert"></p><p>替换模式（黑色下划线）：<img src="https://upload-images.jianshu.io/upload_images/6875152-426522041791876e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Replace"></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://stackoverflow.com/questions/14920634/cursor-color-in-xterm-change-accordingly-to-the-syntax-in-vim" target="_blank" rel="noopener">Cursor color in xterm; change accordingly to the syntax in vim</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Windows Terminal 里的 Vim 设置了浅的配色，刚好光标默认是白色的竖线，不容易看出来。很有点费眼睛。&lt;/p&gt;
&lt;p&gt;想把光标改成其他颜色的方块样式。因为不是 gvim，&lt;code&gt;guicursor&lt;/code&gt; 之类的配置不起作用。&lt;br&gt;上网查了些资料
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Tools" scheme="https://rollingstarky.github.io/tags/Tools/"/>
    
      <category term="Tricks" scheme="https://rollingstarky.github.io/tags/Tricks/"/>
    
      <category term="Vim" scheme="https://rollingstarky.github.io/tags/Vim/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Xterm" scheme="https://rollingstarky.github.io/tags/Xterm/"/>
    
      <category term="Terminal" scheme="https://rollingstarky.github.io/tags/Terminal/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——所有权与 Move 机制</title>
    <link href="https://rollingstarky.github.io/2021/06/07/the-rust-programming-language-reading-notes-ownership-and-move/"/>
    <id>https://rollingstarky.github.io/2021/06/07/the-rust-programming-language-reading-notes-ownership-and-move/</id>
    <published>2021-06-06T16:00:00.000Z</published>
    <updated>2021-06-07T15:16:34.071Z</updated>
    
    <content type="html"><![CDATA[<ul><li>所有权概念是 Rust 语言的核心功能</li><li>Rust 没有垃圾回收（GC）机制</li><li>Rust 通过所有权和相关工具保障内存安全</li></ul><p>所有语言都需要管理自己在运行时使用的计算机内存空间。<br>使用垃圾回收机制的语言（Java、Python）会<strong>在运行时定期检查并回收</strong>没有被继续使用的内存；另外一些语言（C、C++）则需要<strong>程序员手动地分配和释放</strong>内存。</p><p>Rust 采用第三种方式：它使用包含特定规则的所有权系统来管理内存。这套规则允许<strong>编译器在编译过程中执行检查工作</strong>，不会产生任何的运行时开销。</p><h4 id="栈与堆"><a href="#栈与堆" class="headerlink" title="栈与堆"></a>栈与堆</h4><p>栈和堆都是代码在运行时可以使用的内存空间。<br><strong>所有存储在栈中的数据必须拥有一个已知且固定的大小。在编译期无法确定大小的数据只能存放在堆中</strong>。</p><p>堆空间的管理较为松散。当希望将数据放入堆中时，可以请求特定大小的空间，操作系统会根据请求在堆中找到一块足够大的可用空间，并把指向这块空间地址的指针返回给我们。这个过程称为分配。</p><p>由于指针（内存地址）的大小是固定的且可以在编译期确定，因此可以将指针存放在栈中。通过指针指向的地址访问指针所指向的具体数据。</p><p>由于多了指针跳转的环节，<strong>访问堆上的数据要慢于访问栈上的数据</strong>。许多系统编程语言都需要程序员去记录代码中分配的堆空间，最小化堆上的冗余，并及时清理无用数据以避免耗尽内存空间。所有权的概念就是为了将上述问题交给 Rust 处理，减轻程序员的这部分心智负担。</p><h4 id="所有权规则"><a href="#所有权规则" class="headerlink" title="所有权规则"></a>所有权规则</h4><ul><li>Rust 中的每一个值都有一个对应的变量作为它的拥有者</li><li>在同一时间内，值有且只有一个拥有者</li><li>当所有者离开自己的作用域时，它拥有的值就会被释放掉</li></ul><h4 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h4><p><strong>作用域是一个对象在程序中有效的范围</strong>。</p><p>如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;                       <span class="comment">// 变量 s 还未声明，因此在这里不可用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="string">"hello"</span>;    <span class="comment">// 从这里开始变量 s 变得可用</span></span><br><span class="line">    <span class="comment">// 执行与 s 相关的操作</span></span><br><span class="line">&#125;                       <span class="comment">// 作用域到这里结束，变量 s 不再可用</span></span><br></pre></td></tr></table></figure></p><ul><li>变量在进入作用域后变得有效</li><li>变量会保持自己的有效性直到离开自己的作用域</li></ul><p>字符串字面量（如 <code>let s = &quot;hello&quot;</code>）属于被<strong>硬编码进程序</strong>的字符串值。很方便，但并不适用于所有场景。<br>一是因为<strong>字符串字面量是不可变的</strong>，二是因为并不是所有字符串的值都能在编写代码时确定。<br>比如需要获取用户的输入并保存。</p><p>Rust 提供了第二种字符串类型 String。<strong>String 会在堆上分配存储空间</strong>，因此能够处理未知大小的文本。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line">s.push_str(<span class="string">", world!"</span>);    <span class="comment">// push_str() 函数向 String 空间的尾部添加了一段字符串字面量</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, s);    <span class="comment">// 这里会输出完整的 hello, world!</span></span><br></pre></td></tr></table></figure></p><p>对于字符串字面量而言，由于在编译时就知道其内容，这部分硬编码的文本被直接嵌入到了可执行文件中。这也是访问字符串字面量异常高效的原因。<br>对于 String 类型而言，为了支持一种可变的、可增长的类型，需要在堆上分配一块在编译时未知大小的内存来存放数据。<br><strong>当使用完 String 时，则需要通过某种方式来将这些内存归还给操作系统</strong>。</p><p>对于拥有 GC 机制的语言，GC 会替代程序员记录并清理那些不再使用的内存。而对于没有 GC 的语言，识别不再使用的内存并调用代码显式释放的工作就需要程序员来完成。<br>假如忘记释放内存，就会造成内存泄漏；假如过早地释放内存，就会产生一个非法变量；假如重复释放同一块内存，就会产生无法预知的后果。</p><p>Rust 提供了另外一套解决方案：<strong>内存会在拥有它的变量离开作用域后自动地进行释放</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;                                     <span class="comment">// 变量 s 还未声明，因此在这里不可用</span></span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);    <span class="comment">// 从这里开始变量 s 变得可用</span></span><br><span class="line">    <span class="comment">// 执行与 s 相关的操作</span></span><br><span class="line">&#125;                                     <span class="comment">// 作用域到这里结束，变量 s 失效</span></span><br></pre></td></tr></table></figure></p><p>Rust 会在作用域结束的地方（即 <code>}</code> 处）自动回收分配给变量 s 的内存。</p><h4 id="内存与分配"><a href="#内存与分配" class="headerlink" title="内存与分配"></a>内存与分配</h4><p>对于整数类型的数据：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br></pre></td></tr></table></figure></p><p>上述代码将整数值 5 绑定给变量 x，再创建一个 x 值的拷贝，绑定给变量 y。由于整数是已知固定大小的简单值，两个值 5 会同时被推入栈中。</p><p>对于 String 类型的数据：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1;</span><br></pre></td></tr></table></figure></p><p>类似的代码，运行方式却并不一致。</p><p>String 的内存布局如下图：<img src="https://upload-images.jianshu.io/upload_images/6875152-ecb048bdb6e79553.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="String"></p><p>对于绑定给变量 s1 的 String 来说，该字符串的文本内容（<code>hello</code>）保存在了堆上，同时在栈中保存着一个指向字符串内容的指针、一个长度和一个容量信息。</p><p>当将 s1 赋值给 s2 时，便复制了一次 String 的数据。这意味着我们复制了它存储在栈上的指针、长度和容量字段，而指针指向的堆上的数据并没有被复制。</p><p>变量 s1 和 s2 的内存布局如下图：<img src="https://upload-images.jianshu.io/upload_images/6875152-70f122622d77bade.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="s1 &amp; s2"></p><p>前面提到过，当一个变量离开当前的作用域时，Rust 会自动将变量使用的堆内存释放和回收。但若是有两个指针指向了同一个地址，就会导致如 s2 和 s1 离开自己的作用域时，Rust 会尝试重复释放相同的内存，进而有可能导致正在使用的数据发生损坏。<br>为了确保内存安全，同时也避免复制分配的内存，Rust 在上述场景下会简单的将 s1 废弃。因此也就不需要在 s1 离开作用域后清理任何东西。这一行为即为 <strong>Move</strong>。</p><p>试图在 s2 创建完毕后访问 s1（如下所示）会导致编译错误。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> s2 = s1;  <span class="comment">// 变量 s1 在这里被废弃</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;, world"</span>, s1);  <span class="comment">// 错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Rust 会报出 <strong>borrow of moved value: <code>s1</code></strong> 错误。</p><p><strong>Rust 永远不会自动创建数据的深度拷贝</strong>。</p><p>对于<strong>栈上数据的复制</strong>，比如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> y = x;</span><br><span class="line"></span><br><span class="line"><span class="built_in">println!</span>(<span class="string">"x = &#123;&#125;, y = &#123;&#125;"</span>, x, y);</span><br></pre></td></tr></table></figure></p><p>上面的代码是完全合法的。因为整型的数据可以在编译时确定自己的大小，能够将数据完整地存储在栈中。对于这些类型而言，深度拷贝与浅度拷贝没有任何区别。</p><h4 id="所有权与函数"><a href="#所有权与函数" class="headerlink" title="所有权与函数"></a>所有权与函数</h4><p><strong>将值传递给函数在语义上类似于对变量进行赋值。将变量传递给函数将会触发移动或复制</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">//变量 s 进入作用域</span></span><br><span class="line">    takes_ownership(s); <span class="comment">// s 的值被移动进了函数</span></span><br><span class="line">                        <span class="comment">// 变量 s 从这里开始不再有效</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>; <span class="comment">// 变量 x 进入作用域</span></span><br><span class="line">    makes_copy(x); <span class="comment">// 变量 x 被传递进了函数</span></span><br><span class="line">                   <span class="comment">// 但 i32 类型不受 Move 机制影响，因此这里 x 依旧可用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_ownership</span></span>(some_string: <span class="built_in">String</span>) &#123;</span><br><span class="line">    <span class="comment">// some_string 进入作用域</span></span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, some_string);</span><br><span class="line">&#125; <span class="comment">// some_string 离开作用域，占用的内存被释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">makes_copy</span></span>(some_integer: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, some_integer);</span><br><span class="line">&#125; <span class="comment">// some_integer 离开作用域，没有特别的事情发生</span></span><br></pre></td></tr></table></figure><p>在上述代码中，尝试在调用 <code>takes_ownership</code> 后使用变量 s 会导致编译错误。</p><p><strong>函数在返回值的过程中也会发生所有权的转移</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = gives_ownership(); <span class="comment">// gives_ownership 将它的返回值移动至变量 s1 中</span></span><br><span class="line">    <span class="keyword">let</span> s2 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">// 变量 s2 进入作用域</span></span><br><span class="line">    <span class="keyword">let</span> s3 = takes_and_gives_back(s2); <span class="comment">// s2 被移动进函数 takes_and_gives_back，而这个函数的返回值又被移动到了变量 s3 上</span></span><br><span class="line">&#125; <span class="comment">// s3 和 s1 在这里离开作用域并被销毁，而 s2 已经移动了，因此不会发生任何事情</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">gives_ownership</span></span>() -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> some_string = <span class="built_in">String</span>::from(<span class="string">"hello"</span>); <span class="comment">//  some_string 进入作用域</span></span><br><span class="line">    some_string <span class="comment">// some_string 作为返回值移动至调用方</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// takes_and_gives_back 将取得一个 String 的所有权并将它作为结果返回</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">takes_and_gives_back</span></span>(a_string: <span class="built_in">String</span>) -&gt; <span class="built_in">String</span> &#123;</span><br><span class="line">    a_string <span class="comment">// a_string 作为返回值移动至调用方</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量的所有权转移总是遵循相同的模式：<strong>将一个值赋值给另一个变量时就会转移所有权。当一个持有堆数据的变量离开作用域时，它的数据就会被清理回收，除非这些数据的所有权被移动到了另一个变量上</strong>。</p><h4 id="引用与借用"><a href="#引用与借用" class="headerlink" title="引用与借用"></a>引用与借用</h4><p>参考如下示例代码：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> (s2, len) = calculate_length(s1);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;"</span>, s2, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: <span class="built_in">String</span>) -&gt; (<span class="built_in">String</span>, <span class="built_in">usize</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> length = s.len();</span><br><span class="line">    (s, length)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>由于调用 <code>caculate_length</code> 会导致 String 移动到函数体内部，我们又需要在调用后继续使用该 String，因此不得不通过元组将 String 作为元素继续返回。</p><p>这种写法未免过于笨拙。在下面的代码中，新的 <code>calculate_length</code> 函数使用了 String 的引用作为参数而不会直接转移值的所有权。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s1 = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> len = calculate_length(&amp;s1);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The length of '&#123;&#125;' is &#123;&#125;"</span>, s1, len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">calculate_length</span></span>(s: &amp;<span class="built_in">String</span>) -&gt; <span class="built_in">usize</span> &#123;</span><br><span class="line">    s.len()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在新的代码中，调用 <code>calculate_length</code> 函数时使用了 <code>&amp;s1</code> 作为参数，且在该函数的定义中使用 <code>&amp;String</code> 替代了 <code>String</code>。<br><strong>&amp; 代表引用，允许在不获取所有权的情况下使用值</strong>。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-98dfcbcd42cf0d54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="引用"></p><p><code>&amp;s1</code> 语法允许在不转移所有权的前提下创建一个指向 <code>s1</code> 值的引用。由于引用不持有值的所有权，当引用离开当前作用域时，它指向的值也不会被丢弃。<br>当一个函数使用引用而不是值本身作为参数时，我们就不需要为了归还所有权而特意去返回值。毕竟引用根本没有取得所有权。</p><p><strong>这种通过引用传递参数给函数的方法也称作借用</strong>。</p><h5 id="可变引用"><a href="#可变引用" class="headerlink" title="可变引用"></a>可变引用</h5><p>与变量类似，引用默认是不可变的。Rust 不允许修改引用指向的值（除非声明为 mut）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    change(&amp;<span class="keyword">mut</span> s);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"&#123;&#125;"</span>, s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">change</span></span>(some_string: &amp;<span class="keyword">mut</span> <span class="built_in">String</span>) &#123;</span><br><span class="line">    some_string.push_str(<span class="string">", world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>对于特定作用域中的特定数据，一次只能声明一个可变引用</strong>。<br>比如：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;<span class="keyword">mut</span> s;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, r1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就会出现 <strong>cannot borrow <code>s</code> as mutable more than once at a time</strong> 编译错误。这个规则使得引用的可变性只能以一种受到严格限制的方式使用。但另一方面，遵循这条限制性规则可以在编译时避免数据竞争。即<strong>不允许两个或两个以上的指针同时访问（且至少有一个指针会写入数据）同一空间</strong>。<br>数据竞争会导致未定义的行为，往往难以在运行时进行跟踪，也就使得出现的 bug 更加难以被诊断和修复。</p><p><strong>不能在拥有不可变引用的同时创建可变引用</strong>。编译时会报出 <strong>cannot borrow <code>s</code> as immutable because it is also borrowed as mutable</strong> 错误。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> s = <span class="built_in">String</span>::from(<span class="string">"hello"</span>);</span><br><span class="line">    <span class="keyword">let</span> r1 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> r2 = &amp;s; <span class="comment">// 没问题</span></span><br><span class="line">    <span class="keyword">let</span> r3 = &amp;<span class="keyword">mut</span> s; <span class="comment">// 错误</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>, r2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不能在拥有不可变引用的同时创建可变引用，但可以同时存在多个不可变引用。因为对数据的只读操作不会影响到其他读取数据的用户。</p><p><strong>Rust 编译器可以为用户提早（编译时而不是运行时）暴露那些潜在的 bug，并且明确指出出现问题的地方。用户就不再需要去追踪调试为何数据会在运行时发生了非预期的变化</strong>。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;所有权概念是 Rust 语言的核心功能&lt;/li&gt;
&lt;li&gt;Rust 没有垃圾回收（GC）机制&lt;/li&gt;
&lt;li&gt;Rust 通过所有权和相关工具保障内存安全&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所有语言都需要管理自己在运行时使用的计算机内存空间。&lt;br&gt;使用垃圾回收机制的
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Reference" scheme="https://rollingstarky.github.io/tags/Reference/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Ownership" scheme="https://rollingstarky.github.io/tags/Ownership/"/>
    
      <category term="Move" scheme="https://rollingstarky.github.io/tags/Move/"/>
    
      <category term="Pointer" scheme="https://rollingstarky.github.io/tags/Pointer/"/>
    
  </entry>
  
  <entry>
    <title>The Rust programming language 读书笔记——通用编程概念</title>
    <link href="https://rollingstarky.github.io/2021/06/04/the-rust-programming-language-reading-notes-common-concepts/"/>
    <id>https://rollingstarky.github.io/2021/06/04/the-rust-programming-language-reading-notes-common-concepts/</id>
    <published>2021-06-03T16:00:00.000Z</published>
    <updated>2021-06-04T12:03:49.088Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、变量"><a href="#一、变量" class="headerlink" title="一、变量"></a>一、变量</h4><p><strong>Rust 中的变量默认是不可变的</strong>。</p><p>可以通过如下代码测试变量的不可变性：</p><ul><li>使用 <code>cargo new variables</code> 命令创建新的 Rust 项目</li><li>进入新创建的 <code>variables</code> 目录，编辑 <code>src/main.rs</code> 源代码文件</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value is &#123;&#125;"</span>, x);</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value is &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行 <code>cargo run</code> 命令编译并执行 Rust 程序，出现如下报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `x`</span><br></pre></td></tr></table></figure></p><p>即 Rust 编译器不允许程序代码对不可变变量进行二次赋值。</p><p><strong>可以通过 <code>let mut</code> 关键字声明可变变量</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> x = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value is &#123;&#125;"</span>, x);</span><br><span class="line">    x = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value is &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.29s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value is 10</span><br><span class="line">The value is 20</span><br></pre></td></tr></table></figure><p><strong>PS</strong>：在使用重型数据结构时，适当地使用可变性去修改一个实例，可能比重新返回一个新分配的实例更有效率；而数据结构更为轻量时，采用偏函数式的风格创建新变量来进行赋值，可能会使代码更易于理解。</p><h5 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h5><ul><li>使用 <code>const</code> 而不是 <code>let</code> 关键字声明常量</li><li>声明常量时必须显式地<strong>标注值的类型</strong></li><li>常量可以被声明在任何作用域中。在一个值需要被不同部分的代码共同引用时很有用处</li><li>无法将一个函数的返回值或其他需要<strong>在运行时计算</strong>的值绑定到常量上</li></ul><p><code>const PI: f32 = 3.1415;</code></p><h5 id="Shadow"><a href="#Shadow" class="headerlink" title="Shadow"></a>Shadow</h5><p>Shadow 的意思是，<strong>一个新声明的变量可以覆盖掉旧的同名变量</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> x = x + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> x = x * <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value is &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    Finished dev [unoptimized + debuginfo] target(s) in 0.00s</span><br><span class="line">     Running `target/debug/variables`</span><br><span class="line">The value is 12</span><br></pre></td></tr></table></figure><p>Shadow 机制允许在复用变量名称的同时改变变量的类型。比如下面的代码就是合法的：<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spaces = <span class="string">"     "</span>;</span><br><span class="line"><span class="keyword">let</span> sapces = spaces.len();</span><br></pre></td></tr></table></figure></p><p>通过复用 <code>spaces</code> 这个名字，就不需要再声明诸如 <code>spaces_str</code> 和 <code>spaces_num</code> 之类的变量。</p><p>但如果使用 <code>mut</code> 关键字来模拟上述效果就会报错。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">mut</span> spaces = <span class="string">"     "</span>;</span><br><span class="line">spaces = spaces.len();</span><br></pre></td></tr></table></figure></p><p>因为编译器拒绝修改变量的类型，即便该变量是可变的。<br>Shadow 的机制在于使用 <code>let</code> 关键字<strong>重新声明</strong>了变量。</p><h4 id="二、数据类型"><a href="#二、数据类型" class="headerlink" title="二、数据类型"></a>二、数据类型</h4><p><strong>Rust 是一门静态类型语言，在编译过程中需要知道所有变量的具体类型。</strong></p><p>大部分情况下，编译器可以自动推导出变量类型。但比如需要将 String 类型转换为数值类型时，就必须显式地添加类型标注：<br><code>let guess: u32 = &quot;42&quot;.parse().expect(&quot;Not a number&quot;);</code></p><h5 id="标量（Scalar）类型"><a href="#标量（Scalar）类型" class="headerlink" title="标量（Scalar）类型"></a>标量（Scalar）类型</h5><p>标量类型是单个值类型的统称。Rust 内置 4 种基础的标量类型：整数、浮点数、布尔值和字符。</p><p><strong>整数类型</strong></p><table><thead><tr><th>长度</th><th>有符号</th><th>无符号</th></tr></thead><tbody><tr><td>8 bit</td><td>i8</td><td>u8</td></tr><tr><td>16 bit</td><td>i16</td><td>u16</td></tr><tr><td>32 bit</td><td>i32</td><td>u32</td></tr><tr><td>64 bit</td><td>i64</td><td>u64</td></tr></tbody></table><p>有无符号代表了一个整数类型是否包含负数。即有符号的整数总是需要一个 bit 表示当前数值是否为正。<br>对于一个 n bit 的有符号整数，其取值范围是 <code>- 2 ^ (n - 1)</code> 到 <code>2 ^ (n - 1) - 1</code>；长度为 n bit 的无符号整数，其取值范围则是 <code>0</code> 到 <code>2 ^ n - 1</code>。</p><p><strong>浮点数类型</strong><br>包含 <code>f32</code> 和 <code>f64</code> 两种类型。Rust 默认会将未标注类型的浮点数推导为 <code>f64</code>。整数会推导为 <code>i32</code>。</p><p><strong>字符类型</strong><br>Rust 中，char 类型使用单引号指定，字符串类型使用双引号指定。</p><p>char 类型占用 <strong>4 个字节</strong>，是一个 Unicode 标量值。<br><code>let smile = &#39;😀&#39;;</code></p><h5 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h5><p>复合类型可以将多个<strong>不同类型</strong>的值组合成一个类型。Rust 内置两种复合类型，元组和数组。</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><ul><li>元组每个位置上的值都有一个类型</li><li>元组拥有固定的长度。无法在声明结束后增加或减少其中的元素。</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了从元组中获取单个值，可以使用<strong>模式匹配</strong>来<strong>解构</strong>（拆包）元组。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> tup = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> (x, y, z) = tup;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还可以通过索引使用点号访问元组中的元素。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: (<span class="built_in">i32</span>, <span class="built_in">f64</span>, <span class="built_in">u8</span>) = (<span class="number">500</span>, <span class="number">6.4</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">let</span> five_hundred = x.<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> six_point_four = x.<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">let</span> one = x.<span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><ul><li>数组中的所有元素都必须是相同的类型</li><li>数组拥有固定的长度，一旦声明就无法更改大小</li></ul><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> months = [</span><br><span class="line">        <span class="string">"January"</span>,</span><br><span class="line">        <span class="string">"February"</span>,</span><br><span class="line">        <span class="string">"March"</span>,</span><br><span class="line">        <span class="string">"April"</span>,</span><br><span class="line">        <span class="string">"May"</span>,</span><br><span class="line">        <span class="string">"June"</span>,</span><br><span class="line">        <span class="string">"July"</span>,</span><br><span class="line">        <span class="string">"August"</span>,</span><br><span class="line">        <span class="string">"September"</span>,</span><br><span class="line">        <span class="string">"October"</span>,</span><br><span class="line">        <span class="string">"November"</span>,</span><br><span class="line">        <span class="string">"December"</span>,</span><br><span class="line">    ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数组的类型标注：<code>let a: [i32; 5] = [1, 2, 3, 4, 5];</code></p><p>初始化含有相同元素的数组：<code>let a = [3; 5];</code><br>等价于 <code>let a = [3, 3, 3, 3, 3];</code></p><p><strong>数组由一整块分配在栈上的内存组成，可以通过索引访问数组中的元素。</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> first = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">let</span> second = a[<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="三、函数"><a href="#三、函数" class="headerlink" title="三、函数"></a>三、函数</h4><p><strong>必须显式地声明每个参数（如果有）的数据类型</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    another_function(<span class="number">5</span>, <span class="number">6</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">another_function</span></span>(x: <span class="built_in">i32</span>, y: <span class="built_in">i32</span>) &#123;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Rust 是一门基于<strong>表达式</strong>的语言。它将<strong>语句（statement）</strong>与<strong>表达式（expression）</strong>区分为两个不同的概念。</p><p>如使用 <code>let</code> 关键字创建变量并绑定值时的指令就是一条语句：<br><code>let y = 6;</code><br><strong>语句不会返回值</strong>。</p><p>在 C 或 Ruby 语言里，赋值语句会返回所赋的值。因此可以使用 <code>x = y =6</code> 这样的语句，但 Rust 不支持这样的语法。</p><p><strong>表达式会计算出某个值作为结果返回</strong>。<br>如 <code>5 + 6</code> 就是表达式（返回 11），<code>let y = 6</code> 中的数字 6 也是表达式（返回 6 本身）。<br>表达式本身可以作为语句的一部分。<br>用来创建新作用域的<strong>大括号也是表达式</strong>。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">let</span> y = &#123;</span><br><span class="line">        <span class="keyword">let</span> x = <span class="number">3</span>;</span><br><span class="line">        x + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"The value of y is: &#123;&#125;"</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，<code>let y =</code> 后面大括号部分的内容就是一个表达式，它会将计算出的结果 4 作为返回值。该返回值接着通过赋值语句绑定给变量 <code>y</code>。<br>结尾处的 <code>x + 1</code> 并没有添加分号。若加上分号，则这段代码就变成了语句而不会返回任何值。</p><p><strong>函数可以向调用它的代码返回值。但需要在箭头后面声明值的类型</strong>。<br>可以使用 <code>return</code> 关键字指定一个值提前从函数中返回，但<strong>大多数函数都隐式地返回了最后的表达式</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x = plus_one(<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of x is: &#123;&#125;"</span>, x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">plus_one</span></span>(x: <span class="built_in">i32</span>) -&gt; <span class="built_in">i32</span> &#123;</span><br><span class="line">    x + <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码会输出 6。但如果在 <code>plus_one</code> 函数末尾的 <code>x + 1</code> 处加上分号，该表达式就会变成语句（不返回任何值），最终在编译时报出 <strong>mismatched types</strong> 错误。<br>原因是 <code>plus_one</code> 的声明中指定返回值类型为 <code>i32</code>，但由于语句不返回任何值，Rust 默认返回了一个空元组（<code>()</code>），导致实际的返回值类型与函数定义产生了冲突。</p><h4 id="四、控制流"><a href="#四、控制流" class="headerlink" title="四、控制流"></a>四、控制流</h4><h5 id="if-表达式"><a href="#if-表达式" class="headerlink" title="if 表达式"></a>if 表达式</h5><p><strong>if 表达式必须产生一个 bool 类型的值，否则会触发编译错误</strong>。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span> number &#123;</span><br><span class="line">        <span class="built_in">print!</span>(<span class="string">"number was three"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上面的代码中，if 表达式的计算结果为 3，而 Rust 期望获得一个 bool 值，因此编译时会爆出 mismatched types 错误。<br><strong>Rust 不会自动尝试将非布尔值转换为布尔类型</strong>。</p><p><strong>if 是一个表达式</strong>。可以在 <code>let</code> 语句右侧使用 if 表达式来完成赋值。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="number">6</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of number is &#123;&#125;"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整个 if 表达式的值取决于具体哪一个代码块得到了执行。因此，<strong>所有 if 分支可能返回的值都必须是同一种类型的</strong>。否则会触发编译错误。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> condition = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">let</span> number = <span class="keyword">if</span> condition &#123;</span><br><span class="line">        <span class="number">5</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="string">"six"</span>    <span class="comment">// 错误，类型不匹配</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The value of number is &#123;&#125;"</span>, number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h5><p>Rust 提供了 3 种循环：<code>loop</code>、<code>while</code>、<code>for</code>。</p><p><strong>从 loop 循环中返回值</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> counter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">loop</span> &#123;</span><br><span class="line">        counter += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> counter == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span> counter * <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">print!</span>(<span class="string">"The result is &#123;&#125;"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>break</code> 关键字中断循环并返回 <code>counter * 2</code>。</p><p><strong>while 循环</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> number = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> number != <span class="number">0</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line"></span><br><span class="line">        number = number - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>for 循环遍历集合中的元素</strong><br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> element <span class="keyword">in</span> a.iter() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"the value is: &#123;&#125;"</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for 循环重构前面使用 while 循环的代码<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> number <span class="keyword">in</span> (<span class="number">1</span>..<span class="number">4</span>).rev() &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">"&#123;&#125;!"</span>, number);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"LIFTOFF!!!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://doc.rust-lang.org/book/" target="_blank" rel="noopener">The Rust Programming Language</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、变量&quot;&gt;&lt;a href=&quot;#一、变量&quot; class=&quot;headerlink&quot; title=&quot;一、变量&quot;&gt;&lt;/a&gt;一、变量&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;Rust 中的变量默认是不可变的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;可以通过如下代码测试变量的不可变性：&lt;/
      
    
    </summary>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/categories/Rust/"/>
    
    
      <category term="Function" scheme="https://rollingstarky.github.io/tags/Function/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="Programming" scheme="https://rollingstarky.github.io/tags/Programming/"/>
    
      <category term="Basic" scheme="https://rollingstarky.github.io/tags/Basic/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="Variable" scheme="https://rollingstarky.github.io/tags/Variable/"/>
    
      <category term="Loop" scheme="https://rollingstarky.github.io/tags/Loop/"/>
    
  </entry>
  
  <entry>
    <title>Vim 8.1 懒人配置手册（包含 C/C++、Python、Rust 自动补全，基于 coc.nvim）</title>
    <link href="https://rollingstarky.github.io/2021/05/30/vim-configuration-with-coc-support-rust-c-python-complete/"/>
    <id>https://rollingstarky.github.io/2021/05/30/vim-configuration-with-coc-support-rust-c-python-complete/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2021-05-30T04:11:52.734Z</updated>
    
    <content type="html"><![CDATA[<p>先说点废话。</p><p>最近装了 WSL2，想着作为 Win10 内置的 Linux 系统，应该比一般的虚拟机要来得平滑一些。毕竟虚拟机还要装 Virtualbox，每次开机还要多点几下，还要等它启动。怕麻烦。。。</p><p>可能习惯问题，喜欢在 Linux 下配置开发环境（学习写代码）。总感觉 Windows 上略显磨叽了一些。也许我道行不够。碰到需要编译的东西，一套工具装起来过于繁琐，直接 <code>sudo apt install gcc</code> 不香吗。</p><p>可惜 WSL 没有桌面支持，装不上 Vscode。对于工具的选择，我的原则是简单够用就好，Vscode 即是目前我的最爱（非重度编码）。<br>开箱即用，功能满足基本需求。无非代码高亮、自动补全、查看定义、语法检查、代码格式化，再加个跳转。</p><p>于是决定在 Windows 系统上安装 Vscode，借助 Remote WSL 插件“远程”编码。可惜有 BUG，一直不能正常工作。Github 上提了 issue，没人理。无奈转向 Vim。</p><p>一开始用的补全插件是 YouCompleteMe，还要编译。虽然敲个命令就能自动执行，但光 Rust 支持就在本地给我搞了将近 1G 的文件，不太能忍。网上查了下，貌似已经很老的机制了。于是转向较新一点的 <a href="https://github.com/neoclide/coc.nvim" target="_blank" rel="noopener">coc.nvim</a>。据说支持各种 <strong>LSP</strong>（这个缩写。。。），也不懂，能用就行。</p><p>废话结束。</p><h4 id="一、效果截图"><a href="#一、效果截图" class="headerlink" title="一、效果截图"></a>一、效果截图</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bce3edb12a0512e4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Rust"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-2f240a19b109d409.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Python"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-95c01dea41212ed7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="C++"></p><h4 id="二、NERDTree-文件浏览器"><a href="#二、NERDTree-文件浏览器" class="headerlink" title="二、NERDTree 文件浏览器"></a>二、NERDTree 文件浏览器</h4><p><a href="https://www.vim.org/" target="_blank" rel="noopener">vim</a> 用的自带的 8.1 版本，有内置的插件管理。一般的插件安装流程是直接将插件源代码 clone 到 <code>~/.vim/pack/vendor/start</code> 路径下（没有就创建），再在 vim 中运行 <code>:helptags ~/.vim/pack/vendor/start/someplugin/doc</code> 命令生成帮助文档（这一步可选）。</p><p>vim 会自动检测已经下载的插件。<code>vendor</code> 路径下可以有 <code>start</code> 和 <code>opt</code> 两个目录，<code>start</code> 路径下的插件会在 vim 启动时自动加载，<code>opt</code> 路径下的插件则需要通过 <code>:packadd</code> 命令手动加载。</p><p><code>vendor</code> 也可以是其他名称，同位置下也可以有多个相同结构的目录，方便对不同类型的插件分别进行管理。<br>省事起见，这里所有的插件都放在 <code>~/.vim/pack/vendor/start</code> 下面。</p><p>NERDTree 文件浏览器插件安装：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.vim/pack/vendor/start</span><br><span class="line">git clone https://github.com/scrooloose/nerdtree</span><br></pre></td></tr></table></figure></p><p>在 <code>~/.vimrc</code> 文件中添加配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 进入 vim 时自动开启 NERDTree</span></span><br><span class="line"><span class="keyword">autocmd</span> VimEnter * NERDTree | <span class="keyword">wincmd</span> <span class="keyword">p</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 若关闭某个 buff 后 NERDTree 是仅剩的最后一个 buff，则自动关闭 NERDTree</span></span><br><span class="line"><span class="keyword">autocmd</span> BufEnter * <span class="keyword">if</span> <span class="built_in">tabpagenr</span>(<span class="string">'$'</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">winnr</span>(<span class="string">'$'</span>) == <span class="number">1</span> &amp;&amp; <span class="built_in">exists</span>(<span class="string">'b:NERDTree'</span>) &amp;&amp; <span class="variable">b:NERDTree</span>.isTabTree() | <span class="keyword">quit</span> | <span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" 使用 Ctrl+n 快捷键打开或关闭 NERDTree</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;C-n&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure></p><p>更多配置选项参考 <a href="https://vimawesome.com/plugin/nerdtree-red" target="_blank" rel="noopener">VimAwesome</a></p><h4 id="三、vim-airline-与配色"><a href="#三、vim-airline-与配色" class="headerlink" title="三、vim-airline 与配色"></a>三、vim-airline 与配色</h4><p>安装 vim-airline 状态栏美化插件：<br><code>git clone https://github.com/vim-airline/vim-airline</code></p><p>关于配色，萝卜青菜各有所爱。懒得去一个一个试。<br>准备了两套，vim-one 深色和 gruvbox 浅色。</p><p>vim-one 插件安装：<br><code>git clone https://github.com/rakr/vim-one</code></p><p>添加配置：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" 深色背景</span></span><br><span class="line"><span class="keyword">set</span> bg=dark</span><br><span class="line"></span><br><span class="line"><span class="comment">" 启用 one 配色</span></span><br><span class="line"><span class="keyword">colorscheme</span> one</span><br></pre></td></tr></table></figure></p><p>效果截图：<img src="https://upload-images.jianshu.io/upload_images/6875152-46db9d19ef58a4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="vim-one dark"></p><p>安装 gruvbox 插件：<br><code>git clone https://github.com/morhetz/gruvbox</code></p><p>修改配置文件（注释掉 <code>colorscheme one</code>）：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> bg=light</span><br><span class="line"><span class="comment">" colorscheme one</span></span><br><span class="line"><span class="keyword">autocmd</span> vimenter * ++nested <span class="keyword">colorscheme</span> gruvbox</span><br></pre></td></tr></table></figure></p><p>效果截图：<img src="https://upload-images.jianshu.io/upload_images/6875152-8affb9a9151b9816.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="gruvbox light"></p><p>更复杂的配置可自行在 <a href="https://vimawesome.com/" target="_blank" rel="noopener">VimAwesome</a> 搜索对应的插件，或者进入相应的 Github 主页查看。</p><h4 id="四、coco-nvim-代码补全与语法检查"><a href="#四、coco-nvim-代码补全与语法检查" class="headerlink" title="四、coco.nvim 代码补全与语法检查"></a>四、coco.nvim 代码补全与语法检查</h4><p>安装  <a href="https://nodejs.org/en/download/" target="_blank" rel="noopener">nodejs</a> &gt;= 10.12，官网上写的是通过 <code>curl -sL install-node.now.sh/lts | bash</code> 命令安装。我个人建议使用 <a href="https://github.com/nvm-sh/nvm" target="_blank" rel="noopener">nvm</a> 安装最新的 lts 版本。此处不赘述。</p><p>安装 coc.nvim 插件：<br><code>git clone https://github.com/neoclide/coc.nvim.git</code></p><p>为了得到某种编程语言的补全功能，还需要安装对应语言的 coc 扩展以及代码补全后端（LSP）。<br>比如 C/C++ 对应的 coc 扩展为 <a href="https://github.com/clangd/coc-clangd" target="_blank" rel="noopener">coc-clangd</a>，LSP 为 <code>clangd</code>。两个都需要。</p><p>安装 coc 扩展的方法非常简单，进入 vim 后运行 <code>:CocInstall extension_name</code> 命令即可。<br>比如使用 <code>:CocInstall coc-clangd</code> 命令安装 <code>coc-clangd</code> 扩展。coc 扩展我遇到的都比较小，安装非常迅速，也会单独开一个窗口显示进度信息。</p><p>coc 扩展安装完成后，打开对应的源代码文件，比如 <code>vim test.c</code>，vim 就会自动在本地环境中寻找对应的 LSP（C/C++ 语言是 <code>clangd</code>）。</p><p>若 <code>clangd</code> 此时并未安装，vim 就会提示你运行某个命令（在 vim 内部）自动安装该依赖。这里有个坑。<br>不知道是不是网络的问题，我复制运行了 vim 提供的命令，一直显示下载中，几个小时不见下载完成。。。</p><p>好在可以手动安装 <code>clangd</code>，退出 vim 直接运行 <code>sudo apt install clangd</code> 即可。<br>此时 coc.nvim 对于 C/C++ 的补全支持即安装配置完成。</p><h5 id="Rust-和-Python-语言支持"><a href="#Rust-和-Python-语言支持" class="headerlink" title="Rust 和 Python 语言支持"></a>Rust 和 Python 语言支持</h5><p>对于 Rust 语言，需要先安装 <a href="https://github.com/fannheyward/coc-rust-analyzer" target="_blank" rel="noopener">coc-rust-analyzer</a> 扩展：<br><code>:CocInstall coc-rust-analyzer</code><br>这一步简单迅速。</p><p>安装 <code>rust-src</code>：<code>rustup component add rust-src</code></p><p>接着还必须安装针对 Rust 的 LSP（<code>rust-analyzer</code>）。鉴于安装 <code>clangd</code> 时出现的曲折，我决定手动安装 <code>rust-analyzer</code>。诡异的事情发生了。手动安装的可执行程序不被 coc 识别。<br>无奈下尝试 vim 中的自动安装居然成功了。。。</p><p>方法是用 vim 新建任意一个 rust 源文件（<code>vim test.rs</code>），vim 会自动弹出提示，找不到 <code>rust-analyzer</code>，是否自动安装，选择 <code>Yes</code> 即可。这里的安装过程居然异乎寻常的快。<br>安装完成后可能不会立即生效，会尝试创建索引。多打开几个文件试试。</p><p>至于 Python，安装 <a href="https://github.com/fannheyward/coc-pyright" target="_blank" rel="noopener">coc-pyright</a>：<br><code>:CocInstall coc-pyright</code></p><p>印象中并没有做其他操作，对于 Python 的支持就自动生效了，也许是安装扩展的时候自动安装了对应的 LSP。</p><p>对于其他语言的支持，可参考 <a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions" target="_blank" rel="noopener">Using coc extensions</a>。</p><p>coc.nvim 示例配置（从官方 Github 上 copy 的，主要是一些快捷键的映射，可根据需求删减。没细看）：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">" Set internal encoding of vim, not needed on neovim, since coc.nvim using some</span></span><br><span class="line"><span class="comment">" unicode characters in the file autoload/float.vim</span></span><br><span class="line"><span class="keyword">set</span> encoding=utf-<span class="number">8</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" TextEdit might fail if hidden is not set.</span></span><br><span class="line"><span class="keyword">set</span> hidden</span><br><span class="line"></span><br><span class="line"><span class="comment">" Some servers have issues with backup files, see #649.</span></span><br><span class="line"><span class="keyword">set</span> nobackup</span><br><span class="line"><span class="keyword">set</span> nowritebackup</span><br><span class="line"></span><br><span class="line"><span class="comment">" Give more space for displaying messages.</span></span><br><span class="line"><span class="keyword">set</span> cmdheight=<span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable</span></span><br><span class="line"><span class="comment">" delays and poor user experience.</span></span><br><span class="line"><span class="keyword">set</span> updatetime=<span class="number">300</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Don't pass messages to |ins-completion-menu|.</span></span><br><span class="line"><span class="keyword">set</span> shortmess+=<span class="keyword">c</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Always show the signcolumn, otherwise it would shift the text each time</span></span><br><span class="line"><span class="comment">" diagnostics appear/become resolved.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">"nvim-0.5.0"</span>) || <span class="built_in">has</span>(<span class="string">"patch-8.1.1564"</span>)</span><br><span class="line">  <span class="comment">" Recently vim can merge signcolumn and number column into one</span></span><br><span class="line">  <span class="keyword">set</span> signcolumn=<span class="keyword">number</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">set</span> signcolumn=yes</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Use tab for trigger completion with characters ahead and navigate.</span></span><br><span class="line"><span class="comment">" <span class="doctag">NOTE:</span> Use command ':verbose imap &lt;tab&gt;' to make sure tab is not mapped by</span></span><br><span class="line"><span class="comment">" other plugin before putting this into your config.</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;TAB&gt;</span></span><br><span class="line">      \ <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-n&gt;"</span> :</span><br><span class="line">      \ <span class="symbol">&lt;SID&gt;</span>check_back_space() ? <span class="string">"\&lt;TAB&gt;"</span> :</span><br><span class="line">      \ coc#refresh()</span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;expr&gt;</span><span class="symbol">&lt;S-TAB&gt;</span> <span class="built_in">pumvisible</span>() ? <span class="string">"\&lt;C-p&gt;"</span> : <span class="string">"\&lt;C-h&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">check_back_space</span><span class="params">()</span> <span class="title">abort</span></span></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">col</span> = <span class="keyword">col</span>(<span class="string">'.'</span>) - <span class="number">1</span></span><br><span class="line">  <span class="keyword">return</span> !col || <span class="built_in">getline</span>(<span class="string">'.'</span>)[<span class="keyword">col</span> - <span class="number">1</span>]  =~# <span class="string">'\s'</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Use &lt;c-space&gt; to trigger completion.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">'nvim'</span>)</span><br><span class="line">  <span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;c-space&gt;</span> coc#refresh()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> &lt;<span class="keyword">c</span>-@&gt; coc#refresh()</span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Make &lt;CR&gt; auto-select the first completion item and notify coc.nvim to</span></span><br><span class="line"><span class="comment">" format on enter, &lt;cr&gt; could be remapped by other vim plugin</span></span><br><span class="line"><span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;cr&gt;</span> <span class="built_in">pumvisible</span>() ? coc#_select_confirm()</span><br><span class="line">                              \: <span class="string">"\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Use `[g` and `]g` to navigate diagnostics</span></span><br><span class="line"><span class="comment">" Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> [g <span class="symbol">&lt;Plug&gt;</span>(coc-diagnostic-<span class="keyword">prev</span>)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> ]g <span class="symbol">&lt;Plug&gt;</span>(coc-diagnostic-<span class="keyword">next</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" GoTo code navigation.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> gd <span class="symbol">&lt;Plug&gt;</span>(coc-definition)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> gy <span class="symbol">&lt;Plug&gt;</span>(coc-<span class="built_in">type</span>-definition)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> gi <span class="symbol">&lt;Plug&gt;</span>(coc-implementation)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="keyword">gr</span> <span class="symbol">&lt;Plug&gt;</span>(coc-references)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Use K to show documentation in preview window.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span> K :<span class="keyword">call</span> <span class="symbol">&lt;SID&gt;</span>show_documentation()<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>! <span class="title">s</span>:<span class="title">show_documentation</span><span class="params">()</span></span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">index</span>([<span class="string">'vim'</span>,<span class="string">'help'</span>], &amp;<span class="keyword">filetype</span>) &gt;= <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">execute</span> <span class="string">'h '</span>.<span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)</span><br><span class="line">  <span class="keyword">elseif</span> (coc#rpc#ready())</span><br><span class="line">    <span class="keyword">call</span> CocActionAsync(<span class="string">'doHover'</span>)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">execute</span> <span class="string">'!'</span> . &amp;keywordprg . <span class="string">" "</span> . <span class="built_in">expand</span>(<span class="string">'&lt;cword&gt;'</span>)</span><br><span class="line">  <span class="keyword">endif</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Highlight the symbol and its references when holding the cursor.</span></span><br><span class="line"><span class="keyword">autocmd</span> CursorHold * <span class="keyword">silent</span> <span class="keyword">call</span> CocActionAsync(<span class="string">'highlight'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Symbol renaming.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>rn <span class="symbol">&lt;Plug&gt;</span>(coc-<span class="built_in">rename</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Formatting selected code.</span></span><br><span class="line"><span class="keyword">xmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span>  <span class="symbol">&lt;Plug&gt;</span>(coc-format-selected)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">f</span>  <span class="symbol">&lt;Plug&gt;</span>(coc-format-selected)</span><br><span class="line"></span><br><span class="line"><span class="keyword">augroup</span> mygroup</span><br><span class="line">  autocmd!</span><br><span class="line">  <span class="comment">" Setup formatexpr specified filetype(s).</span></span><br><span class="line">  <span class="keyword">autocmd</span> FileType typescript,json <span class="keyword">setl</span> formatexpr=CocAction(<span class="string">'formatSelected'</span>)</span><br><span class="line">  <span class="comment">" Update signature help on jump placeholder.</span></span><br><span class="line">  <span class="keyword">autocmd</span> User CocJumpPlaceholder <span class="keyword">call</span> CocActionAsync(<span class="string">'showSignatureHelp'</span>)</span><br><span class="line"><span class="keyword">augroup</span> end</span><br><span class="line"></span><br><span class="line"><span class="comment">" Applying codeAction to the selected region.</span></span><br><span class="line"><span class="comment">" Example: `&lt;leader&gt;aap` for current paragraph</span></span><br><span class="line"><span class="keyword">xmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">a</span>  <span class="symbol">&lt;Plug&gt;</span>(coc-codeaction-selected)</span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span><span class="keyword">a</span>  <span class="symbol">&lt;Plug&gt;</span>(coc-codeaction-selected)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Remap keys for applying codeAction to the current buffer.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>ac  <span class="symbol">&lt;Plug&gt;</span>(coc-codeaction)</span><br><span class="line"><span class="comment">" Apply AutoFix to problem on the current line.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;leader&gt;</span>qf  <span class="symbol">&lt;Plug&gt;</span>(coc-<span class="keyword">fix</span>-current)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Map function and class text objects</span></span><br><span class="line"><span class="comment">" <span class="doctag">NOTE:</span> Requires 'textDocument.documentSymbol' support from the language server.</span></span><br><span class="line"><span class="keyword">xmap</span> <span class="keyword">if</span> <span class="symbol">&lt;Plug&gt;</span>(coc-funcobj-i)</span><br><span class="line"><span class="keyword">omap</span> <span class="keyword">if</span> <span class="symbol">&lt;Plug&gt;</span>(coc-funcobj-i)</span><br><span class="line"><span class="keyword">xmap</span> af <span class="symbol">&lt;Plug&gt;</span>(coc-funcobj-<span class="keyword">a</span>)</span><br><span class="line"><span class="keyword">omap</span> af <span class="symbol">&lt;Plug&gt;</span>(coc-funcobj-<span class="keyword">a</span>)</span><br><span class="line"><span class="keyword">xmap</span> ic <span class="symbol">&lt;Plug&gt;</span>(coc-classobj-i)</span><br><span class="line"><span class="keyword">omap</span> ic <span class="symbol">&lt;Plug&gt;</span>(coc-classobj-i)</span><br><span class="line"><span class="keyword">xmap</span> ac <span class="symbol">&lt;Plug&gt;</span>(coc-classobj-<span class="keyword">a</span>)</span><br><span class="line"><span class="keyword">omap</span> ac <span class="symbol">&lt;Plug&gt;</span>(coc-classobj-<span class="keyword">a</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Remap &lt;C-f&gt; and &lt;C-b&gt; for scroll float windows/popups.</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">has</span>(<span class="string">'nvim-0.4.0'</span>) || <span class="built_in">has</span>(<span class="string">'patch-8.2.0750'</span>)</span><br><span class="line">  <span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-f&gt;</span> coc#float#has_scroll() ? coc#float#scroll(<span class="number">1</span>) : <span class="string">"\&lt;C-f&gt;"</span></span><br><span class="line">  <span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-b&gt;</span> coc#float#has_scroll() ? coc#float#scroll(<span class="number">0</span>) : <span class="string">"\&lt;C-b&gt;"</span></span><br><span class="line">  <span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-f&gt;</span> coc#float#has_scroll() ? <span class="string">"\&lt;c-r&gt;=coc#float#scroll(1)\&lt;cr&gt;"</span> : <span class="string">"\&lt;Right&gt;"</span></span><br><span class="line">  <span class="keyword">inoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-b&gt;</span> coc#float#has_scroll() ? <span class="string">"\&lt;c-r&gt;=coc#float#scroll(0)\&lt;cr&gt;"</span> : <span class="string">"\&lt;Left&gt;"</span></span><br><span class="line">  <span class="keyword">vnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-f&gt;</span> coc#float#has_scroll() ? coc#float#scroll(<span class="number">1</span>) : <span class="string">"\&lt;C-f&gt;"</span></span><br><span class="line">  <span class="keyword">vnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span><span class="symbol">&lt;expr&gt;</span> <span class="symbol">&lt;C-b&gt;</span> coc#float#has_scroll() ? coc#float#scroll(<span class="number">0</span>) : <span class="string">"\&lt;C-b&gt;"</span></span><br><span class="line"><span class="keyword">endif</span></span><br><span class="line"></span><br><span class="line"><span class="comment">" Use CTRL-S for selections ranges.</span></span><br><span class="line"><span class="comment">" Requires 'textDocument/selectionRange' support of language server.</span></span><br><span class="line"><span class="keyword">nmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;C-s&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(coc-<span class="built_in">range</span>-select)</span><br><span class="line"><span class="keyword">xmap</span> <span class="symbol">&lt;silent&gt;</span> <span class="symbol">&lt;C-s&gt;</span> <span class="symbol">&lt;Plug&gt;</span>(coc-<span class="built_in">range</span>-select)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Add `:Format` command to format current buffer.</span></span><br><span class="line">command! -nargs=<span class="number">0</span> Format :<span class="keyword">call</span> CocAction(<span class="string">'format'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Add `:Fold` command to fold current buffer.</span></span><br><span class="line">command! -nargs=? Fold :<span class="keyword">call</span>     CocAction(<span class="string">'fold'</span>, <span class="symbol">&lt;f-args&gt;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Add `:OR` command for organize imports of the current buffer.</span></span><br><span class="line">command! -nargs=<span class="number">0</span> OR   :<span class="keyword">call</span>     CocAction(<span class="string">'runCommand'</span>, <span class="string">'editor.action.organizeImport'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">" Add (Neo)Vim's native statusline support.</span></span><br><span class="line"><span class="comment">" <span class="doctag">NOTE:</span> Please see `:h coc-status` for integrations with external plugins that</span></span><br><span class="line"><span class="comment">" provide custom statusline: lightline.vim, vim-airline.</span></span><br><span class="line"><span class="keyword">set</span> statusline^=%&#123;coc#status()&#125;%&#123;<span class="built_in">get</span>(<span class="variable">b:</span>,<span class="string">'coc_current_function'</span>,<span class="string">''</span>)&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">" Mappings for CoCList</span></span><br><span class="line"><span class="comment">" Show all diagnostics.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">a</span>  :<span class="symbol">&lt;C-u&gt;</span>CocList diagnostics<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">" Manage extensions.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">e</span>  :<span class="symbol">&lt;C-u&gt;</span>CocList extensions<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">" Show commands.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">c</span>  :<span class="symbol">&lt;C-u&gt;</span>CocList commands<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">" Find symbol of current document.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">o</span>  :<span class="symbol">&lt;C-u&gt;</span>CocList outline<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">" Search workspace symbols.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span>s  :<span class="symbol">&lt;C-u&gt;</span>CocList -I symbols<span class="symbol">&lt;cr&gt;</span></span><br><span class="line"><span class="comment">" Do default action for next item.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">j</span>  :<span class="symbol">&lt;C-u&gt;</span>CocNext<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">" Do default action for previous item.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">k</span>  :<span class="symbol">&lt;C-u&gt;</span>CocPrev<span class="symbol">&lt;CR&gt;</span></span><br><span class="line"><span class="comment">" Resume latest coc list.</span></span><br><span class="line"><span class="keyword">nnoremap</span> <span class="symbol">&lt;silent&gt;</span><span class="symbol">&lt;nowait&gt;</span> <span class="symbol">&lt;space&gt;</span><span class="keyword">p</span>  :<span class="symbol">&lt;C-u&gt;</span>CocListResume<span class="symbol">&lt;CR&gt;</span></span><br></pre></td></tr></table></figure></p><h4 id="五、彩蛋"><a href="#五、彩蛋" class="headerlink" title="五、彩蛋"></a>五、彩蛋</h4><h5 id="smile"><a href="#smile" class="headerlink" title="smile"></a>smile</h5><p>在 vim 中运行 <code>:smile</code></p><p>效果：<img src="https://upload-images.jianshu.io/upload_images/6875152-bda45aec4856c64d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=":smile"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">:smile</span><br><span class="line">                            oooo$$$$$$$$$$$$oooo</span><br><span class="line">                        oo$$$$$$$$$$$$$$$$$$$$$$$$o</span><br><span class="line">                     oo$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o         o$   $$ o$</span><br><span class="line">     o $ oo        o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$o       $$ $$ $$o$</span><br><span class="line">  oo $ $ &quot;$      o$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$o       $$$o$$o$</span><br><span class="line">  &quot;$$$$$$o$     o$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$o    $$$$$$$$</span><br><span class="line">    $$$$$$$    $$$$$$$$$$$      $$$$$$$$$$$      $$$$$$$$$$$$$$$$$$$$$$$</span><br><span class="line">    $$$$$$$$$$$$$$$$$$$$$$$    $$$$$$$$$$$$$    $$$$$$$$$$$$$$  &quot;&quot;&quot;$$$</span><br><span class="line">     &quot;$$$&quot;&quot;&quot;&quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     &quot;$$$</span><br><span class="line">      $$$   o$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     &quot;$$$o</span><br><span class="line">     o$$&quot;   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$       $$$o</span><br><span class="line">     $$$    $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot; &quot;$$$$$$ooooo$$$$o</span><br><span class="line">    o$$$oooo$$$$$  $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$   o$$$$$$$$$$$$$$$$$</span><br><span class="line">    $$$$$$$$&quot;$$$$   $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$     $$$$&quot;&quot;&quot;&quot;&quot;&quot;&quot;&quot;</span><br><span class="line">   &quot;&quot;&quot;&quot;       $$$$    &quot;$$$$$$$$$$$$$$$$$$$$$$$$$$$$&quot;      o$$$</span><br><span class="line">              &quot;$$$o     &quot;&quot;&quot;$$$$$$$$$$$$$$$$$$&quot;$$&quot;         $$$</span><br><span class="line">                $$$o          &quot;$$&quot;&quot;$$$$$$&quot;&quot;&quot;&quot;           o$$$</span><br><span class="line">                 $$$$o                                o$$$&quot;</span><br><span class="line">                  &quot;$$$$o      o$$$$$$o&quot;$$$$o        o$$$$</span><br><span class="line">                    &quot;$$$$$oo     &quot;&quot;$$$$o$$$$$o   o$$$$&quot;&quot;</span><br><span class="line">                       &quot;&quot;$$$$$oooo  &quot;$$$o$$$$$$$$$&quot;&quot;&quot;</span><br><span class="line">                          &quot;&quot;$$$$$$$oo $$$$$$$$$$</span><br><span class="line">                                  &quot;&quot;&quot;&quot;$$$$$$$$$$$</span><br><span class="line">                                      $$$$$$$$$$$$</span><br><span class="line">                                       $$$$$$$$$$&quot;</span><br><span class="line">                                        &quot;$$$&quot;&quot;&quot;&quot;</span><br></pre></td></tr></table></figure><h5 id="Kill-Sheep-小游戏"><a href="#Kill-Sheep-小游戏" class="headerlink" title="Kill Sheep 小游戏"></a>Kill Sheep 小游戏</h5><p>针对 vim 8.2 版本，可在 Windows 系统中安装 <a href="https://www.vim.org/download.php" target="_blank" rel="noopener">gvim 8.2</a>。</p><p>进入 <code>C:\Users\xxx\vimfiles\pack\vendor\start</code> 路径下（没有就创建），clone 源代码：<br><code>git clone https://github.com/vim/killersheep.git</code></p><p>打开 gvim，最大化，运行 <code>:KillKillKill</code> 命令即可进入游戏。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-e6ba73150a202b42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="killer sheep"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先说点废话。&lt;/p&gt;
&lt;p&gt;最近装了 WSL2，想着作为 Win10 内置的 Linux 系统，应该比一般的虚拟机要来得平滑一些。毕竟虚拟机还要装 Virtualbox，每次开机还要多点几下，还要等它启动。怕麻烦。。。&lt;/p&gt;
&lt;p&gt;可能习惯问题，喜欢在 Linux 下配置
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Tools" scheme="https://rollingstarky.github.io/tags/Tools/"/>
    
      <category term="Vim" scheme="https://rollingstarky.github.io/tags/Vim/"/>
    
      <category term="Configuration" scheme="https://rollingstarky.github.io/tags/Configuration/"/>
    
      <category term="Editor" scheme="https://rollingstarky.github.io/tags/Editor/"/>
    
      <category term="Rust" scheme="https://rollingstarky.github.io/tags/Rust/"/>
    
      <category term="IDE" scheme="https://rollingstarky.github.io/tags/IDE/"/>
    
      <category term="Completer" scheme="https://rollingstarky.github.io/tags/Completer/"/>
    
  </entry>
  
  <entry>
    <title>Windows Terminal 美化（wsl2、zsh、天气、数字时钟、ASCII Logo、彩色动画）</title>
    <link href="https://rollingstarky.github.io/2021/05/26/windows-terminal-beautify-wsl2-weather-digital-clock-splash-animation/"/>
    <id>https://rollingstarky.github.io/2021/05/26/windows-terminal-beautify-wsl2-weather-digital-clock-splash-animation/</id>
    <published>2021-05-25T16:00:00.000Z</published>
    <updated>2021-05-26T12:33:32.776Z</updated>
    
    <content type="html"><![CDATA[<p>上次用 <strong>WSL</strong>（Windows Subsystem for Linux）要追溯到好几年前了。当时 WSL 刚出来不久，抱着尝鲜的态度试着装了，想着万一能用，就不用装虚拟机了。</p><p>结果遇到了 BUG，就再也没用过。最近才听说 WSL2 已经有了，类似虚拟机的机制，好用很多。再次装来试试，目前还没遇到啥问题。记录下初始的美化步骤。</p><h4 id="一、效果截图"><a href="#一、效果截图" class="headerlink" title="一、效果截图"></a>一、效果截图</h4><p><strong>天气、日历、数字时钟、Linux 发行版的 logo、系统信息</strong><br><img src="https://upload-images.jianshu.io/upload_images/6875152-94fa6accaa42f4b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weather-calendar-clock-logo-sysinfo"></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Weather report: Hangzhou                May 2021</span><br><span class="line">                                  Su Mo Tu We Th Fr Sa       ┌────────────────────────────┐</span><br><span class="line">    _`/&quot;&quot;.-.     Rain shower, mist                   1       │   ┏━┓┏━┓ ┏━┓┏━┓   ┏━┓┏┳┓   │</span><br><span class="line">     ,\_(   ).   21 °C             2  3  4  5  6  7  8       │   ┃┃┃┣━┓╹┃┃┃┣━┓   ┣━┛┃┃┃   │</span><br><span class="line">      /(___(__)  ↓ 15 km/h         9 10 11 12 13 14 15       │   ┗━┛┗━┛╹┗━┛┗━┛   ╹  ╹ ╹   │</span><br><span class="line">        ‘ ‘ ‘ ‘  3 km             16 17 18 19 20 21 22       └────────────────────────────┘</span><br><span class="line">       ‘ ‘ ‘ ‘   0.8 mm           23 24 25 26 27 28 29</span><br><span class="line">                                  30 31</span><br><span class="line"></span><br><span class="line">    _-`````-,           ,- &apos;- .       starky@xxxxxx</span><br><span class="line">  .&apos;   .- - |          | - -.  `.     ----------------</span><br><span class="line"> /.&apos;  /                     `.   \    OS: Ubuntu 20.04.2 LTS on Windows 10 x86_64</span><br><span class="line">:/   :      _...   ..._      ``   :   Kernel: 5.4.72-microsoft-standard-WSL2</span><br><span class="line">::   :     /._ .`:&apos;_.._\.    ||   :   Uptime: 38 mins</span><br><span class="line">::    `._ ./  ,`  :    \ . _.&apos;&apos;   .   Packages: 736 (dpkg)</span><br><span class="line">`:.      /   |  -.  \-. \_      /     Shell: zsh 5.8</span><br><span class="line">  \:._ _/  .&apos;   .@)  \@) ` `\ ,.&apos;     Terminal: /dev/pts/0</span><br><span class="line">     _/,--&apos;       .- .\,-.`--`.       CPU: Intel i7-10850H (12) @ 2.712GHz</span><br><span class="line">       ,&apos;/&apos;&apos;     (( \ `  )            Memory: 118MiB / 12466MiB (0%)</span><br><span class="line">        /&apos;/&apos;  \    `-&apos;  (             CPU Usage: 1%</span><br><span class="line">         &apos;/&apos;&apos;  `._,-----&apos;             Disk (/): 3.3G / 251G (2%)</span><br><span class="line">          &apos;&apos;/&apos;    .,---&apos;              Battery1: 100% [Full]</span><br><span class="line">           &apos;&apos;/&apos;      ;:               Local IP: xx.xx.xx.xx</span><br><span class="line">             &apos;&apos;/&apos;&apos;  &apos;&apos;/               Public IP: xx.xx.xx.xx</span><br><span class="line">               &apos;&apos;/&apos;&apos;/&apos;&apos;</span><br><span class="line">                 &apos;/&apos;/&apos;</span><br><span class="line">                  `;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GNU</span><br></pre></td></tr></table></figure><p><strong>启动动画</strong><br><img src="https://upload-images.jianshu.io/upload_images/6875152-0d4935f9cd7d1897.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="splash animation"></p><p><strong>动图（加载慢）</strong><br><img src="https://upload-images.jianshu.io/upload_images/6875152-f69345a2d6fabaef.gif?imageMogr2/auto-orient/strip" alt="pipes"></p><h4 id="二、安装-WSL2-和-Windows-Terminal"><a href="#二、安装-WSL2-和-Windows-Terminal" class="headerlink" title="二、安装 WSL2 和 Windows Terminal"></a>二、安装 WSL2 和 Windows Terminal</h4><p>参考微软<strong>官方</strong>文档 <a href="https://docs.microsoft.com/en-us/windows/wsl/install-win10" target="_blank" rel="noopener">Windows Subsystem for Linux Installation Guide for Windows 10</a></p><p>很详细，不用再看其他文章了。</p><h4 id="三、oh-my-zsh"><a href="#三、oh-my-zsh" class="headerlink" title="三、oh-my-zsh"></a>三、oh-my-zsh</h4><p>进入 wsl，安装 <strong>zsh</strong>：<br><code>sudo apt update</code><br><code>sudo apt install zsh -y</code></p><p>安装 <strong>oh-my-zsh</strong>：<code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code></p><p>安装 <strong>Powerline9k</strong> 主题：<code>git clone https://github.com/bhilburn/powerlevel9k.git ~/.oh-my-zsh/custom/themes/powerlevel9k</code></p><p>启用 Powerline9k 主题：编辑 <code>~/.zshrc</code> 配置文件，修改 <strong>ZSH_THEME</strong> 项的内容为 <code>ZSH_THEME=&quot;powerlevel9k/powerlevel9k&quot;</code></p><p>安装字体：访问 <a href="https://github.com/ryanoasis/nerd-fonts/releases" target="_blank" rel="noopener">nerd-fonts</a> 的 Github release 页，下载某种字体的压缩包（如 <code>JetBrainsMono.zip</code>），解压后在 Windows 系统上安装字体文件（有些时候可能需要使用管理员权限安装）</p><p>修改 Windows Terminal 的默认字体：<img src="https://upload-images.jianshu.io/upload_images/6875152-a84f2b661b58c39a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="fonts"></p><h4 id="四、oh-my-zh-插件"><a href="#四、oh-my-zh-插件" class="headerlink" title="四、oh-my-zh 插件"></a>四、oh-my-zh 插件</h4><p>安装 <strong>zsh-autosuggestions</strong>：<br><code>git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions</code></p><p>安装 <strong>zsh-syntax-highlighting</strong>：<br><code>git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting</code></p><p>启用插件（包含默认插件）：修改 <code>~/.zshrc</code> 配置文件的 <code>plugins</code> 项，内容如下（可按需添加或删减）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">plugins=(</span><br><span class="line">  cargo</span><br><span class="line">  command-not-found</span><br><span class="line">  docker</span><br><span class="line">  git</span><br><span class="line">  golang</span><br><span class="line">  npm</span><br><span class="line">  nvm</span><br><span class="line">  rust</span><br><span class="line">  sudo</span><br><span class="line">  systemd</span><br><span class="line">  web-search</span><br><span class="line">  zsh-autosuggestions</span><br><span class="line">  zsh-syntax-highlighting</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-30b1da8f2fd403e7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zsh-autosuggestions"><br>插件安装完成后，如上图中的情况，直接按键盘上的右方向键即可自动补全命令。</p><h4 id="五、neofetch-获取-Linux-发行版-ASCII-logo-和系统信息"><a href="#五、neofetch-获取-Linux-发行版-ASCII-logo-和系统信息" class="headerlink" title="五、neofetch 获取 Linux 发行版 ASCII logo 和系统信息"></a>五、neofetch 获取 Linux 发行版 ASCII logo 和系统信息</h4><p>安装 neofetch：<code>sudo apt install neofetch</code></p><p>效果如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ neofetch --ascii_distro raspbian        </span><br><span class="line">  `.::///+:/-.        --///+//-:``    starky@xxxxxx</span><br><span class="line"> `+oooooooooooo:   `+oooooooooooo:    ----------------</span><br><span class="line">  /oooo++//ooooo:  ooooo+//+ooooo.    OS: Ubuntu 20.04.2 LTS on Windows 10 x86_64</span><br><span class="line">  `+ooooooo:-:oo-  +o+::/ooooooo:     Kernel: 5.4.72-microsoft-standard-WSL2</span><br><span class="line">   `:oooooooo+``    `.oooooooo+-      Uptime: 11 mins</span><br><span class="line">     `:++ooo/.        :+ooo+/.`       Packages: 736 (dpkg)</span><br><span class="line">        ...`  `.----.` ``..           Shell: zsh 5.8</span><br><span class="line">     .::::-``:::::::::.`-:::-`        Terminal: /dev/pts/0</span><br><span class="line">    -:::-`   .:::::::-`  `-:::-       CPU: Intel i7-10850H (12) @ 2.712GHz</span><br><span class="line">   `::.  `.--.`  `` `.---.``.::`      Memory: 107MiB / 12466MiB (0%)</span><br><span class="line">       .::::::::`  -::::::::` `       CPU Usage: 0%</span><br><span class="line"> .::` .:::::::::- `::::::::::``::.    Disk (/): 3.3G / 251G (2%)</span><br><span class="line">-:::` ::::::::::.  ::::::::::.`:::-   Battery1: 100% [Full]</span><br><span class="line">::::  -::::::::.   `-::::::::  ::::   Local IP: xx.xx.xx.xx</span><br><span class="line">-::-   .-:::-.``....``.-::-.   -::-   Public IP: xx.xx.xx.xx</span><br><span class="line"> .. ``       .::::::::.     `..`..</span><br><span class="line">   -:::-`   -::::::::::`  .:::::`</span><br><span class="line">   :::::::` -::::::::::` :::::::.</span><br><span class="line">   .:::::::  -::::::::. ::::::::</span><br><span class="line">    `-:::::`   ..--.`   ::::::.</span><br><span class="line">      `...`  `...--..`  `...`</span><br><span class="line">            .::::::::::</span><br><span class="line">             `.-::::-`</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6c46aaa42e1aa0df.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="neofetch --ascii_distro raspbian"></p><p><code>neofetch</code> 默认会输出当前系统的 logo，这里写个脚本（<code>random_distro.sh</code>）随机获取某个 Linux 发行版的 logo。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># random_distro.sh</span></span><br><span class="line">distro_list=(<span class="string">'Alpine'</span> <span class="string">'Anarchy'</span> <span class="string">'Android'</span> <span class="string">'Antergos'</span> <span class="string">'antiX'</span> <span class="string">'AOSC'</span> <span class="string">'ArcoLinux'</span> <span class="string">'ArchBox'</span> <span class="string">'ARCHlabs'</span> <span class="string">'ArchStrike'</span> <span class="string">'XFerience'</span> <span class="string">'ArchMerge'</span> <span class="string">'Arch'</span> <span class="string">'Artix'</span> <span class="string">'Arya'</span> <span class="string">'Bedrock'</span> <span class="string">'BlackArch'</span> <span class="string">'BLAG'</span> <span class="string">'BlankOn'</span> <span class="string">'BlueLight'</span> <span class="string">'bonsai'</span> <span class="string">'BSD'</span> <span class="string">'BunsenLabs'</span> <span class="string">'Calculate'</span> <span class="string">'Carbs'</span> <span class="string">'CentOS'</span> <span class="string">'Chakra'</span> <span class="string">'Chapeau'</span> <span class="string">'Chrom'</span> <span class="string">'Cleanjaro'</span> <span class="string">'ClearOS'</span> <span class="string">'Clear_Linux'</span> <span class="string">'Clover'</span> <span class="string">'Condres'</span> <span class="string">'Container_Linux'</span> <span class="string">'CRUX'</span> <span class="string">'Debian'</span> <span class="string">'Deepin'</span> <span class="string">'DesaOS'</span> <span class="string">'Devuan'</span> <span class="string">'DracOS'</span> <span class="string">'DragonFly'</span> <span class="string">'Drauger'</span> <span class="string">'Elementary'</span> <span class="string">'EndeavourOS'</span> <span class="string">'Endless'</span> <span class="string">'Exherbo'</span> <span class="string">'Fedora'</span> <span class="string">'Feren'</span> <span class="string">'FreeBSD'</span> <span class="string">'FreeMiNT'</span> <span class="string">'Frugalware'</span> <span class="string">'Funtoo'</span> <span class="string">'GalliumOS'</span> <span class="string">'Gentoo'</span> <span class="string">'Pentoo'</span> <span class="string">'GNU'</span> <span class="string">'GoboLinux'</span> <span class="string">'Grombyang'</span> <span class="string">'Guix'</span> <span class="string">'Haiku'</span> <span class="string">'Huayra'</span> <span class="string">'Hyperbola'</span> <span class="string">'janus'</span> <span class="string">'Kali'</span> <span class="string">'KaOS'</span> <span class="string">'KDE_neon'</span> <span class="string">'Kogaion'</span> <span class="string">'Korora'</span> <span class="string">'KSLinux'</span> <span class="string">'Kubuntu'</span> <span class="string">'LEDE'</span> <span class="string">'LFS'</span> <span class="string">'Linux_Lite'</span> <span class="string">'LMDE'</span> <span class="string">'Lubuntu'</span> <span class="string">'Lunar'</span> <span class="string">'macos'</span> <span class="string">'Mageia'</span> <span class="string">'Mandriva'</span> <span class="string">'Manjaro'</span> <span class="string">'Maui'</span> <span class="string">'Mer'</span> <span class="string">'Minix'</span> <span class="string">'LinuxMint'</span> <span class="string">'MX_Linux'</span> <span class="string">'Namib'</span> <span class="string">'Neptune'</span> <span class="string">'NetBSD'</span> <span class="string">'Netrunner'</span> <span class="string">'NixOS'</span> <span class="string">'Nurunner'</span> <span class="string">'NuTyX'</span> <span class="string">'OBRevenge'</span> <span class="string">'OpenBSD'</span> <span class="string">'OpenIndiana'</span> <span class="string">'OpenMandriva'</span> <span class="string">'OpenWrt'</span> <span class="string">'osmc'</span> <span class="string">'Oracle'</span> <span class="string">'Parabola'</span> <span class="string">'Pardus'</span> <span class="string">'Parrot'</span> <span class="string">'Parsix'</span> <span class="string">'TrueOS'</span> <span class="string">'PCLinuxOS'</span> <span class="string">'Peppermint'</span> <span class="string">'popos'</span> <span class="string">'Porteus'</span> <span class="string">'PostMarketOS'</span> <span class="string">'Puppy'</span> <span class="string">'PureOS'</span> <span class="string">'Qubes'</span> <span class="string">'Radix'</span> <span class="string">'Raspbian'</span> <span class="string">'Reborn_OS'</span> <span class="string">'Redstar'</span> <span class="string">'Redcore'</span> <span class="string">'Redhat'</span> <span class="string">'Refracted_Devuan'</span> <span class="string">'Rosa'</span> <span class="string">'sabotage'</span> <span class="string">'Sabayon'</span> <span class="string">'Sailfish'</span> <span class="string">'SalentOS'</span> <span class="string">'Scientific'</span> <span class="string">'Septor'</span> <span class="string">'SharkLinux'</span> <span class="string">'Siduction'</span> <span class="string">'SliTaz'</span> <span class="string">'SmartOS'</span> <span class="string">'Solus'</span> <span class="string">'Source_Mage'</span> <span class="string">'Sparky'</span> <span class="string">'Star'</span> <span class="string">'SteamOS'</span> <span class="string">'SunOS'</span> <span class="string">'openSUSE_Leap'</span> <span class="string">'openSUSE'</span> <span class="string">'SwagArch'</span> <span class="string">'Tails'</span> <span class="string">'Trisquel'</span> <span class="string">'Ubuntu-Budgie'</span> <span class="string">'Ubuntu-GNOME'</span> <span class="string">'Ubuntu-MATE'</span> <span class="string">'Ubuntu-Studio'</span> <span class="string">'Void'</span> <span class="string">'Obarun'</span> <span class="string">'windows10'</span> <span class="string">'Windows7'</span> <span class="string">'Xubuntu'</span>)</span><br><span class="line"></span><br><span class="line">length=<span class="variable">$&#123;#distro_list[@]&#125;</span></span><br><span class="line"></span><br><span class="line">distro=<span class="variable">$&#123;distro_list[$RANDOM % $length]&#125;</span></span><br><span class="line"></span><br><span class="line">neofetch --ascii_distro <span class="variable">$distro</span></span><br></pre></td></tr></table></figure></p><p>运行 <code>bash random_distro.sh</code> 即可获取随机的 Linux 发行版 logo。</p><p>为了使该脚本可以在 Terminal 启动时自动运行，可以添加如下一条命令到 <code>~/.zshrc</code> 配置文件末尾：<br><code>bash /path/to/random_distro.sh</code></p><h4 id="六、Shell-脚本显示天气和数字时钟"><a href="#六、Shell-脚本显示天气和数字时钟" class="headerlink" title="六、Shell 脚本显示天气和数字时钟"></a>六、Shell 脚本显示天气和数字时钟</h4><p><code>weather-clock.sh</code> 脚本从网上找的，没做改动（参考文章 <a href="https://askubuntu.com/questions/1020692/terminal-splash-screen-with-weather-calendar-time-sysinfo" target="_blank" rel="noopener">Terminal splash screen with Weather, Calendar, Time &amp; Sysinfo?</a>）。代码如下：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># NAME: now</span></span><br><span class="line"><span class="comment"># PATH: $HOME/bin</span></span><br><span class="line"><span class="comment"># DESC: Display current weather, calendar and time</span></span><br><span class="line"><span class="comment"># CALL: Called from terminal or ~/.bashrc</span></span><br><span class="line"><span class="comment"># DATE: Apr 6, 2017. Modified: May 24, 2019.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># UPDT: 2019-05-24 If Weather unavailable nicely formatted error message.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># <span class="doctag">NOTE:</span> To display all available toilet fonts use this one-liner:</span></span><br><span class="line"><span class="comment">#       for i in $&#123;TOILET_FONT_PATH:=/usr/share/figlet&#125;/*.&#123;t,f&#125;lf; do j=$&#123;i##*/&#125;; toilet -d "$&#123;i%/*&#125;" -f "$j" "$&#123;j%.*&#125;"; done</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Setup for 92 character wide terminal</span></span><br><span class="line">DateColumn=34 <span class="comment"># Default is 27 for 80 character line, 34 for 92 character line</span></span><br><span class="line">TimeColumn=61 <span class="comment"># Default is 49 for   "   "   "   "    61 "   "   "   "</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Replace Edmonton with your city name, GPS, etc. See: curl wttr.in/:help</span></span><br><span class="line">curl wttr.in/Hangzhou?0 --silent --max-time 3 &gt; /tmp/now-weather</span><br><span class="line"><span class="comment"># Timeout #. Increase for slow connection---^</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">readarray</span> aWeather &lt; /tmp/now-weather</span><br><span class="line">rm -f /tmp/now-weather</span><br><span class="line"></span><br><span class="line"><span class="comment"># Was valid weather report found or an error message?</span></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$&#123;aWeather[0]&#125;</span>"</span> == <span class="string">"Weather report:"</span>* ]] ; <span class="keyword">then</span></span><br><span class="line">    WeatherSuccess=<span class="literal">true</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"<span class="variable">$&#123;aWeather[@]&#125;</span>"</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    WeatherSuccess=<span class="literal">false</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"+============================+"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"| Weather unavailable now!!! |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"| Check reason with command: |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"|                            |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"| curl wttr.in/Edmonton?0    |"</span> <span class="comment"># Replace Edmonton with your city</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"|   --silent --max-time 3    |"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">"+============================+"</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" "</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">" "</span>                <span class="comment"># Pad blank lines for calendar &amp; time to fit</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#--------- DATE -------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># calendar current month with today highlighted.</span></span><br><span class="line"><span class="comment"># colors 00=bright white, 31=red, 32=green, 33=yellow, 34=blue, 35=purple,</span></span><br><span class="line"><span class="comment">#        36=cyan, 37=white</span></span><br><span class="line"></span><br><span class="line">tput sc                 <span class="comment"># Save cursor position.</span></span><br><span class="line"><span class="comment"># Move up 9 lines</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ $((++i)) -lt 10 ]; <span class="keyword">do</span> tput cuu1; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">"<span class="variable">$WeatherSuccess</span>"</span> == <span class="literal">true</span> ]] ; <span class="keyword">then</span></span><br><span class="line">    <span class="comment"># Depending on length of your city name and country name you will:</span></span><br><span class="line">    <span class="comment">#   1. Comment out next three lines of code. Uncomment fourth code line.</span></span><br><span class="line">    <span class="comment">#   2. Change subtraction value and set number of print spaces to match</span></span><br><span class="line">    <span class="comment">#      subtraction value. Then place comment on fourth code line.</span></span><br><span class="line">    Column=$((DateColumn - 10))</span><br><span class="line">    tput cuf <span class="variable">$Column</span>        <span class="comment"># Move x column number</span></span><br><span class="line">    <span class="comment"># Blank out ", country" with x spaces</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"          "</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    tput cuf <span class="variable">$DateColumn</span>    <span class="comment"># Position to column 27 for date display</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -h needed to turn off formating: https://askubuntu.com/questions/1013954/bash-substring-stringoffsetlength-error/1013960#1013960</span></span><br><span class="line">cal &gt; /tmp/terminal1</span><br><span class="line"><span class="comment"># -h not supported in Ubuntu 18.04. Use second answer: https://askubuntu.com/a/1028566/307523</span></span><br><span class="line">tr -<span class="built_in">cd</span> <span class="string">'\11\12\15\40\60-\136\140-\176'</span> &lt; /tmp/terminal1  &gt; /tmp/terminal</span><br><span class="line"></span><br><span class="line">CalLineCnt=1</span><br><span class="line">Today=$(date +<span class="string">"%e"</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\033[32m"</span>   <span class="comment"># color green -- see list above.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r Cal; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">"<span class="variable">$Cal</span>"</span></span><br><span class="line">    <span class="keyword">if</span> [[ <span class="variable">$CalLineCnt</span> -gt 2 ]] ; <span class="keyword">then</span></span><br><span class="line">        <span class="comment"># See if today is on current line &amp; invert background</span></span><br><span class="line">        tput cub 22</span><br><span class="line">        <span class="keyword">for</span> (( j=0 ; j &lt;= 18 ; j += 3 )) ; <span class="keyword">do</span></span><br><span class="line">            Test=<span class="variable">$&#123;Cal:$j:2&#125;</span>            <span class="comment"># Current day on calendar line</span></span><br><span class="line">            <span class="keyword">if</span> [[ <span class="string">"<span class="variable">$Test</span>"</span> == <span class="string">"<span class="variable">$Today</span>"</span> ]] ; <span class="keyword">then</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">"\033[7m"</span>        <span class="comment"># Reverse: [ 7 m</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">"<span class="variable">$Today</span>"</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">"\033[0m"</span>        <span class="comment"># Normal: [ 0 m</span></span><br><span class="line">                <span class="built_in">printf</span> <span class="string">"\033[32m"</span>       <span class="comment"># color green -- see list above.</span></span><br><span class="line">                tput cuf 1</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tput cuf 3</span><br><span class="line">            <span class="keyword">fi</span></span><br><span class="line">        <span class="keyword">done</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">    tput cud1               <span class="comment"># Down one line</span></span><br><span class="line">    tput cuf <span class="variable">$DateColumn</span>    <span class="comment"># Move 27 columns right</span></span><br><span class="line">    CalLineCnt=$((++CalLineCnt))</span><br><span class="line"><span class="keyword">done</span> &lt; /tmp/terminal</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span> <span class="string">"\033[00m"</span>           <span class="comment"># color -- bright white (default)</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">""</span></span><br><span class="line"></span><br><span class="line">tput rc                     <span class="comment"># Restore saved cursor position.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#-------- TIME --------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">tput sc                 <span class="comment"># Save cursor position.</span></span><br><span class="line"><span class="comment"># Move up 8 lines</span></span><br><span class="line">i=0</span><br><span class="line"><span class="keyword">while</span> [ $((++i)) -lt 9 ]; <span class="keyword">do</span> tput cuu1; <span class="keyword">done</span></span><br><span class="line">tput cuf <span class="variable">$TimeColumn</span>    <span class="comment"># Move 49 columns right</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Do we have the toilet package?</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hash</span> toilet 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">" <span class="variable">$(date +"%I:%M %P")</span> "</span> | \</span><br><span class="line">        toilet -f future --filter border &gt; /tmp/terminal</span><br><span class="line"><span class="comment"># Do we have the figlet package?</span></span><br><span class="line"><span class="keyword">elif</span> <span class="built_in">hash</span> figlet 2&gt;/dev/null; <span class="keyword">then</span></span><br><span class="line"><span class="comment">#    echo $(date +"%I:%M %P") | figlet &gt; /tmp/terminal</span></span><br><span class="line">    date +<span class="string">"%I:%M %P"</span> | figlet &gt; /tmp/terminal</span><br><span class="line"><span class="comment"># else use standard font</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">#    echo $(date +"%I:%M %P") &gt; /tmp/terminal</span></span><br><span class="line">    date +<span class="string">"%I:%M %P"</span> &gt; /tmp/terminal</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> IFS= <span class="built_in">read</span> -r Time; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"\033[01;36m"</span>    <span class="comment"># color cyan</span></span><br><span class="line">    <span class="built_in">printf</span> <span class="string">"%s"</span> <span class="string">"<span class="variable">$Time</span>"</span></span><br><span class="line">    tput cud1               <span class="comment"># Up one line</span></span><br><span class="line">    tput cuf <span class="variable">$TimeColumn</span>    <span class="comment"># Move 49 columns right</span></span><br><span class="line"><span class="keyword">done</span> &lt; /tmp/terminal</span><br><span class="line"></span><br><span class="line">tput rc                     <span class="comment"># Restore saved cursor position.</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ bash weather-clock.sh</span><br><span class="line">Weather report: Hangzhou                May 2021</span><br><span class="line">                                  Su Mo Tu We Th Fr Sa       ┌────────────────────────────┐</span><br><span class="line">    _`/&quot;&quot;.-.     Rain shower, mist                   1       │   ┏━┓┏━┓ ┏━┓┏━┓   ┏━┓┏┳┓   │</span><br><span class="line">     ,\_(   ).   21 °C             2  3  4  5  6  7  8       │   ┃┃┃┣━┓╹┃┃┃┗━┫   ┣━┛┃┃┃   │</span><br><span class="line">      /(___(__)  ↓ 15 km/h         9 10 11 12 13 14 15       │   ┗━┛┗━┛╹┗━┛┗━┛   ╹  ╹ ╹   │</span><br><span class="line">        ‘ ‘ ‘ ‘  3 km             16 17 18 19 20 21 22       └────────────────────────────┘</span><br><span class="line">       ‘ ‘ ‘ ‘   0.8 mm           23 24 25 26 27 28 29</span><br><span class="line">                                  30 31</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4d563fc7479cc5bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weather-clock"></p><p>其中获取天气的关键代码为 <code>curl wttr.in/Hangzhou?0 --silent --max-time 3</code>，可自行改为自己所在的城市。</p><p>同样，为了使 Terminal 在启动时能自动运行该脚本，在 <code>~/.zshrc</code> 配置文件的末尾（<code>random-distro.sh</code> 上面一行）添加如下内容：<br><code>bash /path/to/weather-clock.sh</code></p><p><strong>PS</strong>：数字时钟的正常显示需要依赖 <code>toilet</code> 软件。<br>安装 <code>toilet</code>：<code>sudo apt install toilet</code></p><h4 id="七、pipe-sh-生成-Terminal-启动动画"><a href="#七、pipe-sh-生成-Terminal-启动动画" class="headerlink" title="七、pipe.sh 生成 Terminal 启动动画"></a>七、pipe.sh 生成 Terminal 启动动画</h4><p>获取 <code>pipe.sh</code> 程序：<code>git clone https://github.com/pipeseroni/pipes.sh.git</code></p><p>提取项目中的 <code>pipes.sh/pipes.sh</code> 源文件到任意路径下。<br>为了使 Terminal 在启动时能自动运行该脚本，在 <code>~/.zshrc</code> 配置文件的末尾（weather-clock.sh 上面一行）添加如下内容：<br><code>bash /path/to/pipes.sh -p 5</code></p><p>运行效果：<img src="https://upload-images.jianshu.io/upload_images/6875152-2976132226d25aca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pipes.sh"></p><p>按下空格键可终止动画。</p><p>GIF 版本：<img src="https://upload-images.jianshu.io/upload_images/6875152-f69345a2d6fabaef.gif?imageMogr2/auto-orient/strip" alt="pipes"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上次用 &lt;strong&gt;WSL&lt;/strong&gt;（Windows Subsystem for Linux）要追溯到好几年前了。当时 WSL 刚出来不久，抱着尝鲜的态度试着装了，想着万一能用，就不用装虚拟机了。&lt;/p&gt;
&lt;p&gt;结果遇到了 BUG，就再也没用过。最近才听说 WS
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Shell" scheme="https://rollingstarky.github.io/tags/Shell/"/>
    
      <category term="Terminal" scheme="https://rollingstarky.github.io/tags/Terminal/"/>
    
      <category term="Zsh" scheme="https://rollingstarky.github.io/tags/Zsh/"/>
    
      <category term="Beautify" scheme="https://rollingstarky.github.io/tags/Beautify/"/>
    
      <category term="Neofetch" scheme="https://rollingstarky.github.io/tags/Neofetch/"/>
    
      <category term="Ascii Art" scheme="https://rollingstarky.github.io/tags/Ascii-Art/"/>
    
      <category term="Weather" scheme="https://rollingstarky.github.io/tags/Weather/"/>
    
  </entry>
  
  <entry>
    <title>Miniconda 和 poetry 搭建 Python 开发环境（支持多版本、依赖管理）</title>
    <link href="https://rollingstarky.github.io/2021/05/19/build-python-development-environment-with-miniconda-and-poetry/"/>
    <id>https://rollingstarky.github.io/2021/05/19/build-python-development-environment-with-miniconda-and-poetry/</id>
    <published>2021-05-18T16:00:00.000Z</published>
    <updated>2021-05-18T17:00:13.482Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>基于自己的日常习惯测试整理，通过 Windows 系统演示（Linux 系统操作步骤大同小异）。<a href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">Miniconda</a> 用来提供 <code>conda</code> 命令管理多个 Python 版本（如 Python 3.8、Python 3.9）；<a href="https://python-poetry.org/" target="_blank" rel="noopener">poetry</a> 则用来创建基于项目的虚拟环境，维护对应的包依赖关系。</p></blockquote><h4 id="一、效果演示"><a href="#一、效果演示" class="headerlink" title="一、效果演示"></a>一、效果演示</h4><p><code>conda</code> 命令查看安装的 Python 版本：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\Administrator&gt;conda env list</span><br><span class="line"># conda environments:</span><br><span class="line">#</span><br><span class="line">base                  *  C:\Users\xniu\Miniconda3</span><br><span class="line">python2.7.18             C:\Users\xniu\Miniconda3\envs\python2.7.18</span><br><span class="line">python3.9.4              C:\Users\xniu\Miniconda3\envs\python3.9.4</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9b8721fa7a29c760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="conda env list"></p><p><code>poetry</code> 查看某个项目的包依赖关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\auto-test&gt;poetry show</span><br><span class="line">certifi  2020.12.5 Python package for providing Mozilla&apos;s CA Bundle.</span><br><span class="line">chardet  4.0.0     Universal encoding detector for Python 2 and 3</span><br><span class="line">idna     2.10      Internationalized Domain Names in Applications (IDNA)</span><br><span class="line">requests 2.25.1    Python HTTP for Humans.</span><br><span class="line">selenium 3.141.0   Python bindings for Selenium</span><br><span class="line">urllib3  1.26.4    HTTP library with thread-safe connection pooling, file post, and more.</span><br><span class="line"></span><br><span class="line">(python3.9.4) C:\Users\Administrator\projects\auto-test&gt;poetry show -t</span><br><span class="line">requests 2.25.1 Python HTTP for Humans.</span><br><span class="line">|-- certifi &gt;=2017.4.17</span><br><span class="line">|-- chardet &gt;=3.0.2,&lt;5</span><br><span class="line">|-- idna &gt;=2.5,&lt;3</span><br><span class="line">`-- urllib3 &gt;=1.21.1,&lt;1.27</span><br><span class="line">selenium 3.141.0 Python bindings for Selenium</span><br><span class="line">`-- urllib3 *</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e8240c1acb75577f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="poetry show"></p><h4 id="二、安装-Miniconda"><a href="#二、安装-Miniconda" class="headerlink" title="二、安装 Miniconda"></a>二、安装 Miniconda</h4><p>Miniconda 软件提供了 <code>conda</code> 命令，可以用来创建基于不同 Python 版本的虚拟环境。</p><p>访问 <a href="https://docs.conda.io/en/latest/miniconda.html" target="_blank" rel="noopener">Miniconda 官网</a>，下载对应系统版本的安装包并安装。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-2c77ef6a30057998.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="package"></p><p>安装完成后，添加 <code>conda</code> 命令的路径（安装目录下的 <code>Scripts</code> 目录）到 <strong>PATH</strong> 环境变量。其路径一般为 <code>C:\Users\xxx\Miniconda3\Scripts\</code>。</p><p>添加完成后，打开一个新的命令提示符，运行 <code>conda</code> 命令看是否有反应。</p><h5 id="创建基于不同-Python-版本的虚拟环境"><a href="#创建基于不同-Python-版本的虚拟环境" class="headerlink" title="创建基于不同 Python 版本的虚拟环境"></a>创建基于不同 Python 版本的虚拟环境</h5><p><code>conda create -n python3.9.4 python=3.9.4</code><br>上述命令会创建一个新的 Python 虚拟环境，并安装 Python 3.9.4。</p><p>其中 <code>-n</code> 选项用于指定该虚拟环境的名称，方便后续通过 <code>conda activate xxx</code> 启用该虚拟环境；<br><code>python=3.9.4</code> 命令用于安装指定版本的 Python 程序。</p><p>虚拟环境创建成功后，即可使用 <code>conda activate python3.9.4</code> 命令启用该虚拟环境。<br>此后在该命令提示符环境下任何 <code>python</code> 命令都会自动使用 Python3.9.4 执行。</p><p><code>conda env list</code> 命令可以查看现有的 Python 虚拟环境。</p><p><strong>PS</strong>：更多 <code>conda</code> 命令可参考 <a href="https://docs.conda.io/projects/conda/en/latest/commands.html" target="_blank" rel="noopener">Command reference</a>。</p><h4 id="三、安装-poetry"><a href="#三、安装-poetry" class="headerlink" title="三、安装 poetry"></a>三、安装 poetry</h4><p>poetry 的安装可参考 <a href="https://python-poetry.org/docs/#installation" target="_blank" rel="noopener">poetry 官方文档</a>。对于 Windows 系统可直接打开一个 PowerShell 窗口，运行以下命令：<br><code>(Invoke-WebRequest -Uri https://raw.githubusercontent.com/python-poetry/poetry/master/get-poetry.py -UseBasicParsing).Content | python -</code></p><p>安装成功后，<code>poetry</code> 命令会自动添加到 PATH 环境变量中。</p><h5 id="创建基于项目的虚拟环境"><a href="#创建基于项目的虚拟环境" class="headerlink" title="创建基于项目的虚拟环境"></a>创建基于项目的虚拟环境</h5><p>打开一个新的命令提示符，使用 <code>conda activate python3.9.4</code> 命令激活某个 Python 版本。</p><p>进入到项目路径下，运行 <code>poetry init</code> 命令初始化配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry init</span><br><span class="line"></span><br><span class="line">This command will guide you through creating your pyproject.toml config.</span><br><span class="line"></span><br><span class="line">Package name [test-poetry]:</span><br><span class="line">Version [0.1.0]:</span><br><span class="line">Description []:</span><br><span class="line">Author [None, n to skip]:  n</span><br><span class="line">License []:</span><br><span class="line">Compatible Python versions [^3.9]:</span><br><span class="line"></span><br><span class="line">Would you like to define your main dependencies interactively? (yes/no) [yes] no</span><br><span class="line">Would you like to define your development dependencies interactively? (yes/no) [yes] no</span><br><span class="line">Generated file</span><br><span class="line"></span><br><span class="line">[tool.poetry]</span><br><span class="line">name = &quot;test-poetry&quot;</span><br><span class="line">version = &quot;0.1.0&quot;</span><br><span class="line">description = &quot;&quot;</span><br><span class="line">authors = [&quot;Your Name &lt;you@example.com&gt;&quot;]</span><br><span class="line"></span><br><span class="line">[tool.poetry.dependencies]</span><br><span class="line">python = &quot;^3.9&quot;</span><br><span class="line"></span><br><span class="line">[tool.poetry.dev-dependencies]</span><br><span class="line"></span><br><span class="line">[build-system]</span><br><span class="line">requires = [&quot;poetry-core&gt;=1.0.0&quot;]</span><br><span class="line">build-backend = &quot;poetry.core.masonry.api&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you confirm generation? (yes/no) [yes] yes</span><br></pre></td></tr></table></figure></p><p>上述操作会在项目目录下自动创建 <code>pyproject.toml</code> 配置文件，内容如下：<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"test-poetry"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">""</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"Your Name &lt;you@example.com&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">"^3.9"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">"poetry-core&gt;=1.0.0"</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">"poetry.core.masonry.api"</span></span><br></pre></td></tr></table></figure></p><p>使用 <code>poetry shell</code> 命令自动创建<strong>基于当前项目</strong>的虚拟环境并激活该环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry shell</span><br><span class="line">Creating virtualenv test-poetry-thSlgjIV-py3.9 in C:\Users\Administrator\AppData\Local\pypoetry\Cache\virtualenvs</span><br><span class="line">Spawning shell within C:\Users\Administrator\AppData\Local\pypoetry\Cache\virtualenvs\test-poetry-thSlgjIV-py3.9</span><br><span class="line">Microsoft Windows [Version 10.0.18363.1316]</span><br><span class="line">(c) 2019 Microsoft Corporation. All rights reserved.</span><br></pre></td></tr></table></figure></p><p>运行 <code>code .</code> 命令使用 VSCode 软件打开本项目，此时即可在 IDE 中切换到新创建的基于本项目的虚拟环境（VSCode 已经安装了 Python 插件）。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-14910e736377b051.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="VSCode"></p><h5 id="安装依赖包"><a href="#安装依赖包" class="headerlink" title="安装依赖包"></a>安装依赖包</h5><p><code>poetry add xxx</code> 命令可以用来在当前环境中安装某个依赖包：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry add requests</span><br><span class="line">Using version ^2.25.1 for requests</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies...</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 5 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing certifi (2020.12.5)</span><br><span class="line">  • Installing chardet (4.0.0)</span><br><span class="line">  • Installing idna (2.10)</span><br><span class="line">  • Installing urllib3 (1.26.4)</span><br><span class="line">  • Installing requests (2.25.1)</span><br></pre></td></tr></table></figure></p><p><code>poetry add xxx -D</code> 命令可以用来安装针对开发环境的某个依赖包（用 <code>poetry remove</code> 命令卸载此类包时也需要指定 <code>-D</code> 选项）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry add autopep8 -D</span><br><span class="line">Using version ^1.5.7 for autopep8</span><br><span class="line"></span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies...</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 3 installs, 0 updates, 0 removals</span><br><span class="line"></span><br><span class="line">  • Installing pycodestyle (2.7.0)</span><br><span class="line">  • Installing toml (0.10.2)</span><br><span class="line">  • Installing autopep8 (1.5.7)</span><br></pre></td></tr></table></figure></p><p>同时，安装的依赖包信息也会自动添加到 <code>pyproject.toml</code> 配置文件中：<br><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[tool.poetry]</span></span><br><span class="line"><span class="attr">name</span> = <span class="string">"test-poetry"</span></span><br><span class="line"><span class="attr">version</span> = <span class="string">"0.1.0"</span></span><br><span class="line"><span class="attr">description</span> = <span class="string">""</span></span><br><span class="line"><span class="attr">authors</span> = [<span class="string">"Your Name &lt;you@example.com&gt;"</span>]</span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dependencies]</span></span><br><span class="line"><span class="attr">python</span> = <span class="string">"^3.9"</span></span><br><span class="line"><span class="attr">requests</span> = <span class="string">"^2.25.1"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[tool.poetry.dev-dependencies]</span></span><br><span class="line"><span class="attr">autopep8</span> = <span class="string">"^1.5.7"</span></span><br><span class="line"></span><br><span class="line"><span class="section">[build-system]</span></span><br><span class="line"><span class="attr">requires</span> = [<span class="string">"poetry-core&gt;=1.0.0"</span>]</span><br><span class="line"><span class="attr">build-backend</span> = <span class="string">"poetry.core.masonry.api"</span></span><br></pre></td></tr></table></figure></p><p>后续配置新的环境时，<code>pyproject.toml</code> 可以发挥类似 <code>requirements.txt</code> 文件的作用。即借助此文件中的配置，可以直接使用 <code>peotry install</code> 命令自动安装文件中包含的依赖项。</p><h5 id="维护环境依赖"><a href="#维护环境依赖" class="headerlink" title="维护环境依赖"></a>维护环境依赖</h5><p>使用 <code>poetry show</code> 命令查看当前安装的依赖包列表：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry show</span><br><span class="line">autopep8    1.5.7     A tool that automatically formats Python code to conform to the PEP 8 style guide</span><br><span class="line">certifi     2020.12.5 Python package for providing Mozilla&apos;s CA Bundle.</span><br><span class="line">chardet     4.0.0     Universal encoding detector for Python 2 and 3</span><br><span class="line">idna        2.10      Internationalized Domain Names in Applications (IDNA)</span><br><span class="line">pycodestyle 2.7.0     Python style guide checker</span><br><span class="line">requests    2.25.1    Python HTTP for Humans.</span><br><span class="line">toml        0.10.2    Python Library for Tom&apos;s Obvious, Minimal Language</span><br><span class="line">urllib3     1.26.4    HTTP library with thread-safe connection pooling, file post, and more.</span><br></pre></td></tr></table></figure></p><p>使用 <code>poetry show -t</code> 命令查看当前环境中各包之间的依赖关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry show -t</span><br><span class="line">autopep8 1.5.7 A tool that automatically formats Python code to conform to the PEP 8 style guide</span><br><span class="line">|-- pycodestyle &gt;=2.7.0</span><br><span class="line">`-- toml *</span><br><span class="line">requests 2.25.1 Python HTTP for Humans.</span><br><span class="line">|-- certifi &gt;=2017.4.17</span><br><span class="line">|-- chardet &gt;=3.0.2,&lt;5</span><br><span class="line">|-- idna &gt;=2.5,&lt;3</span><br><span class="line">`-- urllib3 &gt;=1.21.1,&lt;1.27</span><br></pre></td></tr></table></figure></p><p>若此时使用 <code>poetry remove autopep8 -D</code> 命令移除 <code>autopep8</code>，则之前自动安装的 <code>pycodestyle</code>、<code>toml</code> 依赖项也会被移除。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(python3.9.4) C:\Users\Administrator\projects\python\test-poetry&gt;poetry remove autopep8 -D</span><br><span class="line">Updating dependencies</span><br><span class="line">Resolving dependencies...</span><br><span class="line"></span><br><span class="line">Writing lock file</span><br><span class="line"></span><br><span class="line">Package operations: 0 installs, 0 updates, 3 removals</span><br><span class="line"></span><br><span class="line">  • Removing autopep8 (1.5.7)</span><br><span class="line">  • Removing pycodestyle (2.7.0)</span><br><span class="line">  • Removing toml (0.10.2)</span><br></pre></td></tr></table></figure></p><p><strong>PS</strong>：更多 <code>poetry</code> 命令和用法可参考官方文档：<a href="https://python-poetry.org/docs/cli/" target="_blank" rel="noopener">Poetry Commands</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;基于自己的日常习惯测试整理，通过 Windows 系统演示（Linux 系统操作步骤大同小异）。&lt;a href=&quot;https://docs.conda.io/en/latest/miniconda.html&quot; target=&quot;_blank&quot; rel
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="Poetry" scheme="https://rollingstarky.github.io/tags/Poetry/"/>
    
      <category term="Miniconda" scheme="https://rollingstarky.github.io/tags/Miniconda/"/>
    
      <category term="Conda" scheme="https://rollingstarky.github.io/tags/Conda/"/>
    
      <category term="Package" scheme="https://rollingstarky.github.io/tags/Package/"/>
    
  </entry>
  
  <entry>
    <title>Django（drf）配合 Vue Element 实现文件上传下载功能</title>
    <link href="https://rollingstarky.github.io/2021/03/13/django-drf-and-vue-element-file-upload-and-download/"/>
    <id>https://rollingstarky.github.io/2021/03/13/django-drf-and-vue-element-file-upload-and-download/</id>
    <published>2021-03-12T16:00:00.000Z</published>
    <updated>2021-03-13T15:22:28.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="后台代码"><a href="#后台代码" class="headerlink" title="后台代码"></a>后台代码</h4><h5 id="Models"><a href="#Models" class="headerlink" title="Models"></a>Models</h5><p>编辑 <code>models.py</code> 代码，通过 <code>FileField</code> 字段记录文件信息：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    file = models.FileField(upload_to=<span class="string">'uploads/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'files_storage'</span></span><br><span class="line">        ordering = [<span class="string">'-id'</span>]</span><br></pre></td></tr></table></figure></p><h5 id="Serializer"><a href="#Serializer" class="headerlink" title="Serializer"></a>Serializer</h5><p>这里使用 Django REST framework 实现后端 REST API，需要创建序列化器 <code>serializers.py</code>，内容如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> serializers</span><br><span class="line"><span class="comment"># files 是 app 的名字</span></span><br><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesSerializer</span><span class="params">(serializers.ModelSerializer)</span>:</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        model = models.FilesModel</span><br><span class="line">        fields = <span class="string">'__all__'</span></span><br></pre></td></tr></table></figure></p><h5 id="Views"><a href="#Views" class="headerlink" title="Views"></a>Views</h5><p>编辑 <code>views.py</code> 代码，内容如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> models, serializers</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = models.FilesModel.objects.all()</span><br><span class="line">    serializer_class = serializers.FilesSerializer</span><br></pre></td></tr></table></figure></p><h5 id="Urls"><a href="#Urls" class="headerlink" title="Urls"></a>Urls</h5><p>在 files 路径下新建 <code>urls.py</code> 文件，填写路由配置：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> include, path</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> routers</span><br><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">router = routers.DefaultRouter()</span><br><span class="line">router.register(<span class="string">r'files'</span>, views.FileViewSet)</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">''</span>, include(router.urls))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><p>在项目总配置路径下（<code>settings.py</code> 所在的路径）编辑根路由配置文件 <code>urls.py</code>：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path, include</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">'admin/'</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">'storage/'</span>, include(<span class="string">'files.urls'</span>))</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h5 id="测试后端-API"><a href="#测试后端-API" class="headerlink" title="测试后端 API"></a>测试后端 API</h5><p>运行后台服务 <code>python manage.py runserver 0.0.0.0:8000</code>，访问 <a href="http://xx.xx.xx.xx:8000/storage/files/，界面如下：" target="_blank" rel="noopener">http://xx.xx.xx.xx:8000/storage/files/，界面如下：</a><br><img src="https://upload-images.jianshu.io/upload_images/6875152-ed76119688b03565.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Django REST framework"></p><p>测试上传文件，效果如下：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-010d20514b00401a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传成功"></p><h4 id="前端代码（手动上传）"><a href="#前端代码（手动上传）" class="headerlink" title="前端代码（手动上传）"></a>前端代码（手动上传）</h4><p>借助 Element UI 的 upload 组件，Vue 代码（<code>index.vue</code>）如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      ref=&quot;upload&quot;</span><br><span class="line">      drag</span><br><span class="line">      action=&quot;http://xx.xx.xx.xx:8000/storage/files/&quot;</span><br><span class="line">      :auto-upload=&quot;false&quot;</span><br><span class="line">      :on-success=&quot;onSuccess&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;i class=&quot;el-icon-upload&quot; /&gt;</span><br><span class="line">      &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">    &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&gt;上传到服务器&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;UploadDemo&apos;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitUpload() &#123;</span><br><span class="line">      this.$refs.upload.submit()</span><br><span class="line">    &#125;,</span><br><span class="line">    onSuccess() &#123;</span><br><span class="line">      this.$message.success(&apos;上传成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>其中 <code>el-upload</code> 组件的 <code>action</code> 属性用于指定后台 API 的 URI；<br><code>:auto-upload</code> 属性用于设置是否自动上传（这里设置为 <code>false</code>，手动触发上传动作）；<br><code>:on-success</code> 属性用于指定上传成功后触发的方法。</p><p><code>submitUpload()</code> 中的 <code>this.$refs.upload.submit()</code> 方法触发文件上传动作。</p><p>界面如下：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-65b26a1e943716c2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传界面"></p><p>测试文件上传：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-7ccc4d25b88df2c0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="上传成功"></p><p>后台数据如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/template.html"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">18</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/20171215091830_55126_hSnPtZR.png"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">17</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="文件上传的同时添加其他数据"><a href="#文件上传的同时添加其他数据" class="headerlink" title="文件上传的同时添加其他数据"></a>文件上传的同时添加其他数据</h4><h5 id="修改数据库模型"><a href="#修改数据库模型" class="headerlink" title="修改数据库模型"></a>修改数据库模型</h5><p>编辑后端 <code>models.py</code> 文件，添加其他字段：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FilesModel</span><span class="params">(models.Model)</span>:</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">20</span>, default=<span class="string">''</span>)</span><br><span class="line">    file = models.FileField(upload_to=<span class="string">'uploads/'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Meta</span>:</span></span><br><span class="line">        db_table = <span class="string">'files_storage'</span></span><br><span class="line">        ordering = [<span class="string">'-id'</span>]</span><br></pre></td></tr></table></figure></p><p>数据库迁移后，重启后台 Web 服务。</p><p>后台数据如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/template.html"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/20171215091830_55126_hSnPtZR.png"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">17</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h5 id="修改前端代码"><a href="#修改前端代码" class="headerlink" title="修改前端代码"></a>修改前端代码</h5><p>添加其他数据的输入界面，同时将附加数据绑定到 <code>el-upload</code> 组件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;el-label&gt;名称&lt;/el-label&gt;</span><br><span class="line">    &lt;el-input v-model=&quot;fileData.name&quot; style=&quot;width: 20%&quot; /&gt;</span><br><span class="line">    &lt;el-upload</span><br><span class="line">      ref=&quot;upload&quot;</span><br><span class="line">      drag</span><br><span class="line">      class=&quot;upload-demo&quot;</span><br><span class="line">      action=&quot;http://xx.xx.xx.xx:8000/storage/files/&quot;</span><br><span class="line">      :data=&quot;fileData&quot;</span><br><span class="line">      :auto-upload=&quot;false&quot;</span><br><span class="line">      :on-success=&quot;onSuccess&quot;</span><br><span class="line">      style=&quot;padding: 30px&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      &lt;i class=&quot;el-icon-upload&quot; /&gt;</span><br><span class="line">      &lt;div class=&quot;el-upload__text&quot;&gt;将文件拖到此处，或&lt;em&gt;点击上传&lt;/em&gt;&lt;/div&gt;</span><br><span class="line">    &lt;/el-upload&gt;</span><br><span class="line">    &lt;el-button style=&quot;margin-left: 10px;&quot; size=&quot;small&quot; type=&quot;success&quot; @click=&quot;submitUpload&quot;&gt;上传到服务器&lt;/el-button&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  name: &apos;UploadDemo&apos;,</span><br><span class="line">  data() &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      fileData: &#123;</span><br><span class="line">        name: &apos;&apos;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">    submitUpload() &#123;</span><br><span class="line">      this.$refs.upload.submit()</span><br><span class="line">    &#125;,</span><br><span class="line">    onSuccess() &#123;</span><br><span class="line">      this.$message.success(&apos;上传成功&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>其中 <code>el-upload</code> 组件的 <code>:data</code> 属性用于指定文件上传时附加的数据（类型为 JavaScript 对象）。</p><p>文件上传测试：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-5f22e11cd28c0ee4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="文件上传（带数据）"></p><p>上传完成，后台数据如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/AnyDesk.exe"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">19</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">"测试文件"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/template.html"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">18</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">""</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"file"</span>: <span class="string">"http://172.20.23.34:8000/storage/files/uploads/20171215091830_55126_hSnPtZR.png"</span>,</span><br><span class="line">        <span class="attr">"id"</span>: <span class="number">17</span>,</span><br><span class="line">        <span class="attr">"name"</span>: <span class="string">""</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h4><p>修改后台视图代码（<code>views.py</code>），添加文件下载的 API 响应逻辑：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.viewsets <span class="keyword">import</span> ModelViewSet</span><br><span class="line"><span class="keyword">from</span> files <span class="keyword">import</span> models, serializers</span><br><span class="line"><span class="keyword">from</span> rest_framework.decorators <span class="keyword">import</span> action</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> FileResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileViewSet</span><span class="params">(ModelViewSet)</span>:</span></span><br><span class="line">    queryset = models.FilesModel.objects.all()</span><br><span class="line">    serializer_class = serializers.FilesSerializer</span><br><span class="line"></span><br><span class="line"><span class="meta">    @action(methods=['get', 'post'], detail=True)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">download</span><span class="params">(self, request, pk=None, *args, **kwargs)</span>:</span></span><br><span class="line">        file_obj = self.get_object()</span><br><span class="line">        response = FileResponse(open(file_obj.file.path, <span class="string">'rb'</span>))</span><br><span class="line">        <span class="keyword">return</span> response</span><br></pre></td></tr></table></figure><p>此时访问 <a href="http://xx.xx.xx.xx:8000/storage/files/[id]/download/" target="_blank" rel="noopener">http://xx.xx.xx.xx:8000/storage/files/[id]/download/</a> 链接，即可直接下载上传到服务器上的文件。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-bb5a7c0448592919.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="下载文件"></p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -o anydesk.exe <span class="number">172</span>.<span class="number">20</span>.<span class="number">23</span>.<span class="number">34</span>:<span class="number">8000</span>/storage/files/<span class="number">19</span>/download/</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   <span class="built_in">Time</span>    <span class="built_in">Time</span>     <span class="built_in">Time</span>  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line"><span class="number">100</span> <span class="number">3584</span>k  <span class="number">100</span> <span class="number">3584</span>k    <span class="number">0</span>     <span class="number">0</span>   <span class="number">102</span>M      <span class="number">0</span> --:--:-- --:--:-- --:--:--  <span class="number">102</span>M</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://element.eleme.cn/#/zh-CN/component/upload" target="_blank" rel="noopener">Element UI 官方文档</a><br><a href="https://docs.djangoproject.com/en/3.1/topics/http/file-uploads/" target="_blank" rel="noopener">Django 官方文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;后台代码&quot;&gt;&lt;a href=&quot;#后台代码&quot; class=&quot;headerlink&quot; title=&quot;后台代码&quot;&gt;&lt;/a&gt;后台代码&lt;/h4&gt;&lt;h5 id=&quot;Models&quot;&gt;&lt;a href=&quot;#Models&quot; class=&quot;headerlink&quot; title=&quot;Model
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Web" scheme="https://rollingstarky.github.io/tags/Web/"/>
    
      <category term="Django" scheme="https://rollingstarky.github.io/tags/Django/"/>
    
      <category term="Vue" scheme="https://rollingstarky.github.io/tags/Vue/"/>
    
      <category term="drf" scheme="https://rollingstarky.github.io/tags/drf/"/>
    
      <category term="Element" scheme="https://rollingstarky.github.io/tags/Element/"/>
    
      <category term="File" scheme="https://rollingstarky.github.io/tags/File/"/>
    
  </entry>
  
  <entry>
    <title>基本算法问题的 Python 解法——图（Graph）问题</title>
    <link href="https://rollingstarky.github.io/2021/02/20/classic-compute-problems-with-python-graph-problems/"/>
    <id>https://rollingstarky.github.io/2021/02/20/classic-compute-problems-with-python-graph-problems/</id>
    <published>2021-02-19T16:00:00.000Z</published>
    <updated>2021-02-20T12:35:08.593Z</updated>
    
    <content type="html"><![CDATA[<p><strong>图（Graph）</strong>是一种用来对某些现实问题进行建模的抽象的数学结构，这些问题从逻辑上可以被划分成一系列相互连接的<strong>节点</strong>。其中的节点称为<strong>顶点</strong>（<em>vertex</em>），顶点之间的连接称为<strong>边</strong>（<em>edge</em>）。<br>比如地铁线路就可以看作由图表示成的运输网络。每一个顶点都代表一个地铁站，而顶点之间的边则表示两个地铁站之间的路径。如果想知道某个站点到另一个站点的最短路径，图算法就能发挥作用。实际上，图算法可以被应用到任何类型的网络问题中。</p><h4 id="map-as-graph"><a href="#map-as-graph" class="headerlink" title="map as graph"></a>map as graph</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8255210fc341b4ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="美国最大的15个 MSA 的地图"></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9f88ead301ab7f25.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="美国最大的15个 MSA 的 graph 表示"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># edge.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span>:</span></span><br><span class="line">    u: int  <span class="comment"># the "from" vertex</span></span><br><span class="line">    v: int  <span class="comment"># the "to" vertex</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversed</span><span class="params">(self)</span> -&gt; Edge:</span></span><br><span class="line">        <span class="keyword">return</span> Edge(self.v, self.u)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;self.u&#125;</span> -&gt; <span class="subst">&#123;self.v&#125;</span>"</span></span><br></pre></td></tr></table></figure><p>上面代码中的 <code>Edge</code> 类表示两个顶点之间的连接（即“边”），每个顶点都由整数索引表示。其中 <code>u</code> 用来表示第一个顶点，<code>v</code> 表示第二个顶点。<br>这里只关注非方向性的 graph，edge 是双向的。而在<strong>有向图（digraph）</strong>中，edge 可以是单向的。<code>reversed()</code> 方法用来返回当前 edge 的逆向形式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Generic, List, Optional</span><br><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> Edge</span><br><span class="line"></span><br><span class="line">V = TypeVar(<span class="string">'V'</span>)  <span class="comment"># type of the vertices in the graph</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span><span class="params">(Generic[V])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vertices: List[V] = [])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._vertices: List[V] = vertices</span><br><span class="line">        self._edges: List[List[Edge]] = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> vertices]</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vertex_count</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> len(self._vertices)  <span class="comment"># Number of vertices</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">edge_count</span><span class="params">(self)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> sum(map(len, self._edges))  <span class="comment"># Number of edges</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add a vertex to the graph and return its index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_vertex</span><span class="params">(self, vertex: V)</span> -&gt; int:</span></span><br><span class="line">        self._vertices.append(vertex)</span><br><span class="line">        self._edges.append([])  <span class="comment"># Add empty list for containing edges</span></span><br><span class="line">        <span class="keyword">return</span> self.vertex_count - <span class="number">1</span>  <span class="comment"># Return index of added vertex</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># This is an undirected graph,</span></span><br><span class="line">    <span class="comment"># so we always add edges in both directions</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge</span><span class="params">(self, edge: Edge)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._edges[edge.u].append(edge)</span><br><span class="line">        self._edges[edge.v].append(edge.reversed())</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add an edge using vertex indices (convenience method)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge_by_indices</span><span class="params">(self, u: int, v: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        edge: Edge = Edge(u, v)</span><br><span class="line">        self.add_edge(edge)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Add an edge by looking up vertex indices (convenience method)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge_by_vertices</span><span class="params">(self, first: V, second: V)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        u: int = self._vertices.index(first)</span><br><span class="line">        v: int = self._vertices.index(second)</span><br><span class="line">        self.add_edge_by_indices(u, v)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the vertex at a specific index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">vertex_at</span><span class="params">(self, index: int)</span> -&gt; V:</span></span><br><span class="line">        <span class="keyword">return</span> self._vertices[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the index of a vertex in the graph</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">index_of</span><span class="params">(self, vertex: V)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self._vertices.index(vertex)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Find the vertices that a vertex at some index is connected to</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neighbors_for_index</span><span class="params">(self, index: int)</span> -&gt; List[V]:</span></span><br><span class="line">        <span class="keyword">return</span> list(map(self.vertex_at, [e.v <span class="keyword">for</span> e <span class="keyword">in</span> self._edges[index]]))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Look up a vertice's index and find its neighbors (convenience method)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neighbors_for_vertex</span><span class="params">(self, vertex: V)</span> -&gt; List[V]:</span></span><br><span class="line">        <span class="keyword">return</span> self.neighbors_for_index(self.index_of(vertex))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Return all of the edges associated with a vertex at some index</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">edges_for_index</span><span class="params">(self, index: int)</span> -&gt; List[Edge]:</span></span><br><span class="line">        <span class="keyword">return</span> self._edges[index]</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Look up the index of a vertex and return its edges (convenience method)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">edges_for_vertex</span><span class="params">(self, vertex: V)</span> -&gt; List[Edge]:</span></span><br><span class="line">        <span class="keyword">return</span> self.edges_for_index(self.index_of(vertex))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># Make it easy to pretty-print a Graph</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        desc: str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.vertex_count):</span><br><span class="line">            desc += <span class="string">f"<span class="subst">&#123;self.vertex_at(i)&#125;</span> -&gt; <span class="subst">&#123;self.neighbors_for_index(i)&#125;</span>\n"</span></span><br><span class="line">        <span class="keyword">return</span> desc</span><br></pre></td></tr></table></figure><p><code>Graph</code> 类聚焦于 graph 的核心角色，即将顶点用边连接起来。<br><code>_vertices</code> 列表是 Graph 类的核心，每个顶点都会被存储在该列表中。但是之后在实际引用时会使用顶点在列表中的索引。顶点本身有可能会是非常复杂的数据类型，但其索引一定会是 int 类型，相对而言更加方便使用。<br>graph 数据类型可以使用 <strong>adjacency lists</strong> 方式实现，每个顶点都拥有一个列表，里面包含了这个顶点连接的其他顶点。这里使用了由 edge 组成的列表再组成的列表（<code>_edges</code>），每个顶点都拥有一个由 edge 组成的列表，这些 edge 表示该顶点与其他顶点的连接关系。</p><p><code>Graph</code> 类中实现的方法的简单介绍：</p><ul><li><code>vertex_count</code> 属性：获取 graph 中顶点的数量</li><li><code>edge_count</code> 属性：获取 graph 中边的数量</li><li><code>add_vertex</code> 方法：添加一个新的孤立的顶点并返回其索引</li><li><code>add_edge</code> 方法：添加一条边（双向，参数是 Edge 对象）</li><li><code>add_edge_by_indices</code> 方法：通过顶点索引添加新的边（参数是边的两个顶点的索引 u、v）</li><li><code>add_edge_by_vertices</code> 方法：通过顶点添加新的边（参数是边的两个顶点（Vertex）对象）</li><li><code>vertex_at</code> 方法：通过特定的索引查询顶点</li><li><code>index_of</code> 方法：根据顶点返回其索引</li><li><code>neighbors_for_index</code> 方法：根据某个顶点的索引获取其临近的顶点（参数为顶点索引）</li><li><code>neighbors_for_vertex</code> 方法：根据某个顶点获取其临近的顶点（参数为顶点对象）</li><li><code>edges_for_index</code> 方法：根据某个顶点的索引获取与其连接的边（参数为顶点索引）</li><li><code>edges_for_vertex</code> 方法：根据某个顶点获取与其连接的边（参数为顶点对象）</li><li><code>__str__</code> 方法：友好的方式输出整个 graph</li></ul><p>补充测试代码：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph.py continued</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># test basic Graph construction</span></span><br><span class="line">    city_graph: Graph[str] = Graph([<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>, <span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>, <span class="string">"Phoenix"</span>, <span class="string">"Chicago"</span>, <span class="string">"Boston"</span>, <span class="string">"New York"</span>,</span><br><span class="line">                                    <span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>, <span class="string">"Dallas"</span>, <span class="string">"Houston"</span>, <span class="string">"Detroit"</span>, <span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>])</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"Chicago"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Riverside"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Los Angeles"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Phoenix"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Phoenix"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Chicago"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Dallas"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Houston"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Chicago"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Atlanta"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Houston"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Atlanta"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Miami"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Chicago"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Washington"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Miami"</span>, <span class="string">"Washington"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Chicago"</span>, <span class="string">"Detroit"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Boston"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Washington"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"New York"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Boston"</span>, <span class="string">"New York"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"New York"</span>, <span class="string">"Philadelphia"</span>)</span><br><span class="line">    city_graph.add_edge_by_vertices(<span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>)</span><br><span class="line">    print(city_graph)</span><br></pre></td></tr></table></figure></p><p>运行结果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Seattle -&gt; ['Chicago', 'San Francisco']</span><br><span class="line">San Francisco -&gt; ['Seattle', 'Riverside', 'Los Angeles']</span><br><span class="line">Los Angeles -&gt; ['San Francisco', 'Riverside', 'Phoenix']</span><br><span class="line">Riverside -&gt; ['San Francisco', 'Los Angeles', 'Phoenix', 'Chicago']</span><br><span class="line">Phoenix -&gt; ['Los Angeles', 'Riverside', 'Dallas', 'Houston']</span><br><span class="line">Chicago -&gt; ['Seattle', 'Riverside', 'Dallas', 'Atlanta', 'Detroit']</span><br><span class="line">Boston -&gt; ['Detroit', 'New York']</span><br><span class="line">New York -&gt; ['Detroit', 'Boston', 'Philadelphia']</span><br><span class="line">Atlanta -&gt; ['Dallas', 'Houston', 'Chicago', 'Washington', 'Miami']</span><br><span class="line">Miami -&gt; ['Houston', 'Atlanta', 'Washington']</span><br><span class="line">Dallas -&gt; ['Phoenix', 'Chicago', 'Atlanta', 'Houston']</span><br><span class="line">Houston -&gt; ['Phoenix', 'Dallas', 'Atlanta', 'Miami']</span><br><span class="line">Detroit -&gt; ['Chicago', 'Boston', 'Washington', 'New York']</span><br><span class="line">Philadelphia -&gt; ['New York', 'Washington']</span><br><span class="line">Washington -&gt; ['Atlanta', 'Miami', 'Detroit', 'Philadelphia']</span><br></pre></td></tr></table></figure></p><h4 id="寻找最短路径"><a href="#寻找最短路径" class="headerlink" title="寻找最短路径"></a>寻找最短路径</h4><p>在 graph 理论中，任意两个顶点之间的所有连线（边）称为路径。即从一个顶点到达另一个顶点需要走过的所有路径。<br>在一个未加权的 graph 中（即不考虑边的长度），寻找最短的路径意味着从起始顶点到目标顶点之间经过的边最少。可以使用<strong>宽度优先搜索（breadth-first search, BFS）</strong>算法查找两个顶点之间的最短路径。（BFS 算法的具体实现可参考 <a href="https://www.jianshu.com/p/34e392141d30" target="_blank" rel="noopener">基本算法问题的 Python 解法（递归与搜索）</a>中的迷宫问题）。</p><p>BFS 部分代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generic_search.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Generic, List, Callable, Deque, Set, Optional</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span><span class="params">(Generic[T])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, state: T, parent: Optional[Node])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.state: T = state</span><br><span class="line">        self.parent: Optional[Node] = parent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span><span class="params">(Generic[T])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._container: Deque[T] = Deque()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._container  <span class="comment"># not is true for empty container</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item: T)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._container.append(item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; T:</span></span><br><span class="line">        <span class="keyword">return</span> self._container.popleft()  <span class="comment"># FIFO</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self._container)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bfs</span><span class="params">(initial: T, goal_test: Callable[[T], bool], successors: Callable[[T], List[T]])</span> -&gt; Optional[Node[T]]:</span></span><br><span class="line">    <span class="comment"># frontier is where we've yet to go</span></span><br><span class="line">    frontier: Queue[Node[T]] = Queue()</span><br><span class="line">    frontier.push(Node(initial, <span class="keyword">None</span>))</span><br><span class="line">    <span class="comment"># explored is where we've been</span></span><br><span class="line">    explored: Set[T] = &#123;initial&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment"># keep going while there is more to explore</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> frontier.empty:</span><br><span class="line">        current_node: Node[T] = frontier.pop()</span><br><span class="line">        current_state: T = current_node.state</span><br><span class="line">        <span class="comment"># if we found the goal, we're done</span></span><br><span class="line">        <span class="keyword">if</span> goal_test(current_state):</span><br><span class="line">            <span class="keyword">return</span> current_node</span><br><span class="line">        <span class="comment"># check where we can go next and haven't explored</span></span><br><span class="line">        <span class="keyword">for</span> child <span class="keyword">in</span> successors(current_state):</span><br><span class="line">            <span class="keyword">if</span> child <span class="keyword">in</span> explored:  <span class="comment"># skip children we already explored</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            explored.add(child)</span><br><span class="line">            frontier.push(Node(child, current_node))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span>  <span class="comment"># went through everything and never found goal</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">node_to_path</span><span class="params">(node: Node[T])</span> -&gt; List[T]:</span></span><br><span class="line">    path: List[T] = [node.state]</span><br><span class="line">    <span class="comment"># work backwards from end to front</span></span><br><span class="line">    <span class="keyword">while</span> node.parent <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">        node = node.parent</span><br><span class="line">        path.append(node.state)</span><br><span class="line">    path.reverse()</span><br><span class="line">    <span class="keyword">return</span> path</span><br></pre></td></tr></table></figure></p><p>继续补充 <code>graph.py</code> 代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># graph.py continued</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line">    <span class="keyword">from</span> generic_search <span class="keyword">import</span> bfs, Node, node_to_path</span><br><span class="line">    bfs_result: Optional[Node[V]] = bfs(<span class="string">"Boston"</span>, <span class="keyword">lambda</span> x: x == <span class="string">"Miami"</span>,</span><br><span class="line">                                        city_graph.neighbors_for_vertex)</span><br><span class="line">    <span class="keyword">if</span> bfs_result <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">"No solution found using breadth-first search!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        path: List[V] = node_to_path(bfs_result)</span><br><span class="line">        print(<span class="string">"Path from Boston to Miami:"</span>)</span><br><span class="line">        print(path)</span><br></pre></td></tr></table></figure></p><p><code>bfs()</code> 函数接受三个参数：初始状态、用于检测当前状态是否符合目标状态的 Callable（可调用对象）、用于寻找达成目标状态的路径的 Callable。<br>若需要寻找 Boston 到 Miami 的最短路径（不考虑加权的情况），则初始状态为顶点 “Boston”，用于状态检测的 Callable 则判断当前顶点是否为 “Miami”。</p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Path</span> from Boston to Miami:</span><br><span class="line">['Boston', 'Detroit', 'Washington', 'Miami']</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5aca5a560c6a0105.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="BFS"></p><h4 id="加权图"><a href="#加权图" class="headerlink" title="加权图"></a>加权图</h4><p>之前的计算中，最短路径只考虑经过的站点最少，而未将站点之间的路程计算在内。若需要将路程包含进去，则可以为 edge 加上<strong>权重</strong>来表示该 edge 对应的距离。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-dc49ed8f5b35b7fb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="weight"></p><p>为了实现加权的 graph，需要实现 Edge 的子类 WeightedEdge 以及 Graph 的子类 WeightedGraph。每一个 WeightedEdge 对象都有一个关联的 float 类型的属性用来表示权重。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weighted_edge.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> edge <span class="keyword">import</span> Edge</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedEdge</span><span class="params">(Edge)</span>:</span></span><br><span class="line">    weight: float</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reversed</span><span class="params">(self)</span> -&gt; WeightedEdge:</span></span><br><span class="line">        <span class="keyword">return</span> WeightedEdge(self.v, self.u, self.weight)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># so that we can order edges by weight to find the minimum weight edge</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other: WeightedEdge)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.weight &lt; other.weight</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">f"<span class="subst">&#123;self.u&#125;</span> <span class="subst">&#123;self.weight&#125;</span>&gt; <span class="subst">&#123;self.v&#125;</span>"</span></span><br></pre></td></tr></table></figure></p><p>WeightedEdge 子类添加了一个 <code>weight</code> 属性，通过 <code>__lt__()</code> 方法实现了 <code>&lt;</code> 操作符，令 WeightedEdge 对象成为可比较的，使得返回 weight 最小的 edge 成为可能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weighted_graph.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Generic, List, Tuple</span><br><span class="line"><span class="keyword">from</span> graph <span class="keyword">import</span> Graph</span><br><span class="line"><span class="keyword">from</span> weighted_edge <span class="keyword">import</span> WeightedEdge</span><br><span class="line"></span><br><span class="line">V = TypeVar(<span class="string">'V'</span>)  <span class="comment"># type of the vertices in the graph</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WeightedGraph</span><span class="params">(Generic[V], Graph[V])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, vertices: List[V] = [])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._vertices: List[V] = vertices</span><br><span class="line">        self._edges: List[List[WeightedEdge]] = [[] <span class="keyword">for</span> _ <span class="keyword">in</span> vertices]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge_by_indices</span><span class="params">(self, u: int, v: int, weight: float)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        edge: WeightedEdge = WeightedEdge(u, v, weight)</span><br><span class="line">        self.add_edge(edge)  <span class="comment"># call superclass version</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_edge_by_vertices</span><span class="params">(self, first: V, second: V, weight: float)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        u: int = self._vertices.index(first)</span><br><span class="line">        v: int = self._vertices.index(second)</span><br><span class="line">        self.add_edge_by_indices(u, v, weight)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">neighbors_for_index_with_weights</span><span class="params">(self, index: int)</span> -&gt; List[Tuple[V, float]]:</span></span><br><span class="line">        distance_tuples: List[Tuple[V, float]] = []</span><br><span class="line">        <span class="keyword">for</span> edge <span class="keyword">in</span> self.edges_for_index(index):</span><br><span class="line">            distance_tuples.append((self.vertex_at(edge.v), edge.weight))</span><br><span class="line">        <span class="keyword">return</span> distance_tuples</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        desc: str = <span class="string">""</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(self.vertex_count):</span><br><span class="line">            desc += <span class="string">f"<span class="subst">&#123;self.vertex_at(i)&#125;</span> -&gt; <span class="subst">&#123;self.neighbors_for_index_with_weights(i)&#125;</span>\n"</span></span><br><span class="line">        <span class="keyword">return</span> desc</span><br></pre></td></tr></table></figure><p>WeightedGraph 类继承自 Graph，在原来的基础上对某些需要适应 weight 属性的方法做了对应的修改。</p><p>补充 <code>weighted_graph.py</code> 代码，测试运行效果：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># weighted_graph.py continued</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    city_graph2: WeightedGraph[str] = WeightedGraph([<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>,</span><br><span class="line">                                                     <span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>,</span><br><span class="line">                                                     <span class="string">"Phoenix"</span>, <span class="string">"Chicago"</span>, <span class="string">"Boston"</span>,</span><br><span class="line">                                                     <span class="string">"New York"</span>, <span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>,</span><br><span class="line">                                                     <span class="string">"Dallas"</span>, <span class="string">"Houston"</span>, <span class="string">"Detroit"</span>,</span><br><span class="line">                                                     <span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>])</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"Chicago"</span>, <span class="number">1737</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>, <span class="number">678</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Riverside"</span>, <span class="number">386</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Los Angeles"</span>, <span class="number">348</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>, <span class="number">50</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Phoenix"</span>, <span class="number">357</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Phoenix"</span>, <span class="number">307</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Chicago"</span>, <span class="number">1704</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Dallas"</span>, <span class="number">887</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Houston"</span>, <span class="number">1015</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Chicago"</span>, <span class="number">805</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Atlanta"</span>, <span class="number">721</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Houston"</span>, <span class="number">225</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Atlanta"</span>, <span class="number">702</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Miami"</span>, <span class="number">968</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Chicago"</span>, <span class="number">588</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Washington"</span>, <span class="number">543</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>, <span class="number">604</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Miami"</span>, <span class="string">"Washington"</span>, <span class="number">923</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Chicago"</span>, <span class="string">"Detroit"</span>, <span class="number">238</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Boston"</span>, <span class="number">613</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Washington"</span>, <span class="number">396</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"New York"</span>, <span class="number">482</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Boston"</span>, <span class="string">"New York"</span>, <span class="number">190</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"New York"</span>, <span class="string">"Philadelphia"</span>, <span class="number">81</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>, <span class="number">123</span>)</span><br><span class="line"></span><br><span class="line">    print(city_graph2)</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Seattle -&gt; [('Chicago', <span class="number">1737</span>), ('San Francisco', <span class="number">678</span>)]</span><br><span class="line">San Francisco -&gt; [('Seattle', <span class="number">678</span>), ('Riverside', <span class="number">386</span>), ('Los Angeles', <span class="number">348</span>)]</span><br><span class="line">Los Angeles -&gt; [('San Francisco', <span class="number">348</span>), ('Riverside', <span class="number">50</span>), ('Phoenix', <span class="number">357</span>)]</span><br><span class="line">Riverside -&gt; [('San Francisco', <span class="number">386</span>), ('Los Angeles', <span class="number">50</span>), ('Phoenix', <span class="number">307</span>), ('Chicago', <span class="number">1704</span>)]</span><br><span class="line">Phoenix -&gt; [('Los Angeles', <span class="number">357</span>), ('Riverside', <span class="number">307</span>), ('Dallas', <span class="number">887</span>), ('Houston', <span class="number">1015</span>)]</span><br><span class="line">Chicago -&gt; [('Seattle', <span class="number">1737</span>), ('Riverside', <span class="number">1704</span>), ('Dallas', <span class="number">805</span>), ('Atlanta', <span class="number">588</span>), ('Detroit', <span class="number">238</span>)]</span><br><span class="line">Boston -&gt; [('Detroit', <span class="number">613</span>), ('New York', <span class="number">190</span>)]</span><br><span class="line">New York -&gt; [('Detroit', <span class="number">482</span>), ('Boston', <span class="number">190</span>), ('Philadelphia', <span class="number">81</span>)]</span><br><span class="line">Atlanta -&gt; [('Dallas', <span class="number">721</span>), ('Houston', <span class="number">702</span>), ('Chicago', <span class="number">588</span>), ('Washington', <span class="number">543</span>), ('Miami', <span class="number">604</span>)]</span><br><span class="line">Miami -&gt; [('Houston', <span class="number">968</span>), ('Atlanta', <span class="number">604</span>), ('Washington', <span class="number">923</span>)]</span><br><span class="line">Dallas -&gt; [('Phoenix', <span class="number">887</span>), ('Chicago', <span class="number">805</span>), ('Atlanta', <span class="number">721</span>), ('Houston', <span class="number">225</span>)]</span><br><span class="line">Houston -&gt; [('Phoenix', <span class="number">1015</span>), ('Dallas', <span class="number">225</span>), ('Atlanta', <span class="number">702</span>), ('Miami', <span class="number">968</span>)]</span><br><span class="line">Detroit -&gt; [('Chicago', <span class="number">238</span>), ('Boston', <span class="number">613</span>), ('Washington', <span class="number">396</span>), ('New York', <span class="number">482</span>)]</span><br><span class="line">Philadelphia -&gt; [('New York', <span class="number">81</span>), ('Washington', <span class="number">123</span>)]</span><br><span class="line">Washington -&gt; [('Atlanta', <span class="number">543</span>), ('Miami', <span class="number">923</span>), ('Detroit', <span class="number">396</span>), ('Philadelphia', <span class="number">123</span>)]</span><br></pre></td></tr></table></figure></p><h4 id="在加权图中搜索最短路径"><a href="#在加权图中搜索最短路径" class="headerlink" title="在加权图中搜索最短路径"></a>在加权图中搜索最短路径</h4><p>寻找某个起点城市到另一个城市的所有路线中花费最小的一条，属于单源头最短路径（single-source shortest path）问题，即从加权图中的某个顶点到任意的另外一个顶点的最短路径。</p><p><strong>Dijkstra 算法</strong> 可以用来解决单源头最短路径问题。该算法从某个起始顶点开始，可以找出加权图中所有其他顶点到起始顶点的最短路径。从某个顶点开始按照远近关系依次遍历完所有顶点并记录其总的花费（从起始顶点到当前顶点），若重复出现的顶点花费更小，则令其替换已有的记录。</p><p>具体步骤如下：</p><ul><li>将起始顶点加入到优先级队列中</li><li>从优先级队列中弹出一个顶点（一开始就是起始顶点）作为当前顶点</li><li>查看与当前顶点临近的所有顶点，若某一个之前没有被记录到，或某个顶点按照当前路径的花费低于已有的最小记录，则记录其到起始顶点的距离（作为新的最小记录）及生成该距离的最后一条边（记录路径），并将该顶点 push 到优先级队列中（令其作为之后的“当前”顶点）</li><li>重复前面两步直到优先级队列为空</li><li>返回所有顶点到起始顶点的最小距离及路径</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># priority_queue.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, Generic, List</span><br><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">'T'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span><span class="params">(Generic[T])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self._container: List[T] = []</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">empty</span><span class="params">(self)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">not</span> self._container</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">push</span><span class="params">(self, item: T)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        heappush(self._container, item)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pop</span><span class="params">(self)</span> -&gt; T:</span></span><br><span class="line">        <span class="keyword">return</span> heappop(self._container)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span> -&gt; str:</span></span><br><span class="line">        <span class="keyword">return</span> repr(self._container)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># dijkstra.py</span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> annotations</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> TypeVar, List, Optional, Tuple, Dict</span><br><span class="line"><span class="keyword">from</span> dataclasses <span class="keyword">import</span> dataclass</span><br><span class="line"><span class="keyword">from</span> mst <span class="keyword">import</span> WeightedPath, print_weighted_path</span><br><span class="line"><span class="keyword">from</span> weighted_graph <span class="keyword">import</span> WeightedGraph</span><br><span class="line"><span class="keyword">from</span> weighted_edge <span class="keyword">import</span> WeightedEdge</span><br><span class="line"><span class="keyword">from</span> priority_queue <span class="keyword">import</span> PriorityQueue</span><br><span class="line"></span><br><span class="line">V = TypeVar(<span class="string">'V'</span>)  <span class="comment"># type of the vertices in the graph</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DijkstraNode</span>:</span></span><br><span class="line">    vertex: int</span><br><span class="line">    distance: float</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__lt__</span><span class="params">(self, other: DijkstraNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.distance &lt; other.distance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__eq__</span><span class="params">(self, other: DijkstraNode)</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">return</span> self.distance == other.distance</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dijkstra</span><span class="params">(wg: WeightedGraph[V], root: V)</span> -&gt; Tuple[List[Optional[float]],</span></span><br><span class="line"><span class="function">                                                     Dict[int, WeightedEdge]]:</span></span><br><span class="line">    first: int = wg.index_of(root)</span><br><span class="line">    <span class="comment"># distances are unknown at first</span></span><br><span class="line">    distances: List[Optional[float]] = [<span class="keyword">None</span>] * wg.vertex_count</span><br><span class="line">    distances[first] = <span class="number">0</span>  <span class="comment"># the root is 0 away from the root</span></span><br><span class="line">    path_dict: Dict[int, WeightedEdge] = &#123;&#125;  <span class="comment"># how we got to each vertex</span></span><br><span class="line">    pq: PriorityQueue[DijkstraNode] = PriorityQueue()</span><br><span class="line">    pq.push(DijkstraNode(first, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> pq.empty:</span><br><span class="line">        u: int = pq.pop().vertex  <span class="comment"># explore the next closest vertex</span></span><br><span class="line">        dist_u: float = distances[u]  <span class="comment"># should already have seen it</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># look at every edge/vertex from current vertex</span></span><br><span class="line">        <span class="keyword">for</span> we <span class="keyword">in</span> wg.edges_for_index(u):</span><br><span class="line">            <span class="comment"># the old distance from starting vertex to this vertex</span></span><br><span class="line">            dist_v: float = distances[we.v]</span><br><span class="line">            <span class="comment"># no old distance or found shorter path</span></span><br><span class="line">            <span class="keyword">if</span> dist_v <span class="keyword">is</span> <span class="keyword">None</span> <span class="keyword">or</span> dist_v &gt; we.weight + dist_u:</span><br><span class="line">                <span class="comment"># update distance to this vertex</span></span><br><span class="line">                distances[we.v] = we.weight + dist_u</span><br><span class="line">                <span class="comment"># update the edge on the shortest path to this vertex</span></span><br><span class="line">                path_dict[we.v] = we</span><br><span class="line">                <span class="comment"># explore this vertex soon</span></span><br><span class="line">                pq.push(DijkstraNode(we.v, we.weight + dist_u))</span><br><span class="line">    <span class="keyword">return</span> distances, path_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Helper function to get easier access to dijkstra results</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distance_array_to_vertex_dict</span><span class="params">(wg: WeightedGraph[V], distances:</span></span></span><br><span class="line"><span class="function"><span class="params">                                  List[Optional[float]])</span> -&gt; Dict[V, Optional[float]]:</span></span><br><span class="line">    distance_dict: Dict[V, Optional[float]] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(distances)):</span><br><span class="line">        distance_dict[wg.vertex_at(i)] = distances[i]</span><br><span class="line">    <span class="keyword">return</span> distance_dict</span><br><span class="line"></span><br><span class="line"><span class="comment"># Takes a dictionary of edges to reach each node and returns a list of</span></span><br><span class="line"><span class="comment"># edges that goes from `start` ot `end`</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">path_dict_to_path</span><span class="params">(start: int, end: int, path_dict: Dict[int,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                            WeightedEdge])</span> -&gt; WeightedPath:</span></span><br><span class="line">    <span class="keyword">if</span> len(path_dict) == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    edge_path: WeightedPath = []</span><br><span class="line">    e: WeightedEdge = path_dict[end]</span><br><span class="line">    edge_path.append(e)</span><br><span class="line">    <span class="keyword">while</span> e.u != start:</span><br><span class="line">        e = path_dict[e.u]</span><br><span class="line">        edge_path.append(e)</span><br><span class="line">    <span class="keyword">return</span> list(reversed(edge_path))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    city_graph2: WeightedGraph[str] = WeightedGraph([<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>,</span><br><span class="line">                                                     <span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>,</span><br><span class="line">                                                     <span class="string">"Phoenix"</span>, <span class="string">"Chicago"</span>, <span class="string">"Boston"</span>,</span><br><span class="line">                                                     <span class="string">"New York"</span>, <span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>,</span><br><span class="line">                                                     <span class="string">"Dallas"</span>, <span class="string">"Houston"</span>, <span class="string">"Detroit"</span>,</span><br><span class="line">                                                     <span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>])</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"Chicago"</span>, <span class="number">1737</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Seattle"</span>, <span class="string">"San Francisco"</span>, <span class="number">678</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Riverside"</span>, <span class="number">386</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"San Francisco"</span>, <span class="string">"Los Angeles"</span>, <span class="number">348</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Riverside"</span>, <span class="number">50</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Los Angeles"</span>, <span class="string">"Phoenix"</span>, <span class="number">357</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Phoenix"</span>, <span class="number">307</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Riverside"</span>, <span class="string">"Chicago"</span>, <span class="number">1704</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Dallas"</span>, <span class="number">887</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Phoenix"</span>, <span class="string">"Houston"</span>, <span class="number">1015</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Chicago"</span>, <span class="number">805</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Atlanta"</span>, <span class="number">721</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Dallas"</span>, <span class="string">"Houston"</span>, <span class="number">225</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Atlanta"</span>, <span class="number">702</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Houston"</span>, <span class="string">"Miami"</span>, <span class="number">968</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Chicago"</span>, <span class="number">588</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Washington"</span>, <span class="number">543</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Atlanta"</span>, <span class="string">"Miami"</span>, <span class="number">604</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Miami"</span>, <span class="string">"Washington"</span>, <span class="number">923</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Chicago"</span>, <span class="string">"Detroit"</span>, <span class="number">238</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Boston"</span>, <span class="number">613</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"Washington"</span>, <span class="number">396</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Detroit"</span>, <span class="string">"New York"</span>, <span class="number">482</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Boston"</span>, <span class="string">"New York"</span>, <span class="number">190</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"New York"</span>, <span class="string">"Philadelphia"</span>, <span class="number">81</span>)</span><br><span class="line">    city_graph2.add_edge_by_vertices(<span class="string">"Philadelphia"</span>, <span class="string">"Washington"</span>, <span class="number">123</span>)</span><br><span class="line">    distances, path_dict = dijkstra(city_graph2, <span class="string">"Los Angeles"</span>)</span><br><span class="line">    name_distance: Dict[str, Optional[int]] = distance_array_to_vertex_dict(city_graph2, distances)</span><br><span class="line">    print(<span class="string">"Distances from Los Angeles:"</span>)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> name_distance.items():</span><br><span class="line">        print(<span class="string">f"<span class="subst">&#123;key&#125;</span> : <span class="subst">&#123;value&#125;</span>"</span>)</span><br><span class="line">    print(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"Shortest path from Los Angelges to Boston:"</span>)</span><br><span class="line">    path: WeightedPath = path_dict_to_path(city_graph2.index_of(<span class="string">"Los Angeles"</span>),</span><br><span class="line">                                           city_graph2.index_of(<span class="string">"Boston"</span>), path_dict)</span><br><span class="line">    print_weighted_path(city_graph2, path)</span><br></pre></td></tr></table></figure><p>运行结果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Distances from Los Angeles:</span><br><span class="line">Seattle : <span class="number">1026</span></span><br><span class="line">San Francisco : <span class="number">348</span></span><br><span class="line">Los Angeles : <span class="number">0</span></span><br><span class="line">Riverside : <span class="number">50</span></span><br><span class="line">Phoenix : <span class="number">357</span></span><br><span class="line">Chicago : <span class="number">1754</span></span><br><span class="line">Boston : <span class="number">2605</span></span><br><span class="line">New York : <span class="number">2474</span></span><br><span class="line">Atlanta : <span class="number">1965</span></span><br><span class="line">Miami : <span class="number">2340</span></span><br><span class="line">Dallas : <span class="number">1244</span></span><br><span class="line">Houston : <span class="number">1372</span></span><br><span class="line">Detroit : <span class="number">1992</span></span><br><span class="line">Philadelphia : <span class="number">2511</span></span><br><span class="line">Washington : <span class="number">2388</span></span><br><span class="line"></span><br><span class="line">Shortest <span class="built_in">path</span> from Los Angelges to Boston:</span><br><span class="line">Los Angeles <span class="number">50</span>&gt; Riverside</span><br><span class="line">Riverside <span class="number">1704</span>&gt; Chicago</span><br><span class="line">Chicago <span class="number">238</span>&gt; Detroit</span><br><span class="line">Detroit <span class="number">613</span>&gt; Boston</span><br><span class="line">Total Weight: <span class="number">2605</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/classic-computer-science-problems-in-python" target="_blank" rel="noopener">Classic Computer Science Problems in Python</a><br><a href="https://github.com/davecom/ClassicComputerScienceProblemsInPython" target="_blank" rel="noopener">davecom/ClassicComputerScienceProblemsInPython</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;图（Graph）&lt;/strong&gt;是一种用来对某些现实问题进行建模的抽象的数学结构，这些问题从逻辑上可以被划分成一系列相互连接的&lt;strong&gt;节点&lt;/strong&gt;。其中的节点称为&lt;strong&gt;顶点&lt;/strong&gt;（&lt;em&gt;vertex&lt;/em&gt;），顶
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Algorithm" scheme="https://rollingstarky.github.io/tags/Algorithm/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Graph" scheme="https://rollingstarky.github.io/tags/Graph/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式——反模式</title>
    <link href="https://rollingstarky.github.io/2021/02/03/python-design-patterns-anti-pattern/"/>
    <id>https://rollingstarky.github.io/2021/02/03/python-design-patterns-anti-pattern/</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-02-03T12:33:26.537Z</updated>
    
    <content type="html"><![CDATA[<p>软件设计模式提供了一套规则或标准，能够帮助开发人员在设计层面进行决策。不良的设计主要表现在四个方面：</p><ul><li>不动性：开发的应用程序非常难以重用</li><li>刚性：任何小的更改需求都会导致软件的太多部分必须进行相应的改动，牵一发而动全身</li><li>脆弱性：应用程序的任何更改都会导致现有系统变得非常容易崩溃</li><li>粘滞性：由于架构层面的修改非常困难，修改必须由开发人员在代码层面或环境本身中进行</li></ul><h4 id="软件开发反模式"><a href="#软件开发反模式" class="headerlink" title="软件开发反模式"></a>软件开发反模式</h4><p>在软件开发过程中，往往会偏离最初的代码结构，原因一般有：</p><ul><li>开发人员的想法会随着开发过程的推进而发生变化</li><li>用例通常会随着客户的反馈而进行更改</li><li>最初设计的数据结构可能会随功能或可伸缩性等方面的考虑而发生变化</li></ul><p>基于上述原因，软件通常需要进行重构。</p><p><strong>意大利面条式代码</strong></p><p>典型成因包括：</p><ul><li>对面向对象编程和分析的无知</li><li>没有考虑产品的架构或设计</li><li>快餐式思维</li></ul><p>问题：</p><ul><li>结构的重用性会降到最低</li><li>维护工作量过高</li><li>进行修改时，扩展性和灵活性会降低</li></ul><p><strong>金锤</strong></p><p>金锤的意思是一把锤子搞定所有的钉子（解决所有问题）。软件开发人员或团队通常会有一种倾向，一头扎进一个成熟的解决方案，而不管其是否满足适用性。</p><p>典型成因：</p><ul><li>来自不了解具体问题的高层的建议</li><li>某解决方案在过去多次验证有效，但当前项目有不同的背景和要求</li><li>公司已被这种技术“绑架”，或员工们因为顺手对这种技术情有独钟</li></ul><p>金锤的影响：</p><ul><li>痴迷于一个解决方案，并把它应用于所有软件项目</li><li>不是通过功能，而是通过开发中使用的技术来描述产品</li><li>没有满足需求，造成与用户的预期不符</li></ul><p><strong>熔岩流</strong></p><p>熔岩流与软件应用中的死代码或一段用不到的代码有关，人们害怕一旦对其进行修改就会破坏其他东西。随着时间的流逝，这段代码会一直留在软件中并固化其位置，就像熔岩变成硬岩一样。</p><p>熔岩流的成因：</p><ul><li>在产品中有大量的试错代码</li><li>由一个人单独编写的代码，未经审查的情况下移交给了其他开发团队</li><li>软件架构或设计的初始思想是通过代码库实现的，但没有人能理解</li></ul><p>熔岩流的症状：</p><ul><li>开发的测试工作具有很低的代码覆盖率</li><li>代码中含有莫名其妙的注释</li><li>过时的接口，或开发人员需要围绕既有代码展开工作</li></ul><p><strong>复制粘贴式编程</strong></p><p>原因：</p><ul><li>新手开发者不习惯编写代码或不知道如何开发</li><li>快速修复 bug 或急就章式的开发</li><li>代码重复，无法满足跨模块标准化以及代码结构化的要求</li><li>缺乏长远打算或深谋远虑</li></ul><p>后果：</p><ul><li>多个软件应用存在同种类型的问题</li><li>维护成本更高，bug 的生命周期也会变得更长</li><li>较少的模块化代码库，相同的代码会散落于多处</li><li>继承问题</li></ul><h4 id="软件架构反模式"><a href="#软件架构反模式" class="headerlink" title="软件架构反模式"></a>软件架构反模式</h4><p><strong>重新发明轮子</strong></p><p>原因：</p><ul><li>缺乏中央文档或存储库来讲解架构级问题和存放已实现的解决方案</li><li>社区或公司内的技术领袖之间缺乏沟通</li><li>组织中遵循的流程是从头开始构建的</li></ul><p>后果：</p><ul><li>解决一个标准问题的方案太多，其中有许多考虑得并不周全</li><li>会耗费工程团队更多的时间和资源，导致预算超标，完成时间延后</li><li>封闭的系统架构、重复劳动和糟糕的风险管理</li></ul><p><strong>供应商套牢</strong></p><p>原因：</p><ul><li>熟悉供应商公司的权威人士以及技术采购的可能折扣</li><li>基于营销和销售业务人员而不是技术评估选择的技术</li><li>在当前项目中使用经过验证的技术，即使它不适合当前项目的需要</li><li>技术人员已经接受过相关技术的培训</li></ul><p>后果：</p><ul><li>公司产品的发布周期和维护周期直接取决于供应商的发布时间</li><li>该产品是围绕该技术而不是根据客户的要求开放的</li><li>产品上市时间不可靠，不能满足客户的期望</li></ul><p><strong>委员会设计</strong></p><p>原因：</p><ul><li>根据组织的流程，产品的架构或设计是由众多的利益相关者批准的</li><li>没有指定单独的联系人或负责设计的架构师</li><li>由营销或技术专家确定设计优先级，而不是客户反馈</li></ul><p>症状：</p><ul><li>开发人员和架构师之间的观点冲突，即使在设计完成后依旧如此</li><li>过于复杂的设计，很难记录</li><li>规格或设计的任何改动都需要经过多次审查，导致实现延迟</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;软件设计模式提供了一套规则或标准，能够帮助开发人员在设计层面进行决策。不良的设计主要表现在四个方面：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不动性：开发的应用程序非常难以重用&lt;/li&gt;
&lt;li&gt;刚性：任何小的更改需求都会导致软件的太多部分必须进行相应的改动，牵一发而动全身&lt;/li&gt;
&lt;
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
  </entry>
  
  <entry>
    <title>基本算法问题的 Python 解法——约束满足问题（CSP）</title>
    <link href="https://rollingstarky.github.io/2021/02/03/classic-compute-problems-with-python-constraint-satisfaction-problems/"/>
    <id>https://rollingstarky.github.io/2021/02/03/classic-compute-problems-with-python-constraint-satisfaction-problems/</id>
    <published>2021-02-02T16:00:00.000Z</published>
    <updated>2021-02-03T12:39:37.488Z</updated>
    
    <content type="html"><![CDATA[<p>由计算工具解决的很大一部分问题都可以归类为<strong>约束满足问题（CSPs, constraint-satisfaction problems）</strong>。CSP 一般包含三个基本概念：<strong>变量（variables）</strong>、<strong>域（domains）</strong>和<strong>约束条件（constraints）</strong>。</p><p>比如需要在星期五为 Joe、Mary、Sue 三个人安排一场会议，要求 Sue 必须和另外的至少一个人同时在场。针对此问题：</p><ul><li>Joe、Mary、Sue 三个人即为变量（variables）</li><li>每个人（变量）各自空闲的时间点即为对应的域（domains）。比如变量 Mary 在下午 2 点和 3 点的时候有空，这两个时间点即为变量 Mary 对应的域</li><li>约束条件（constraints）有两点：Sue 必须在场；除 Sue 以外至少还需要另一人到场</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-7d5dcdd81b242fa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="约会问题是非常经典的约束满足问题"></p><h4 id="构建-CSP-框架"><a href="#构建-CSP-框架" class="headerlink" title="构建 CSP 框架"></a>构建 CSP 框架</h4><p>约束条件通过 <code>Constraint</code> 类实现。该类中包含被约束的变量以及测试其是否满足约束的 <code>satisfied()</code> 方法。确定是否满足约束条件是针对某个特定的 CSP 的核心逻辑，该 <code>satisfied()</code> 方法必须为抽象方法，由子类覆盖后发挥实际作用，以满足不同问题的不同约束条件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csp.py</span></span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Generic, TypeVar, Dict, List, Optional</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line">V = TypeVar(<span class="string">'V'</span>)  <span class="comment"># variable type</span></span><br><span class="line"></span><br><span class="line">D = TypeVar(<span class="string">'D'</span>)  <span class="comment"># domain type</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Constraint</span><span class="params">(Generic[V, D], ABC)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, variables: List[V])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.variables = variables</span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">satisfied</span><span class="params">(self, assignment: Dict[V, D])</span> -&gt; bool:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure></p><p>约束满足框架的核心部分代码是 <code>CSP</code> 类，该类集中处理变量、域和约束条件。CSP 的类型使用 Generic，目的是使其足够灵活，能够处理各种类型的 variables 和 domains。其中 variables 是 list 类型，domains 是由 variable 和对应的 list （所有可能的值）关联成的 dict 类型，constraints 则是由 variable 和对应的 list（约束条件列表）关联成的 dict 类型。</p><p><code>__init__()</code> 初始化方法会创建 <code>constraints</code> 字典，将 variables 中的值作为键，每个键关联一个空列表。<code>add_constraint()</code> 方法遍历 variables 中的值（同时也是 <code>constraints</code> 中的键），将对应的 constraint 添加到 <code>constraints</code> 字典的该 variable 键关联的列表中。<br>从而完成对 variables、domains、constraints 三类数据的初始化。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csp.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CSP</span><span class="params">(Generic[V, D])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, variables: List[V], domains: Dict[V, List[D]])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        self.variables = variables</span><br><span class="line">        self.domains = domains</span><br><span class="line">        self.constraints: Dict[V, List[Constraint[V, D]]] = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> variable <span class="keyword">in</span> self.variables:</span><br><span class="line">            self.constraints[variable] = []</span><br><span class="line">            <span class="keyword">if</span> variable <span class="keyword">not</span> <span class="keyword">in</span> self.domains:</span><br><span class="line">                <span class="keyword">raise</span> LookupError(<span class="string">"Every variable should have a domain assigned to it"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_constraint</span><span class="params">(self, constraint: Constraint[V, D])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="keyword">for</span> variable <span class="keyword">in</span> constraint.variables:</span><br><span class="line">            <span class="keyword">if</span> variable <span class="keyword">not</span> <span class="keyword">in</span> self.variables:</span><br><span class="line">                <span class="keyword">raise</span> LookupError(<span class="string">"Variable in constraint not in CSP"</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.constraints[variable].append(constraint)</span><br></pre></td></tr></table></figure></p><p><code>consistent()</code> 方法用于检查给定的 variable 对应的每一个约束条件是否一一符合当前预设的方案。这个临时的方案用 assignment 表示。<br>即先有某个 variable，然后为其选择对应的 domain 中的任意一个值作为临时的 assignment，再检查该 assignment 是否符合对应的 variable 关联的所有约束条件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># csp.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consistent</span><span class="params">(self, variable: V, assignment: Dict[V, D])</span> -&gt; bool:</span></span><br><span class="line">    <span class="keyword">for</span> constraint <span class="keyword">in</span> self.constraints[variable]:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> constraint.satisfied(assignment):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure></p><p>约束满足框架还需要一个简单的 <em>backtracking</em> 搜索用于查找问题的解决方案。Backtracking 意味着一旦在搜索路径的某个节点上终止，则返回到上一个已知的搜索节点，选择另一条搜索路径。有点类似于<strong>深度优先</strong>搜索（<strong>DFS, depth-first search</strong>）。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtracking_search</span><span class="params">(self, assignment: Dict[V, D] = &#123;&#125;)</span> -&gt; Optional[Dict[V, D]]:</span></span><br><span class="line">    <span class="comment"># assignment is complete if every variable is assigned</span></span><br><span class="line">    <span class="keyword">if</span> len(assignment) == len(self.variables):</span><br><span class="line">        <span class="keyword">return</span> assignment</span><br><span class="line"></span><br><span class="line">    <span class="comment"># get all variables in the CSP but not in the assignment</span></span><br><span class="line">    unassigned: List[V] = [v <span class="keyword">for</span> v <span class="keyword">in</span> self.variables <span class="keyword">if</span> v <span class="keyword">not</span> <span class="keyword">in</span> assignment]</span><br><span class="line">    first: V = unassigned[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> self.domains[first]:</span><br><span class="line">        local_assignment = assignment.copy()</span><br><span class="line">        local_assignment[first] = value</span><br><span class="line">        <span class="keyword">if</span> self.consistent(first, local_assignment):</span><br><span class="line">            result: Optional[Dict[V, D]] = self.backtracking_search(local_assignment)</span><br><span class="line">            <span class="keyword">if</span> result <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure></p><p>逐条分析以上代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">if len(assignment) == len(self.variables):</span><br><span class="line">    return assignment</span><br></pre></td></tr></table></figure></p><p>上面的 backtracking 搜索采用了<strong>递归</strong>的形式，此 <code>if</code> 语句则提供了一种递归的终止条件。即当所有 variable 都被赋予了合法的值时，意味着其中一种搭配方案已被找到，则停止进一步的搜索，返回该搭配方案。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unassigned: List[V] = [v for v in self.variables if v not in assignment]</span><br><span class="line">first: V = unassigned[0]</span><br></pre></td></tr></table></figure><p>取出 variables 中第一个还未被赋值（未做选择）的 variable，作为下一步中进行赋值（做决定）和约束条件测试的对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if self.consistent(first, local_assignment):</span><br><span class="line">    result: Optional[Dict[V, D]] = self.backtracking_search(local_assignment)</span><br><span class="line">    if result is not None:</span><br><span class="line">        return result</span><br></pre></td></tr></table></figure><p>为前面未赋值的某个 variable “做决定”。将对应的 domain 中所有存在的值依次赋值给该 variable，形成一个新的方案（local_assignment）。若该方案符合所有的约束条件（通过 <code>consistent()</code> 方法检测），则借助递归进行下一轮对另一个 variable 的赋值，直到触发终止条件（所有 variable 都被赋值）。</p><p><code>return None</code></p><p>若针对某个特定的 variable，已经检查完 domain 中包含的所有可能的值，仍没有找到符合要求的方案，则返回 <code>None</code> 表示没有解决。这会导致 backtracking 搜索结束本轮 <code>for</code> 循环，返回到递归的上一层中的 <code>for</code> 循环，尝试为上一步中已赋值的 variable 做出不同的决定，并继续递归（或回溯）下去。</p><h4 id="地图上色问题"><a href="#地图上色问题" class="headerlink" title="地图上色问题"></a>地图上色问题</h4><p>假如有一张澳大利亚地图，需要按州进行上色。要求所有相邻的州不能有相同的颜色。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-bc114087e7adbbc7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="地图上色问题的一种解决方案"></p><p>借助前面构建的约束符合框架，实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map_coloring.py</span></span><br><span class="line"><span class="keyword">from</span> csp <span class="keyword">import</span> Constraint, CSP</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List, Optional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MapColoringConstraint</span><span class="params">(Constraint[str, str])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, place1: str, place2: str)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        super().__init__([place1, place2])</span><br><span class="line">        self.place1 = place1</span><br><span class="line">        self.place2 = place2</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">satisfied</span><span class="params">(self, assignment: Dict[str, str])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># if either place is not in the assignment, then it is not</span></span><br><span class="line">        <span class="comment"># yet possible for their colors to be conflicting</span></span><br><span class="line">        <span class="keyword">if</span> self.place1 <span class="keyword">not</span> <span class="keyword">in</span> assignment <span class="keyword">or</span> self.place2 <span class="keyword">not</span> <span class="keyword">in</span> assignment:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="comment"># check the color assigned to place1 is not the same as the</span></span><br><span class="line">        <span class="comment"># color assigned to place2</span></span><br><span class="line">        <span class="keyword">return</span> assignment[self.place1] != assignment[self.place2]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    variables: List[str] = [<span class="string">"Western Australia"</span>, <span class="string">"Northern Territory"</span>, <span class="string">"South Australia"</span>,</span><br><span class="line">                            <span class="string">"Queensland"</span>, <span class="string">"New South Wales"</span>, <span class="string">"Victoria"</span>, <span class="string">"Tasmania"</span>]</span><br><span class="line">    domains: Dict[str, List[str]] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> variable <span class="keyword">in</span> variables:</span><br><span class="line">        domains[variable] = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>]</span><br><span class="line">    csp: CSP[str, str] = CSP(variables, domains)</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Western Australia"</span>, <span class="string">"Northern Territory"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Western Australia"</span>, <span class="string">"South Australia"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"South Australia"</span>, <span class="string">"Northern Territory"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Queensland"</span>, <span class="string">"Northern Territory"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Queensland"</span>, <span class="string">"South Australia"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Queensland"</span>, <span class="string">"New South Wales"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"New South Wales"</span>, <span class="string">"South Australia"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Victoria"</span>, <span class="string">"South Australia"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Victoria"</span>, <span class="string">"New South Wales"</span>))</span><br><span class="line">    csp.add_constraint(MapColoringConstraint(<span class="string">"Victoria"</span>, <span class="string">"Tasmania"</span>))</span><br><span class="line"></span><br><span class="line">    solution: Optional[Dict[str, str]] = csp.backtracking_search()</span><br><span class="line">    <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">"No solution found"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(solution)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; &#123;'Western Australia': 'red', 'Northern Territory': 'green', 'South</span></span><br><span class="line"><span class="comment"># Australia': 'blue', 'Queensland': 'red', 'New South Wales': 'green',</span></span><br><span class="line"><span class="comment"># 'Victoria': 'red', 'Tasmania': 'green'&#125;</span></span><br></pre></td></tr></table></figure></p><p>简单梳理一下程序逻辑：</p><p>在上述 CSP 中，地图中的 7 个州即为 variables（为方便，以 a、b、c、d、e、f、g 代替）<br><code>variables = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;]</code></p><p>每个州都可以涂成红绿蓝三种颜色（假设用 1、2、3 指代）中的任何一种，各 variable 对应的所有颜色即组成对应 variable 的 domain：<br><code>domains = {&#39;a&#39;: [1, 2, 3], &#39;b&#39;: [1, 2, 3], &#39;c&#39;: [1, 2, 3], &#39;d&#39;: [1, 2, 3], &#39;e&#39;: [1, 2, 3], &#39;f&#39;: [1, 2, 3], &#39;g&#39;: [1, 2, 3]}</code></p><p>constraints 的逻辑在 MapColoringConstraints 类中实现，即已经涂色的相邻的两个州色彩须不一致。比如 a 与 b 相邻，则该 constraint 的表示如下：<br><code>MapColoringConstraint(&#39;a&#39;, &#39;b&#39;)</code><br>而所有的 constraints 都会关联到对应的以 variable 为键的字典中。即若 a 同时与 b 和 c 相邻，则变量 a 的 constraints 表示为：<br><code>{&#39;a&#39;: [MapColoringConstraint(&#39;a&#39;, &#39;b&#39;), MapColoringConstraint(&#39;a&#39;, &#39;c&#39;)]}</code></p><p><code>backtrack_search()</code> 方法的执行流程为：</p><ul><li>在 variables 中取第一个未被赋值（涂色）的 variable，为其赋予对应 domain 中的某个数值作为临时方案</li><li>用该 variable 对应的所有 constraints 测试上述临时方案的可行性。若符合要求，则借助递归开启下一轮循环，继续为另一个未被赋值（涂色）的 variable 赋值</li><li>若不符合要求，则继续本轮循环，为本 variable 赋予 domain 中的另一个值</li><li>若对应 domain 中的所有值赋予 variable 后都不能符合约束要求，则返回 None。本轮循环结束，回到递归的上一轮继续循环，为上一轮中已赋值的 variable 赋予不同的值，延续递归操作</li><li>若所有 variable 都已被赋值，则返回 variable 及其对应的值作为最终的解决方案；若所有循环（递归/回溯）结束，返回结果最终为 None，则表示无法找到合理的解决方案</li></ul><h4 id="国际象棋的八王后问题"><a href="#国际象棋的八王后问题" class="headerlink" title="国际象棋的八王后问题"></a>国际象棋的八王后问题</h4><p>国际象棋的棋盘由 8x8 的方格组成，棋子落于方格上。而棋子王后能够吃掉处于同一行、同一列、同一斜线上的任何一个敌方棋子。<br>八王后问题是指需要将 8 个王后放置到国际象棋棋盘上且彼此之间不会产生冲突（即不会有任意两枚棋子位于同一行、同一列或者同一斜线上）。</p><p>其中一种可能的解决方案如下图：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-9424bba1dc8714d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="eight queens"></p><p>实现代码如下：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> csp <span class="keyword">import</span> Constraint, CSP</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Dict, List, Optional</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">QueensConstraint</span><span class="params">(Constraint[int, int])</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, columns: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        super().__init__(columns)</span><br><span class="line">        self.columns = columns</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">satisfied</span><span class="params">(self, assignment: Dict[int, int])</span> -&gt; bool:</span></span><br><span class="line">        <span class="comment"># q1c = queen 1 column, q1r = queen 1 row</span></span><br><span class="line">        <span class="keyword">for</span> q1c, q1r <span class="keyword">in</span> assignment.items():</span><br><span class="line">            <span class="comment"># q2c = queen 2 column</span></span><br><span class="line">            <span class="keyword">for</span> q2c <span class="keyword">in</span> range(q1c + <span class="number">1</span>, len(self.columns) + <span class="number">1</span>):</span><br><span class="line">                <span class="keyword">if</span> q2c <span class="keyword">in</span> assignment:</span><br><span class="line">                    q2r = assignment[q2c]</span><br><span class="line">                    <span class="keyword">if</span> q1r == q2r:  <span class="comment"># same row?</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                    <span class="keyword">if</span> abs(q1r - q2r) == abs(q1c - q2c):  <span class="comment"># same diagonal?</span></span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    columns: List[int] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    rows: Dict[int, List[int]] = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> column <span class="keyword">in</span> columns:</span><br><span class="line">        rows[column] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">    csp: CSP[int, int] = CSP(columns, rows)</span><br><span class="line"></span><br><span class="line">    csp.add_constraint(QueensConstraint(columns))</span><br><span class="line">    solution: Optional[Dict[int, int]] = csp.backtracking_search()</span><br><span class="line">    <span class="keyword">if</span> solution <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        print(<span class="string">"No solution found!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(solution)</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; &#123;1: 1, 2: 5, 3: 8, 4: 6, 5: 3, 6: 7, 7: 2, 8: 4&#125;</span></span><br></pre></td></tr></table></figure></p><p>简单解释下 <code>satisfied()</code> 方法中的两个 <code>for</code> 循环。<code>assignment</code> 采用类似 <code>{1: 1, 2: 5, 3: 8, 4: 6, 5: 3, 6: 7, 7: 2, 8: 4}</code> 的字典类型（一开始会短一些），上述两个 <code>for</code> 循环的作用在于，先以棋盘上的第一列为标准，若第一列与剩余的几列不存在冲突，则去掉第一列，再比较第二列与剩余的几列是否存在冲突，以此类推。一旦出现任何冲突，则返回 False。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/classic-computer-science-problems-in-python" target="_blank" rel="noopener">Classic Computer Science Problems in Python</a><br><a href="https://github.com/davecom/ClassicComputerScienceProblemsInPython" target="_blank" rel="noopener">davecom/ClassicComputerScienceProblemsInPython</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由计算工具解决的很大一部分问题都可以归类为&lt;strong&gt;约束满足问题（CSPs, constraint-satisfaction problems）&lt;/strong&gt;。CSP 一般包含三个基本概念：&lt;strong&gt;变量（variables）&lt;/strong&gt;、&lt;stron
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="DataStructure" scheme="https://rollingstarky.github.io/tags/DataStructure/"/>
    
      <category term="Algorithm" scheme="https://rollingstarky.github.io/tags/Algorithm/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="CSP" scheme="https://rollingstarky.github.io/tags/CSP/"/>
    
  </entry>
  
  <entry>
    <title>Python 设计模式——模板方法模式</title>
    <link href="https://rollingstarky.github.io/2020/12/29/python-design-patterns-template-pattern/"/>
    <id>https://rollingstarky.github.io/2020/12/29/python-design-patterns-template-pattern/</id>
    <published>2020-12-28T16:00:00.000Z</published>
    <updated>2020-12-29T11:32:16.699Z</updated>
    
    <content type="html"><![CDATA[<p>行为模式主要关注对象的响应性，处理对象之间的交互以实现更强大的功能。模板方法模式即为一种行为设计模式。<br>比如可以将制作饮料的步骤定义为模板方法中的算法，子类就能使用模板方法来实现沏茶的步骤。且步骤的改变（即子类的具体实现）并不会影响原始算法的结构。这样模板方法模式中的子类就可以通过覆盖来创建不同的行为。</p><p>模板方法模式适用于以下场景：</p><ul><li>当多个算法或类实现类似或相同逻辑的时候</li><li>在子类中实现算法有助于减少重复代码的时候</li><li>子类可以通过覆盖实现多种不同行为的时候</li></ul><p>模板方法模式的主要意图：</p><ul><li>使用基本操作定义算法的框架</li><li>重新定义子类的某些操作，无需修改算法的结构</li><li>实现代码重用并避免重复工作</li><li>利用通用接口或功能实现</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e01622b62200ad45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML"></p><ul><li>AbstractClass：在抽象方法的帮助下定义算法的操作或步骤。这些步骤将被具体的子类覆盖</li><li>template_method()：定义算法的框架。在模板方法中调用抽象方法定义的步骤以形成序列或算法</li><li>ConcreteClass：实现需要算法子类关注的特定步骤</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compiler</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collectSource</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compileToObject</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compileAndRun</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.collectSource()</span><br><span class="line">        self.compileToObject()</span><br><span class="line">        self.run()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iOSCompiler</span><span class="params">(Compiler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">collectSource</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Collecting Swift Source Code"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compileToObject</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Compiling Swift code to LLVM bitcode"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Program runing on runtime environment"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">iOS = iOSCompiler()</span><br><span class="line">iOS.compileAndRun()</span><br><span class="line"><span class="comment"># =&gt; Collecting Swift Source Code</span></span><br><span class="line"><span class="comment"># =&gt; Compiling Swift code to LLVM bitcode</span></span><br><span class="line"><span class="comment"># =&gt; Program runing on runtime environment</span></span><br></pre></td></tr></table></figure><h4 id="现实中的模板方法模式"><a href="#现实中的模板方法模式" class="headerlink" title="现实中的模板方法模式"></a>现实中的模板方法模式</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> abstractmethod, ABCMeta</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trip</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setTransport</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day2</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day3</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">returnHome</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">itinerary</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.setTransport()</span><br><span class="line">        self.day1()</span><br><span class="line">        self.day2()</span><br><span class="line">        self.day3()</span><br><span class="line">        self.returnHome()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VeniceTrip</span><span class="params">(Trip)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setTransport</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Take a boat and find your way in the Grand Canal"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Visit St Mark's Basilica in St Mark's Square"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Appreciate Doge's Palace"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day3</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Enjoy the food near the Rialto Bridge"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">returnHome</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Get souovenirs for friends and get back"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaldivesTrip</span><span class="params">(Trip)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setTransport</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"On foot, on any island, Wow!"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day1</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Enjoy the marine life of Banana Reef"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day2</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Go for the water sports and snorkelling"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">day3</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Relax on the beach and enjoy the sun"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">returnHome</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"Don't feel like leaving the beach.."</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TravelAgency</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">arrange_trip</span><span class="params">(self)</span>:</span></span><br><span class="line">        choice = input(<span class="string">"What kind of place you'd like to go historical or to a beach? "</span>)</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">'historical'</span>:</span><br><span class="line">            self.trip = VeniceTrip()</span><br><span class="line">            self.trip.itinerary()</span><br><span class="line">        <span class="keyword">if</span> choice == <span class="string">'beach'</span>:</span><br><span class="line">            self.trip = MaldivesTrip()</span><br><span class="line">            self.trip.itinerary()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">TravelAgency().arrange_trip()</span><br><span class="line"></span><br><span class="line"><span class="comment"># =&gt; What kind of place you'd like to go historical or to a beach? beach</span></span><br><span class="line"><span class="comment"># =&gt; On foot, on any island, Wow!</span></span><br><span class="line"><span class="comment"># =&gt; Enjoy the marine life of Banana Reef</span></span><br><span class="line"><span class="comment"># =&gt; Go for the water sports and snorkelling</span></span><br><span class="line"><span class="comment"># =&gt; Relax on the beach and enjoy the sun</span></span><br><span class="line"><span class="comment"># =&gt; Don't feel like leaving the beach..</span></span><br></pre></td></tr></table></figure><ul><li>抽象类 Trip 是一个接口，定义了不同日子使用的交通方式和参观地点等细节</li><li>setTransport 是一个抽象方法，由 ConcreteClass 实现，作用是设置交通方式</li><li>day1()、day2()、day3() 抽象方法定义了特定日期所参观的地点</li><li>itinerary() 模板方法则用于创建完整的行程</li><li>VeniceTrip 类和 MaldivesTrip 类是 Trip 接口的具体实现</li></ul><h4 id="模板方法的优点和缺点"><a href="#模板方法的优点和缺点" class="headerlink" title="模板方法的优点和缺点"></a>模板方法的优点和缺点</h4><p>优点：</p><ul><li>没有代码重复</li><li>使用继承而不是合成，只有为数不多的几个方法需要重写</li><li>灵活性，允许子类决定如何实现算法中的步骤</li></ul><p>缺点：</p><ul><li>调试和理解模板方法模式中的流程序列时可能会令人困惑</li><li>模板框架的维护可能是一个问题，任何层次（底层或高层）的变更都可能对实现造成干扰</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;行为模式主要关注对象的响应性，处理对象之间的交互以实现更强大的功能。模板方法模式即为一种行为设计模式。&lt;br&gt;比如可以将制作饮料的步骤定义为模板方法中的算法，子类就能使用模板方法来实现沏茶的步骤。且步骤的改变（即子类的具体实现）并不会影响原始算法的结构。这样模板方法模式中的
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Advanced" scheme="https://rollingstarky.github.io/tags/Advanced/"/>
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Development" scheme="https://rollingstarky.github.io/tags/Development/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
  </entry>
  
</feed>
