<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>StarryLand</title>
  
  <subtitle>我的全部道路，就是从孤独走向人间</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://rollingstarky.github.io/"/>
  <updated>2023-06-19T12:30:35.207Z</updated>
  <id>https://rollingstarky.github.io/</id>
  
  <author>
    <name>星舞</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Automated Placement</title>
    <link href="https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-automated-placement/"/>
    <id>https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-automated-placement/</id>
    <published>2023-06-18T16:00:00.000Z</published>
    <updated>2023-06-19T12:30:35.207Z</updated>
    
    <content type="html"><![CDATA[<p><em>Automated Placement</em> 是 Kubernetes 中 scheduler 的核心功能，负责将新的 Pod 分配给合适的节点，满足容器的资源需求，同时遵守设定好的调度策略。</p><p>基于微服务的系统通常会包含数十个甚至数百个隔离的进程，容器和 Pod 为它们提供了很好的打包和部署机制，但并没有解决将众多的进程分配给适当的节点这项工作。<br>容器之间存在依赖关系，有些还需要关联到特定的节点，容器自身也有一定的资源需求。这些都会随着时间发生变化。同时集群本身的资源也不是恒定的，它会执行缩容或者扩容，其特定时刻下的容量也取决于已经放置的容器数量。<br>这些因素都会左右容器的调度。</p><h4 id="Available-Node-Resources"><a href="#Available-Node-Resources" class="headerlink" title="Available Node Resources"></a>Available Node Resources</h4><p>首先需要考虑的就是节点上是否有足够的可用资源。Scheduler 会确保 Pod 申请的资源总和小于可分配节点上的可用容量。节点可用容量的计算公式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Allocatable [capacity for application pods] =</span><br><span class="line">    Node Capacity [available capacity on a node]</span><br><span class="line">        - Kube-Reserved [Kubernetes daemons like kubelet, container runtime]</span><br><span class="line">        - System-Reserved [OS system daemons like sshd, udev]</span><br></pre></td></tr></table></figure></p><h4 id="Container-Resource-Demands"><a href="#Container-Resource-Demands" class="headerlink" title="Container Resource Demands"></a>Container Resource Demands</h4><p>Pod 在调度时，另一个重要的考虑因素就是容器有着自己的运行时依赖和资源需求。<br>比如：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    resources:</span></span><br><span class="line"><span class="attr">      requests:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">100</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">100</span><span class="string">Mi</span></span><br><span class="line"><span class="attr">      limits:</span></span><br><span class="line"><span class="attr">        cpu:</span> <span class="number">200</span><span class="string">m</span></span><br><span class="line"><span class="attr">        memory:</span> <span class="number">200</span><span class="string">Mi</span></span><br></pre></td></tr></table></figure></p><h4 id="Placement-Policies"><a href="#Placement-Policies" class="headerlink" title="Placement Policies"></a>Placement Policies</h4><p>Scheduler 配置了一组默认的优先级策略，适用于绝大多数场景。这个策略可以在 scheduler 启动时被替换掉。</p><p>scheduler 策略示例：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"kind"</span> : <span class="string">"Policy"</span>,</span><br><span class="line">    <span class="attr">"apiVersion"</span> : <span class="string">"v1"</span>,</span><br><span class="line">    <span class="attr">"predicates"</span> : [</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"PodFitsHostPorts"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"PodFitsResources"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"NoDiskConflict"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"NoVolumeZoneConflict"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"MatchNodeSelector"</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"HostName"</span>&#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"priorities"</span> : [</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"LeastRequestedPriority"</span>, <span class="attr">"weight"</span> : <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"BalancedResourceAllocation"</span>, <span class="attr">"weight"</span> : <span class="number">1</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"ServiceSpreadingPriority"</span>, <span class="attr">"weight"</span> : <span class="number">2</span>&#125;,</span><br><span class="line">        &#123;<span class="attr">"name"</span> : <span class="string">"EqualPriority"</span>, <span class="attr">"weight"</span> : <span class="number">1</span>&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 Predicate 规则用于过滤掉不合格的节点。比如 <code>PodFitsHostsPorts</code> 关注特定的固定主机端口，只有在这些端口可用时对应的节点才会作为候选。<br>Priorities 用于根据一些偏好设置来对候选的节点进行排序。比如 <code>LeastRequestedPriority</code> 会赋予请求了较少资源的节点更高的优先级。</p><p>可以同时运行多个 scheduler，让 Pod 自己去指定使用哪一个。只需要在 Pod 的配置中添加一条 <code>.spec.schedulerName</code>，其值为自定义 scheduler 的名字。</p><h4 id="调度流程"><a href="#调度流程" class="headerlink" title="调度流程"></a>调度流程</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-92760d77eed2a546.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A Pod-to-node assignment"></p><p>只要 Pod 创建完成且还没有被分配给任何节点，scheduler 就会挑选出该 Pod，连同所有可用的节点及优先级策略。第一阶段借助过滤策略移除所有不满足要求的节点，剩余的节点在第二阶段有权重地排序。最后一个阶段得到最终的胜出节点。</p><p>在绝大多数情况下，最好都只让 scheduler 去做 Pod-to-Node 的分配工作，不要去尝试“微操”调度逻辑。<br>在某些特殊场景下，如果需要强制某个 Pod 只能分配给特定的一个或一组节点，可以借助 Pod 的 <code>.spec.nodeSelector</code> 字段。<br>该字段可以指定一些键值对，对应节点身上的标签。比如想要 Pod 运行在拥有 SSD 磁盘的硬件上：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  nodeSelector:</span></span><br><span class="line"><span class="attr">    disktype:</span> <span class="string">ssd</span></span><br></pre></td></tr></table></figure></p><p>除了通过自定义标签指定节点，还可以通过每个节点上都有的默认标签来筛选，比如 <code>kubernetes.io/hostname</code>。</p><h4 id="Node-Affinity"><a href="#Node-Affinity" class="headerlink" title="Node Affinity"></a>Node Affinity</h4><p>Kubernetes 还支持更为灵活的配置调度流程的方式，比如 node affinity。其实它相当于 nodeSelector 机制的泛化，其规则可以被指定为“必需”或者“优先”。<br>“必需”表示相应的规则必须被满足，否则节点无法作为候选；“优先”则并不强制，只是提高匹配节点的权重。<br>此外，node affinity 支持多种操作符，如 <code>In</code>、<code>NotIn</code>、<code>Exists</code>、<code>DoesNotExist</code>、<code>Gt</code>、<code>Lt</code> 等，从而获得更强的表达能力。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  affinity:</span></span><br><span class="line"><span class="attr">    nodeAffinity:</span></span><br><span class="line"><span class="attr">      requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">        nodeSelectorTerms:</span></span><br><span class="line"><span class="attr">        - matchExpressions:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">numberCores</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">Gt</span></span><br><span class="line"><span class="attr">            values:</span> <span class="string">[</span> <span class="string">"3"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">      preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - weight:</span> <span class="number">1</span></span><br><span class="line"><span class="attr">        preference:</span></span><br><span class="line"><span class="attr">          matchFields:</span></span><br><span class="line"><span class="attr">          - key:</span> <span class="string">metadata.name</span></span><br><span class="line"><span class="attr">            operator:</span> <span class="string">NotIn</span></span><br><span class="line"><span class="attr">            values:</span> <span class="string">[</span> <span class="string">"master"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br></pre></td></tr></table></figure><p>其中 <code>requiredDuringSchedulingIgnoredDuringExecution</code> 用来指定节点必须具备的条件，此规则不会在执行过程中重新计算。结合后面的 <code>nodeSelectorTerms</code> 配置，筛选出核心数大于 3 的节点。<br><code>preferredDuringSchedulingIgnoredDuringExecution</code> 用于指定非必须的条件，表现为一个带有权重的 selector 列表。对于每一个节点，计算出所有匹配项的权重总和，结果最高的节点被选中，只要该节点已经满足了前面的“必需”条件。</p><p>PS：<code>matchFields</code> 只支持 <code>In</code> 和 <code>NotIn</code> 操作符，<code>values</code> 指定的列表中也只允许有一个值。</p><p>诚然，node affinity 相比于 <code>nodeSelector</code> 功能更为强大。它允许通过标签或者字段为 Pod 选择合适的节点，但不能够用来表达 Pod 之间的依赖关系，比如无法根据某个节点上已经部署的 Pod 判断某个新 Pod 是否也应该部署到该节点。这类需求可以通过 Pod affinity 实现。</p><h4 id="Pod-Affinity"><a href="#Pod-Affinity" class="headerlink" title="Pod Affinity"></a>Pod Affinity</h4><p>Node affinity 工作在节点层级上，Pod affinity 则可以在多个拓扑层级上表达规则，达到粒度更细的控制。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  affinity:</span></span><br><span class="line"><span class="attr">    podAffinity:</span></span><br><span class="line"><span class="attr">      requiredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - labelSelector:</span></span><br><span class="line"><span class="attr">          matchLabels:</span></span><br><span class="line"><span class="attr">            confidential:</span> <span class="string">high</span></span><br><span class="line"><span class="attr">        topologyKey:</span> <span class="string">security-zone</span></span><br><span class="line"><span class="attr">    podAntiAffinity:</span></span><br><span class="line"><span class="attr">      preferredDuringSchedulingIgnoredDuringExecution:</span></span><br><span class="line"><span class="attr">      - weight:</span> <span class="number">100</span></span><br><span class="line"><span class="attr">        podAffinityTerm:</span></span><br><span class="line"><span class="attr">          labelSelector:</span></span><br><span class="line"><span class="attr">            matchLabels:</span></span><br><span class="line"><span class="attr">              confidential:</span> <span class="string">none</span></span><br><span class="line"><span class="attr">          topologyKey:</span> <span class="string">kubernetes.io/hostname</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>podAffinity</code> 部分的配置表示，符合条件的节点上必须有带有 <code>confidential=high</code> 标签的 Pod 在运行，且该节点有 <code>security-zone</code> 标签。<br><code>podAntiAffinity</code> 定义的规则用于过滤掉匹配的节点。结合其配置，即节点上有带 <code>confidential=none</code> 标签的 Pod 在运行时，该节点不会用来部署当前 Pod。</p><h4 id="Taints-and-Tolerations"><a href="#Taints-and-Tolerations" class="headerlink" title="Taints and Tolerations"></a>Taints and Tolerations</h4><p>Taints 和 Tolerations 是一类更高级的用于控制调度策略的特性。简单来说，node affinity 允许 Pod 根据规则选择合适的节点，taints 和 tolerations 则正相反，它允许节点自身去控制 Pod 是否应该分配给自己。<br>Taint 是节点自身的一种属性，当它存在时，会阻止 Pod 分配给自己，除非该 Pod 拥有针对 taint 的 tolerations。</p><p>Taint 可以使用 <code>kubectl</code> 命令添加。如 <code>kubectl taint nodes master noderole.kubernetes.io/master=&quot;true&quot;:NoSchedule</code>，等效于下面的配置。</p><p>Tainted 节点：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Node</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">master</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  taints:</span></span><br><span class="line"><span class="attr">  - effect:</span> <span class="string">NoSchedule</span></span><br><span class="line"><span class="attr">    key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br></pre></td></tr></table></figure></p><p>拥有此 taint 的节点不会被分配任何 Pod，除非有 Pod 指定了对应的 toleration。比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">  tolerations:</span></span><br><span class="line"><span class="attr">  - key:</span> <span class="string">node-role.kubernetes.io/master</span></span><br><span class="line"><span class="attr">    operator:</span> <span class="string">Exists</span></span><br><span class="line"><span class="attr">    effect:</span> <span class="string">NoSchedule</span></span><br></pre></td></tr></table></figure><p>在生产级别的集群中，带有 <code>noderole.kubernetes.io/master</code> 配置的 taint 一般会指定给 master 节点，阻止 Pod 部署到 master 上。<br>这里给 Pod 添加的 toleration 会覆盖 taint 的 <code>NoSchedule</code> 效果，即无论如何都允许此 Pod 分配给 master 节点。</p><p>Taint 可以是硬性的，阻止节点作为候选（<code>effect=NoSchedule</code>），也可以是软性的，尝试避免节点作为候选（<code>effect=PreferNoSchedule</code>），还可以强制移除节点上已经在运行的 Pod（<code>effect=NoExecute</code>）。</p><p>当 Pod 已经分配给某个节点，scheduler 的工作就已经算完成了，它不会再对完成的分配进行调整。除非该 Pod 被删除或者重建。随着时间的推移，这一定会导致资源的碎片化，集群利用率降低。<br>另一个潜在的问题是，Pod 被创建后具体分配给哪一个节点，依赖于当时集群的状态。而集群本身是动态的，节点的资源配置会更改，或者有新的节点加入进来，scheduler 并不会纠正已经存在的部署。此外，节点上的标签也有可能会变动，影响到之后的调度，但之前已经完成的调度依旧保持不变。</p><p>以上所有的场景都可以通过 descheduler 去解决。Kubernetes 的 descheduler 是一个可选的特性，通常作为 Job 执行，当管理员觉得是时候通过重新调度 Pod 来整理集群的碎片。<br>Descheduler 有一些预先定义的策略，可以被启用或者禁用：</p><ul><li>RemoveDuplicates：该策略会确保 ReplicaSet 或 Deployment 关联的单一 Pod 只运行在唯一一个节点上。当某个节点不健康时，controller 会在其他健康的节点上启动新的 Pod。此时若之前不健康的节点恢复正常重新加入集群，正在运行的 Pod 就会大于需要的数量。此策略就可以应用于这类的场景。同时 RemoveDuplicates 还可以在策略或集群架构发生变化后，将 Pod 更均匀地分散在更多的节点上</li><li>LowNodeUtilization：该策略会找到使用率低的节点，并将高使用率节点上的 Pod 移除掉，希望这些移除的 Pod 可以重新分配到未充分利用的节点上。使用率低指 CPU、内存或 Pod 数量小于 <code>thresholds</code> 配置；使用率高指的是 CPU、内存或 Pod 数量大于 <code>targetThresholds</code> 配置</li><li>RemovePodsViolatingInterPodAntiAffinity：该策略会移除违反了 pod antiaffinity 规则的 Pod。这种情况可能发生在，添加规则时一些不符合规则的 Pod 就已经存在了</li><li>RemovePodsViolatingNodeAffinity：移除违反了 node affinity 规则的 Pod</li></ul><p>不管使用何种配置的策略，descheduler 会避免移除如下类型的 Pod：</p><ul><li>在 annotation 中标记为 <code>scheduler.alpha.kubernetes.io/criticalpod</code> 的关键 Pod</li><li>不由 ReplicaSet、Deployment 或 Job 管理的 Pod</li><li>由 DaemonSet 管理的 Pod</li><li>拥有本地存储的 Pod</li><li>配置了 <code>PodDisruptionBudget</code> 的 Pod，且移除时会违反此规则</li><li>Descheduler Pod 本身</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>容器调度是一个我们希望尽可能少干预的领域。从简单到复杂，以下方法控制着调度的具体策略：</p><ul><li>nodeName：最简单的分配方式，将 Pod 到节点的关系硬编码到配置中。理想的情况下，此字段应该由 scheduler 填充，策略去驱动，而不是手动指定</li><li>nodeSelector：键值对映射。符合条件的节点必须包含此键值对指向的标签。在控制调度策略的可接受的方式中，最简单的一种</li><li>Default scheduling alteration：必要的情况下，可以修改 default scheduler 的过滤规则和优先级策略、顺序、权重等</li><li>Pod affinity 和 antiaffinity：此机制允许 Pod 表达自身对其他 Pod 的依赖关系</li><li>Node affinity：允许 Pod 表达自身对节点的依赖关系，比如节点的硬件配置、地理位置等</li><li>Taints 和 tolerations：允许节点去控制哪些 Pod 允许哪些不允许分配给自己。比如为一组 Pod 分配一个专用节点，甚至在运行时移除 Pod</li><li>Custom scheduler：若上述方案都不能符合需求，还可以编写自定义的 scheduler。自定义 scheduler 可以替换掉标准的 Kubernetes scheduler，也可以两者一起运行</li></ul><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Automated Placement&lt;/em&gt; 是 Kubernetes 中 scheduler 的核心功能，负责将新的 Pod 分配给合适的节点，满足容器的资源需求，同时遵守设定好的调度策略。&lt;/p&gt;
&lt;p&gt;基于微服务的系统通常会包含数十个甚至数百个隔离的进程，
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Node" scheme="https://rollingstarky.github.io/tags/Node/"/>
    
      <category term="Schedule" scheme="https://rollingstarky.github.io/tags/Schedule/"/>
    
      <category term="Policy" scheme="https://rollingstarky.github.io/tags/Policy/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Job &amp; CronJob</title>
    <link href="https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-job-and-cronjob/"/>
    <id>https://rollingstarky.github.io/2023/06/19/kubernetes-patterns-reading-notes-job-and-cronjob/</id>
    <published>2023-06-18T16:00:00.000Z</published>
    <updated>2023-06-19T12:42:26.965Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Batch-Job"><a href="#Batch-Job" class="headerlink" title="Batch Job"></a>Batch Job</h4><p>Batch Job 模式适合处理<strong>隔离的</strong>、<strong>原子化的</strong>工作任务，能够在分布式的环境中，可靠地运行 short-lived Pods，直到工作任务成功地结束。</p><p>在 Kubernetes 中，可以通过不同的方式创建 Pod：</p><ul><li>Bare Pod：可以手动创建 Pod 来运行容器应用，但是当此类 Pod 所在的节点失效时，Pod 不会自动重启。除非用于开发或测试目的，此类方式并不推荐</li><li>ReplicaSet：当 Pod 应该长时间持续运行时（比如 web server），就适合用此方式来创建 Pod 和管理其生命周期。它会确保在任意时刻，运行着的 Pod 副本数量都是稳定的</li><li>DaemonSet：负责在每一个节点上都部署一个 Pod。通常情况下用于平台管理工作，比如监控、日志聚合、存储等</li></ul><p>上述 Pod 有一个共同点，它们都代表着长时间运行的进程，并不是在一段时间后就需要被关掉。但是在某些场景下，仍需要执行一类预先定义好的、有限的工作流，当该工作流程可靠地完成后，再关闭对应的容器。</p><p>Kubernetes Job 类似于 ReplicaSet，它也会创建 1 个或者多个 Pods 并确保它们成功运行。区别在于，当特定数量的 Pods 成功终止后，Job 就变为完成状态，不会再有额外的 Pod 被启动。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Job</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  completions:</span> <span class="number">5</span></span><br><span class="line"><span class="attr">  parallelism:</span> <span class="number">2</span></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      restartPolicy:</span> <span class="string">OnFailure</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">        name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[</span> <span class="string">"java"</span><span class="string">,</span> <span class="string">"-cp"</span><span class="string">,</span> <span class="string">"/"</span><span class="string">,</span> <span class="string">"RandomRunner"</span><span class="string">,</span> <span class="string">"/numbers.txt"</span><span class="string">,</span> <span class="string">"10000"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>比如上面配置的 Job，会确保有 5 个 Pod 成功执行完毕，可以有两个 Pod 同时运行。此外，Job 配置文件中的 <code>restartPolicy</code> 是必需的，且其值只能是 <code>OnFailure</code> 或 <code>Never</code>，不能是 <code>Always</code>。</p><p>为什么不通过 bare Pods 来执行 Job 对应的任务呢？因为 Job 相比于 bare Pods，能够提供更多可靠性和扩展性方面的好处。</p><ul><li>Job 并不是临时的 in-memory 任务，而是一个持久化的能够在集群重启后幸存的任务</li><li>Job 完成后并不会被删除，而是继续保留，方便以后追踪问题。只有当 bare Pods 是 <code>restartPolicy: OnFailure</code> 时，其才会拥有同样的特性</li><li>Job 可能需要执行多次，可以通过 <code>.spec.completions</code> 指定</li><li>当任务确实需要完成多次时，Job 还支持扩展，即同一时间开启多个 Pods。可以通过 <code>.spec.parallelism</code> 指定</li><li>若节点失效，或者 Pod 正在运行时因为某些原因被移除，由 Job 创建的 Pods 会被 scheduler 重新分配给健康的节点</li></ul><p>两个字段对控制 Job 的行为发挥着关键作用：</p><ul><li><code>.spec.completions</code>：指定 Pod 的数量。当特定数量的 Pod 执行完毕后，当前 Job 才算完成</li><li><code>.spec.parallelism</code>：指定可以并行执行的 Pod 副本数量</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5fc1677a539a8d5b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Parallel Batch Job with a fixed completion count"></p><p>基于上述两个参数，Job 可以分为如下几种类型：</p><ul><li>Single Pod Job：不设置 <code>.spec.completions</code> 和 <code>.spec.parallelism</code> 的值，或者将它们设置为默认值 1。此类 Job 只会启动一个 Pod，当 Pod 成功退出后，Job 完成</li><li>Fixed completions count Jobs：<code>.spec.completions</code> 的值大于 1。当特定数量（<code>.spec.completions</code>）的 Pod 执行完毕后，Job 完成</li><li>Work queue Job：<code>.spec.completions</code> 不设置或者设为默认值，<code>.spec.parallelism</code> 大于 1。适用于工作队列中的 Job。当至少有一个 Pod 成功终止时，所有其他 Pod 也会自行终止。比如，一堆固定数量的待处理项目保存在某个队列中，并行的 Pod 可以按顺序获取并处理它们，当某个 Pod 检测到队列为空并成功退出后，Job controller 等待其他 Pod 终止运行</li></ul><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>Job 帮助我们将隔离的工作单元变成一个可靠的、可扩展的执行单元。并不是所有的服务都需要一直运行，比如某些服务可能需要按需运行，某些必须在特定的时间窗口运行，某些必须按照计划重复执行。<br>通过 Job 可以只在需要的时候运行 Pod，且任务完成后就退出。使用 Job 处理 short-lived 任务可以节约系统资源。</p><h4 id="Periodic-Job"><a href="#Periodic-Job" class="headerlink" title="Periodic Job"></a>Periodic Job</h4><p>Periodic Job 是对 Batch Job 的扩展，为其添加了时间维度，同时允许临时的事件触发工作流的执行。<br>在分布式系统的世界里，有一种比较清晰的倾向，借助 HTTP 和轻量的消息系统实现实时、事件驱动的应用。不考虑软件开发中的此类倾向，计划任务仍然是一种历史悠久且至今常用的手段。<br>它们通常用于自动化的系统维护工作或者管理员任务，在商业应用方面的场景比如文件同步、发送邮件、清理和归档旧文件等。</p><p>传统的处理 Periodic Job 的方式是借助专门的计划任务软件比如 Cron。但是 Cron jobs 运行在单一的服务器上，难以维护且有发生单点故障的风险。<br>这也是为什么很多开发者会尝试实现自己的方案，比如 Java 中的 Quartz、Spring Batch 等。但是类似于 Cron，它们也会遇到弹性和高可用性方面的挑战，导致较高的资源使消耗。此外在这类方案里，Job 调度器是应用的一部分，为了获得高可用，通常就需要运行多个应用实例，同时还需要确保同一时刻下只有一个实例是活跃的。从而引入 leader election 等分布式系统问题。</p><p>面对以上的一些问题，Kubernetes 实现了 CronJob，允许开发者以广为熟知的 Cron 格式将 Job 设置为计划任务。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">batch/v1beta1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CronJob</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="comment"># Every three minutes</span></span><br><span class="line"><span class="attr">  schedule:</span> <span class="string">"*/3 * * * *"</span></span><br><span class="line"><span class="attr">  jobTemplate:</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      template:</span></span><br><span class="line"><span class="attr">        spec:</span></span><br><span class="line"><span class="attr">          containers:</span></span><br><span class="line"><span class="attr">          - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">            name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">            command:</span> <span class="string">[</span> <span class="string">"java"</span><span class="string">,</span> <span class="string">"-cp"</span><span class="string">,</span> <span class="string">"/"</span><span class="string">,</span> <span class="string">"RandomRunner"</span><span class="string">,</span> <span class="string">"/numbers.txt"</span><span class="string">,</span> <span class="string">"10000"</span> <span class="string">]</span></span><br><span class="line"><span class="attr">restartPolicy:</span> <span class="string">OnFailure</span></span><br></pre></td></tr></table></figure><p>与 Job 相比，CronJob 有一些额外的字段：</p><ul><li><code>.spec.schedule</code>：指定 Job 的 schedule 模式（如 <code>0 * * * *</code> 表示每个小时触发一次）</li><li><code>.spec.startingDeadlineSeconds</code>：Job 启动时的截止时间。有些时候由于资源不够或者缺少其他依赖，Job 错过了预定的触发时间。此字段用于指定错过多少秒后就直接跳过此次执行</li><li><code>.spec.concurrencyPolicy</code>：用于控制同一个 CronJob 的并发执行。默认值为 <code>Allow</code>，即使前一个 Job 并未结束，也允许新的 Job 实例被创建；可以指定为 <code>Forbid</code>，若当前 Job 并未结束，则跳过下一次执行；或者改为 <code>Replace</code>，取消当前还未结束的 Job 并启动一个新的 Job 实例</li><li><code>.spec.suspend</code>：暂停所有后续执行，但不影响已经开始的执行</li><li><code>.spec.successfulJobsHistoryLimit</code> 和 <code>.spec.failedJobsHistoryLimit</code>：应保留多少已完成和失败的 Job 作为审计数据</li></ul><h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>CronJob 其实是一个非常简单的原语，在现有的 Job 定义中添加类似 Cron 的行为。但是当它与 Kubernetes 提供的其他原语比如 Pods、资源隔离结合起来时，就成为一个非常强大的任务调度系统。<br>它的调度行为是平台的一部分，实现在应用的外部，使得开发者能够专注于应用的业务逻辑，无需在应用内部额外设计一套调度逻辑。同时提供了高可用、高弹性、高容积以及由策略驱动的 Pod 部署等特性。<br>当然，和 Job 一样，CronJob 容器在部署时，也需要考虑所有的特殊情况，比如重复执行、未触发、并发执行和任务取消等。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Batch-Job&quot;&gt;&lt;a href=&quot;#Batch-Job&quot; class=&quot;headerlink&quot; title=&quot;Batch Job&quot;&gt;&lt;/a&gt;Batch Job&lt;/h4&gt;&lt;p&gt;Batch Job 模式适合处理&lt;strong&gt;隔离的&lt;/strong&gt;、&lt;stro
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Virtualization" scheme="https://rollingstarky.github.io/tags/Virtualization/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="Job" scheme="https://rollingstarky.github.io/tags/Job/"/>
    
      <category term="CronJob" scheme="https://rollingstarky.github.io/tags/CronJob/"/>
    
  </entry>
  
  <entry>
    <title>Python 借助 asyncio 实现并发编程</title>
    <link href="https://rollingstarky.github.io/2023/01/12/python-concurrency-with-coroutine-and-asyncio-basics/"/>
    <id>https://rollingstarky.github.io/2023/01/12/python-concurrency-with-coroutine-and-asyncio-basics/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-01-12T12:38:36.585Z</updated>
    
    <content type="html"><![CDATA[<h4 id="asyncio-基础"><a href="#asyncio-基础" class="headerlink" title="asyncio 基础"></a>asyncio 基础</h4><h5 id="创建协程"><a href="#创建协程" class="headerlink" title="创建协程"></a>创建协程</h5><p><strong>使用 async 关键字创建 coroutine</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine_add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function_result = add_one(<span class="number">1</span>)</span><br><span class="line">coroutine_result = coroutine_add_one(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">print(</span><br><span class="line">    <span class="string">f'Function result is <span class="subst">&#123;function_result&#125;</span> and the type is <span class="subst">&#123;type(function_result)&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># =&gt; Function result is 2 and the type is &lt;class 'int'&gt;</span></span><br><span class="line"></span><br><span class="line">print(</span><br><span class="line">    <span class="string">f'Coroutine result is <span class="subst">&#123;coroutine_result&#125;</span> and the type is <span class="subst">&#123;type(coroutine_result)&#125;</span>'</span>)</span><br><span class="line"><span class="comment"># =&gt; Coroutine result is &lt;coroutine object coroutine_add_one at 0x7f9f495f20a0&gt; and the type is &lt;class 'coroutine'&gt;</span></span><br><span class="line"><span class="comment"># =&gt; sys:1: RuntimeWarning: coroutine 'coroutine_add_one' was never awaited</span></span><br></pre></td></tr></table></figure><p>创建 coroutine 和创建普通的函数一样直接，唯一的区别在于使用 <code>async def</code> 而不是 <code>def</code>。<br>当我们直接调用协程 <code>coroutine_add_one</code> 时，传入的参数并没有被加 1 然后返回计算结果，我们只是得到了一个 <code>coroutine object</code>。<br>即我们只是创建了一个能够在之后的某个时间运行的 coroutine 对象，为了运行它，我们总是需要显式地将其放入 event loop 中。最简单的方式就是使用 <code>asyncio.run</code> 函数。</p><p><strong>运行 coroutine</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">coroutine_add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = asyncio.run(coroutine_add_one(<span class="number">1</span>))</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># =&gt; 2</span></span><br></pre></td></tr></table></figure><p><code>asyncio.run</code> 是 asyncio 应用程序的入口。</p><p><strong>使用 await 关键字暂停执行</strong><br>asyncio 的真正用处，在于能够在一个长时间运行的操作过程中，暂停执行，从而令 event loop 有机会处理其他任务。“暂停”的动作通过 <code>await</code> 关键字触发。<code>await</code> 后面通常紧跟着一个对 coroutine （更严谨地说，一个 <code>awaitable</code> 对象）的调用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>)</span><br><span class="line">    two_plus_one = <span class="keyword">await</span> add_one(<span class="number">2</span>)</span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    <span class="comment"># =&gt; 2</span></span><br><span class="line">    print(two_plus_one)</span><br><span class="line">    <span class="comment"># =&gt; 3</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>首先 <code>await</code> 对协程 <code>add_one(1)</code> 的调用，此时父协程（即 <code>main()</code>）被暂停，<code>add_one(1)</code> 执行并获取结果（<code>2</code>），<code>main()</code> 协程恢复执行，将结果赋值给 <code>one_plus_one</code>；同样地，对协程 <code>add_one(2)</code> 的 <code>await</code> 也会导致 <code>main()</code> 被暂停和恢复。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f3dca99e4621c760.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="await"></p><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h5><p>前面的例子只是为了介绍协程的基本语法，并没有涉及任何 long-running 操作，因而也没有享受到 asyncio 在并发方面的作用。我们可以借助 <code>asyncio.sleep</code> 函数模拟 web API 请求或者数据库查询等长时间运行的操作，<code>asyncio.sleep</code> 能够令某个协程“睡眠”指定的时间（秒）。<br><code>asyncio.sleep</code> 本身就是一个协程，因而当我们在某个协程中 await <code>asyncio.sleep</code> 时，其他部分代码就得到了执行的机会。</p><p><strong>sleep 实现 delay 函数</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br></pre></td></tr></table></figure><p><strong>运行两个协程</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">add_one</span><span class="params">(number: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> number + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_world_message</span><span class="params">()</span> -&gt; str:</span></span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Hello Wrold!'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    message = <span class="keyword">await</span> hello_world_message()</span><br><span class="line">    one_plus_one = <span class="keyword">await</span> add_one(<span class="number">1</span>)</span><br><span class="line">    print(one_plus_one)</span><br><span class="line">    print(message)</span><br><span class="line">    <span class="comment"># =&gt; sleeping for 1 second(s)</span></span><br><span class="line">    <span class="comment"># =&gt; finished sleeping for 1 second(s)</span></span><br><span class="line">    <span class="comment"># =&gt; 2</span></span><br><span class="line">    <span class="comment"># =&gt; Hello Wrold!</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br></pre></td></tr></table></figure><p>运行上面的代码，先是等待 1 秒钟，之后才是两个函数调用的结果被打印出来。我们本来希望看到的是，两个协程并发地执行，<code>add_one(1)</code> 的结果直接被输出，并不需要等待 <code>hello_world_message()</code> 中的 <code>sleep</code> 结束。<br>实际上 <code>await</code> 会暂停其所在的协程（这里是 <code>main</code>），并且不会执行当前协程中的任何其他代码，直到 <code>await</code> 表达式获得一个结果。<code>hello_world_message</code> 需要 1 秒钟才能返回结果，因而 main 协程也会被暂停 1 秒钟。排在它后面的 <code>add_one(1)</code> 在暂停结束后执行并返回结果。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-dc45bb81c8969a35.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="execution flow"></p><p>上面的代码和同步、顺序执行的代码没有表现出任何区别。为了实现并发，我们需要引入一个新的概念 <strong>task</strong>。</p><h5 id="tasks"><a href="#tasks" class="headerlink" title="tasks"></a>tasks</h5><p>Task 是对协程的一种包装，能够将一个协程调度至 event loop 并争取尽快执行。这种调度是以一种<strong>非阻塞</strong>的方式发生的，即 task 被创建后会立即返回，不必等待其运行结束，从而我们能够有机会执行其他代码。</p><p><strong>并发地执行多个 task</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">hello_every_second</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">"I'm running other code while I'm waiting!"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    first_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    second_delay = asyncio.create_task(delay(<span class="number">3</span>))</span><br><span class="line">    <span class="keyword">await</span> hello_every_second()</span><br><span class="line">    <span class="keyword">await</span> first_delay</span><br><span class="line">    <span class="keyword">await</span> second_delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="comment"># =&gt; I'm running other code while I'm waiting!</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 3 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 3 second(s)</span></span><br></pre></td></tr></table></figure><p>上述代码创建了 2 个 task，每个都需要 3 秒钟才能执行完毕。两次对 <code>create_task</code> 的调用都会立即返回。由于 task 调度的原则是尽快执行，当后面的 <code>await</code> 代码刷新了一次 event loop 之后，前面创建的 2 个 task 会立即被执行（非阻塞）。<br>两个 delay task 在 <code>sleep</code> 过程中，应用是闲置的，我们得以有机会运行其他代码。协程 <code>hello_every_second</code> 每隔 1 秒输出一条消息。整个应用总的运行时间大约是 3 秒，即大约等于耗时最长的异步任务的时间，而不是像顺序执行的程序那样，等于多个任务运行时间的总和。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5688b12e8271ed3f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="execution flow"></p><h4 id="协程和任务的陷阱"><a href="#协程和任务的陷阱" class="headerlink" title="协程和任务的陷阱"></a>协程和任务的陷阱</h4><p>将一些长时间运行的任务并发的执行，能够带来很大程度上的性能提升。因而我们会倾向于在应用的任何地方使用协程和 task。事实上，仅仅将函数用 async 修饰，将其封装进 task，并不总是带来性能上的提升。甚至有些情况下还会降低程序的效率。<br>最主要的情形有两种，<strong>一个是在不借助多进程的情况下，尝试在 task 或协程中运行 CPU-bound 代码；另一种是在不借助多线程的情况下调用阻塞式 I/O-bound API</strong>。</p><h5 id="CPU-密集型任务"><a href="#CPU-密集型任务" class="headerlink" title="CPU 密集型任务"></a>CPU 密集型任务</h5><p>有时候我们需要一些函数执行 CPU 密集型的任务，比如对一个很大的字典执行循环或者数学计算。为了提升效率，我们会想着将它们放置在单独的 task 中运行。然而现实是，<strong>asyncio 使用单线程并发模型，我们依然会受到单个线程和 GIL 的限制</strong>。</p><p><strong>计算协程运行时间</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># util.py</span></span><br><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> Callable, Any</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">async_timed</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(func: Callable)</span> -&gt; Callable:</span></span><br><span class="line"><span class="meta">        @functools.wraps(func)</span></span><br><span class="line">        <span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">wrapped</span><span class="params">(*args, **kwargs)</span> -&gt; Any:</span></span><br><span class="line">            print(<span class="string">f'Starting <span class="subst">&#123;func&#125;</span> with <span class="subst">&#123;args&#125;</span> <span class="subst">&#123;kwargs&#125;</span>'</span>)</span><br><span class="line">            start = time.time()</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">await</span> func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                end = time.time()</span><br><span class="line">                total = end - start</span><br><span class="line">                print(<span class="string">f'finished <span class="subst">&#123;func&#125;</span> in <span class="subst">&#123;total:<span class="number">.4</span>f&#125;</span> second(s)'</span>)</span><br><span class="line">        <span class="keyword">return</span> wrapped</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">delay</span><span class="params">(delay_seconds: int)</span> -&gt; int:</span></span><br><span class="line">    print(<span class="string">f'sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">await</span> asyncio.sleep(delay_seconds)</span><br><span class="line">    print(<span class="string">f'finished sleeping for <span class="subst">&#123;delay_seconds&#125;</span> second(s)'</span>)</span><br><span class="line">    <span class="keyword">return</span> delay_seconds</span><br></pre></td></tr></table></figure><p><strong>运行 CPU-bound 代码</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay, async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">cpu_bound_work</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    counter = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000000</span>):</span><br><span class="line">        counter = counter + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_one = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    task_two = asyncio.create_task(cpu_bound_work())</span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">await</span> task_one</span><br><span class="line">    <span class="keyword">await</span> task_two</span><br><span class="line">    <span class="keyword">await</span> delay_task</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7f2d6b85bc70&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; in 2.7423 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function cpu_bound_work at 0x7f2d6c2bba30&gt; in 2.7430 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7f2d6b85a0e0&gt; with (4,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 4 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 4 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7f2d6b85a0e0&gt; in 4.0048 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7f2d6b85bc70&gt; in 9.4903 second(s)</span></span><br></pre></td></tr></table></figure><p>上述代码创建了 3 个 task，但实际执行时依然是顺序的而非并发的，耗费的时间并没有变少。两个 CPU-bound task 是依次执行的，甚至 <code>delay_task</code> 也并没有与其他两个任务呈现并发性。原因在于我们先创建了两个 CPU-bound 任务，这两个任务会阻塞 event loop，阻止其调度执行任何其他任务。<br>因此，总的运行时间等于两个 CPU-bound 任务执行完毕的时间加上 delay 任务运行的 4 秒。即 asyncio 并没有为 CPU-bound 的任务带来任何性能上的提升。<br>假如我们需要在执行 CPU-bound 任务的同时仍使用 <code>async</code> 语法，就必须借助多进程，告诉 asyncio 在 <em>process pool</em> 中执行任务。</p><h5 id="阻塞式-API"><a href="#阻塞式-API" class="headerlink" title="阻塞式 API"></a>阻塞式 API</h5><p>我们也会倾向于使用<strong>现有的库</strong>执行 I/O-bound 操作，再将其封装进协程。然而，这会引起与 CPU-bound 操作同样的问题。因为这些 API 会阻塞 main 线程。<br>当我们在协程内部调用一个阻塞的 API，我们会阻塞 event loop 线程本身，线程被阻塞请求占据，导致 event loop 无法调度任何其他协程和任务。阻塞式 API 请求包括 <code>requests</code> 库和 <code>time.sleep</code> 等。<strong>通常来说，任何执行 I/O 操作且不是协程的函数，以及执行 CPU 密集型任务的函数，都可以认为是阻塞的</strong>。</p><p><strong>协程内部调用阻塞式 API</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_example_status</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">return</span> requests.get(<span class="string">'http://www.example.com'</span>).status_code</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_1 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_2 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_3 = asyncio.create_task(get_example_status())</span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7f4335080790&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5144 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5163 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7f4335186170&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7f4335186170&gt; in 0.5177 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7f4335080790&gt; in 1.5488 second(s)</span></span><br></pre></td></tr></table></figure><p><code>main</code> 协程运行的总时间基本上等于所有 task 运行的时间之和。即我们并没有获取到任何并发上的收益。原因在于 <code>requests</code> 库是阻塞的，任何调用都会阻塞当前线程，而 asyncio 只有一个线程，在阻塞调用结束之前，线程中的 event loop 没有机会以异步的形式运行任何任务。<br>当你使用的库并没有返回协程，你并没有在自己的协程中使用 <code>await</code> 关键字，很大可能你就是在进行阻塞的函数调用。当前我们使用的大多数 API 都是阻塞的，并不支持与 asyncio 开箱即用。<br>要想体验到 asyncio 带来的异步和并发特性，就必须使用原生支持协程和非阻塞 socket 的库，比如 <code>aiohttp</code>。或者你坚持使用 <code>requests</code> 库，同时又需要 <code>async</code> 语法，就必须显式地告诉 <code>asyncio</code> 使用多线程的方式，通过 <em>thread pool executor</em> 执行阻塞调用。</p><p><strong>借助支持协程的库 aiohttp 实现并发</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> aiohttp <span class="keyword">import</span> ClientSession</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> async_timed</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">get_example_status</span><span class="params">()</span> -&gt; int:</span></span><br><span class="line">    session = ClientSession()</span><br><span class="line">    resp = <span class="keyword">await</span> session.get(<span class="string">'http://example.com'</span>)</span><br><span class="line">    <span class="keyword">await</span> session.close()</span><br><span class="line">    <span class="keyword">return</span> resp.status</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@async_timed()</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task_1 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_2 = asyncio.create_task(get_example_status())</span><br><span class="line">    task_3 = asyncio.create_task(get_example_status())</span><br><span class="line">    <span class="keyword">await</span> task_1</span><br><span class="line">    <span class="keyword">await</span> task_2</span><br><span class="line">    <span class="keyword">await</span> task_3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function main at 0x7fd9f90b6a70&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function get_example_status at 0x7fd9f90b63b0&gt; with () &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function get_example_status at 0x7fd9f90b63b0&gt; in 0.5191 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function main at 0x7fd9f90b6a70&gt; in 0.5196 second(s)</span></span><br></pre></td></tr></table></figure><p>可以看到所有 task 执行的总时间，基本上只比一个 task 运行的时间多一点点。此时的程序是并发执行的。</p><h4 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h4><p><strong>取消任务</strong></p><p>每个 <code>task</code> 对象都有一个 <code>cancel</code> 方法可以帮助我们随时终止该任务。当我们 <code>await</code> 取消的任务时，会报出 <code>CancelledError</code> 异常。<br>比如我们调度执行某个任务，又不希望该任务运行的时间超过 5 秒：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> asyncio <span class="keyword">import</span> CancelledError</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    long_task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    seconds_elapsed = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> long_task.done():</span><br><span class="line">        print(<span class="string">'Task not finished, checking again in a second.'</span>)</span><br><span class="line">        <span class="keyword">await</span> asyncio.sleep(<span class="number">1</span>)</span><br><span class="line">        seconds_elapsed = seconds_elapsed + <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> seconds_elapsed == <span class="number">5</span>:</span><br><span class="line">            long_task.cancel()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">await</span> long_task</span><br><span class="line">    <span class="keyword">except</span> CancelledError:</span><br><span class="line">        print(<span class="string">'Our task was cancelled'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7fdb383ae0e0&gt; with (10,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; Task not finished, checking again in a second.</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7fdb383ae0e0&gt; in 5.0079 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Our task was cancelled</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<code>CancelledError</code> 只会在 <code>await</code> 语句处抛出，调用 <code>cancel</code> 方法并不会神奇地强行关闭正在运行的任务，只有你刚好遇到 <code>await</code> 时任务才会被终止，不然就等待下一个 <code>await</code>。</p><p><strong>使用 wait_for 设置超时时间</strong><br>每隔一段时间手动进行检查，以确定是否取消某个任务，并不算一种简单的处理方式。asyncio 提供了一个 <code>wait_for</code> 函数，它接收一个协程或者任务，以及超时的秒数作为参数，返回一个协程对象。<br>若任务运行超时，一个 <code>TimeoutException</code> 就会被抛出，任务自动被终止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> asyncio</span><br><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    delay_task = asyncio.create_task(delay(<span class="number">2</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(delay_task, timeout=<span class="number">1</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> asyncio.exceptions.TimeoutError:</span><br><span class="line">        print(<span class="string">'Got a timeout'</span>)</span><br><span class="line">        print(<span class="string">f'Was the task cancelled? <span class="subst">&#123;delay_task.cancelled()&#125;</span>'</span>)</span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7f71e18160e0&gt; with (2,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 2 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7f71e18160e0&gt; in 1.0016 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Got a timeout</span></span><br><span class="line"><span class="comment"># =&gt; Was the task cancelled? True</span></span><br></pre></td></tr></table></figure><p><strong>asyncio.shield</strong><br>在另外一些情况下，我们有可能并不希望直接取消某个超时的任务，而是当任务运行时间过长时，提醒用户这个情况，但是并不执行任何 cancel 操作。<br><code>shield</code> 可以帮助我们实现这样的功能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> util <span class="keyword">import</span> delay</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    task = asyncio.create_task(delay(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        result = <span class="keyword">await</span> asyncio.wait_for(asyncio.shield(task), <span class="number">5</span>)</span><br><span class="line">        print(result)</span><br><span class="line">    <span class="keyword">except</span> asyncio.exceptions.TimeoutError:</span><br><span class="line">        print(<span class="string">"Task took longer than five seconds, it will finish soon!"</span>)</span><br><span class="line">        result = <span class="keyword">await</span> task</span><br><span class="line">        print(result)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">asyncio.run(main())</span><br><span class="line"><span class="comment"># =&gt; Starting &lt;function delay at 0x7ff344d120e0&gt; with (10,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># =&gt; sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; Task took longer than five seconds, it will finish soon!</span></span><br><span class="line"><span class="comment"># =&gt; finished sleeping for 10 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; finished &lt;function delay at 0x7ff344d120e0&gt; in 10.0063 second(s)</span></span><br><span class="line"><span class="comment"># =&gt; 10</span></span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/python-concurrency-with-asyncio" target="_blank" rel="noopener">Python Concurrency with asyncio</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;asyncio-基础&quot;&gt;&lt;a href=&quot;#asyncio-基础&quot; class=&quot;headerlink&quot; title=&quot;asyncio 基础&quot;&gt;&lt;/a&gt;asyncio 基础&lt;/h4&gt;&lt;h5 id=&quot;创建协程&quot;&gt;&lt;a href=&quot;#创建协程&quot; class=&quot;head
      
    
    </summary>
    
      <category term="Python" scheme="https://rollingstarky.github.io/categories/Python/"/>
    
    
      <category term="Python" scheme="https://rollingstarky.github.io/tags/Python/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Thread" scheme="https://rollingstarky.github.io/tags/Thread/"/>
    
      <category term="Async" scheme="https://rollingstarky.github.io/tags/Async/"/>
    
      <category term="Coroutine" scheme="https://rollingstarky.github.io/tags/Coroutine/"/>
    
      <category term="Asyncio" scheme="https://rollingstarky.github.io/tags/Asyncio/"/>
    
      <category term="EventLoop" scheme="https://rollingstarky.github.io/tags/EventLoop/"/>
    
      <category term="Non-blocking" scheme="https://rollingstarky.github.io/tags/Non-blocking/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 消息中间件及其应用模式（任务分发）</title>
    <link href="https://rollingstarky.github.io/2023/01/12/node-js-design-patterns-message-broker-pattern-task-distribution/"/>
    <id>https://rollingstarky.github.io/2023/01/12/node-js-design-patterns-message-broker-pattern-task-distribution/</id>
    <published>2023-01-11T16:00:00.000Z</published>
    <updated>2023-01-12T12:33:13.527Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://upload-images.jianshu.io/upload_images/6875152-0ad90045a8fe8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Distributing tasks to a set of consumers"></p><p>将高成本的任务委派给多个工作节点，这种类型的应用并不适合由 Pub/Sub 模式实现。因为我们并不想同一个任务被多个消费者收到，相反我们更需要一种类似负载均衡的消息分发模式。在消息系统术语中，也被称为 <em>competing consumers</em>，<em>fanout distribution</em> 或 <em>ventilator</em>。<br>与 HTTP 负载均衡器不同的是，任务分发系统中的消费者是一种更活跃的角色。绝大多数时候都是消费者连接到任务队列，请求新的任务。这一点在可扩展系统中非常关键，允许我们在不修改生产者部分的情况下，直接平滑地增加工作节点的数量。<br>此外，在一个通用的消息系统中，我们没有必要强调生产者和消费者之间的请求/响应通信。多数情况下，更优先的选择是使用单向的异步通信，从而获得更优异的并行能力和扩展性。消息基本上总是沿着一个方向流动，这样的管道允许我们构建复杂的信息处理架构，又不必承受同步通信带来的开销。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6258cabc8d854f4b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A messaging pipeline"></p><h4 id="ZeroMQ-Fanout-Fanin-模式"><a href="#ZeroMQ-Fanout-Fanin-模式" class="headerlink" title="ZeroMQ Fanout/Fanin 模式"></a>ZeroMQ Fanout/Fanin 模式</h4><h5 id="分布式-hashsum-破解器"><a href="#分布式-hashsum-破解器" class="headerlink" title="分布式 hashsum 破解器"></a>分布式 hashsum 破解器</h5><p>需要以下组件实现一个标准的并行管线：</p><ul><li>一个协调节点负责在多个工作节点间分发任务</li><li>多个工作节点承担具体的计算任务</li><li>一个用于收集计算结果的节点</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-91adec0584325527.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The architecture of a typical pipeline with ZeroMQ"></p><p>即一个节点负责生成所有可能的字符串组合，并将它们分发给不同的工作节点；工作节点则负责计算接收到的字符串，比较 hash 值；最后一个节点负责收集暴力破解的结果。</p><h5 id="实现-producer"><a href="#实现-producer" class="headerlink" title="实现 producer"></a>实现 producer</h5><p>为了表示所有可能的字符组合，这里使用 N 维索引树。每个节点包含一个当前位置下可能出现的字母，比如只有 <code>a</code>、<code>b</code> 两个字母的话，长度为 3 的字符串组合共有图示的以下几种：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d4b87b3295b700ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Indexed n-ary tree for alphabet (a, b)"></p><p><code>indexed-string-variation</code> 包可以帮助我们由索引计算出对应的字符串，这项工作可以在工作节点完成，因此 producer 这里只需要将分好组的索引值分发给工作节点。<br>generateTasks.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span>* <span class="title">generateTasks</span>(<span class="params">searchHash, alphabet,</span></span></span><br><span class="line"><span class="function"><span class="params">    maxWordLength, batchSize</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nVariations = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> n = <span class="number">1</span>; n &lt;= maxWordLength; n++) &#123;</span><br><span class="line">        nVariations += <span class="built_in">Math</span>.pow(alphabet.length, n)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Finding the hashsum source string over '</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;nVariations&#125;</span> possible variations`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> batchStart = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> (batchStart &lt;= nVariations) &#123;</span><br><span class="line">        <span class="keyword">const</span> batchEnd = <span class="built_in">Math</span>.min(</span><br><span class="line">            batchStart + batchSize - <span class="number">1</span>, nVariations)</span><br><span class="line">        <span class="keyword">yield</span> &#123;</span><br><span class="line">            searchHash,</span><br><span class="line">            alphabet: alphabet,</span><br><span class="line">            batchStart,</span><br><span class="line">            batchEnd</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        batchStart = batchEnd + <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>producer.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"><span class="keyword">import</span> delay <span class="keyword">from</span> <span class="string">'delay'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> ventilator = <span class="keyword">new</span> zmq.Push()</span><br><span class="line">    <span class="keyword">await</span> ventilator.bind(<span class="string">'tcp://*:5016'</span>)</span><br><span class="line">    <span class="keyword">await</span> delay(<span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET, maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        <span class="keyword">await</span> ventilator.send(<span class="built_in">JSON</span>.stringify(task))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><ul><li>创建一个 PUSH socket 并绑定给本地的 5016 端口，工作节点的 PULL socket 会连接到此端口并接收任务</li><li>将每一个生成的任务字符串化，通过 PUSH socket 的 <code>send()</code> 方法发送给工作节点。工作节点以轮询的方式接收不同的任务</li></ul><h5 id="实现-worker"><a href="#实现-worker" class="headerlink" title="实现 worker"></a>实现 worker</h5><p>process Task.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isv <span class="keyword">from</span> <span class="string">'indexed-string-variation'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createHash &#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">processTask</span>(<span class="params">task</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> variationGen = isv.generator(task.alphabet)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'processing from '</span> +</span><br><span class="line">        <span class="string">`<span class="subst">$&#123;variationGen(task.batchStart)&#125;</span> (<span class="subst">$&#123;task.batchStart&#125;</span>)`</span> +</span><br><span class="line">        <span class="string">`to <span class="subst">$&#123;variationGen(task.batchEnd)&#125;</span> (<span class="subst">$&#123;task.batchEnd&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> idx = task.batchStart; idx &lt;= task.batchEnd; idx++) &#123;</span><br><span class="line">        <span class="keyword">const</span> word = variationGen(idx)</span><br><span class="line">        <span class="keyword">const</span> shasum = createHash(<span class="string">'sha1'</span>)</span><br><span class="line">        shasum.update(word)</span><br><span class="line">        <span class="keyword">const</span> digest = shasum.digest(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (digest === task.searchHash) &#123;</span><br><span class="line">            <span class="keyword">return</span> word</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>processTask()</code> 遍历给定区间内的所有索引值，对每一个索引生成对应的字符串，再计算其 SHA1 值，与传入的 <code>task</code> 对象中的 <code>searchHash</code> 比较。</p><p>worker.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fromVentilator = <span class="keyword">new</span> zmq.Pull()</span><br><span class="line">    <span class="keyword">const</span> toSink = <span class="keyword">new</span> zmq.Push()</span><br><span class="line"></span><br><span class="line">    fromVentilator.connect(<span class="string">'tcp://localhost:5016'</span>)</span><br><span class="line">    toSink.connect(<span class="string">'tcp://localhost:5017'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> rawMessage <span class="keyword">of</span> fromVentilator) &#123;</span><br><span class="line">        <span class="keyword">const</span> found = processTask(<span class="built_in">JSON</span>.parse(rawMessage.toString()))</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">await</span> toSink.send(<span class="string">`Found: $found`</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p><code>worker.js</code> 创建了两个 socket。PULL socket 负责连接到任务发布方（Ventilator），接收任务；PUSH socket 负责连接到结果收集方（sink），传递任务执行的结果。</p><h5 id="实现-results-collector"><a href="#实现-results-collector" class="headerlink" title="实现 results collector"></a>实现 results collector</h5><p>collector.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> sink = <span class="keyword">new</span> zmq.Pull()</span><br><span class="line">    <span class="keyword">await</span> sink.bind(<span class="string">'tcp://*:5017'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> rawMessage <span class="keyword">of</span> sink) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Message from worker: '</span>, rawMessage.toString())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行以下命令测试结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker.js</span><br><span class="line">node worker.js</span><br><span class="line">node collector.js</span><br><span class="line">node producer.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="AMQP-实现-pipeline-和-competing-consumers"><a href="#AMQP-实现-pipeline-和-competing-consumers" class="headerlink" title="AMQP 实现 pipeline 和 competing consumers"></a>AMQP 实现 pipeline 和 competing consumers</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-e0f424ea12f666ff.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Task distribution architecture using a message queue broker"></p><p>像前面那样在点对点的模式下，实现 pipeline 是非常直观的。假设我们需要借助 AMQP 这类系统实现任务分配模式，就必须确保每条消息都只会被一个消费者接收到。<br>可以直接将任务发布到目标 queue，不经过 exchange。避免了 exchange 有可能绑定了多个 queue 的情况。之后，多个消费者同时监听这一个 queue，消息即会以 fanout 的方式均匀地分发给所有的消费者。</p><h5 id="hashsum-破解器的-AMQP-实现"><a href="#hashsum-破解器的-AMQP-实现" class="headerlink" title="hashsum 破解器的 AMQP 实现"></a>hashsum 破解器的 AMQP 实现</h5><p>producer-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createConfirmChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertQueue(<span class="string">'tasks_queue'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET,</span><br><span class="line">        maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        channel.sendToQueue(<span class="string">'tasks_queue'</span>, Buffer.from(<span class="built_in">JSON</span>.stringify(task)))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> channel.waitForConfirms()</span><br><span class="line">    channel.close()</span><br><span class="line">    connection.close()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><ul><li>此处创建的是一个 <code>confirmChannel</code>，它提供了一个 <code>waitForConfirms()</code> 函数，可以在 broker 确认收到消息前等待，确保应用不会过早地关闭到 broker 的连接</li><li><code>channel.sendToQueue()</code> 负责将一条消息直接发送给某个 queue，跳过任何 exchange 或者路由</li></ul><p>worker-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(<span class="string">'tasks_queue'</span>)</span><br><span class="line">    channel.consume(queue, <span class="keyword">async</span> (rawMessage) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> found = processTask(</span><br><span class="line">            <span class="built_in">JSON</span>.parse(rawMessage.content.toString()))</span><br><span class="line">        <span class="keyword">if</span> (found) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">            <span class="keyword">await</span> channel.sendToQueue(<span class="string">'results_queue'</span>,</span><br><span class="line">                Buffer.from(<span class="string">`Found: <span class="subst">$&#123;found&#125;</span>`</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">await</span> channel.ack(rawMessage)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>collector-amqp.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(<span class="string">'results_queue'</span>)</span><br><span class="line">    channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message from worker: <span class="subst">$&#123;msg.content.toString()&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行如下命令测试效果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker-amqp.js</span><br><span class="line">node worker-amqp.js</span><br><span class="line">node collector-amqp.js</span><br><span class="line">node producer-amqp.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="通过-Redis-Streams-实现任务分发"><a href="#通过-Redis-Streams-实现任务分发" class="headerlink" title="通过 Redis Streams 实现任务分发"></a>通过 Redis Streams 实现任务分发</h4><p>Redis Stream 可以借助一种叫做 <strong>consumer groups</strong> 的特性实现任务分发模式。Consumer group 是一个有状态的实体，由一组名称标识的消费者组成，组中的消费者会以 round-robin 的方式接收记录。<br>每条记录都必须被显式地确认，否则该记录会一直处于 <em>pending</em> 状态。每个消费者都只能访问它自己的 pending 记录，假如消费者突然崩溃，在其回到线上后会先尝试获取其 pending 的记录。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1df8534f81ab4f51.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A Redis Stream consumer group"></p><p>Consumer group 也会记录其读取的上一条消息的 ID，因而在连续的读取操作中，consumer group 知道下一条要读取的记录时是哪个。</p><p>producer-redis.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"><span class="keyword">import</span> &#123; generateTasks &#125; <span class="keyword">from</span> <span class="string">'./generateTasks.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ALPHABET = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span></span><br><span class="line"><span class="keyword">const</span> BATCH_SIZE = <span class="number">10000</span></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [, , maxLength, searchHash] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> generatorObj = generateTasks(searchHash, ALPHABET,</span><br><span class="line">        maxLength, BATCH_SIZE)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> task <span class="keyword">of</span> generatorObj) &#123;</span><br><span class="line">        <span class="keyword">await</span> redisClient.xadd(<span class="string">'tasks_stream'</span>, <span class="string">'*'</span>,</span><br><span class="line">            <span class="string">'task'</span>, <span class="built_in">JSON</span>.stringify(task))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    redisClient.disconnect()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure><p>worker-redis.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"><span class="keyword">import</span> &#123; processTask &#125; <span class="keyword">from</span> <span class="string">'./processTask.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> [, , consumerName] = process.argv</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> redisClient.xgroup(<span class="string">'CREATE'</span>, <span class="string">'tasks_stream'</span>,</span><br><span class="line">        <span class="string">'workers_group'</span>, <span class="string">'$'</span>, <span class="string">'MKSTREAM'</span>)</span><br><span class="line">        .catch(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Consumer group already exists'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClient.xreadgroup(</span><br><span class="line">        <span class="string">'GROUP'</span>, <span class="string">'workers_group'</span>, consumerName, <span class="string">'STREAMS'</span>,</span><br><span class="line">        <span class="string">'tasks_stream'</span>, <span class="string">'0'</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, rawTask]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">        <span class="keyword">await</span> processAndAck(recordId, rawTask)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClient.xreadgroup(</span><br><span class="line">            <span class="string">'GROUP'</span>, <span class="string">'workers_group'</span>, consumerName, <span class="string">'BLOCK'</span>, <span class="string">'0'</span>,</span><br><span class="line">            <span class="string">'COUNT'</span>, <span class="string">'1'</span>, <span class="string">'STREAMS'</span>, <span class="string">'tasks_stream'</span>, <span class="string">'&gt;'</span>)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, rawTask]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">            <span class="keyword">await</span> processAndAck(recordId, rawTask)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processAndAck</span>(<span class="params">recordId, rawTask</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> found = processTask(<span class="built_in">JSON</span>.parse(rawTask))</span><br><span class="line">    <span class="keyword">if</span> (found) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Found! =&gt; <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> redisClient.xadd(<span class="string">'results_stream'</span>, <span class="string">'*'</span>, <span class="string">'result'</span>,</span><br><span class="line">            <span class="string">`Found: <span class="subst">$&#123;found&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">await</span> redisClient.xack(<span class="string">'tasks_stream'</span>, <span class="string">'workers_group'</span>, recordId)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure><ul><li><code>xgroup</code> 命令用来确保 consumer group 存在。<ul><li><code>CREATE</code> 表示我们希望创建一个 consumer group</li><li><code>tasks_stream</code> 表示我们想要读取的 stream 的名字</li><li><code>workers_group</code> 是 consumer group 的名字</li><li>第四个参数表示 consumer group 开始读取的记录的位置。<code>$</code> 表示当前 stream 中最后一条记录的 ID</li><li><code>MKSTREAM</code> 表示如果 stream 不存在则创建它</li></ul></li><li>通过 <code>xreadgroup</code> 命令读取属于当前 consumer 的所有 pending 的记录。<ul><li><code>&#39;GROUP&#39;</code>、<code>&#39;workers_group&#39;</code>、<code>consumerName</code> 用来指代 consumer group 和 consumer 的名字</li><li><code>STREAMS</code> 和 <code>tasks_stream</code> 用来指代我们想要读取的 stream 的名字</li><li><code>0</code> 用来表示我们想要开始读取的记录的位置。这里表示从属于当前 consumer 的第一条记录开始，读取所有 pending 的消息</li></ul></li><li>通过另外一条 <code>xreadgroup</code> 命令读取 stream 里新增加的记录。<ul><li><code>&#39;BLOCK&#39;</code> 和 <code>&#39;0&#39;</code> 两个参数表示如果没有新的消息，就一直阻塞等待。<code>&#39;0&#39;</code> 具体表示一直等待永不超时</li><li><code>&#39;COUNT&#39;</code> 和 <code>&#39;1&#39;</code> 表示一次请求只获取一条记录</li><li>特殊 ID <code>&gt;</code> 表示只获取还没有被当前的 consumer group 处理过的消息</li></ul></li><li><code>processAndAck()</code> 函数负责当 <code>xreadgroup()</code> 返回的记录被处理完成时，调用 <code>xack</code> 命令进行确认，将该记录从当前 consumer 的 pending 列表里移除</li></ul><p>collector-redis.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> lastRecordId = <span class="string">'$'</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> data = <span class="keyword">await</span> redisClient.xread(</span><br><span class="line">            <span class="string">'BLOCK'</span>, <span class="string">'0'</span>, <span class="string">'STREAMS'</span>, <span class="string">'results_stream'</span>, lastRecordId)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [, logs] <span class="keyword">of</span> data) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, message]] <span class="keyword">of</span> logs) &#123;</span><br><span class="line">                <span class="built_in">console</span>.log(<span class="string">`Message from worker: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">                lastRecordId = recordId</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p>运行程序测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node worker-redis.js workerA</span><br><span class="line">node worker-redis.js workerB</span><br><span class="line">node collector-redis.js</span><br><span class="line">node producer-redis.js 4 f8e966d1e207d02c44511a58dccff2f5429e9a3b</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://upload-images.jianshu.io/upload_images/6875152-0ad90045a8fe8b1d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot;
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Pipeline" scheme="https://rollingstarky.github.io/tags/Pipeline/"/>
    
      <category term="Message" scheme="https://rollingstarky.github.io/tags/Message/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="AMQP" scheme="https://rollingstarky.github.io/tags/AMQP/"/>
    
      <category term="Redis" scheme="https://rollingstarky.github.io/tags/Redis/"/>
    
      <category term="RabbitMQ" scheme="https://rollingstarky.github.io/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
      <category term="Task" scheme="https://rollingstarky.github.io/tags/Task/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 消息中间件及其应用模式（发布订阅）</title>
    <link href="https://rollingstarky.github.io/2023/01/03/node-js-design-patterns-message-queue-pub-sub-pattern/"/>
    <id>https://rollingstarky.github.io/2023/01/03/node-js-design-patterns-message-queue-pub-sub-pattern/</id>
    <published>2023-01-02T16:00:00.000Z</published>
    <updated>2023-01-03T12:34:12.199Z</updated>
    
    <content type="html"><![CDATA[<p>主要有两类技术可以用来整合分布式应用：一类是通过共享存储作为一个中心化的协调者，跟踪和保存所有需要共享的信息；另一类则是通过消息中间件，向系统中的所有节点散布数据、事件和命令等。<br>消息存在于软件系统的各个层级。我们通过互联网交换消息完成通信；通过管道发送消息给其他进程；设备驱动通过消息与硬件进行交互等等。任何用于在组件和系统之间交换信息的离散或结构化数据都可以视为消息。</p><h3 id="消息系统基础"><a href="#消息系统基础" class="headerlink" title="消息系统基础"></a>消息系统基础</h3><p>对于消息系统，有以下四个基本要素需要考虑：</p><ul><li>通讯的方向。可以是单向的，也可以是“请求 - 响应”模式</li><li>通讯的目的。同时决定了消息本身的内容</li><li>消息的时效性。可以同步或者异步地发送与接收</li><li>消息的投递方式。可以直接投递也可以通过某个中间件</li></ul><h4 id="单向-vs-“请求-应答”模式"><a href="#单向-vs-“请求-应答”模式" class="headerlink" title="单向 vs “请求 - 应答”模式"></a>单向 vs “请求 - 应答”模式</h4><p>单向模式：消息从源头推送到目的地。常见的应用比如邮件系统、将工作任务分派给一系列工作节点的系统。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-d445119d21df5465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单向通信"></p><p>“请求 - 响应”模式：一方发出的消息总能够与对方发出的消息匹配。比如 web 服务的调用、向数据库请求数据等。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-166789a1fd06211a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Request/Reply"></p><p>包含多个响应节点的“请求 - 响应”模式：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0057bb50d2792ea4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Multi-node request/reply"></p><h4 id="消息类型"><a href="#消息类型" class="headerlink" title="消息类型"></a>消息类型</h4><p>消息内容主要取决于通信的目的。通常有以下三种：</p><ul><li>命令消息</li><li>事件消息</li><li>文档消息</li></ul><p>命令消息用来令接收者触发某个动作或者任务。借助它可以实现<strong>远程过程调用（RPC）</strong>系统，分布式计算等。RESTful HTTP 请求就是简单的命令消息的例子。<br>事件消息用来通知另一个组件发生了某些情况。事件在分布式系统中是一种很重要的整合机制，用来确保系统的各个组件保持同样的步调。<br>文档消息基本上就是在组件之间传输数据。比如数据库请求的结果。</p><h4 id="异步队列和流"><a href="#异步队列和流" class="headerlink" title="异步队列和流"></a>异步队列和流</h4><p>同步通信类似于打电话。电话的双方必须同时在线，连接到同一个通道，实时地交流信息。当我们需要打给另一个人时，通常就得搞一部新的手机或者挂掉当前正在进行的通话，拨打新的号码。<br>异步通信类似于发短信。我们发送短信的时刻，并不需要接收方已经接入了网络。我们可以一条接一条地发送多条短信给不同的人，以任意顺序接收对方的回复（如果有的话）。</p><p>另一个异步通信的重要特性就是，消息可以被临时存储在某个地方，再在之后的某个时间送达。当接收方非常忙碌无法处理新的消息，或者我们需要确保投递的成功率时，这个特性就非常有用了。<br>消息队列就是这样一种在生产者和消费者之间存储消息的中间组件。若消费者因为某种原因崩溃、断开连接等，消息会在队列中累积，待消费者重新上线时立即进行分发。</p><p>另外一种类似的数据结构是 <strong>log</strong>。log 是一种只能追加的结构，它是持久的，其消息可以在到达时被读取，也可以通过访问其历史记录来获取。在消息系统中，也常被叫做 <strong>stream</strong>。<br>不同于队列，在 stream 中，消息被消费后不会被移除，意味着 stream 在消息的获取方面有着更高的自由度。队列通常一次只暴露一条消息给消费者，而一个 stream 能够被多个消费者共享（甚至是同一份消息）。</p><p>消息队列：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-c6b7d3ba279f1e70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message queue"></p><p>流：<br><img src="https://upload-images.jianshu.io/upload_images/6875152-dff0875b9635f2b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="stream"></p><h4 id="点对点-vs-消息中间件"><a href="#点对点-vs-消息中间件" class="headerlink" title="点对点 vs 消息中间件"></a>点对点 vs 消息中间件</h4><p><img src="https://upload-images.jianshu.io/upload_images/6875152-95cde728d89fdf28.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer-to-peer vs broker"></p><h3 id="“发布-订阅”-模式"><a href="#“发布-订阅”-模式" class="headerlink" title="“发布 - 订阅” 模式"></a>“发布 - 订阅” 模式</h3><p>就是一种分布式的观察者模式。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d7b68c4fed8460c8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Pub/Sub"></p><h4 id="一个最小化的实时聊天应用"><a href="#一个最小化的实时聊天应用" class="headerlink" title="一个最小化的实时聊天应用"></a>一个最小化的实时聊天应用</h4><p>package.json：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">    <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">        <span class="attr">"amqplib"</span>: <span class="string">"^0.10.3"</span>,</span><br><span class="line">        <span class="attr">"ioredis"</span>: <span class="string">"^5.2.4"</span>,</span><br><span class="line">        <span class="attr">"JSONStream"</span>: <span class="string">"^1.3.5"</span>,</span><br><span class="line">        <span class="attr">"level"</span>: <span class="string">"^8.0.0"</span>,</span><br><span class="line">        <span class="attr">"leveldown"</span>: <span class="string">"^6.1.1"</span>,</span><br><span class="line">        <span class="attr">"levelup"</span>: <span class="string">"^5.1.1"</span>,</span><br><span class="line">        <span class="attr">"monotonic-timestamp"</span>: <span class="string">"^0.0.9"</span>,</span><br><span class="line">        <span class="attr">"serve-handler"</span>: <span class="string">"^6.1.5"</span>,</span><br><span class="line">        <span class="attr">"superagent"</span>: <span class="string">"^8.0.6"</span>,</span><br><span class="line">        <span class="attr">"ws"</span>: <span class="string">"^8.11.0"</span>,</span><br><span class="line">        <span class="attr">"yargs"</span>: <span class="string">"^17.6.2"</span>,</span><br><span class="line">        <span class="attr">"zeromq"</span>: <span class="string">"^6.0.0-beta.16"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState == ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><ul><li>首先创建一个 HTTP 服务，将所有请求转发给一个特别的 handler（<code>staticHandler</code>），该 handler 负责 serve 所有的静态文件</li><li>创建一个 WebSocket 服务实例，绑定到 HTTP 服务。同时监听来自 WebSocket 客户端的连接请求，以及客户端发送的消息</li><li>当某个客户端发送的新消息到达时，通过 <code>broadcast()</code> 函数将消息广播给所有的客户端</li></ul><p>www/index.html：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    Messages:</span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"messages"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">"msgForm"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"Send a message"</span> <span class="attr">id</span>=<span class="string">"msgBox"</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"Send"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> ws = <span class="keyword">new</span> WebSocket(</span></span><br><span class="line"><span class="javascript">          <span class="string">`ws://<span class="subst">$&#123;<span class="built_in">window</span>.<span class="built_in">document</span>.location.host&#125;</span>`</span></span></span><br><span class="line"><span class="undefined">      )</span></span><br><span class="line"><span class="javascript">      ws.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">message</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> msgDiv = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span></span><br><span class="line"><span class="undefined">          msgDiv.innerHTML = message.data</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementById(<span class="string">'messages'</span>).appendChild(msgDiv)</span></span><br><span class="line"><span class="undefined">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> form = <span class="built_in">document</span>.getElementById(<span class="string">'msgForm'</span>)</span></span><br><span class="line"><span class="javascript">      form.addEventListener(<span class="string">'submit'</span>, (event) =&gt; &#123;</span></span><br><span class="line"><span class="undefined">          event.preventDefault()</span></span><br><span class="line"><span class="javascript">          <span class="keyword">const</span> message = <span class="built_in">document</span>.getElementById(<span class="string">'msgBox'</span>).value</span></span><br><span class="line"><span class="undefined">          ws.send(message)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.getElementById(<span class="string">'msgBox'</span>).value = <span class="string">''</span></span></span><br><span class="line"><span class="undefined">      &#125;)</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>通过 <code>node index.js 8002</code> 命令运行应用，打开两个浏览器页面访问 Web 服务，测试聊天效果：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d15f32a8b9cdeca9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="simple chat"></p><p>但我们的应用是无法进行横向扩展的。比如再启动一个新的服务实例 <code>node index.js 8003</code>，此时连接到 8002 的客户端无法与连接到 8003 的客户端通信。可以自行测试。</p><h4 id="使用-Redis-作为消息中间件"><a href="#使用-Redis-作为消息中间件" class="headerlink" title="使用 Redis 作为消息中间件"></a>使用 Redis 作为消息中间件</h4><p>架构图如下所示。每个服务实例都会把从客户端收到的消息发布到消息中间件，同时也会通过中间件订阅从其他服务实例发布的消息。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8d3811d91615328c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message broker"></p><ul><li>通过客户端网页发送的消息传递给对应的 chat server</li><li>chat server 把收到的消息发布到 Redis</li><li>Redis 将收到的消息分发给所有的订阅方（chat server）</li><li>chat server 将收到的消息再分发给所有连接的客户端</li></ul><p>index-redis.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisSub = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> redisPub = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        redisPub.publish(<span class="string">'chat_message'</span>, <span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">redisSub.subscribe(<span class="string">'chat_message'</span>)</span><br><span class="line"></span><br><span class="line">redisSub.on(<span class="string">'message'</span>, (channel, msg) =&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><p>运行 <code>node index-redis.js 8002</code>、<code>node index-redis.js 8003</code> 两条命令启动两个服务实例，此时连接到不同服务器的客户端相互之间也能够进行通信。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-499f672a581f13b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="message broker"></p><h4 id="点对点-Pub-Sub-模式"><a href="#点对点-Pub-Sub-模式" class="headerlink" title="点对点 Pub/Sub 模式"></a>点对点 Pub/Sub 模式</h4><p>通过 ZeroMQ 创建两种类型的 socket：<code>PUB</code> 和 <code>SUB</code>。PUB socket 绑定到本地机器的某个端口，负责监听来自其他机器上 SUB socket 的订阅请求。当一条消息通过 PUB socket 发送时，该消息会被广播到所有连接的 SUB socket。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4b4de0d43ad174c3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer to peer"></p><p>index-zeromq.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> yargs <span class="keyword">from</span> <span class="string">'yargs'</span></span><br><span class="line"><span class="keyword">import</span> zmq <span class="keyword">from</span> <span class="string">'zeromq'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> pubSocket</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">initializeSockets</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    pubSocket = <span class="keyword">new</span> zmq.Publisher()</span><br><span class="line">    <span class="keyword">await</span> pubSocket.bind(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;yargs(process.argv).argv.pub&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> subSocket = <span class="keyword">new</span> zmq.Subscriber()</span><br><span class="line">    <span class="keyword">const</span> subPorts = [].concat(yargs(process.argv).argv.sub)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> port <span class="keyword">of</span> subPorts) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Subscribing to <span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">        subSocket.connect(<span class="string">`tcp://127.0.0.1:<span class="subst">$&#123;port&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    subSocket.subscribe(<span class="string">'chat'</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> [msg] <span class="keyword">of</span> subSocket) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message from another server: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(msg.toString().split(<span class="string">' '</span>)[<span class="number">1</span>])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">initializeSockets()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(<span class="string">`<span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        pubSocket.send(<span class="string">`chat <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server.listen(yargs(process.argv).argv.http || <span class="number">8000</span>)</span><br></pre></td></tr></table></figure></p><ul><li>通过 <code>yargs</code> 模块解析命令行参数</li><li>通过 <code>initializeSocket()</code> 函数创建 Publisher，并绑定到由 <code>--pub</code> 命令行参数提供的端口上</li><li>创建 Subscriber socket 并将其连接到其他应用实例的 Publisher socket。被连接的 Publisher 端口由 <code>--sub</code> 命令行参数提供。之后创建以 <code>chat</code> 为过滤器的订阅，即只接收以 <code>chat</code> 开头的消息</li><li>通过 <code>for</code> 循环监听到达 Subscriber 的消息，去除消息中的 <code>chat</code> 前缀，通过 <code>broadcast()</code> 函数将处理后的消息广播给所有连接的客户端</li><li>当有消息到达当前实例的 WebSocket 服务时，广播此消息到所有客户端，同时通过 Publisher 发布该消息</li></ul><p>运行服务测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node index-zeromq.js --http 8002 --pub 5000 --sub 5001 --sub 5002</span><br><span class="line">node index-zeromq.js --http 8003 --pub 5001 --sub 5000 --sub 5002</span><br><span class="line">node index-zeromq.js --http 8004 --pub 5002 --sub 5000 --sub 5001</span><br></pre></td></tr></table></figure></p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-12e13d4709bf8fd8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="peer to peer"></p><h4 id="通过队列实现可靠的消息投递"><a href="#通过队列实现可靠的消息投递" class="headerlink" title="通过队列实现可靠的消息投递"></a>通过队列实现可靠的消息投递</h4><p>消息队列是消息系统中的一种重要抽象。借助消息队列，通信中的发送方和接收方不必同时处于活跃的连接状态。队列系统会负责存储未投递的消息，直到目标处于能够接收的状态。</p><p>消息系统的投递机制可以简单概况为以下 3 类：</p><ul><li>最多一次：<em>fire-and-forget</em>。消息不会被持久化，投递状态也不会被确认。意味着在接收者崩溃或者断开连接时，消息有可能丢失</li><li>最少一次：消息会确保至少被收到一次。但是重复收取同一条消息的情况有可能出现，比如接收者在收到消息后突然崩溃，没有来得及告知发送者消息已经收到。</li><li>只有一次：这是最可靠的投递机制，保证消息只会被接收一次。但由于需要更复杂的确认机制，会牺牲一部分消息投递的效率。</li></ul><p>当消息投递机制可以实现“最少一次”或者“只有一次”时，我们就有了 <strong>durable subscriber</strong>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-91ce9034f820ad86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="durable subscriber"></p><h5 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h5><p>AMQP 是一个被很多消息系统支持的开放标准协议。除了定义一个通用的传输协议以外，他还提供了用于描述 routing、filtering、queuing、reliability 和 security 的模型。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-41538e4ba6810317.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMQP"></p><ul><li>Queue：用于存储消息的数据结构。假如多个消费者绑定了同一个队列，消息在它们之间是负载均衡的。队列可以是以下任意一种类型：<ul><li>Durable：当中间件重启时队列会自动重建。但这并不意味着其内容也会被保留。实际上只有标记为持久化消息的内容才会被保存到磁盘，并在重启时恢复</li><li>Exclusive：队列只绑定给唯一一个特定的订阅者，当连接关闭时，队列即被销毁</li><li>Auto-delete：当最后一个订阅者断开连接时，队列被删除</li></ul></li><li>Exchange：消息发布的地方。Exchange 会将消息路由至一个或者多个 queue。路由规则取决于具体的实现：<ul><li>Direct exchange：通过完整匹配一个 routing key 来对消息进行路由（如 <code>chat.msg</code>）</li><li>Topic exchange：对 routing key 进行模糊匹配（如 <code>chat.#</code> 匹配所有以 <code>chat</code> 开头的 key）</li><li>Fanout exchange：将消息广播至所有连接的 queue，忽略提供的任何 routing key</li></ul></li><li>Binding：Exchange 和 queue 之间的链接，定义了用于过滤消息的 routing key 或模式</li></ul><p>上述所有组件由中间件进行维护，同时对外暴露用于创建和维护的 API。当连接到某个中间件时，客户端会创建一个 <strong>channel</strong> 对象负责维护通信的状态。</p><h4 id="AMQP-和-RabbitMQ-实现-durable-subscriber"><a href="#AMQP-和-RabbitMQ-实现-durable-subscriber" class="headerlink" title="AMQP 和 RabbitMQ 实现 durable subscriber"></a>AMQP 和 RabbitMQ 实现 durable subscriber</h4><p>chat 应用和消息历史记录服务的架构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9da25ec0835b65cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="AMQP and history service"></p><h5 id="AMQP-和数据库实现-history-service"><a href="#AMQP-和数据库实现-history-service" class="headerlink" title="AMQP 和数据库实现 history service"></a>AMQP 和数据库实现 history service</h5><p>此模块由两部分组成：一个 HTTP 服务负责将聊天历史记录暴露给客户端；一个 AMQP 消费者负责获取聊天消息并将它们保存在本地数据库中。</p><p>historySvc.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> levelup <span class="keyword">from</span> <span class="string">'levelup'</span></span><br><span class="line"><span class="keyword">import</span> leveldown <span class="keyword">from</span> <span class="string">'leveldown'</span></span><br><span class="line"><span class="keyword">import</span> timestamp <span class="keyword">from</span> <span class="string">'monotonic-timestamp'</span></span><br><span class="line"><span class="keyword">import</span> JSONStream <span class="keyword">from</span> <span class="string">'JSONStream'</span></span><br><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> db = levelup(leveldown(<span class="string">'./msgHistory'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = channel.assertQueue(<span class="string">'chat_history'</span>)</span><br><span class="line">    <span class="keyword">await</span> channel.bindQueue(queue, <span class="string">'chat'</span>)</span><br><span class="line">    channel.consume(queue, <span class="keyword">async</span> msg =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> content = msg.content.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Saving message: <span class="subst">$&#123;content&#125;</span>`</span>)</span><br><span class="line">        <span class="keyword">await</span> db.put(timestamp(), content)</span><br><span class="line">        channel.ack(msg)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        res.writeHead(<span class="number">200</span>)</span><br><span class="line">        db.createValueStream()</span><br><span class="line">            .pipe(JSONStream.stringify())</span><br><span class="line">            .pipe(res)</span><br><span class="line">    &#125;).listen(<span class="number">8090</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><ul><li>创建一个到 AMQP 中间件的连接</li><li>设置一个名为 <code>chat</code> 的 fanout 模式的 exchange。<code>assertExchange()</code> 函数会确保相应的 exchange 存在，否则就创建</li><li>创建一个名为 <code>chat_history</code> 的 queue，绑定给上一步中创建的 exchange</li><li>开始监听来自 queue 的消息，将收到的每一条消息保存至 LevelDB 数据库，以时间戳作为键。消息保存成功后由 <code>channel.ack(msg)</code> 进行确认。若确认动作未被中间件收到，则该条消息会保留在队列中再次被处理</li></ul><p>index-amqp.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> amqp <span class="keyword">from</span> <span class="string">'amqplib'</span></span><br><span class="line"><span class="keyword">import</span> JSONStream <span class="keyword">from</span> <span class="string">'JSONStream'</span></span><br><span class="line"><span class="keyword">import</span> superagent <span class="keyword">from</span> <span class="string">'superagent'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpPort = process.argv[<span class="number">2</span>] || <span class="number">8000</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> connection = <span class="keyword">await</span> amqp.connect(<span class="string">'amqp://localhost'</span>)</span><br><span class="line">    <span class="keyword">const</span> channel = <span class="keyword">await</span> connection.createChannel()</span><br><span class="line">    <span class="keyword">await</span> channel.assertExchange(<span class="string">'chat'</span>, <span class="string">'fanout'</span>)</span><br><span class="line">    <span class="keyword">const</span> &#123; queue &#125; = <span class="keyword">await</span> channel.assertQueue(</span><br><span class="line">        <span class="string">`chat_srv_<span class="subst">$&#123;httpPort&#125;</span>`</span>,</span><br><span class="line">        &#123; <span class="attr">exclusive</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">    <span class="keyword">await</span> channel.bindQueue(queue, <span class="string">'chat'</span>)</span><br><span class="line">    channel.consume(queue, msg =&gt; &#123;</span><br><span class="line">        msg = msg.content.toString()</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`From queue: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        broadcast(msg)</span><br><span class="line">    &#125;, &#123; <span class="attr">noAck</span>: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">    wss.on(<span class="string">'connection'</span>, client =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line"></span><br><span class="line">        client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">            channel.publish(<span class="string">'chat'</span>, <span class="string">''</span>, Buffer.from(msg))</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        superagent</span><br><span class="line">            .get(<span class="string">'http://localhost:8090'</span>)</span><br><span class="line">            .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.log(err))</span><br><span class="line">            .pipe(JSONStream.parse(<span class="string">'*'</span>))</span><br><span class="line">            .on(<span class="string">'data'</span>, msg =&gt; &#123;</span><br><span class="line">                client.send(Buffer(msg).toString())</span><br><span class="line">            &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">            <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">                client.send(msg)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    server.listen(httpPort)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.log(err))</span><br></pre></td></tr></table></figure></p><ul><li>我们的聊天服务没必要是 durable subscriber，<strong>fire-and-forget</strong> 机制就足够了，因而有 <code>{ exclusive: true }</code> 选项</li><li>确认机制也是不需要的。<code>{ noAck: true }</code></li><li>发布消息也很简单，只需要指定目标 exchange（<code>chat</code>）和一个 routing key 即可，这里我们使用的是 fanout exchange，不需要路由，routing key 为空</li><li>发布到 exchange 的消息被转发到所有绑定的 queue，再到达所有订阅了 queue 的服务实例，每个实例再将消息发送到所有连接的客户端</li><li>通过 <code>superagent</code> 请求 history 微服务，将获取到的所有历史消息发送给刚连接的客户端</li></ul><p>运行服务测试效果：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node index-amqp.js 8002</span><br><span class="line">node index-amqp.js 8003</span><br><span class="line">node historySvc.js</span><br></pre></td></tr></table></figure></p><h4 id="通过-streams-实现可靠的消息投递"><a href="#通过-streams-实现可靠的消息投递" class="headerlink" title="通过 streams 实现可靠的消息投递"></a>通过 streams 实现可靠的消息投递</h4><p>在系统集成的范畴里，stream（或 log）是一种有序的、只能追加的持久化的数据结构。Stream 概念里的 message 更应该叫做 record，总是被添加到 stream 末尾，且不会在被消费之后自动删除（不同于 queue）。这种特性令 stream 更像是一种数据仓库而不是消息中间件。<br>Stream 的另一个重要特性在于，record 是被消费者从 stream 中“拉取”的，因而消费者可以按照自己的节奏处理 record。<br>Stream 可以用来实现可靠的消息投递，一旦消费者崩溃，它可以在恢复后从中断的地方继续拉取消息。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-f9552fc7ba634302.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Reliable message delivery with streams"></p><h5 id="Streams-vs-消息队列"><a href="#Streams-vs-消息队列" class="headerlink" title="Streams vs 消息队列"></a>Streams vs 消息队列</h5><p>Stream 明显的应用场景在于处理顺序的流数据，也支持批量处理或者根据之前的消息确定相关性，并可以跨多个节点分发数据。<br>Stream 和消息队列都可以实现 Pub/Sub 模式，但消息队列更适合复杂的系统集成任务，它可以提供更复杂的路由机制，允许我们为不同的消息提供不同的优先级，而 Stream 中 record 的顺序是一定的。</p><h5 id="通过-Redis-Streams-实现-chat-应用"><a href="#通过-Redis-Streams-实现-chat-应用" class="headerlink" title="通过 Redis Streams 实现 chat 应用"></a>通过 Redis Streams 实现 chat 应用</h5><p>index-stream.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createServer &#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> staticHandler <span class="keyword">from</span> <span class="string">'serve-handler'</span></span><br><span class="line"><span class="keyword">import</span> ws, &#123; WebSocketServer &#125; <span class="keyword">from</span> <span class="string">'ws'</span></span><br><span class="line"><span class="keyword">import</span> Redis <span class="keyword">from</span> <span class="string">'ioredis'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> redisClient = <span class="keyword">new</span> Redis()</span><br><span class="line"><span class="keyword">const</span> redisClientXRead = <span class="keyword">new</span> Redis()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> staticHandler(req, res, &#123; <span class="attr">public</span>: <span class="string">'www'</span> &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> wss = <span class="keyword">new</span> WebSocketServer(&#123; server &#125;)</span><br><span class="line">wss.on(<span class="string">'connection'</span>, <span class="keyword">async</span> client =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client connected'</span>)</span><br><span class="line">    client.on(<span class="string">'message'</span>, msg =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Message: <span class="subst">$&#123;msg&#125;</span>`</span>)</span><br><span class="line">        redisClient.xadd(<span class="string">'chat_stream'</span>, <span class="string">'*'</span>, <span class="string">'message'</span>, msg)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> logs = <span class="keyword">await</span> redisClient.xrange(</span><br><span class="line">        <span class="string">'chat_stream'</span>, <span class="string">'-'</span>, <span class="string">'+'</span>)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> [, [, message]] <span class="keyword">of</span> logs) &#123;</span><br><span class="line">        client.send(message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">broadcast</span>(<span class="params">msg</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> client <span class="keyword">of</span> wss.clients) &#123;</span><br><span class="line">        <span class="keyword">if</span> (client.readyState === ws.OPEN) &#123;</span><br><span class="line">            client.send(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lastRecordId = <span class="string">'$'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">processStreamMessages</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> [[, records]] = <span class="keyword">await</span> redisClientXRead.xread(</span><br><span class="line">            <span class="string">'BLOCK'</span>, <span class="string">'0'</span>, <span class="string">'STREAMS'</span>, <span class="string">'chat_stream'</span>, lastRecordId)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> [recordId, [, message]] <span class="keyword">of</span> records) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">`Message from stream: <span class="subst">$&#123;message&#125;</span>`</span>)</span><br><span class="line">            broadcast(message)</span><br><span class="line">            lastRecordId = recordId</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">processStreamMessages().catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br><span class="line"></span><br><span class="line">server.listen(process.argv[<span class="number">2</span>] || <span class="number">8080</span>)</span><br></pre></td></tr></table></figure></p><ul><li><code>xadd</code> 负责在收到来自客户端的消息时，向 stream 添加一条新的 record。它接收 3 个参数：<ul><li>Stream 的名字，这里是 <code>chat_stream</code></li><li>record 的 ID。这里传入的是星号（<code>*</code>），令 Redis 为我们生成一个 ID。ID 必须是单调递增的，以保持 record 的顺序，而 Redis 可以替我们处理这些</li><li>key-value 的列表。这里只提供 value <code>msg</code>（从客户端收到的消息）的 ‘message’ key</li></ul></li><li>使用 <code>xrange</code> 检索 stream 的过往记录，以获取聊天历史。我们在每次有客户端连接时就进行一次检索。其中 <code>-</code> 表示最小的 ID 值，<code>+</code> 表示最大的 ID 值，因而整个 <code>xrange</code> 会获取当前 stream 中所有的消息</li><li>最后一部分的逻辑是等待新的记录被添加到 stream 中，从而每个应用实例都能读取到更新的消息。这里使用一个无线循环和 <code>xread</code> 命令：<ul><li>其中 <code>BLOCK</code> 表示在新消息到达前阻塞</li><li><code>0</code> 用来指定超时时间，超过这个时间则直接返回 <code>null</code>。<code>0</code> 代表不超时</li><li><code>STREAMS</code> 是一个关键字，告诉 Redis 我们接下来会指定想要读取的 stream 的细节</li><li><code>chat_stream</code> 是 stream 的名字</li><li>最后我们提供 record ID（<code>lastRecordId</code>）作为读取新消息的节点。初始情况下是 <code>$</code>，表示当前 stream 中最大的 ID。当我们读取第一条消息后，更新 <code>lastRecordId</code> 为最近读取到的消息的 ID</li></ul></li></ul><p>此外，解包消息的代码 <code>for (const [, [, message]] of logs) {...}</code> 实际上等同于 <code>for (const [recordId, [propertyId, message]] of logs) {...}</code>，由 <code>xrange</code> 命令查询到的消息的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [&quot;1588590110918-0&quot;, [&quot;message&quot;, &quot;This is a message&quot;]],</span><br><span class="line">  [&quot;1588590130852-0&quot;, [&quot;message&quot;, &quot;This is another message&quot;]]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;主要有两类技术可以用来整合分布式应用：一类是通过共享存储作为一个中心化的协调者，跟踪和保存所有需要共享的信息；另一类则是通过消息中间件，向系统中的所有节点散布数据、事件和命令等。&lt;br&gt;消息存在于软件系统的各个层级。我们通过互联网交换消息完成通信；通过管道发送消息给其他进程
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Queue" scheme="https://rollingstarky.github.io/tags/Queue/"/>
    
      <category term="Message" scheme="https://rollingstarky.github.io/tags/Message/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Observer" scheme="https://rollingstarky.github.io/tags/Observer/"/>
    
      <category term="Broker" scheme="https://rollingstarky.github.io/tags/Broker/"/>
    
      <category term="Pub/Sub" scheme="https://rollingstarky.github.io/tags/Pub-Sub/"/>
    
      <category term="AMQP" scheme="https://rollingstarky.github.io/tags/AMQP/"/>
    
      <category term="Redis" scheme="https://rollingstarky.github.io/tags/Redis/"/>
    
      <category term="RabbitMQ" scheme="https://rollingstarky.github.io/tags/RabbitMQ/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 组合类型</title>
    <link href="https://rollingstarky.github.io/2022/12/15/programming-with-types-compound-types/"/>
    <id>https://rollingstarky.github.io/2022/12/15/programming-with-types-compound-types/</id>
    <published>2022-12-14T16:00:00.000Z</published>
    <updated>2022-12-15T12:41:26.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="复合类型"><a href="#复合类型" class="headerlink" title="复合类型"></a>复合类型</h3><p>最直观的创造新的复合类型的方式，就是直接将多个类型组合在一起。比如平面上的点都有 X 和 Y 两个坐标，各自都属于 number 类型。因此可以说，平面上的点是由两个 number 类型组合成的新类型。<br>通常来说，将多个类型直接组合在一起形成新的类型，这样的类型最终的取值范围，就是全部成员类型所有可能的组合值的集合。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-5679c2f114176904.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Compound Types"></p><h4 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h4><p>假如我们需要一个函数来计算两个点之间的距离，可以这样实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">x1: <span class="built_in">number</span>, y1: <span class="built_in">number</span>, x2: <span class="built_in">number</span>, y2: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt((x1 - x1) ** <span class="number">2</span> + (y1 - y2) ** <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述实现能够正常工作，但并不算完美。<code>x1</code> 在没有对应的 Y 坐标一起出现的情况下，是没有任何实际含义的。同时在应用的其他地方，我们很可能也会遇到很多针对坐标点的其他操作，因此相对于将 X 坐标和 Y 坐标独立地进行表示和传递，我们可以将两者组合在一起，成为一个新的元组类型。<br>元组能够帮助我们将单独的 X 和 Y 坐标组合在一起作为“点”对待，从而令代码更方便阅读和书写。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Point = [<span class="built_in">number</span>, <span class="built_in">number</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1[<span class="number">0</span>] - point2[<span class="number">0</span>]) ** <span class="number">2</span> + (point1[<span class="number">1</span>] - point2[<span class="number">1</span>]) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h5 id="DIY-元组"><a href="#DIY-元组" class="headerlink" title="DIY 元组"></a>DIY 元组</h5><p>大部分语言都提供了元组作为内置语法，这里假设在标准库里没有元组的情况下，如何自己实现包含两个元素的元组类型：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Pair&lt;T1, T2&gt; &#123;</span><br><span class="line">    m0: T1;</span><br><span class="line">    m1: T2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">m0: T1, m1: T2</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.m0 = m0;</span><br><span class="line">        <span class="keyword">this</span>.m1 = m1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Point = Pair&lt;<span class="built_in">number</span>, <span class="built_in">number</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1.m0 - point2.m0) ** <span class="number">2</span> + (point1.m1 - point2.m1) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Record-类型"><a href="#Record-类型" class="headerlink" title="Record 类型"></a>Record 类型</h4><p>将坐标点定义为数字对，是可以正常工作的。但是我们也因此失去了在代码中包含更多含义的机会。在前面的例子中，我们假定第一个数字是 X 坐标，第二个数字是 Y 坐标。但最好是借助类型系统，在代码中编入更精确的含义。从而彻底消除将 X 错认为是 Y 或者将 Y 错认为是 X 的机会。<br>可以借助 Record 类型来实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">    x: <span class="built_in">number</span>;</span><br><span class="line">    y: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">distance</span>(<span class="params">point1: Point, point2: Point</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(</span><br><span class="line">        (point1.x - point2.x) ** <span class="number">2</span> + (point1.y - point2.y) ** <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>首要的原则是，最好优先使用含义清晰的 Record 类型，它包含的元素是有明确的命名的。而不是直接将元组传来传去</strong>。元组并不会为自己的元素提供名称，只是靠数字索引访问，因而会存在很大的误解的可能性。当然另一方面，元组是内置的，而 Record 类型通常需要额外进行定义。但大多数情况下，这样的额外工作是值得的。</p><h4 id="维持不可变性"><a href="#维持不可变性" class="headerlink" title="维持不可变性"></a>维持不可变性</h4><p>类的成员函数和成员变量可以被定义为 <code>public</code>（能够被公开访问），也可以被定义为 <code>private</code>（只允许内部访问）。在 TypeScript 中，成员默认都是公开的。<br>通常情况下我们定义 Record 类型，如果其成员变量是独立的，比如之前的 Point，X 坐标和 Y 坐标都可以独立的进行修改，不会影响到对方。且它们的值可以在不引起问题的情况下变化。像这样的成员被定义成公开的一般不会出现问题。<br>但是也存在另外一些情况。比如下面这个由 <code>dollar</code> 值和 <code>cents</code> 值组成的 Currency 类型：</p><ul><li>dollar 值必须是一个大于或者等于 0 的整数</li><li>cent 值也必须是一个大于或者等于 0 的整数</li><li>cent 值不能大于 99，每 100 cents 都必须转换成 1 dollar</li></ul><p>如果我们允许 <code>dollars</code> 和 <code>cents</code> 变量被公开访问，就有可能导致出现不规范的对象：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    dollars: <span class="built_in">number</span>;</span><br><span class="line">    cents: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        dollars = dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>);</span><br><span class="line">        cents = cents % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">        <span class="keyword">this</span>.cents = cents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> amount: Currency = <span class="keyword">new</span> Currency(<span class="number">5</span>, <span class="number">50</span>);</span><br><span class="line">amount.cents = <span class="number">300</span>;  <span class="comment">// 由于属性是公开的，外部代码可以直接修改。从而产生非法对象</span></span><br></pre></td></tr></table></figure></p><p>上述情况可以通过将成员变量定义为 <code>private</code> 来避免。同时为了维护方便，一般还需要提供公开的方法对私有的属性进行修改。这些方法通常会包含一定的验证规则，确保修改后的对象状态是合法的。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    <span class="keyword">private</span> dollars: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> cents: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.assignDollars(dollars);</span><br><span class="line">        <span class="keyword">this</span>.assignCents(cents);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getDollars(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.dollars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assignDollars(dollars: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getCents(): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.cents;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assignCents(cents: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.assignDollars(<span class="keyword">this</span>.dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>));</span><br><span class="line">        <span class="keyword">this</span>.cents = cents % <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>外部代码只能通过 <code>assignDollars()</code> 和 <code>assignCents()</code> 两个公开的方法，对私有的属性 <code>dollars</code> 和 <code>cents</code> 进行修改。同时这两个方法也会确保对象的状态一直符合我们定义的规则。</p><p>另外一种观点是，可以将属性定义成<strong>不可变</strong>（只读）的。这样属性就可以直接被外部访问，因为只读属性会阻止自身被修改。从而对象状态保持合法。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Currency &#123;</span><br><span class="line">    readonly dollars: <span class="built_in">number</span>;</span><br><span class="line">    readonly cents: <span class="built_in">number</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">dollars: <span class="built_in">number</span>, cents: <span class="built_in">number</span></span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(cents) || cents &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        dollars = dollars + <span class="built_in">Math</span>.floor(cents / <span class="number">100</span>);</span><br><span class="line">        cents = cents % <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">Number</span>.isSafeInteger(dollars) || dollars &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.dollars = dollars;</span><br><span class="line">        <span class="keyword">this</span>.cents = cents;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>不可变对象还有一个优势，从不同的线程对这类数据并发地访问是保证安全的。可变性会导致数据竞争。<br>但其劣势在于，每次我们需要一个新的值，就必须创建一个新的实例，无法通过修改现有对象得到。而创建新对象有时候是很昂贵的操作。</p><p>最终的目的在于，阻止外部代码直接修改属性，以至于跳过验证规则。可以将属性变为私有，对属性的访问完全通过包含验证规则的公开方法；也可以将属性声明为不可变的，在构造对象时执行验证。</p><h3 id="either-or-类型"><a href="#either-or-类型" class="headerlink" title="either-or 类型"></a>either-or 类型</h3><p><strong>either-or</strong> 是另外一种基础的将类型组合在一起的方式，即某个值有可能是多个类型所有合法取值中的任何一个。比如 Rust 语言中的 <code>Result&lt;T, E&gt;</code>，可能是成功的值 <code>Ok(T)</code>，也可能是失败值 <code>Err(E)</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-ea3eccddddacfc53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="either-or"></p><h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>先从一个简单的例子开始，通过类型系统编码周一到周日。我们可以用 0-6 的数字来表示一周的七天，0 表示一周里的第一天。但这样表示并不理想，因为不同的工程师可能对这些数字有不同的理解。有些国家第一天是周日，有些国家第一天是周一。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == <span class="number">5</span> || dayOfWeek == <span class="number">6</span>;</span><br><span class="line">&#125;  <span class="comment">// 欧洲国家判断是否是周末</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= <span class="number">1</span> &amp;&amp; dayOfWeek &lt;= <span class="number">5</span>;</span><br><span class="line">&#125;  <span class="comment">// 美国判断是否是工作日</span></span><br></pre></td></tr></table></figure></p><p>上述两个函数是冲突的。若 0 表示周日，则 <code>isWeekend()</code> 是不正确的；若 0 表示周一，则 <code>isWeekday()</code> 是不正确的。</p><p>其他的方案是定义一系列常量用来表示一周七天。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sunday: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> Monday: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> Tuesday: <span class="built_in">number</span> = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> Wednesday: <span class="built_in">number</span> = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> Thursday: <span class="built_in">number</span> = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">const</span> Friday: <span class="built_in">number</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> Saturday: <span class="built_in">number</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == Saturday || dayOfWeek == Sunday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: <span class="built_in">number</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= Monday &amp;&amp; dayOfWeek &lt;= Friday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在的实现看上去好了一些，但仍有问题。单看函数的签名，无法清楚的知道 <code>number</code> 类型的参数的期待值具体是什么。假如一个新接手代码的人刚看到 <code>dayOfWeek: number</code>，他可能不会意识到存在 <code>Sunday</code> 这类常量在某个模块的某处。因而他们会倾向于自己解释此处的数字。甚至一些人会传入非法的数字参数比如 <code>-1</code> 或 <code>10</code>。</p><p>更好的方案是借助枚举类型。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> DayOfWeek &#123;</span><br><span class="line">    Sunday,</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekend</span>(<span class="params">dayOfWeek: DayOfWeek</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek == DayOfWeek.Saturday</span><br><span class="line">        || dayOfWeek == DayOfWeek.Sunday;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isWeekday</span>(<span class="params">dayOfWeek: DayOfWeek</span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dayOfWeek &gt;= DayOfWeek.Monday</span><br><span class="line">        &amp;&amp; dayOfWeek &lt;= DayOfWeek.Friday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Optional-类型"><a href="#Optional-类型" class="headerlink" title="Optional 类型"></a>Optional 类型</h4><p>假设我们需要将一个用户输入的 <code>string</code> 值转换为 <code>DayOfWeek</code>，若该 <code>string</code> 值是合法的，则返回对应的 <code>DayOfWeek</code>；若该 <code>string</code> 值非法，则显式地返回 <code>undefined</code>。<br>在 TypeScript 中，可以通过 <code>|</code> 类型操作符来实现，<code>|</code> 允许我们组合多个类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">DayOfWeek</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>: <span class="keyword">return</span> DayOfWeek.Sunday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>: <span class="keyword">return</span> DayOfWeek.Monday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>: <span class="keyword">return</span> DayOfWeek.Tuesday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"Wednesday"</span>: <span class="keyword">return</span> DayOfWeek.Wednesday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>: <span class="keyword">return</span> DayOfWeek.Thursday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>: <span class="keyword">return</span> DayOfWeek.Friday;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>: <span class="keyword">return</span> DayOfWeek.Saturday;</span><br><span class="line">        <span class="keyword">default</span>: <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useInput</span>(<span class="params">input: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result: DayOfWeek | <span class="literal">undefined</span> = parseDayOfWeek(input);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result === <span class="literal">undefined</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`Failed to parse "<span class="subst">$&#123;input&#125;</span>"`</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> dayOfWeek: DayOfWeek = result;</span><br><span class="line">        <span class="comment">/* Use dayOfWeek */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述 <code>parseDayOfWeek()</code> 函数返回一个 <code>DayOfWeek</code> 或者 <code>undefined</code>。<code>useInput()</code> 函数在调用 <code>parseDayOfWeek()</code> 后再对返回值进行解包操作，输出错误信息或者得到合法值。</p><blockquote><p><strong>Optional 类型</strong>：也常被叫做 <strong>Maybe</strong> 类型，表示一个可能存在的 T 类型值。一个 Optional 类型的实例，可能会包含一个 T 类型的任意值；也可能是一个特殊值，用来表示 T 类型的值不存在。</p></blockquote><h5 id="DIY-Optional"><a href="#DIY-Optional" class="headerlink" title="DIY Optional"></a>DIY Optional</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Optional&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> value: T | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">private</span> assigned: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value?: T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasValue(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.assigned) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;T&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Optional 类型的优势在于，直接使用 <code>null</code> 空类型非常容易出错。因为判断一个变量什么时候能够为空或者不能为空是非常困难的，我们必须在所有代码中添加非空检查，否则就会有引用指向空值的风险，进一步导致运行时错误。<br>Optional 背后的逻辑在于，将 <code>null</code> 值从合法的取值范围中解耦出来。Optional 明确了哪些变量有可能为空值。类型系统知晓 Optional 类型（比如 <code>DayOfWeek | undefined</code>，可能为空）和对应的非空类型（<code>DayOfWeek</code>）是不一样的。两者是不兼容的类型，因而我们不会将 Optional 类型及其非空类型相混淆，在需要非空类型的地方错误地使用有可能为空值的 Optional。一旦需要取出 Optional 中包含的值，就必须显式地进行解包操作，对空值进行检查。</p><h4 id="Result-or-error"><a href="#Result-or-error" class="headerlink" title="Result or error"></a>Result or error</h4><p>现在尝试扩展前面的 <code>DayOfWeek</code> 例子。当 <code>DayOfWeek</code> 值无法正常识别时，我们不是简单地返回 <code>undefined</code>，而是输出包含更多内容的错误信息。<br>常见的一个反模式就是同时返回 <code>DayOfWeek</code> 和错误码。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> InputError &#123;</span><br><span class="line">    OK,</span><br><span class="line">    NoInput,</span><br><span class="line">    Invalid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Result &#123;</span><br><span class="line">    error: InputError;</span><br><span class="line">    value: DayOfWeek;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">error: InputError, value: DayOfWeek</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.NoInput, DayOfWeek.Sunday);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Sunday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Monday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Tuesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"wednesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Wednesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Thursday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Friday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.OK, DayOfWeek.Saturday);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Result(InputError.Invalid, DayOfWeek.Sunday);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现并不是理想的，原因在于，一旦我们忘记了检查错误代码，没有任何机制阻止我们继续使用 <code>DayOfWeek</code> 值。即便错误代码表明有问题出现，我们仍然可以忽视该错误并直接取用 <code>DayOfWeek</code>。<br>将类型看作值的集合，则上述 <code>Result</code> 类型实际上是 <code>InputError</code> 和 <code>DayOfWeek</code> 所有可能值的组合。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8c4f310c4de150d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Result Type"></p><p>我们应该实现一种 <strong>either-or</strong> 类型，返回值<strong>要么</strong>是错误类型，<strong>要么</strong>是合法的值。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-987b07939b567994.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Either-or Result Type"></p><h5 id="DIY-Either"><a href="#DIY-Either" class="headerlink" title="DIY Either"></a>DIY Either</h5><p><code>Either</code> 类型包含了 <code>TLeft</code> 和 <code>TRight</code> 另外两种类型。<code>TLeft</code> 用来存储错误类型，<code>TRight</code> 保存合法的值。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Either&lt;TLeft, TRight&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> readonly value: TLeft | TRight;</span><br><span class="line">    <span class="keyword">private</span> readonly left: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">value: TLeft | TRight, left: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isLeft(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getLeft(): TLeft &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isLeft()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TLeft&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isRight(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRight(): TRight &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isRight()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TRight&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeLeft&lt;TLeft, TRight&gt;(value: TLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeRight&lt;TLeft, TRight&gt;(value: TRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>借助上面的 <code>Either</code> 实现，我们可以将 <code>parseDayOfWeek()</code> 更新为返回 <code>Either&lt;InputError, DayOfWeek&gt;</code>。若函数返回 <code>InputError</code>，则结果中就不会包含 <code>DayOfWeek</code>；若函数返回 <code>DayOfWeek</code>，就可以肯定没有错误发生。<br>当然，我们需要显式地将结果（或 Error）从 <code>Either</code> 中解包出来。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> InputError &#123;</span><br><span class="line">    NoInput,</span><br><span class="line">    Invalid</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Result = Either&lt;InputError, DayOfWeek&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseDayOfWeek</span>(<span class="params">input: <span class="built_in">string</span></span>): <span class="title">Result</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="string">""</span>)</span><br><span class="line">        <span class="keyword">return</span> Either.makeLeft(InputError.NoInput)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (input.toLowerCase()) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"sunday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Sunday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"monday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Monday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"tuesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Tuesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"wednesday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Wednesday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"thursday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Thursday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"friday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Friday);</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"saturday"</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeRight(DayOfWeek.Saturday);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> Either.makeLeft(InputError.Invalid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当错误本身并不是“异常的”（大部分情况下，处理用户输入的时候），或者调用某个会返回错误码的系统 API，我们并不想直接抛出异常，但仍旧需要传递正确值或者错误码这类信息。这些时候，最好将这类信息编码到 <em>either value or error</em> 中。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;复合类型&quot;&gt;&lt;a href=&quot;#复合类型&quot; class=&quot;headerlink&quot; title=&quot;复合类型&quot;&gt;&lt;/a&gt;复合类型&lt;/h3&gt;&lt;p&gt;最直观的创造新的复合类型的方式，就是直接将多个类型组合在一起。比如平面上的点都有 X 和 Y 两个坐标，各自都属于 numb
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Tuple" scheme="https://rollingstarky.github.io/tags/Tuple/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Optional" scheme="https://rollingstarky.github.io/tags/Optional/"/>
    
      <category term="Either" scheme="https://rollingstarky.github.io/tags/Either/"/>
    
      <category term="Enum" scheme="https://rollingstarky.github.io/tags/Enum/"/>
    
      <category term="Immutable" scheme="https://rollingstarky.github.io/tags/Immutable/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— 生命周期管理</title>
    <link href="https://rollingstarky.github.io/2022/11/29/kubernetes-patterns-reading-notes-managing-lifecycle/"/>
    <id>https://rollingstarky.github.io/2022/11/29/kubernetes-patterns-reading-notes-managing-lifecycle/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:23:40.756Z</updated>
    
    <content type="html"><![CDATA[<p>由云原生平台管理的容器化应用，并不能控制其自身的生命周期。它们必须监听由管理平台发出的事件，再对生命周期做出相对应的变更。所谓的生命周期管理，即代表应用该如何读取和响应这些由管理平台发出的生命周期事件。</p><p>鉴于某些管理策略或者外部环境因素，在任意时间点，管理平台都有可能需要启动或者终止容器中的应用。容器化应用可以决定平台发出的哪些事件是重要的，应该以怎样的行为去响应。这实际上是一个平台用来同应用进行沟通、向应用发送命令的 API，应用可以选择接受或者忽略。</p><p>仅仅使用进程模型来启动和终止应用通常是不够的，现实世界中的应用往往需要更细粒度的交互控制和生命周期管理。有些应用需要 warm up，有些需要一个平滑、干净的关闭流程。因而 Kubernetes 设计了如下几种由平台发出的事件，容器可以选择监听和响应这些事件。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-4553383b68e82dca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="events"></p><h4 id="SIGTERM-Signal"><a href="#SIGTERM-Signal" class="headerlink" title="SIGTERM Signal"></a>SIGTERM Signal</h4><p>当 Kubernetes 决定关闭某个容器时，该容器会收到一个 SIGTERM 信号，之后容器会尝试尽快完成关闭流程。对于某些应用来说，干净的快速终止是可行的。但另外一些应用有可能需要完成处理中的请求，释放打开的连接，清理临时文件等。这会耗费更多的时间。</p><h4 id="SIGKILL-Signal"><a href="#SIGKILL-Signal" class="headerlink" title="SIGKILL Signal"></a>SIGKILL Signal</h4><p>当某个容器进程在收到 SIGTERM 信号后并没有关闭，接下来它会再收到一个 SIGKILL 信号强制终止进程。默认情况下，Kubernetes 会在发出 SIGTERM 信号 30 秒后再发送 SIGKILL。这个 30 秒的过渡时间可以通过 Pod 的 <code>.spec.terminationGracePeriodSeconds</code> 字段进行配置。</p><h4 id="Poststart-Hook"><a href="#Poststart-Hook" class="headerlink" title="Poststart Hook"></a>Poststart Hook</h4><p>仅仅使用进程信号来管理生命周期有一定程度的限制。因而 Kubernetes 又提供了 <code>postStart</code> 和 <code>postStop</code>。<br><code>postStart</code> 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">post-start-hook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      postStart:</span></span><br><span class="line"><span class="attr">        exec:</span></span><br><span class="line"><span class="attr">          command:</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sh</span></span><br><span class="line"><span class="bullet">          -</span> <span class="bullet">-c</span></span><br><span class="line"><span class="bullet">          -</span> <span class="string">sleep</span> <span class="number">30</span> <span class="string">&amp;&amp;</span> <span class="string">echo</span> <span class="string">"Wake up!"</span> <span class="string">&gt; /tmp/postStart_done</span></span><br></pre></td></tr></table></figure></p><p><code>postStart</code> 指定的命令会在容器创建后执行，与容器的基础进程异步。<code>postStart</code> 是一种阻塞请求，其 handler 完成之前，容器会一直处于 <em>Waiting</em> 状态，同时 Pod 处于 <em>Pending</em> 状态。<br><code>postStart</code> 的这种特性可以用来延迟容器的启动，为容器的主进程的初始化争取时间。</p><p>另一个 <code>postStart</code> 的使用场景就是在 Pod 不满足特定的前提条件时，阻止容器完成启动。当 <code>postStart</code> 命令返回了一个非 0 的返回值，主进程会被 Kubernetes 杀掉。</p><p>类似于 Health Probe，postStart 和 preStop 有如下两种 handler 类型：</p><ul><li>exec：在容器中直接运行一个命令</li><li>httpGet：向容器开放的某个端口发送 HTTP GET 请求</li></ul><p>对于 postStart 执行的逻辑，需要注意以下几点：</p><ul><li>postStart 与容器进程是并行的关系，因而这个 hook 有可能在容器启动前执行</li><li>postStart 有至少执行一次的目标，需要考虑重复执行的情况</li><li>对于失败的 HTTP 请求，postStart 不会重复尝试</li></ul><h4 id="preStop"><a href="#preStop" class="headerlink" title="preStop"></a>preStop</h4><p><code>preStop</code> hook 是一个在容器终止前发送给容器的阻塞请求。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pre-stop-hook</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    lifecycle:</span></span><br><span class="line"><span class="attr">      preStop:</span></span><br><span class="line"><span class="attr">        httpGet:</span></span><br><span class="line"><span class="attr">          port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">          path:</span> <span class="string">/shutdown</span></span><br></pre></td></tr></table></figure></p><p>虽然 <code>preStop</code> 是阻塞的，但若它挂起或者返回一个非成功的结果，并不会阻止进程被杀掉、容器被删除。<code>preStop</code> 只是为了能够平滑地关闭应用，是除 SIGTERM 之外的另一种方便的选择。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>云原生平台能提供的最大的好处之一，就是在不够可靠的云计算基础设施上，可靠地运行和扩展应用。这类平台设计了一系列应用必须遵守的协议和约束。处理和响应协议中的事件，能够确保应用平稳地启动和关闭，对接受服务的客户端只有最小的影响。应用的生命周期不再由个人所控制，而是完全由平台自动化管理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由云原生平台管理的容器化应用，并不能控制其自身的生命周期。它们必须监听由管理平台发出的事件，再对生命周期做出相对应的变更。所谓的生命周期管理，即代表应用该如何读取和响应这些由管理平台发出的生命周期事件。&lt;/p&gt;
&lt;p&gt;鉴于某些管理策略或者外部环境因素，在任意时间点，管理平台
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Pod" scheme="https://rollingstarky.github.io/tags/Pod/"/>
    
      <category term="k8s" scheme="https://rollingstarky.github.io/tags/k8s/"/>
    
      <category term="lifecycle" scheme="https://rollingstarky.github.io/tags/lifecycle/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 类型及类型系统</title>
    <link href="https://rollingstarky.github.io/2022/11/29/programming-with-types-type-and-type-system/"/>
    <id>https://rollingstarky.github.io/2022/11/29/programming-with-types-type-and-type-system/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:33:14.957Z</updated>
    
    <content type="html"><![CDATA[<h4 id="为什么要有类型"><a href="#为什么要有类型" class="headerlink" title="为什么要有类型"></a>为什么要有类型</h4><p>从硬件和机器码这类底层视角来看，程序逻辑（代码）和代码操作的数据都是通过比特（bits）来表示，没有任何区别。<br>当系统没办法正确地将这两者区分开来，错误就很容易发生。这类松散解析的一个例子就是 JavaScript 中的 <code>eval()</code> 函数。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"40+2"</span>));</span><br><span class="line"># =&gt; 42</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">eval</span>(<span class="string">"Hello world!"</span>));</span><br><span class="line"># =&gt; Uncaught SyntaxError: Unexpected identifier</span><br></pre></td></tr></table></figure></p><p>除了正确区分代码和数据以外，我们还需要知道如何将一串字节序列中的数据解释出来。<br>比如一个 16 位的字节序列 <code>1100001010100011</code> 既可以表示无符号 16 位整数 <code>49827</code>，又可以表示有符号 16 位整数 <code>-15709</code>，还可以表示 UTF-8 编码的字符 <code>£</code>，或者其他完全不同的数据。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-d97ac5ac41b6a960.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="A sequence of bits can be interpreted in multiple ways"></p><p>类型赋予数据现实的意义。从而我们的软件能够在特定的上下文中，从一串给定的字节序列中解析出正确的值，不会将其误解成其他的含义。<br>此外，类型还能够限定变量的取值范围。比如一个有符号的 16 位整数，只能是  <code>-32768</code> 到 <code>32767</code> 之间的任意整数，不能超过这个范围。<strong>类型可以看作是由合法的值构成的集合</strong>。<br>这种对于取值的限制，很大程度上可以帮助我们减少代码中的错误。</p><h5 id="类型的定义"><a href="#类型的定义" class="headerlink" title="类型的定义"></a>类型的定义</h5><p><strong>类型</strong>是一种对数据的分类，它定义了某类数据上能够执行的操作，允许的取值以及数据本身的意义。编译器或者运行时能够对类型进行检测，确保数据的完整性、访问控制，以及本身的含义没有被曲解。</p><h4 id="类型系统的作用"><a href="#类型系统的作用" class="headerlink" title="类型系统的作用"></a>类型系统的作用</h4><p>从根本上说，所有的数据都是一堆零和一组成的字节序列。数据本身的属性，比如怎样表示、是否可变、是否对于外部可见等，都是类型级别的性质。<br>我们将某个变量声明为数字类型，类型检查器会确保不会将数据解析为字符串。我们将某个变量声明为私有或只读的，即便数据本身在内存中和公开的、可变的数据并没有任何区别，类型检查器会确保私有的变量不会在作用域外部被引用，只读的变量不会被修改。</p><h5 id="Correctness"><a href="#Correctness" class="headerlink" title="Correctness"></a>Correctness</h5><p>类型能够帮助我们向代码中添加更加严格的限制条件，确保其行为正确。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scriptAt</span>(<span class="params">s: <span class="built_in">any</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.indexOf(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="string">"TypeScript"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>上述代码运行时会报出 <code>TypeError</code> 错误，因为 <code>42</code> 并不是 <code>scriptAt</code> 函数的合法参数。但是编译器并没有发现这个错误，因为它没有获得足够的类型信息。<br>将参数 <code>s</code> 的类型从 <code>any</code> 改为 <code>string</code>，修改后的代码会在编译时报出类型错误：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scriptAt</span>(<span class="params">s: <span class="built_in">string</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.indexOf(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="string">"TypeScript"</span>));</span><br><span class="line"><span class="built_in">console</span>.log(scriptAt(<span class="number">42</span>));  <span class="comment">// Argument of type '42' is not assignable to parameter of type 'string'</span></span><br></pre></td></tr></table></figure></p><p>借助类型系统，我们可以将原来在运行时爆发的错误提前到影响相对较小的编译期，从而在代码正式运行或发布之前发现和修复 bug。</p><p>当程序进入到 <em>bad state</em> 状态时，错误就会发生。<em>bad state</em> 意味着当前所有存活着的变量的状态组合，由于某种原因是非法的。消除这类 <em>bad state</em> 的一种方式，就是通过限制变量可以接受的可能值的数量来减少状态空间。即更精确的类型定义。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a70a8613573ae081.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="strict types"></p><h5 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h5><p>不可变性的概念同样来自于将软件系统视为变化的状态空间。当我们处于一个已知的好的状态时，我们能维持该状态的某些部分不发生变化，就能降低出现错误的可能性。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeDivide</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"x should not be 0"</span>);</span><br><span class="line">    x = x - <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述代码中，变量 <code>x</code> 在检查除数不为零的语句之后发生了改变，导致前面的检查语句变得毫无意义。这类情况在现实中经常出现，比如变量被某一个并发的线程所修改。<br>可以将变量声明为不可变的常量。若代码中尝试对常量进行修改，编译时就会报出错误。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">safeDivide</span>(<span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> x: <span class="built_in">number</span> = <span class="number">42</span>;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"x should not be 0"</span>);</span><br><span class="line">    x = x - <span class="number">42</span>;  <span class="comment">// error TS2588: Cannot assign to 'x' because it is a constant</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">42</span> / x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>变量和常量在内存中的表示并无任何异同，只是对编译器而言有不同的意义。优化编译器在处理不可变变量时能够生成更高效的代码，此外当涉及到并发时，不可变性的用处非常大。当数据不可变时，数据竞争的情形就不会存在。</p><h5 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h5><p>封装代表一种隐藏代码内部细节的能力，它能够帮助我们应对复杂性问题。我们将代码分割成一个个相对较小的组件，每个组件只向外部暴露有限的功能，其内部的实现细节则被隐藏和隔离。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SafeDivisor &#123;</span><br><span class="line">    divisor: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setDivisor(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value should not be 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.divisor = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    divide(x: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x / <span class="keyword">this</span>.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> SafeDivisor();</span><br><span class="line">sd.divisor = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">console</span>.log(sd.divide(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>在上述代码中，<code>divisor</code> 不再是不可变的常量，而是可以通过公开的 API <code>setDivisor()</code> 更新的变量。但新的问题在于，调用者可以绕过包含检查功能的赋值接口，直接访问实例的 <code>divisor</code> 属性并将其改为任意值。因为 <code>divisor</code> 属性对于外部世界是可以公开访问的。<br>为了使 <code>divisor</code> 属性只对实例内部可见，外部对该属性的访问只能通过 <code>setDivisor()</code> 这类刻意公开的方法，可以将属性声明为 <code>private</code>：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SafeDivisor &#123;</span><br><span class="line">    <span class="keyword">private</span> divisor: <span class="built_in">number</span> = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    setDivisor(value: <span class="built_in">number</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Value should not be 0"</span>);</span><br><span class="line">        <span class="keyword">this</span>.divisor = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    divide(x: <span class="built_in">number</span>): <span class="built_in">number</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> x / <span class="keyword">this</span>.divisor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sd = <span class="keyword">new</span> SafeDivisor();</span><br><span class="line">sd.divisor = <span class="number">0</span>;  <span class="comment">// error TS2341: Property 'divisor' is private and only accessible within class 'SafeDivisor'</span></span><br><span class="line"><span class="built_in">console</span>.log(sd.divide(<span class="number">42</span>));</span><br></pre></td></tr></table></figure></p><p>封装性能够帮助我们将逻辑和数据分派给公开的接口和非公开的实现，这对于构建大型系统非常有利。面向接口（抽象）编程可以减轻我们理解特定代码片段的心智负担，当我们引用某个功能时，我们只需要知晓公开的接口如何工作、如何使用，不必掌握任何内部的实现细节。<br>同时封装性能够帮助我们将非公开的信息封锁在特定的边界内，保证没有任何外部代码会对其进行改动，提高了代码的安全性。</p><h5 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h5><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstNegativeNumber</span>(<span class="params">numbers: <span class="built_in">number</span>[]</span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i of numbers) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span>) <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstOneCharacterString</span>(<span class="params">strings: <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> str of strings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str.length == <span class="number">1</span>) <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述两个函数有着几乎一致的逻辑，这造成了一定程度的冗余代码。可以将它们之间通用的逻辑抽象成一个共享的算法，将变化的部分（操作的类型、判断条件）作为参数传入：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function first&lt;T&gt;(range: T[], p: (elem: T) =&gt; boolean): T | undefined &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> elem of range) &#123;</span><br><span class="line">        <span class="keyword">if</span> (p(elem)) <span class="keyword">return</span> elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstNegativeNumber</span>(<span class="params">numbers: <span class="built_in">number</span>[]</span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first(numbers, <span class="function"><span class="params">n</span> =&gt;</span> n &lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findFirstOneCharacterString</span>(<span class="params">strings: <span class="built_in">string</span>[]</span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first(strings, <span class="function"><span class="params">str</span> =&gt;</span> str.length == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>假如我们需要为上述所有的实现添加自定义的 logging，只更新 <code>first</code> 函数的实现即可。又或者我们发现了一种更加高效的算法，只需要更新 <code>first</code> 函数，所有 <code>first</code> 的调用者就都能享受到性能的提升。</p><p>将相互独立的组件组合成一个灵活的模块化的系统，各部分组件松散地结合在一起，相互之间有着更少的冗余代码。整体的代码量也会大大降低。新需求的添加往往只需要独立地修改特定的组件，而不会影响到整个系统。同时这样的模块化系统理解起来也更加容易，因为其中的每一个组件都可以拆下来，独立地进行分析。</p><h5 id="可读性"><a href="#可读性" class="headerlink" title="可读性"></a>可读性</h5><p>读代码的动作远远多于写代码。类型提供了额外的非常有价值的信息，能够令代码更加清晰、易读。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">find</span>(<span class="params">range: <span class="built_in">any</span>, pred: <span class="built_in">any</span></span>): <span class="title">any</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">first</span>&lt;<span class="title">T</span>&gt;(<span class="params">range: T[],</span></span></span><br><span class="line">    p: (elem: T) =&gt; boolean): T | undefined;</span><br></pre></td></tr></table></figure><h4 id="类型系统的分类"><a href="#类型系统的分类" class="headerlink" title="类型系统的分类"></a>类型系统的分类</h4><p><strong>动态类型 vs 静态类型</strong><br>动态类型不会在编译期强加任何类型约束，类型只会在运行时生效。<br>静态类型正相反，会在编译期执行类型检查，任何不恰当的类型都会导致编译错误。能够令类型错误在编译期就爆出来，不至于导致正在运行的程序发生故障，是静态类型的主要优势。</p><p>JavaScript、Python 属于动态类型，TypeScript、Java 属于静态类型。</p><p><strong>弱类型 vs 强类型</strong><br>类型系统的强弱，用来描述系统在强制执行类型约束时的严格程度。一个弱的类型系统会隐式地尝试将某个值从实际的类型转换成期待的类型。</p><p>在强类型系统中，“牛奶”不等于“白色”。牛奶是一种液体，而颜色是另外一种不同的事物，两者无法进行比较；<br>在弱类型的世界里，我们可以直接说，因为牛奶的颜色是白色，牛奶等于白色。不需要像强类型那样，对类型显式地进行转换。</p><p>JavaScript 是弱类型的：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="string">'2'</span> == <span class="number">2</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="number">1</span> + <span class="string">'1'</span></span><br><span class="line"><span class="string">'11'</span></span><br></pre></td></tr></table></figure></p><p>隐式类型转换非常危险。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;为什么要有类型&quot;&gt;&lt;a href=&quot;#为什么要有类型&quot; class=&quot;headerlink&quot; title=&quot;为什么要有类型&quot;&gt;&lt;/a&gt;为什么要有类型&lt;/h4&gt;&lt;p&gt;从硬件和机器码这类底层视角来看，程序逻辑（代码）和代码操作的数据都是通过比特（bits）来表示，没有
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Static" scheme="https://rollingstarky.github.io/tags/Static/"/>
    
      <category term="Immutability" scheme="https://rollingstarky.github.io/tags/Immutability/"/>
    
      <category term="Encapsulation" scheme="https://rollingstarky.github.io/tags/Encapsulation/"/>
    
      <category term="Composability" scheme="https://rollingstarky.github.io/tags/Composability/"/>
    
      <category term="Readability" scheme="https://rollingstarky.github.io/tags/Readability/"/>
    
  </entry>
  
  <entry>
    <title>Programming with Types —— 高阶类型（Functor、Monad）</title>
    <link href="https://rollingstarky.github.io/2022/11/29/programming-with-types-higher-kinded-types-functor-monad/"/>
    <id>https://rollingstarky.github.io/2022/11/29/programming-with-types-higher-kinded-types-functor-monad/</id>
    <published>2022-11-28T16:00:00.000Z</published>
    <updated>2022-11-29T12:40:07.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="通用的-map-实现"><a href="#通用的-map-实现" class="headerlink" title="通用的 map 实现"></a>通用的 map 实现</h4><p><strong>map</strong> 是函数式编程中非常常见的一类接口，可以将某个函数操作应用到一系列元素上。一个通用的 <code>map()</code> 实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function* map&lt;T, U&gt;(iter: Iterable&lt;T&gt;, func: (item: T) =&gt; U):</span><br><span class="line">    IterableIterator&lt;U&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> value of iter) &#123;</span><br><span class="line">        <span class="keyword">yield</span> func(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/6875152-671697213fda1f26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Map over Iterable"></p><p>上述实现主要针对可迭代对象，可以将函数 <code>func</code>（类型为 <code>(item: T) =&gt; U</code>）应用给可迭代对象 <code>iter</code> 中的每一个元素。<br>为了使 <code>map()</code> 函数的场景更为通用，<code>func</code> 的参数 <code>item: T</code> 理应能够接收更多类型的值，比如 <code>Option&lt;T&gt;</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Optional&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> value: T | <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">private</span> assigned: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value?: T</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (value) &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.value = <span class="literal">undefined</span>;</span><br><span class="line">            <span class="keyword">this</span>.assigned = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    hasValue(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.assigned;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getValue(): T &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.assigned) <span class="keyword">throw</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;T&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>从逻辑上看，将一个类型为 <code>(value: T) =&gt; U</code> 的函数 map 到 <code>Optional&lt;T&gt;</code> 类型，如果该 <code>Optional&lt;T&gt;</code> 里面包含一个类型为 <code>T</code> 的值，则返回值应该是包含 <code>U</code> 的 <code>Optional&lt;U&gt;</code> 类型；若 <code>Optional&lt;T&gt;</code> 并不包含任何值，则 map 操作应该返回一个空的 <code>Optional&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-8fd119a44a530d07.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapping a function over an optional value"></p><p>下面是支持 Optional 类型的 map 实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Optional &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        optional: Optional&lt;T&gt;, func: (value: T) =&gt; U): Optional&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (optional.hasValue()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;U&gt;(func(optional.getValue()));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Optional&lt;U&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>另一种简单的通用类型 <code>Box&lt;T&gt;</code> 及其 map 实现：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">    value: T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Box &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; U): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Box&lt;U&gt;(func(box.value));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将类型为 <code>(value: T) =&gt; U</code> 的函数 map 到 <code>Box&lt;T&gt;</code>，返回一个 <code>Box&lt;U&gt;</code>。<code>Box&lt;T&gt;</code> 中 <code>T</code> 类型的值会被取出来，传递给被 map 的函数，再将结果放入 <code>Box&lt;U&gt;</code> 中返回。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-266798b640197653.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Mapping a function over a value in a Box"></p><h4 id="处理结果-or-传递错误"><a href="#处理结果-or-传递错误" class="headerlink" title="处理结果 or 传递错误"></a>处理结果 or 传递错误</h4><p>假设我们需要实现一个 <code>square()</code> 函数来计算某个数字的平方，以及一个 <code>stringify</code> 函数将数字转换为字符串。示例如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">square</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value ** <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>还有一个 <code>readNumber()</code> 函数负责从文件中读取数字。当我们需要处理输入数据时，有可能会遇到某些问题，比如文件不存在或者无法打开等。在上述情况下，<code>readNumber()</code> 函数会返回 <code>undefined</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readNumber</span>(<span class="params"></span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* Implementation omitted */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果我们想通过 <code>readNumber()</code> 读取一个数字，再将其传递给 <code>square()</code> 处理，就必须确保 <code>readNumber()</code> 返回的值是一个实际的数字，而不是 <code>undefined</code>。一种可行的方案就是借助 <code>if</code> 语句将 <code>number | undefined</code> 转换为 <code>number</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">number</span> | <span class="literal">undefined</span> = readNumber();</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> stringify(square(value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>square()</code> 接收数字类型的参数，因而当输入有可能是 <code>undefined</code> 时，我们需要显式地处理这类情况。但通常意义上讲，代码的分支越少，其复杂性就越低，就更易于理解和维护。<br>另一种实现 <code>process()</code> 的方式就是，并不对 <code>undefined</code> 做任何处理，只是将其简单地传递下去。即只让 <code>process()</code> 负责数字的处理工作，error 则交给后续的其他人。</p><p>可以借助 为 sum type 实现的 <code>map()</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> SumType &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        value: T | undefined, func: (value: T) =&gt; U): U | undefined &#123;</span><br><span class="line">        <span class="keyword">if</span> (value == <span class="literal">undefined</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> func(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">process</span>(<span class="params"></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> value: <span class="built_in">number</span> | <span class="literal">undefined</span> = readNumber();</span><br><span class="line">    <span class="keyword">let</span> squaredValue: <span class="built_in">number</span> | <span class="literal">undefined</span> = SumType.map(value, square)</span><br><span class="line">    <span class="keyword">return</span> SumType.map(squaredValue, stringify);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时的 <code>process()</code> 实现不再包含分支逻辑。将 <code>number | undefined</code> 解包为 <code>number</code> 并对 <code>underfined</code> 进行检查的操作由 <code>map()</code> 负责。</p><p>同时 <code>map()</code> 是通用的函数，可以直接在其他 process 函数中对更多不同类型的数据使用（如 <code>string | undefined</code>），减少重复代码。</p><p>版本一（不借助 <code>map</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareSumType</span>(<span class="params">value: <span class="built_in">number</span> | <span class="literal">undefined</span></span>): <span class="title">number</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> square(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">squareBox</span>(<span class="params">box: Box&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">Box</span>&lt;<span class="title">number</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(square(box.value))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringifySumType</span>(<span class="params">value: <span class="built_in">number</span> | <span class="literal">undefined</span></span>): <span class="title">string</span> | <span class="title">undefined</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value == <span class="literal">undefined</span>) <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    <span class="keyword">return</span> stringify(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringifyBox</span>(<span class="params">box: Box&lt;<span class="built_in">number</span>&gt;</span>): <span class="title">Box</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(stringify(box.value));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>版本二（借助 <code>map</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x: <span class="built_in">number</span> | <span class="literal">undefined</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y: Box&lt;<span class="built_in">number</span>&gt; = <span class="keyword">new</span> Box(<span class="number">42</span>);</span><br><span class="line"><span class="built_in">console</span>.log(SumType.map(x, stringify))</span><br><span class="line"><span class="built_in">console</span>.log(Box.map(y, stringify))</span><br><span class="line"><span class="built_in">console</span>.log(SumType.map(x, square))</span><br><span class="line"><span class="built_in">console</span>.log(Box.map(y, square))</span><br></pre></td></tr></table></figure></p><h4 id="Functor-定义"><a href="#Functor-定义" class="headerlink" title="Functor 定义"></a>Functor 定义</h4><p><strong>Functor</strong>：对于任意的泛型，比如 <code>Box&lt;T&gt;</code>，能够通过 <code>map()</code> 操作将函数 <code>(value: T) =&gt; U</code> 应用给 <code>Box&lt;T&gt;</code>，并返回一个 <code>Box&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-26bc7d77056c267f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor"></p><p>又或者说，Functor 是支持某种 <code>map()</code> 函数的任意类型 <code>H&lt;T&gt;</code>。该 <code>map()</code> 函数接收 <code>H&lt;T&gt;</code> 作为参数，一个从 <code>T</code> 到 <code>U</code> 的函数作为另一个参数，最终返回 <code>H&lt;U&gt;</code>。<br>以更面向对象一点的形式来表现的话，参考如下代码（当然这段代码是编译不通过的，因为 TypeScript 不支持高阶类型，如 <code>&lt;H&lt;T&gt;&gt;</code>）：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> Functor&lt;H&lt;T&gt;&gt; &#123;</span><br><span class="line">    map&lt;U&gt;<span class="function">(<span class="params">func: (<span class="params">value: T</span>) =&gt; U</span>): <span class="params">H</span>&lt;<span class="params">U</span>&gt;;</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="params">class</span> <span class="params">Box</span>&lt;<span class="params">T</span>&gt; <span class="params">implements</span> <span class="params">Functor</span>&lt;<span class="params">Box</span>&lt;<span class="params">T</span>&gt;&gt; &#123;</span></span><br><span class="line"><span class="function">    <span class="params">value</span>: <span class="params">T</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">constructor</span>(<span class="params">value: T</span>) &#123;</span></span><br><span class="line"><span class="function">        <span class="params">this</span>.<span class="params">value</span> = <span class="params">value</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">    <span class="params">map</span>&lt;<span class="params">U</span>&gt;(<span class="params">func: (<span class="params">value: T</span>) =&gt; U</span>): <span class="params">Box</span>&lt;<span class="params">U</span>&gt; &#123;</span></span><br><span class="line"><span class="function">        <span class="params">return</span> <span class="params">new</span> <span class="params">Box</span>(<span class="params">func(<span class="params"><span class="keyword">this</span>.value</span>)</span>);</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p><h4 id="Functors-for-functions"><a href="#Functors-for-functions" class="headerlink" title="Functors for functions"></a>Functors for functions</h4><p>实际上还存在针对函数的 Functor。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-893278c77eac1c8a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor for function"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">Function</span> &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        f: (arg1: T, arg2: T) =&gt; T, func: (value: T) =&gt; U)</span><br><span class="line">        : <span class="function">(<span class="params">arg1: T, arg2: T</span>) =&gt;</span> U &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">(<span class="params">arg1: T, arg2: T</span>) =&gt;</span> func(f(arg1, arg2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result: <span class="built_in">string</span> = <span class="built_in">Function</span>.map(add, stringify)(<span class="number">40</span>, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br></pre></td></tr></table></figure><h4 id="Monads"><a href="#Monads" class="headerlink" title="Monads"></a>Monads</h4><p>在前面的例子中，只有第一个函数 <code>readNumber()</code> 有可能返回错误（<code>undefined</code>）。借助 Functor，<code>square()</code> 和 <code>stringify()</code> 可以不经修改地正常调用，若 <code>readNumber()</code> 返回 <code>undefined</code>，该 <code>undefined</code> 不会被处理，只是简单地传递下去。<br>但是假如链条中的每一个函数都有可能返回错误，又该如何处理呢？</p><p>假设我们需要打开某个文件，读取其内容，再将读取到的字符串反序列化为一个 <code>Cat</code> 对象。<br>负责打开文件的 <code>openFile()</code> 函数可能返回一个 <code>Error</code> 或者 <code>FileHandle</code>。比如当文件不存在、文件被其他进程锁定或者用户没有权限读取文件，都会导致返回 <code>Error</code>。<br>还需要一个 <code>readFile()</code> 函数，接收 <code>FileHandle</code> 作为参数，返回一个 <code>Error</code> 或者 <code>String</code>。比如有可能内存不足导致文件无法被读取，返回 <code>Error</code>。<br>最后还需要一个 <code>deserializeCat()</code> 函数接收 <code>string</code> 作为参数，返回一个 <code>Error</code> 或者 <code>Cat</code> 对象。同样的道理，string 有可能格式不符合要求，无法被反序列化为 <code>Cat</code> 对象，返回 <code>Error</code>。</p><p>所有上述函数都遵循一种“返回一个正常结果或者一个错误对象”的模式，其返回值类型为 <code>Either&lt;Error, ...&gt;</code>。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">openFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">FileHandle</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">handle: FileHandle</span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">string</span>&gt;</span>;</span><br><span class="line"><span class="keyword">declare</span> <span class="function"><span class="keyword">function</span> <span class="title">deserializeCat</span>(<span class="params">serializedCat: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt;</span>;</span><br></pre></td></tr></table></figure></p><p>只是为了方便举例，上述函数并不包含具体的实现代码。同时 <code>Either</code> 类型的实现如下：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Either&lt;TLeft, TRight&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> readonly value: TLeft | TRight;</span><br><span class="line">    <span class="keyword">private</span> readonly left: <span class="built_in">boolean</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">constructor</span>(<span class="params">value: TLeft | TRight, left: <span class="built_in">boolean</span></span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isLeft(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getLeft(): TLeft &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.isLeft()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TLeft&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    isRight(): <span class="built_in">boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> !<span class="keyword">this</span>.left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    getRight(): TRight &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.isRight()) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">        <span class="keyword">return</span> &lt;TRight&gt;<span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeLeft&lt;TLeft, TRight&gt;(value: TLeft) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> makeRight&lt;TLeft, TRight&gt;(value: TRight) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Either&lt;TLeft, TRight&gt;(value, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终将上述各个函数连接起来的 process 函数类似下面这样：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCatFromFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line">    <span class="keyword">if</span> (handle.isLeft()) <span class="keyword">return</span> Either.makeLeft(handle.getLeft());</span><br><span class="line">    <span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = readFile(handle.getRight());</span><br><span class="line">    <span class="keyword">if</span> (content.isLeft()) <span class="keyword">return</span> Either.makeLeft(content.getLeft());</span><br><span class="line">    <span class="keyword">return</span> deserializeCat(content.getRight());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>就像在上一个例子中对 <code>process</code> 函数做的那样，我们可以实现一个类似的 <code>map()</code> 函数，将 <code>readCatFromFile()</code> 中的所有分支结构和错误检查都转移到通用的 <code>map()</code> 中。<br>按照普遍的约定，<code>Either&lt;TLeft, TRight&gt;</code> 中的 <code>TLeft</code> 包含错误对象，<code>map()</code> 只会将其不做改动地传递下去。只有当 <code>TRight</code> 存在时，<code>map()</code> 才会对 <code>Either</code> 应用给定的函数。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Either &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">TLeft</span>, <span class="title">TRight</span>, <span class="title">URight</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        value: Either&lt;TLeft, TRight&gt;,</span></span></span><br><span class="line">        func: (value: TRight) =&gt; URight): Either&lt;TLeft, URight&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isLeft()) <span class="keyword">return</span> Either.makeLeft(value.getLeft());</span><br><span class="line">        <span class="keyword">return</span> Either.makeRight(func(value.getRight()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述 <code>map()</code> 实现的问题在于，当我们调用 <code>openFile()</code> 得到返回值 <code>Either&lt;Error, FileHandle&gt;</code>，接下来就需要一个类型为 <code>(value: FileHandle) =&gt; string</code> 的函数从 <code>FileHandle</code> 读取文件内容。<br>但是实际上的 <code>readFile()</code> 函数的返回类型不是 <code>string</code>，而是 <code>Either&lt;Error, string&gt;</code>。</p><p>当我们调用<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line"><span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = Either.map(handle, readFile);</span><br></pre></td></tr></table></figure></p><p>会导致爆出 <code>Type &#39;Either&lt;Error, Either&lt;Error, string&gt;&gt;&#39; is not assignable to type &#39;Either&lt;Error, string&gt;&#39;.</code> 错误。</p><p>正确的实现应该是如下形式的 <code>bind()</code> 方法：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Either &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>&lt;<span class="title">TLeft</span>, <span class="title">TRight</span>, <span class="title">URight</span>&gt;(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">        value: Either&lt;TLeft, TRight&gt;,</span></span></span><br><span class="line">        func: (value: TRight) =&gt; Either&lt;TLeft, URight&gt;</span><br><span class="line">    ): Either&lt;TLeft, URight&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (value.isLeft()) <span class="keyword">return</span> Either.makeLeft(value.getLeft());</span><br><span class="line">        <span class="keyword">return</span> func(value.getRight());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>借助 <code>bind()</code> 实现的 <code>readCatFromFile()</code> 函数：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readCatFromFile</span>(<span class="params">path: <span class="built_in">string</span></span>): <span class="title">Either</span>&lt;<span class="title">Error</span>, <span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> handle: Either&lt;<span class="built_in">Error</span>, FileHandle&gt; = openFile(path);</span><br><span class="line">    <span class="keyword">let</span> content: Either&lt;<span class="built_in">Error</span>, <span class="built_in">string</span>&gt; = Either.bind(handle, readFile);</span><br><span class="line">    <span class="keyword">return</span> Either.bind(content, deserializeCat);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Functor-vs-Monad"><a href="#Functor-vs-Monad" class="headerlink" title="Functor vs Monad"></a>Functor vs Monad</h4><p>对于 <code>Box&lt;T&gt;</code>，Functor（<code>map()</code>）会接收一个 <code>Box&lt;T&gt;</code> 值和一个从 <code>T</code> 到 <code>U</code> 的函数（<code>(value: T) =&gt; U</code>）作为参数，将 <code>T</code> 值取出并应用给传入的函数，最终返回 <code>Box&lt;U&gt;</code>。<br>Monad（<code>bind()</code>）接收一个 <code>Box&lt;T&gt;</code> 值和一个从 <code>T</code> 到 <code>Box&lt;U&gt;</code> 的函数（<code>(value: T) =&gt; Box&lt;U&gt;</code>）作为参数，将 <code>T</code> 值取出并应用给传入的函数，最终返回 <code>Box&lt;U&gt;</code>。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-6184c38e9b9f1c45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Functor vs Monad"></p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Box&lt;T&gt; &#123;</span><br><span class="line">    value: T;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(<span class="params">value: T</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> Box &#123;</span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">map</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; U): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Box&lt;U&gt;(func(box.value));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">bind</span>&lt;<span class="title">T</span>, <span class="title">U</span>&gt;(<span class="params"></span></span></span><br><span class="line">        box: Box&lt;T&gt;, func: (value: T) =&gt; Box&lt;U&gt;): Box&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> func(box.value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stringify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s: Box&lt;<span class="built_in">string</span>&gt; = Box.map(<span class="keyword">new</span> Box(<span class="number">42</span>), stringify);</span><br><span class="line"><span class="built_in">console</span>.log(s)</span><br><span class="line"><span class="comment">// =&gt; Box &#123; value: '42' &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">boxify</span>(<span class="params">value: <span class="built_in">number</span></span>): <span class="title">Box</span>&lt;<span class="title">string</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Box(value.toString());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> b: Box&lt;<span class="built_in">string</span>&gt; = Box.bind(<span class="keyword">new</span> Box(<span class="number">42</span>), boxify);</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// =&gt; Box &#123; value: '42' &#125;</span></span><br></pre></td></tr></table></figure><h4 id="Monad-定义"><a href="#Monad-定义" class="headerlink" title="Monad 定义"></a>Monad 定义</h4><p>Monad 表示对于泛型 <code>H&lt;T&gt;</code>，我们有一个 <code>unit()</code> 函数能够接收 <code>T</code> 作为参数，返回类型为 <code>H&lt;T&gt;</code> 的值；同时还有一个 <code>bind()</code> 函数接收 <code>H&lt;T&gt;</code> 和一个从 <code>T</code> 到 <code>H&lt;U&gt;</code> 的函数作为参数，返回 <code>H&lt;U&gt;</code>。<br>现实中能够将 Promise 串联起来的 <code>then()</code> 方法实际上就等同于 <code>bind()</code>，能够从值创建 Promise 的 <code>resolve()</code> 方法等同于 <code>unit()</code>。</p><p>借助 Monad，函数调用序列可以表示为一条抽离了数据管理、控制流程或副作用的管道。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.manning.com/books/programming-with-types" target="_blank" rel="noopener">Programming with Types</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;通用的-map-实现&quot;&gt;&lt;a href=&quot;#通用的-map-实现&quot; class=&quot;headerlink&quot; title=&quot;通用的 map 实现&quot;&gt;&lt;/a&gt;通用的 map 实现&lt;/h4&gt;&lt;p&gt;&lt;strong&gt;map&lt;/strong&gt; 是函数式编程中非常常见的一类接口，
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="Map" scheme="https://rollingstarky.github.io/tags/Map/"/>
    
      <category term="Type" scheme="https://rollingstarky.github.io/tags/Type/"/>
    
      <category term="TypeScript" scheme="https://rollingstarky.github.io/tags/TypeScript/"/>
    
      <category term="Functor" scheme="https://rollingstarky.github.io/tags/Functor/"/>
    
      <category term="Monad" scheme="https://rollingstarky.github.io/tags/Monad/"/>
    
      <category term="generic" scheme="https://rollingstarky.github.io/tags/generic/"/>
    
      <category term="Optional" scheme="https://rollingstarky.github.io/tags/Optional/"/>
    
      <category term="Either" scheme="https://rollingstarky.github.io/tags/Either/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 由 Promises 和 Async、Await 实现的异步模式</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-promises-and-async/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:20:03.300Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。</p><p>为了获得更好的异步编程体验，第一个出现的就是 <strong>promise</strong>，一种保存了异步操作的状态和最终结果的对象。Promise 可以轻易地被串联起来，实现串行控制流，可以像其他任何对象一样自由地转移。Pormise 大大简化了异步代码，后来在此基础上又有了 <strong>async</strong> 和 <strong>await</strong>，能够令异步代码看起来就像是同步代码一样。</p><h4 id="Promises"><a href="#Promises" class="headerlink" title="Promises"></a>Promises</h4><p>Promises 是 ECMAScript 2015 标准（ES6）的一部分，为传递异步结果提供了一种健壮的解决方案，替代原本的 CPS 样式的回调函数。Promise 能够令所有主要的异步控制流更加易读、简洁和健壮。</p><p>Promise 是一种用来代表异步操作的最终结果（或错误）的对象。在专业术语中，当异步操作未完成时，我们称 Promise 是 <strong>pending</strong> 的；当异步操作成功结束时，Promise 是 <strong>fulfilled</strong> 的；当异步操作因为错误终止时，Promise 是 <strong>rejected</strong> 的；当 Promise 或者是 <strong>fulfilled</strong> 或者是 <strong>rejected</strong>，则将其认定为 <strong>settled</strong>。</p><p>Promise 对象的 <code>then()</code> 方法可以获取成功执行后的结果或者终止时报出的错误：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise.then(onFulfilled, onRejected)</span><br></pre></td></tr></table></figure></p><p>其中 <code>onFulfilled</code> 是一个回调函数，最终会接收到 Promise 成功时的值；<code>onRejected</code>是另一个回调函数，最终会接收 Promise 异常终止时的值（如果有的话）。</p><p>基于回调函数的如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperation(arg, (err, result) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// do stuff with the result</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>Promise 实现上述同样的功能，则更加优雅、结构化：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// do stuff with result</span></span><br><span class="line">  &#125;, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle the error</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>asyncOperationPromise()</code> 会返回一个 Promise，可以被用来获取最终结果的值或者失败的原因。但最为关键的属性是，<code>then()</code> 方法会同步地返回另一个 Promise。<br>更进一步地，如果 <code>onFulfilled</code> 或者 <code>onRejected</code> 函数返回一个值 <code>x</code>，那么 <code>then()</code> 方法返回的 Promise 会有以下行为：</p><ul><li>若 <code>x</code> 是一个值，则 <code>then()</code> 返回的 Promise 使用 <code>x</code> 作为自身完成时的值</li><li>若 <code>x</code> 是一个 Promise 且成功完成，则 <code>x</code> 完成时返回的值作为 <code>then()</code> 返回的 Promise 完成时的值</li><li>若 <code>x</code> 是一个 Promise 且因为错误终止，则 <code>x</code> 终止的原因作为 <code>then()</code> 返回的 Promise 终止的原因</li></ul><p>上述行为能够令我们将多个 promise 连接成链，轻松地将异步操作聚合在一起。如果我们没有指定一个 <code>onFulfilled</code> 或者 <code>onRejected</code> handler，Promise 完成时的值或者终止时的原因都会自动地传递给链条中的下一个 Promise。通过 Promise 链，任务的执行顺序突然变得很简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">asyncOperationPromise(arg)</span><br><span class="line">  .then(<span class="function"><span class="params">result1</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return another promise</span></span><br><span class="line">    <span class="keyword">return</span> asyncOperationPromise(arg2)</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result2</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return a value</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="literal">undefined</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// any error in the chain is caught here</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h4 id="promise-API"><a href="#promise-API" class="headerlink" title="promise API"></a>promise API</h4><p>Promise 构造函数（<code>new Promise((resolve, reject) =&gt; {})</code>）会创建一个新的 Promise 实例，其完成还是终止取决于作为参数传入的函数的行为。<br>作为参数传入的函数接收如下两个参数：</p><ul><li><code>resolve(obj)</code>：resolve 是一个函数，在调用时为 Promise 提供完成时的值。当 <code>obj</code> 是值时，则 <code>obj</code> 本身作为 Promise 完成时的值；当 <code>obj</code> 是另一个 Promise 时，则 <code>obj</code> 完成时的值作为当前 Promise 完成时的值</li><li><code>reject(err)</code>：Promise 因为 <code>err</code> 终止</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>().getSeconds()&#125;</span>s\nDelaying...`</span>)</span><br><span class="line">delay(<span class="number">1000</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">newDate</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;newDate.getSeconds()&#125;</span>s`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>Promise 最重要的静态方法：</p><ul><li><code>Promise.resolve(obj)</code>：从另一个 Promise、thenable 对象或者值创建一个新的 Promise</li><li><code>Promise.reject(err)</code>：创建一个 Promise，该 Promise 会因为 <code>err</code> 终止</li><li><code>Promise.all(iterable)</code>：从一个可迭代对象创建 Promise，若该 iterable 中的每一项都提供了一个 fulfill 值，则 Promise 最终以包含这些值的列表作为 fulfill 值；若其中有任意一项 reject，则 Promise.all() 返回的 Promise 以第一个 reject 的 err 终止</li><li><code>Promise.allSettled(iterable)</code>：此方法会等待所有输入的 Promise 或者 fulfill 或者 reject，之后返回一个包含所有 fulfill 值和 reject 原因的列表</li><li><code>Promise.race(iterable)</code>：返回可迭代对象中第一个 fulfill 或 reject 的 Promise</li></ul><p>Promise 关键的实例方法：</p><ul><li><code>promise.catch(onRejected)</code>：实际上就是 <code>promise.then(undefined, onRejected)</code> 的语法糖</li><li><code>promise.finally(onFinally)</code>：允许我们设置一个 <code>onFinally</code> 回调函数，在 <code>promise</code> fulfill 或者 reject 时调用</li></ul><h4 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h4><p>顺序执行意味着，每次只执行一系列任务中的一个，完成后再依次执行后面的任务。这一系列任务的先后顺序必须是预先定义好的，因为一个任务的结果有可能影响后续任务的执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-a0d217ff414af74f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of sequential execution flow with three tasks"></p><p>上述执行流程有着不同形式的变种：</p><ul><li>顺序执行一系列已知的任务，不需要在它们之间传递数据</li><li>前一个任务的输出作为后一个任务的输入（<em>chain</em>、<em>pipeline</em>、<em>waterfall</em>）</li><li>迭代任务集合，同时在每个元素上一个接一个地运行异步任务</li></ul><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"03-promises-web-spider-v2"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"1.0.0"</span>,</span><br><span class="line">  <span class="attr">"private"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"test"</span>: <span class="string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"cheerio"</span>: <span class="string">"^1.0.0-rc.3"</span>,</span><br><span class="line">    <span class="attr">"mkdirp"</span>: <span class="string">"^0.5.1"</span>,</span><br><span class="line">    <span class="attr">"superagent"</span>: <span class="string">"^5.2.2"</span>,</span><br><span class="line">    <span class="attr">"slug"</span>: <span class="string">"^1.1.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;dirname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> superagent <span class="keyword">from</span> <span class="string">'superagent'</span></span><br><span class="line"><span class="keyword">import</span> mkdirp <span class="keyword">from</span> <span class="string">'mkdirp'</span></span><br><span class="line"><span class="keyword">import</span> &#123;urlToFilename, getPageLinks&#125; <span class="keyword">from</span> <span class="string">'./utils.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mkdirpPromises = promisify(mkdirp)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">return</span> superagent.get(url)</span><br><span class="line">    .then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">      content = res.text</span><br><span class="line">      <span class="keyword">return</span> mkdirpPromises(dirname(filename))</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> fsPromises.writeFile(filename, content))</span><br><span class="line">    .then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">      <span class="keyword">return</span> content</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    promise = promise.then(<span class="function"><span class="params">()</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">return</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> err</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The file doesn't exist, so let’s download it</span></span><br><span class="line">      <span class="keyword">return</span> download(url, filename)</span><br><span class="line">    &#125;)</span><br><span class="line">    .then(<span class="function"><span class="params">content</span> =&gt;</span> spiderLinks(url, content, nesting))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>spider-cli.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;spider&#125; <span class="keyword">from</span> <span class="string">'./spider.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> nesting = <span class="built_in">Number</span>.parseInt(process.argv[<span class="number">3</span>], <span class="number">10</span>) || <span class="number">1</span></span><br><span class="line"></span><br><span class="line">spider(url, nesting)</span><br><span class="line">  .then(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'Download complete'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err))</span><br></pre></td></tr></table></figure></p><p><code>utils.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;join, extname&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;URL&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> slug <span class="keyword">from</span> <span class="string">'slug'</span></span><br><span class="line"><span class="keyword">import</span> cheerio <span class="keyword">from</span> <span class="string">'cheerio'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLinkUrl</span>(<span class="params">currentUrl, element</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedLink = <span class="keyword">new</span> URL(element.attribs.href || <span class="string">''</span>, currentUrl)</span><br><span class="line">  <span class="keyword">const</span> currentParsedUrl = <span class="keyword">new</span> URL(currentUrl)</span><br><span class="line">  <span class="keyword">if</span> (parsedLink.hostname !== currentParsedUrl.hostname ||</span><br><span class="line">    !parsedLink.pathname) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> parsedLink.toString()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">urlToFilename</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> parsedUrl = <span class="keyword">new</span> URL(url)</span><br><span class="line">  <span class="keyword">const</span> urlPath = parsedUrl.pathname.split(<span class="string">'/'</span>)</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> component !== <span class="string">''</span></span><br><span class="line">    &#125;)</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">component</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> slug(component, &#123;<span class="attr">remove</span>: <span class="literal">null</span>&#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .join(<span class="string">'/'</span>)</span><br><span class="line">  <span class="keyword">let</span> filename = join(parsedUrl.hostname, urlPath)</span><br><span class="line">  <span class="keyword">if</span> (!extname(filename).match(<span class="regexp">/htm/</span>)) &#123;</span><br><span class="line">    filename += <span class="string">'.html'</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> filename</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getPageLinks</span>(<span class="params">currentUrl, body</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(cheerio.load(body)(<span class="string">'a'</span>))</span><br><span class="line">    .map(<span class="function"><span class="keyword">function</span> (<span class="params">element</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> getLinkUrl(currentUrl, element)</span><br><span class="line">    &#125;)</span><br><span class="line">    .filter(<span class="built_in">Boolean</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>node spider-cli.js http://www.baidu.com 2</code></p><p>其中的 <code>spiderLinks()</code> 函数通过循环动态地构建了一条 Promise 链：</p><ul><li>先定义一个“空的” Promise 对象（resovle 到 <code>undefined</code>），这个空 Promise 只是作为链条的起点</li><li>在循环中，不断将 <code>promise</code> 变量更新为新的 Promise 对象（通过调用上一个 Promise 的 <code>then()</code> 方法得到）。这就是 Promise 的异步遍历模式</li></ul><p>在 <code>for</code> 循环的最后，<code>promise</code> 变量会是最后一个 <code>then()</code> 方法返回的 Promise，因而只有当链条中的所有 Promise 都 resolve 时，<code>promise</code> 才会 resolve。</p><p>纵观所有代码，我们可以不需要像使用 callback 那样，强制地包含众多错误传递逻辑。因而大大减少了代码量和出错的机会。</p><h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>在某些情况下，一系列异步任务的执行顺序并不重要，我们需要的只是当所有的任务都完成后能收到通知。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-bf70d3d597a899bf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of parallel execution with three tasks"></p><p>虽然 Node.js 是单线程的，但得益于其 non-blocking nature，我们仍可以实现并发行为。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-ae64bdc5e85d3d66.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="An example of how asynchronous tasks run in parallel"></p><p>比如我们有一个 Main 函数需要执行两个异步任务：</p><ul><li>Main 函数首先触发异步任务 Task1 和 Task2 的执行。异步任务触发后，会将程序控制权立即交还给 Main 函数，再转交给 event loop</li><li>当 Task1 中的异步任务结束时，event loop 调用 Task1 的回调函数，将控制权交给 Task1。Task1 执行完成自身内部的同步指令，通知 Main 函数并返还控制权</li><li>当 Task2 中的异步任务结束时，event loop 调用 Task2 的回调函数，将控制权交给 Task2。在 Task2 的终点，Main 函数再次被通知。Main 函数得知 Task1 和 Task2 全部结束，继续执行或者返回结果</li></ul><p>简单来说，在 Node.js 中，我们只能并发地执行异步操作，因为它们的并发行为是由内部的非阻塞 API 控制的。同步（阻塞）操作无法并发地执行，除非它们的执行与异步操作交织在一起，或者由 <code>setTimeout()</code>、<code>setImmediate()</code> 包裹。</p><p>Promise 实现并发执行流，可以借助内置的 <code>Promise.all()</code> 方法。该方法会返回一个新的 Promise，只有当所有传入的 Promise 都 fulfill 时，新 Promise 才会 fulfill。如果传入的 Promise 之间没有因果关系，这些 Promise 就会并发地执行。</p><p>对于前面的 spider 应用，只需要将 <code>spiderLinks()</code> 函数改为如下形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Async-await"><a href="#Async-await" class="headerlink" title="Async/await"></a>Async/await</h4><p>Promise 链相对于 callback hell 来说肯定是要好太多的，但是我们仍然需要调用 <code>then()</code> 方法，以及为链条中的每一个任务创建新的函数，对于日常编程中非常普遍的控制流来说还是比较麻烦。而 Async/await 可以帮助我们写出像同步代码一样可读性强、容易理解的异步代码。<br>Async 函数是一种特殊的函数，在函数体里面可以使用 <code>await</code> 表达式“暂停”任意一个 Promise 的执行，将控制权交还给 async 函数的调用者，等该 Promise revolve 后再返回到暂停的地方继续执行。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">    &#125;, milliseconds)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithDelays</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Initial date: '</span>, <span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line">  <span class="keyword">const</span> dateAfterOneSecond = <span class="keyword">await</span> delay(<span class="number">1000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after one second: '</span>, dateAfterOneSecond)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> dateAfterThreeSeconds = <span class="keyword">await</span> delay(<span class="number">3000</span>)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Date after 3 secnods: '</span>, dateAfterThreeSeconds)</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'done'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">playingWithDelays()</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`After 4 seconds: <span class="subst">$&#123;result&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>Async/await 的另一个巨大的优势在于，它能够标准化 <code>try...catch</code> 代码块的行为，不管是针对同步代码中的 <code>throw</code>，抑或是异步代码中的 Promise reject。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delayError</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Error after <span class="subst">$&#123;milliseconds&#125;</span>ms`</span>))</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">playingWithErrors</span>(<span class="params">throwSyncError</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (throwSyncError) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'This is a synchronous error'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">await</span> delayError(<span class="number">1000</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`We have an error: <span class="subst">$&#123;err.message&#125;</span>`</span>)</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Done'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// playingWithErrors(true)</span></span><br><span class="line">playingWithErrors(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>借助 Async/await，可以对之前的 spider 应用实现很多优化。比如 <code>download()</code> 函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">download</span>(<span class="params">url, filename</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloading <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">const</span> &#123;<span class="attr">text</span>: content&#125; = <span class="keyword">await</span> superagent.get(url)</span><br><span class="line">  <span class="keyword">await</span> mkdirpPromises(dirname(filename))</span><br><span class="line">  <span class="keyword">await</span> fsPromises.writeFile(filename, content)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Downloaded and saved: <span class="subst">$&#123;url&#125;</span>`</span>)</span><br><span class="line">  <span class="keyword">return</span> content</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>整段代码行数大大减少，看起来也很“平整”，没有任何层级和缩进。</p><p>接下来是 <code>spiderLinks()</code> 函数，使用 async/await 异步地遍历一个列表：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> link <span class="keyword">of</span> links) &#123;</span><br><span class="line">    <span class="keyword">await</span> spider(link, nesting - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后是 <code>spider()</code> 函数，如何简单地通过 <code>try...catch</code> 处理错误，令异步代码更加易读：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spider</span>(<span class="params">url, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> filename = urlToFilename(url)</span><br><span class="line">  <span class="keyword">let</span> content</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    content = <span class="keyword">await</span> fsPromises.readFile(filename, <span class="string">'utf8'</span>)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="keyword">if</span> (err.code !== <span class="string">'ENOENT'</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> err</span><br><span class="line">    &#125;</span><br><span class="line">    content = <span class="keyword">await</span> download(url, filename)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> spiderLinks(url, content, nesting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="并行执行-1"><a href="#并行执行-1" class="headerlink" title="并行执行"></a>并行执行</h4><p>使用纯 async/await 实现并行的异步执行流程，可以参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> promise <span class="keyword">of</span> promises) &#123;</span><br><span class="line">    <span class="keyword">await</span> promise</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然而上述代码存在一定的问题。如果列表中有一个 Promise reject 了，我们不得不等待列表中其他所有的 Promise 都 resolve，<code>spiderLinks()</code> 函数返回的 Promise 才会 reject。这种行为在多数情况下都是不理想的。<br>我们通常都会想要在操作发生错误的第一时间捕获错误信息。因而并行执行异步操作，最后仍建议使用下面形式的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">spiderLinks</span>(<span class="params">currentUrl, content, nesting</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (nesting === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> links = getPageLinks(currentUrl, content)</span><br><span class="line">  <span class="keyword">const</span> promises = links.map(<span class="function"><span class="params">link</span> =&gt;</span> spider(link, nesting - <span class="number">1</span>))</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;回调函数（Callbacks）是 Node.js 中异步编程的底层构件，但它们远远达不到对用户友好的程度。对于实现代码中最常见的串行控制流，一个未经训练的开发者很容易陷入到 callback hell 问题中。即便实现是正确的，该串行控制流也会显得不必要的复杂和脆弱。&lt;/p
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Async" scheme="https://rollingstarky.github.io/tags/Async/"/>
    
      <category term="Promise" scheme="https://rollingstarky.github.io/tags/Promise/"/>
    
      <category term="Concurrent" scheme="https://rollingstarky.github.io/tags/Concurrent/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Streams 流编程</title>
    <link href="https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/"/>
    <id>https://rollingstarky.github.io/2022/11/12/node-js-design-patterns-streams/</id>
    <published>2022-11-11T16:00:00.000Z</published>
    <updated>2022-11-12T13:23:27.600Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Streams</strong> 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。</p><h3 id="Buffering-vs-streaming"><a href="#Buffering-vs-streaming" class="headerlink" title="Buffering vs streaming"></a>Buffering vs streaming</h3><p>对于输入数据的处理，buffer 模式会将来自资源的所有数据收集到 buffer 中，待操作完成再将数据作为单一的 blob of data 传递给调用者；相反地，streams 允许我们一旦接收到数据就立即对其进行处理。<br>单从效率上说，streams 在空间（内存使用）和时间（CPU 时钟）的使用上都更加高效。此外 Node.js 中的 streams 还有另一个重要的优势：<strong>组合性</strong>。</p><h4 id="空间效率"><a href="#空间效率" class="headerlink" title="空间效率"></a>空间效率</h4><p><strong>使用 buffered API 完成 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;gzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> gzipPromise = promisify(gzip)</span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = <span class="keyword">await</span> fs.readFile(filename)</span><br><span class="line">  <span class="keyword">const</span> gzippedData = <span class="keyword">await</span> gzipPromise(data)</span><br><span class="line">  <span class="keyword">await</span> fs.writeFile(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>, gzippedData)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p><code>node gzip-buffer.js &lt;path to file&gt;</code></p><p>如果我们使用上述代码压缩一个足够大的文件（比如说 8G），我们很有可能会收到一个错误信息，类似文件大小超过了允许的最大 buffer 大小。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RangeError [ERR_FS_FILE_TOO_LARGE]: File size (8130792448) is greater</span><br><span class="line">than possible Buffer: 2147483647 bytes</span><br></pre></td></tr></table></figure></p><p>即便没有超过 V8 的 buffer 大小限制，也有可能出现物理内存不够用的情况。</p><p><strong>使用 streams 实现 Gzip 压缩：</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream, createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createWriteStream(<span class="string">`<span class="subst">$&#123;filename&#125;</span>.gz`</span>))</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'File successfully compressed'</span>))</span><br></pre></td></tr></table></figure></p><p>streams 的优势来自于其接口和可组合性，允许我们实现干净、优雅、简洁的代码。对于此处的示例，它可以对任意大小的文件进行压缩，只需要消耗常量的内存。</p><h4 id="时间效率"><a href="#时间效率" class="headerlink" title="时间效率"></a>时间效率</h4><p>假设我们需要创建一个应用，能够压缩一个文件并将其上传到一个远程的 HTTP 服务器。而服务器端则负责将接收到的文件解压缩并保存。<br>如果我们使用 buffer API 实现客户端组件，则只有当整个文件读取和压缩完成之后，上传操作才开始触发。同时在服务器端，也只有当所有数据都接收完毕之后才开始解压缩操作。</p><p>更好一些的方案是使用 streams。在客户端，streams 允许我们以 chunk 为单位从文件系统逐个、分段地读取数据，并立即进行压缩和发送。同时在服务器端，每个 chunk 被接收到后会立即进行解压缩。</p><p>服务端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure></p><p>客户端程序：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><p><code>mkdir received_files</code><br><code>node gzip-receive.js</code><br><code>node gzip-send.js &lt;path to file&gt; localhost</code></p><p>借助 streams，整套流程的流水线在我们接收到第一个数据块的时候就开始启动了，完全不需要等待整个文件被读取。除此之外，下一个数据块能够被读取时，不需要等到之前的任务完成就能被处理。即另一条流水线被并行地被装配执行，Node.js 可以将这些异步的任务并行化地执行。只需要保证数据块最终的顺序是固定的，而 Node.js 中 streams 的内部实现机制保证了这一点。</p><h4 id="组合性"><a href="#组合性" class="headerlink" title="组合性"></a>组合性</h4><p>借助于 <code>pipe()</code> 方法，不同的 stream 能够被组合在一起。每个处理单元负责各自的单一功能，最终被 <code>pipe()</code> 连接起来。因为 streams 拥有统一的接口，它们彼此之间在 API 层面是互通的。只需要 pipeline 支持前一个 stream 生成的数据类型（可以是二进制、纯文本甚至对象等）。</p><h5 id="客户端加密"><a href="#客户端加密" class="headerlink" title="客户端加密"></a>客户端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createCipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> filename = process.argv[<span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> serverHost = process.argv[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">const</span> secret = Buffer.from(process.argv[<span class="number">4</span>], <span class="string">'hex'</span>)</span><br><span class="line"><span class="keyword">const</span> iv = randomBytes(<span class="number">16</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> httpRequestOptions = &#123;</span><br><span class="line">  hostname: serverHost,</span><br><span class="line">  port: <span class="number">3000</span>,</span><br><span class="line">  path: <span class="string">'/'</span>,</span><br><span class="line">  method: <span class="string">'PUT'</span>,</span><br><span class="line">  headers: &#123;</span><br><span class="line">    <span class="string">'Content-Type'</span>: <span class="string">'application/octet-stream'</span>,</span><br><span class="line">    <span class="string">'Content-Encoding'</span>: <span class="string">'gzip'</span>,</span><br><span class="line">    <span class="string">'X-Filename'</span>: basename(filename),</span><br><span class="line">    <span class="string">'X-Initialization-Vector'</span>: iv.toString(<span class="string">'hex'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> req = request(httpRequestOptions, (res) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`Server response: <span class="subst">$&#123;res.statusCode&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(filename)</span><br><span class="line">  .pipe(createGzip())</span><br><span class="line">  .pipe(createCipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">  .pipe(req)</span><br><span class="line">  .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'File successfully sent'</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><h5 id="服务端加密"><a href="#服务端加密" class="headerlink" title="服务端加密"></a>服务端加密</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createGunzip&#125; <span class="keyword">from</span> <span class="string">'zlib'</span></span><br><span class="line"><span class="keyword">import</span> &#123;basename, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDecipheriv, randomBytes&#125; <span class="keyword">from</span> <span class="string">'crypto'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> secret = randomBytes(<span class="number">24</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`Generated secret: <span class="subst">$&#123;secret.toString(<span class="string">'hex'</span>)&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> filename = basename(req.headers[<span class="string">'x-filename'</span>])</span><br><span class="line">  <span class="keyword">const</span> iv = Buffer.from(</span><br><span class="line">    req.headers[<span class="string">'x-initialization-vector'</span>], <span class="string">'hex'</span></span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">const</span> destFilename = join(<span class="string">'received_files'</span>, filename)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`File request received: <span class="subst">$&#123;filename&#125;</span>`</span>)</span><br><span class="line">  req</span><br><span class="line">    .pipe(createDecipheriv(<span class="string">'aes192'</span>, secret, iv))</span><br><span class="line">    .pipe(createGunzip())</span><br><span class="line">    .pipe(createWriteStream(destFilename))</span><br><span class="line">    .on(<span class="string">'finish'</span>, () =&gt; &#123;</span><br><span class="line">      res.writeHead(<span class="number">201</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">      res.end(<span class="string">'OK\n'</span>)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">`File saved: <span class="subst">$&#123;destFilename&#125;</span>`</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">3000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Listening on http://localhost:3000'</span>))</span><br></pre></td></tr></table></figure><h3 id="Streams-详解"><a href="#Streams-详解" class="headerlink" title="Streams 详解"></a>Streams 详解</h3><p>实际上在 Node.js 中的任何地方都可见到 streams。比如核心模块 fs 有 <code>createReadStream()</code> 方法用来读取文件内容，<code>createWriteStream()</code> 方法用来向文件写入数据；HTTP <code>request</code> 和 <code>response</code> 对象本质上也是 stream；zlib 模块允许我们通过流接口压缩和解压缩数据；甚至 crypto 模块也提供了一些有用的流函数比如 <code>createCipheriv</code> 和 <code>createDecipheriv</code>。</p><h4 id="streams-的结构"><a href="#streams-的结构" class="headerlink" title="streams 的结构"></a>streams 的结构</h4><p>Node.js 中的每一个 stream 对象，都是对以下四种虚拟基类里任意一种的实现，这四个虚拟类都属于 <code>stream</code> 核心模块：</p><ul><li><code>Readable</code></li><li><code>Writable</code></li><li><code>Duplex</code></li><li><code>Transform</code></li></ul><p>每一个 stream 类同时也是 <code>EventEmitter</code> 的实例，实际上 Streams 可以生成几种类型的 event。比如当一个 <code>Readable</code> 流读取完毕时触发 <code>end</code> 事件，<code>Writable</code> 流吸入完毕时触发 <code>finish</code> 事件，或者当任意错误发生时抛出 <code>error</code>。</p><p>Steams 之所以足够灵活，一个重要的原因就是它们不仅仅能够处理 binary data，还支持几乎任意的 JavaScript 值。实际上 streams 有以下两种操作模式：</p><ul><li>Binary mode：以 chunk 的形式（比如 buffers 或 strings）传输数据</li><li>Object mode：通过由独立对象（可以包含任意 JavaScript 值）组成的序列传输数据</li></ul><p>上述两种模式使得我们不仅仅可以利用 streams 处理 I/O 操作，还能够帮助我们以函数式的方式将多个处理单元优雅地组合起来。</p><h4 id="从-Readable-streams-读取数据"><a href="#从-Readable-streams-读取数据" class="headerlink" title="从 Readable streams 读取数据"></a>从 Readable streams 读取数据</h4><h5 id="non-flowing-mode"><a href="#non-flowing-mode" class="headerlink" title="non-flowing mode"></a>non-flowing mode</h5><p>默认模式。<code>readable</code> 事件表示有新的数据可供读取，再通过 <code>read()</code> 方法同步地从内部 buffer 读取数据，返回一个 Buffer 对象。<br>即从 stream 按需拉取数据。当 stream 以 Binary 模式工作时，我们还可以给 <code>read()</code> 方法指定一个 <code>size</code> 值，以读取特定数量的数据。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="flowing-mode"><a href="#flowing-mode" class="headerlink" title="flowing mode"></a>flowing mode</h5><p>此模式下，数据并不会像之前那样通过 <code>read()</code> 方法拉取，而是一旦有数据可用，就主动推送给 <code>data</code> 事件的 listener。flowing 模式对于数据流的控制，相对而言灵活性较低一些。<br>由于默认是 non-flowing 模式，为了使用 flowing 模式，需要绑定一个 listener 给 <code>data</code> 事件或者显式地调用 <code>resume()</code> 方法。调用 <code>pause()</code> 方法会导致 stream 暂时停止发送 <code>data</code> 事件，任何传入的数据会先被缓存到内部 buffer。即 stream 又切换回 non-flowing 模式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">process.stdin</span><br><span class="line">  .on(<span class="string">'readable'</span>, () =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> chunk</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="keyword">while</span> ((chunk = process.stdin.read()) !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(</span><br><span class="line">        <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  .on(<span class="string">'end'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>))</span><br></pre></td></tr></table></figure></p><h5 id="Async-iterators"><a href="#Async-iterators" class="headerlink" title="Async iterators"></a>Async iterators</h5><p>Readable 流同时也是 async iterators。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">const</span> chunk <span class="keyword">of</span> process.stdin) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'New data available'</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`Chunk read (<span class="subst">$&#123;chunk.length&#125;</span> bytes): "<span class="subst">$&#123;chunk.toString()&#125;</span>"`</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'End of stream'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="实现-Readable-streams"><a href="#实现-Readable-streams" class="headerlink" title="实现 Readable streams"></a>实现 Readable streams</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = Chance()</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">RandomStream</span> <span class="keyword">extends</span> <span class="title">Readable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    <span class="keyword">this</span>.emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> RandomStream()</span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure><p>为了实现一个自定义的 Readable stream，首先必须创建一个新的类，该类继承自 <code>stream</code> 模块中的 <code>Readable</code>。其次新创建的类中必须包含 <code>_read()</code> 方法的实现。<br>上面代码中的 <code>_read()</code> 方法做了以下几件事：</p><ul><li>借助第三方的 <code>chance</code> 模块，生成一个长度为 <code>size</code> 的随机字符串</li><li>通过 <code>push()</code> 方法将字符传推送到内部 buffer</li><li>依据 5% 的几率自行终止，终止时推送 <code>null</code> 到内部 buffer，作为 stream 的结束标志</li></ul><p><strong>简化版实现</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">let</span> emittedBytes = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> randomStream = <span class="keyword">new</span> Readable(&#123;</span><br><span class="line">  read(size) &#123;</span><br><span class="line">    <span class="keyword">const</span> chunk = chance.string(&#123;<span class="attr">length</span>: size&#125;)</span><br><span class="line">    <span class="keyword">this</span>.push(chunk, <span class="string">'utf8'</span>)</span><br><span class="line">    emittedBytes += chunk.length</span><br><span class="line">    <span class="keyword">if</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">5</span>&#125;)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(<span class="literal">null</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">randomStream</span><br><span class="line">  .on(<span class="string">'data'</span>, (chunk) =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Chunk received (<span class="subst">$&#123;chunk.length&#125;</span> bytes): <span class="subst">$&#123;chunk.toString()&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure></p><h5 id="从可迭代对象创建-Readable-streams"><a href="#从可迭代对象创建-Readable-streams" class="headerlink" title="从可迭代对象创建 Readable streams"></a>从可迭代对象创建 Readable streams</h5><p><code>Readable.from()</code> 方法支持从数组或者其他可迭代对象（比如 generators, iterators, async iterators）创建 Readable streams。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Readable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountains = [</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Everest'</span>, <span class="attr">height</span>: <span class="number">8848</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'K2'</span>, <span class="attr">height</span>: <span class="number">8611</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Kangchenjunga'</span>, <span class="attr">height</span>: <span class="number">8586</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Lhotse'</span>, <span class="attr">height</span>: <span class="number">8516</span>&#125;,</span><br><span class="line">  &#123;<span class="attr">name</span>: <span class="string">'Makalu'</span>, <span class="attr">height</span>: <span class="number">8481</span>&#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> mountainsStream = Readable.from(mountains)</span><br><span class="line">mountainsStream.on(<span class="string">'data'</span>, (mountain) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;mountain.name.padStart(<span class="number">14</span>)&#125;</span>\t<span class="subst">$&#123;mountain.height&#125;</span>m`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><h4 id="Writable-streams"><a href="#Writable-streams" class="headerlink" title="Writable streams"></a>Writable streams</h4><h5 id="向流写入数据"><a href="#向流写入数据" class="headerlink" title="向流写入数据"></a>向流写入数据</h5><p><code>write()</code> 方法可以向 Writable stream 写入数据。<br><code>writable.write(chunk, [encoding], [callback])</code></p><p><code>end()</code> 方法可以向 stream 表明没有更多的数据需要写入。<br><code>writable.end([chunk], [encoding], [callback])</code></p><p><code>callback</code> 回调函数等同于为 <code>finish</code> 事件注册了一个 listener，会在流中写入的所有数据刷新到底层资源中时触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createServer&#125; <span class="keyword">from</span> <span class="string">'http'</span></span><br><span class="line"><span class="keyword">import</span> Chance <span class="keyword">from</span> <span class="string">'chance'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> chance = <span class="keyword">new</span> Chance()</span><br><span class="line"><span class="keyword">const</span> server = createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.writeHead(<span class="number">200</span>, &#123;<span class="string">'Content-Type'</span>: <span class="string">'text/plain'</span>&#125;)</span><br><span class="line">  <span class="keyword">while</span> (chance.bool(&#123;<span class="attr">likelihood</span>: <span class="number">95</span>&#125;)) &#123;</span><br><span class="line">    res.write(<span class="string">`<span class="subst">$&#123;chance.string()&#125;</span>\n`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  res.end(<span class="string">'\n\n'</span>)</span><br><span class="line">  res.on(<span class="string">'finish'</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'All data sent'</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">8080</span>, () =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'listening on http://localhost:8080'</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>上面代码中 HTTP 服务里的 <code>res</code> 对象是一个 <code>http.ServerResponse</code> 对象，实际上也是一个 Writable stream。</p><h5 id="实现-Writable-stream"><a href="#实现-Writable-stream" class="headerlink" title="实现 Writable stream"></a>实现 Writable stream</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ToFileStream</span> <span class="keyword">extends</span> <span class="title">Writable</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options, <span class="attr">objectMode</span>: <span class="literal">true</span>&#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> ToFileStream()</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Writable&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tfs = <span class="keyword">new</span> Writable(&#123;</span><br><span class="line">  objectMode: <span class="literal">true</span>,</span><br><span class="line">  write(chunk, encoding, cb) &#123;</span><br><span class="line">    fs.writeFile(chunk.path, chunk.content)</span><br><span class="line">      .then(<span class="function"><span class="params">()</span> =&gt;</span> cb())</span><br><span class="line">      .catch(cb)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file1.txt'</span>, <span class="attr">content</span>: <span class="string">'Hello'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file2.txt'</span>, <span class="attr">content</span>: <span class="string">'Node.js'</span>&#125;)</span><br><span class="line">tfs.write(&#123;<span class="attr">path</span>: <span class="string">'file3.txt'</span>, <span class="attr">content</span>: <span class="string">'streams'</span>&#125;)</span><br><span class="line">tfs.end(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'All files created'</span>))</span><br></pre></td></tr></table></figure></p><h4 id="Duplex-streams"><a href="#Duplex-streams" class="headerlink" title="Duplex streams"></a>Duplex streams</h4><p>Duplex 流，既 Readable 又 Writable 的流。它的场景在于，有时候我们描述的实体既是数据源，也是数据的接收者，比如网络套接字。<br>Duplex 流同时继承来着 <code>stream.Readable</code> 和 <code>stream.Writable</code> 的方法。<br>为了创建一个自定义的 Duplex 流，我们必须同时提供 <code>_read()</code> 和 <code>_write()</code> 的实现。</p><h4 id="Transform-streams"><a href="#Transform-streams" class="headerlink" title="Transform streams"></a>Transform streams</h4><p>Transform 流是一种特殊类型的 Duplex 流，主要针对数据的转换。<br>对于 Duplex 流来说，流入和流出的数据之间并没有直接的联系。比如一个 TCP 套接字，只是从远端接收或者发送数据，套接字本身不知晓输入输出之间的任何关系。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-1a65d864ebeb31b4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Duplex stream"></p><p>而 Transform 流则会对收到的每一段数据都应用某种转换操作，从 Writable 端接收数据，进行某种形式地转换后再通过 Readable 端提供给外部。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-0e7f97e927ba0479.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Transform stream"></p><h5 id="实现-Transform-流"><a href="#实现-Transform-流" class="headerlink" title="实现 Transform 流"></a>实现 Transform 流</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceStream</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(searchStr, replaceStr, options) &#123;</span><br><span class="line">    <span class="keyword">super</span>(&#123;...options&#125;)</span><br><span class="line">    <span class="keyword">this</span>.searchStr = searchStr</span><br><span class="line">    <span class="keyword">this</span>.replaceStr = replaceStr</span><br><span class="line">    <span class="keyword">this</span>.tail = <span class="string">''</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(chunk, encoding, callback) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (<span class="keyword">this</span>.tail + chunk).split(<span class="keyword">this</span>.searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = <span class="keyword">this</span>.searchStr.length - <span class="number">1</span></span><br><span class="line">    <span class="keyword">this</span>.tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(<span class="keyword">this</span>.replaceStr))</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.tail)</span><br><span class="line">    callback()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> ReplaceStream(<span class="string">'World'</span>, <span class="string">'Node.js'</span>)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure><p>其中核心的 <code>_transform()</code> 方法，其有着和 Writable 流的 <code>_write()</code> 方法基本一致的签名，但并不会将处理后的数据写入底层资源，而是通过 <code>this.push()</code> 推送给内部 buffer，正如 Readable 流中 <code>_read()</code> 方法的行为。<br>所以形成了 Transform 流整体上接收、转换、发送的行为。<br><code>_flush()</code> 则会在流结束前调用。</p><p><strong>简化形式</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> searchStr = <span class="string">'World'</span></span><br><span class="line"><span class="keyword">const</span> replaceStr = <span class="string">'Node.js'</span></span><br><span class="line"><span class="keyword">let</span> tail = <span class="string">''</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> replaceStream = <span class="keyword">new</span> Transform(&#123;</span><br><span class="line">  defaultEncoding: <span class="string">'utf-8'</span>,</span><br><span class="line"></span><br><span class="line">  transform(chunk, encoding, cb) &#123;</span><br><span class="line">    <span class="keyword">const</span> pieces = (tail + chunk).split(searchStr)</span><br><span class="line">    <span class="keyword">const</span> lastPiece = pieces[pieces.length - <span class="number">1</span>]</span><br><span class="line">    <span class="keyword">const</span> tailLen = searchStr.length - <span class="number">1</span></span><br><span class="line">    tail = lastPiece.slice(-tailLen)</span><br><span class="line">    pieces[pieces.length - <span class="number">1</span>] = lastPiece.slice(<span class="number">0</span>, -tailLen)</span><br><span class="line">    <span class="keyword">this</span>.push(pieces.join(replaceStr))</span><br><span class="line">    cb()</span><br><span class="line">  &#125;,</span><br><span class="line">  flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(tail)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">replaceStream.on(<span class="string">'data'</span>, chunk =&gt; <span class="built_in">console</span>.log(chunk.toString()))</span><br><span class="line">replaceStream.write(<span class="string">'Hello W'</span>)</span><br><span class="line">replaceStream.write(<span class="string">'orld'</span>)</span><br><span class="line">replaceStream.end()</span><br></pre></td></tr></table></figure></p><h4 id="Transform-流筛选和聚合数据"><a href="#Transform-流筛选和聚合数据" class="headerlink" title="Transform 流筛选和聚合数据"></a>Transform 流筛选和聚合数据</h4><p>数据源 <code>data.csv</code>：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">type,country,profit</span><br><span class="line">Household,Namibia,597290.92</span><br><span class="line">Baby Food,Iceland,808579.10</span><br><span class="line">Meat,Russia,277305.60</span><br><span class="line">Meat,Italy,413270.00</span><br><span class="line">Cereal,Malta,174965.25</span><br><span class="line">Meat,Indonesia,145402.40</span><br><span class="line">Household,Italy,728880.54</span><br></pre></td></tr></table></figure></p><p><code>package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"index.js"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"csv-parse"</span>: <span class="string">"^4.10.1"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engines"</span>: &#123;</span><br><span class="line">    <span class="attr">"node"</span>: <span class="string">"&gt;=14"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"engineStrict"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>FilterByCountry</code> Transform 流 <code>filter-by-country.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterByCountry</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(country, options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.country = country</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">if</span> (record.country === <span class="keyword">this</span>.country) &#123;</span><br><span class="line">      <span class="keyword">this</span>.push(record)</span><br><span class="line">    &#125;</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>SumProfit</code> Transform 流 <code>sum-profit.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Transform&#125; <span class="keyword">from</span> <span class="string">'stream'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">SumProfit</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options = &#123;&#125;) &#123;</span><br><span class="line">    options.objectMode = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">super</span>(options)</span><br><span class="line">    <span class="keyword">this</span>.total = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _transform(record, enc, cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.total += <span class="built_in">Number</span>.parseFloat(record.profit)</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _flush(cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.push(<span class="keyword">this</span>.total.toString())</span><br><span class="line">    cb()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createReadStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> parse <span class="keyword">from</span> <span class="string">'csv-parse'</span></span><br><span class="line"><span class="keyword">import</span> &#123;FilterByCountry&#125; <span class="keyword">from</span> <span class="string">'./filter-by-conutry.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;SumProfit&#125; <span class="keyword">from</span> <span class="string">'./sum-profit.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> csvParser = parse(&#123;<span class="attr">columns</span>: <span class="literal">true</span>&#125;)</span><br><span class="line"></span><br><span class="line">createReadStream(<span class="string">'data.csv'</span>)</span><br><span class="line">  .pipe(csvParser)</span><br><span class="line">  .pipe(<span class="keyword">new</span> FilterByCountry(<span class="string">'Italy'</span>))</span><br><span class="line">  .pipe(<span class="keyword">new</span> SumProfit())</span><br><span class="line">  .pipe(process.stdout)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Streams&lt;/strong&gt; 是 Node.js 的组件和模式中最重要的几个之一。在 Node.js 这类基于 event 的平台上，最高效的实时地处理 I/O 的方式，就是当有输入时就立即接收数据，应用产生输出时就立即发送数据。&lt;/p&gt;
&lt;h3 id=
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Stream" scheme="https://rollingstarky.github.io/tags/Stream/"/>
    
      <category term="Pipe" scheme="https://rollingstarky.github.io/tags/Pipe/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Callbacks 和 Events</title>
    <link href="https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/"/>
    <id>https://rollingstarky.github.io/2022/09/07/node-js-design-patterns-callbacks-and-events/</id>
    <published>2022-09-06T16:00:00.000Z</published>
    <updated>2022-09-07T14:18:50.286Z</updated>
    
    <content type="html"><![CDATA[<p>在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。</p><p>而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在“后台”启动和执行的。当我们调用某个异步操作后，即使其并没有执行完毕，该异步操作之后的代码指令也会立刻继续执行。<br>在这种情况下，我们就需要一种“通知”机制。当异步操作执行完毕，我们会收到通知，获取该操作的结果并继续之前定义的执行流程。在 Node.js 中，最基础的通知机制就是<strong>回调函数</strong>。它本质上就是一种由 runtime 调用的带有异步操作结果的函数。</p><h3 id="Callback-模式"><a href="#Callback-模式" class="headerlink" title="Callback 模式"></a>Callback 模式</h3><p>回调函数是一种能够传递操作结果的函数，正是异步编程所需要的。JavaScript 对于回调函数来说是一种理想的语言，函数是<strong>第一等对象</strong>，可以轻松地赋值给变量、作为参数传递给另一个函数、作为函数的返回值，以及存储到数据结构中。</p><h4 id="The-continuation-passing-style"><a href="#The-continuation-passing-style" class="headerlink" title="The continuation-passing style"></a>The continuation-passing style</h4><p>在 JavaScript 中，回调函数会作为参数传递给另一个函数，并且在操作完成时连同结果一起被调用。即执行结果被传递给另一个函数（callback），而不是直接返回给调用者。这种方式在函数式编程里称作 <strong>continuation-passing style (CPS)</strong>。</p><p>下面是一个非常简单的同步函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>和上述函数等效的 CPS 形式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addCps</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  callback(a + b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">addCps(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: $result`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; Result: $result</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br></pre></td></tr></table></figure></p><p><code>addCps</code> 就是一个同步的 CPS 函数。</p><h4 id="Asynchronous-CPS"><a href="#Asynchronous-CPS" class="headerlink" title="Asynchronous CPS"></a>Asynchronous CPS</h4><p><code>addCps</code> 函数的异步版本：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">additionAsync</span>(<span class="params">a, b, callback</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> callback(a + b), <span class="number">100</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'before'</span>)</span><br><span class="line">additionAsync(<span class="number">1</span>, <span class="number">2</span>, result =&gt; <span class="built_in">console</span>.log(<span class="string">`Result: <span class="subst">$&#123;result&#125;</span>`</span>))</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'after'</span>)</span><br><span class="line"><span class="comment">// =&gt; before</span></span><br><span class="line"><span class="comment">// =&gt; after</span></span><br><span class="line"><span class="comment">// =&gt; Result: 3</span></span><br></pre></td></tr></table></figure></p><p>上面的代码使用 <code>setTimeout</code> 来模拟回调函数的异步调用。由于 <code>setTimeout</code> 触发的是异步操作，它并不会等待回调函数 callback 执行，而是立即返回。将控制权交还给 <code>additionAsync</code> 进而回到调用者身上，执行主程序中的第二个 <code>console.log</code>。当异步操作执行完毕后，程序从之前控制权转移时的位置起恢复执行，callback 中的 <code>console.log</code> 被执行。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9fbb0d2cfbef3f1c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Control flow of an asynchronous function&#39;s invocation"></p><p>总结一下就是，同步函数会阻塞其他操作步骤，直到其自身执行完毕；异步函数会立即返回，它的执行结果会在 event loop 的后续周期中传递给 handler（即回调函数）。</p><h4 id="同步-or-异步"><a href="#同步-or-异步" class="headerlink" title="同步 or 异步"></a>同步 or 异步</h4><p>指令的执行顺序取决于函数的自然属性——同步还是异步，这对于整个应用流程的正确性和效率都有很大的影响。所以需要时刻注意避免制造矛盾和困惑。</p><h5 id="Unleashing-Zalgo"><a href="#Unleashing-Zalgo" class="headerlink" title="Unleashing Zalgo"></a>Unleashing Zalgo</h5><p>一个 API 最危险的情形之一，就是有些时候表现为同步另一些情况下表现为异步。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, cb</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// invoked synchronously</span></span><br><span class="line">    cb(cache.get(filename))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      cb(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述程序就是危险的。假如某个文件是第一次被读取，它会表现为异步操作，读取文件设置缓存；当某个文件的内容已经存在于缓存中时，它会表现为同步操作。</p><p>参考下面的示例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFileReader</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> listeners = []</span><br><span class="line">  inconsistentRead(filename, value =&gt; &#123;</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">listener</span> =&gt;</span> listener(value))</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    onDataReady: <span class="function"><span class="params">listener</span> =&gt;</span> listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> reader1 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">reader1.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`First call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reader2 = createFileReader(<span class="string">'data.txt'</span>)</span><br><span class="line">  reader2.onDataReady(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Second call data: <span class="subst">$&#123;data&#125;</span>`</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>其中 <code>createFileReader</code> 函数会创建一个新的 <code>{ onDataReady: function() }</code> 对象作为通知器，以帮助我们为文件读取操作设置多个 listener。若 <code>inconsistentRead</code> 是纯异步操作，实际上 <code>onDataReady</code> 会先被调用，将传入的 listener 添加到 listeners 列表中。之后 <code>inconsistentRead</code> 读取文件内容完毕，回调函数 <code>cb</code> 执行，遍历 listeners 列表并将读取到的文件内容传给 listener。</p><p>实际的执行结果为：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">First <span class="keyword">call</span> data: some data</span><br></pre></td></tr></table></figure></p><p>第二次读取同一个文件并没有获取到任何内容。</p><p>原因在于，当 <code>reader1</code> 创建时，<code>inconsistentRead</code> 函数表现为异步的，因为该文件是第一次被读取。因而 <code>onDataReady</code> 会在刚开始读取文件时就将传入的 listener 添加到 listeners 列表中。文件读取完毕后 listeners 中注册的 listener 被调用。<br><code>reader2</code> 创建时同一个文件的缓存内容已经存在，<code>inconsistentRead</code> 表现为同步的。它的回调函数会立即调用，遍历 listeners 列表。然而我们是先创建的 <code>reader2</code> 再添加的 listener，这就导致遍历 listeners 列表时，向 listeners 添加 listener 的操作还没有执行，我们传入的 listener 并没有来得及注册。</p><p>在实际的应用中，上述类型的 bug 会非常难以定位和复现。npm 的创造者 Isaac Z. Schlueter 将类似的使用不可预测函数的行为，叫做 <em>unleashing Zalgo</em>。</p><h5 id="使用同步-API"><a href="#使用同步-API" class="headerlink" title="使用同步 API"></a>使用同步 API</h5><p>想修复前面的 <code>inconsistentRead</code> 函数，一种可能的方案就是令其彻底变成同步的。实际上 Node.js 针对基础的 I/O 操作提供了一系列同步的 API。比如 <code>fs.readFileSync</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFileSync&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">consistentReadSync</span>(<span class="params">filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(filename)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> data = readFileSync(filename)</span><br><span class="line">    cache.set(filename, data)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>但是，使用同步 API 而不是异步 API 也有一定的风险：</p><ul><li>针对特定功能的同步 API 有可能不存在</li><li>同步 API 会阻塞 event loop，暂停任何并发请求。从而破坏 Node.js 的并发模型并拖慢整个应用</li></ul><p>在很多情况下，使用同步 I/O 操作在 Node.js 里都是非常不推荐的。但在一些场景下，同步 I/O 可能是最简单和高效的方案。比如在应用启动时使用同步阻塞 API 加载配置文件。</p><h5 id="通过延迟执行保证异步性"><a href="#通过延迟执行保证异步性" class="headerlink" title="通过延迟执行保证异步性"></a>通过延迟执行保证异步性</h5><p>另一种修复 <code>inconsistentRead</code> 函数的方案就是，将其变成纯异步操作。诀窍就是将同步的回调函数延期到“未来”执行，而不是在同一个 event loop 周期里立即被调用。<br>在 Node.js 中，可以通过 <code>process.nextTick()</code> 来实现。它会接收一个回调函数作为参数，将其推入到事件队列顶部，位于所有 pending 的 I/O 事件之前，然后立即返回。回调函数会在 event loop 再次收回控制权时立即被调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inconsistentRead</span>(<span class="params">filename, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cache.has(filename)) &#123;</span><br><span class="line">    <span class="comment">// deferred callback invocation</span></span><br><span class="line">    process.nextTick(<span class="function"><span class="params">()</span> =&gt;</span> callback(cache.get(filename)))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// asynchronous function</span></span><br><span class="line">    readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">      cache.set(filename, data)</span><br><span class="line">      callback(data)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Node-js-回调函数的最佳实践"><a href="#Node-js-回调函数的最佳实践" class="headerlink" title="Node.js 回调函数的最佳实践"></a>Node.js 回调函数的最佳实践</h4><h5 id="回调函数出现在最后"><a href="#回调函数出现在最后" class="headerlink" title="回调函数出现在最后"></a>回调函数出现在最后</h5><p>在所有核心的 Node.js 函数中，当其接收一个回调函数作为输入时，回调函数必须作为最后一个参数传入。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">readFile(filename, [options], callback)</span><br></pre></td></tr></table></figure></p><h5 id="error-总是出现在前面"><a href="#error-总是出现在前面" class="headerlink" title="error 总是出现在前面"></a>error 总是出现在前面</h5><p>在 Node.js 中，任何 CPS 函数产生的错误都必须作为回调函数的第一个参数传递，任何实际的执行结果都从第二个参数开始。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">readFile(<span class="string">'foo.txt'</span>, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    handleError(err)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    processData(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>最佳实践还在于总是检查 error 是否存在，以及 error 的定义必须是 <code>Error</code> 类型。</p><h5 id="传递-error"><a href="#传递-error" class="headerlink" title="传递 error"></a>传递 error</h5><p>在同步的函数中，传递 error 可以通过常用的 <code>throw</code> 语句。而在异步的 CPS 函数中，则可以简单地将 error 传递给链条上的下一个回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readJSON</span>(<span class="params">filename, callack</span>) </span>&#123;</span><br><span class="line">  readFile(filename, <span class="string">'utf8'</span>, (err, data) =&gt; &#123;</span><br><span class="line">    <span class="keyword">let</span> parsed</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// propagate the error and exit the current function</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// parse the file contents</span></span><br><span class="line">      parsed = <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="comment">// catch parsing errors</span></span><br><span class="line">      <span class="keyword">return</span> callack(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// no errors, propagate just the data</span></span><br><span class="line">    callack(<span class="literal">null</span>, parsed)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>在 Node.js 中另外一种非常重要和基础的模式就是<strong>观察者（Ovserver）模式</strong>。同 Reactor 模式、回调函数一起，它们都是掌握 Node.js 异步编程的绝对要求。<br>观察者模式定义了一类称为 subject 的对象，它们可以在状态改变时向一系列称为观察者的对象发送通知。它是对回调函数的完美补充。主要区别在于 subject 能够通知多个观察者，而传统的 CPS 回调函数通常只会将结果传递给一个 listener。</p><h4 id="EventEmitter"><a href="#EventEmitter" class="headerlink" title="EventEmitter"></a>EventEmitter</h4><p>观察者模式实际上已经通过 <code>EventEmitter</code> 类内置到 Node.js 的核心中了。<code>EventEmitter</code> 类允许我们注册一个或者多个函数作为 listener，这些 listener 会在特定的事件触发时自动被调用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-9577c60299839e83.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Listeners receiving events from an EventEmitter"></p><p><code>EventEmitter</code> 类的基础方法如下：</p><ul><li><code>on(event, listener)</code>：该方法允许我们为指定的事件类型（一个字符串）注册一个新的 listener（一个函数）</li><li><code>once(event, listener)</code>：该方法允许我们注册一个新的 listener，并且该 listener 会在事件触发一次之后自动被移除</li><li><code>emit(event, [arg1], [...])</code>：该方法会产生一个新的事件，并向指定向 listeners 传递的额外的参数</li><li><code>removeListener(event, listener)</code>：该方法用来移除某个 listener</li></ul><p>上述所有的方法都会返回一个 <code>EventEmitter</code> 实例并允许被串联起来。</p><h5 id="创建和使用-EventEmitter"><a href="#创建和使用-EventEmitter" class="headerlink" title="创建和使用 EventEmitter"></a>创建和使用 EventEmitter</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findRegex</span>(<span class="params">files, regex</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> emitter = <span class="keyword">new</span> EventEmitter()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> files) &#123;</span><br><span class="line">    readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="keyword">return</span> emitter.emit(<span class="string">'error'</span>, err)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      emitter.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line">      <span class="keyword">const</span> match = content.match(regex)</span><br><span class="line">      <span class="keyword">if</span> (match) &#123;</span><br><span class="line">        match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> emitter.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> emitter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">findRegex([<span class="string">'fileA.txt'</span>, <span class="string">'fileB.json'</span>], /hello \w+<span class="regexp">/g)</span></span><br><span class="line"><span class="regexp">  .on('fileread', file =&gt; console.log(`$&#123;file&#125; was read`))</span></span><br><span class="line"><span class="regexp">  .on('found', (file, match) =&gt; console.log(`Matched "$&#123;match&#125;" in $&#123;file&#125;`))</span></span><br><span class="line"><span class="regexp">  .on('error', err =&gt; console.error(`Error emitted $&#123;err.message&#125;`))</span></span><br></pre></td></tr></table></figure><h5 id="令任意对象变得“可监测”"><a href="#令任意对象变得“可监测”" class="headerlink" title="令任意对象变得“可监测”"></a>令任意对象变得“可监测”</h5><p>在 Node.js 的世界里，<code>EventEmitter</code> 很少像上面的例子那样被直接使用。更为常见的情况是其他类继承 <code>EventEmitter</code> 从而变成一个可监测的对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;EventEmitter&#125; <span class="keyword">from</span> <span class="string">'events'</span></span><br><span class="line"><span class="keyword">import</span> &#123;readFile&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FindRegex</span> <span class="keyword">extends</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(regex) &#123;</span><br><span class="line">    <span class="keyword">super</span>()</span><br><span class="line">    <span class="keyword">this</span>.regex = regex</span><br><span class="line">    <span class="keyword">this</span>.files = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  addFile(file) &#123;</span><br><span class="line">    <span class="keyword">this</span>.files.push(file)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  find() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> file <span class="keyword">of</span> <span class="keyword">this</span>.files) &#123;</span><br><span class="line">      readFile(file, <span class="string">'utf8'</span>, (err, content) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (err) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>.emit(<span class="string">'error'</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.emit(<span class="string">'fileread'</span>, file)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> match = content.match(<span class="keyword">this</span>.regex)</span><br><span class="line">        <span class="keyword">if</span> (match) &#123;</span><br><span class="line">          match.forEach(<span class="function"><span class="params">elem</span> =&gt;</span> <span class="keyword">this</span>.emit(<span class="string">'found'</span>, file, elem))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> findRegexInstance = <span class="keyword">new</span> FindRegex(<span class="regexp">/hello \w+/g</span>)</span><br><span class="line">findRegexInstance</span><br><span class="line">  .addFile(<span class="string">'fileA.txt'</span>)</span><br><span class="line">  .addFile(<span class="string">'fileB.json'</span>)</span><br><span class="line">  .find()</span><br><span class="line">  .on(<span class="string">'found'</span>, (file, match) =&gt; <span class="built_in">console</span>.log(<span class="string">`Matched "<span class="subst">$&#123;match&#125;</span>" in file <span class="subst">$&#123;file&#125;</span>`</span>))</span><br><span class="line">  .on(<span class="string">'error'</span>, err =&gt; <span class="built_in">console</span>.error(<span class="string">`Error emitted <span class="subst">$&#123;err.message&#125;</span>`</span>))</span><br></pre></td></tr></table></figure></p><h4 id="EventEmitter-vs-Callback"><a href="#EventEmitter-vs-Callback" class="headerlink" title="EventEmitter vs Callback"></a>EventEmitter vs Callback</h4><p>以下的几点可以作为选择 EventEmitter 还是 Callback 的依据：</p><ul><li>当涉及到需要支持不同类型的事件时，Callback 会有一定的限制。实际上 Callback 也可以区分多个事件，只需要将事件类型作为参数传给回调函数，或者接收多个回调函数。但在这样的情况下，EventEmitter 可以提供更优雅的接口和更精简的代码</li><li>当同样的事件可能多次发生或者根本不会发生时，应该使用 EventEmitter。而无论操作是否成功，回调函数都只会被调用一次</li><li>回调函数机制只支持通知一个特定的 listener，而 EventEmitter 允许我们为同一个事件注册多个 listener</li></ul><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在同步式编程中，为了解决特定的问题，代码被组织成一系列连贯的计算步骤。其中每一个步骤都是阻塞的，即只有当某个操作完成以后，才有可能继续执行下一个步骤。这种方式形成的代码非常容易阅读、理解和调试。&lt;/p&gt;
&lt;p&gt;而在异步式编程中，某些操作比如读取文件或者处理一个网络请求，是在
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Callback" scheme="https://rollingstarky.github.io/tags/Callback/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="Observer" scheme="https://rollingstarky.github.io/tags/Observer/"/>
    
      <category term="Asynchronous" scheme="https://rollingstarky.github.io/tags/Asynchronous/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Node.js 的设计哲学和原理</title>
    <link href="https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/"/>
    <id>https://rollingstarky.github.io/2022/09/05/node-js-design-patterns-nodejs-philosophy-and-internal-pattern/</id>
    <published>2022-09-04T16:00:00.000Z</published>
    <updated>2022-09-07T14:02:50.691Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、Node-js-哲学"><a href="#一、Node-js-哲学" class="headerlink" title="一、Node.js 哲学"></a>一、Node.js 哲学</h4><p>每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受的指导原则和规范。这些规范对语言平台本身的演进以及如何设计和开发应用都有着深刻的影响。</p><h5 id="小的核心"><a href="#小的核心" class="headerlink" title="小的核心"></a>小的核心</h5><p>Node.js 核心，包含 Node.js 运行时以及所有内置的模块。这个核心遵循一系列基本的设计原则。其中一个就是<strong>尽可能只实现所需功能的最小集合</strong>，在此之外的非核心功能则由用户自行实现。用户自己开发的模块围绕在核心周围，形成了一个自由开放的软件生态。<br>将核心的功能限制在最小程度，其他的需求则给与社区足够的自由度，去验证和实现更广泛的解决方案。不仅提升了核心本身的可维护性，同时也给整个生态环境带来了正向的文化氛围。</p><h5 id="小的模块"><a href="#小的模块" class="headerlink" title="小的模块"></a>小的模块</h5><p>Node.js 使用<strong>模块（module）</strong>这个概念来表示程序代码的基础构件，模块是构成应用和库的基本单位。<br>在 Node.js 中，一个广受推崇的原则就是，设计小的模块和包。这里的“小”不仅仅是指代码本身的规模，更为关键的是功能上的“小”和集中。<br>上述原则深受 Unix 设计哲学的影响，即：</p><ul><li>Small is beautiful（小即为美）</li><li>Make each program do one thing well（只做好一件事）</li></ul><p>小的模块具有以下特点：</p><ul><li>更容易理解和使用</li><li>更容易测试和维护</li><li>体积小，在浏览器上运行有优势</li></ul><p>更小、更集中的模块鼓励每一个人共享和重用每一段哪怕是最小的代码块，在一定程度上提升了代码的可重用性。牢记 <strong>Don’t Repeat Yourself (DRY)</strong> 原则。</p><h5 id="Small-surface-area"><a href="#Small-surface-area" class="headerlink" title="Small surface area"></a>Small surface area</h5><p>除了在代码量和功能性上更小以外，Node.js 模块的另一个理想特征就是，尽可能向外界公开一组最小的功能集合。这可以帮助我们实现更清晰、不容易被错误使用的 API。模块只向外暴露单一的功能，只向外提供唯一一个清晰的、明确无误的入口。</p><p>很多 Node.js 模块的另一个特点是，模块本身被创建出来，是为了被使用而不是被扩展。通过禁止任何扩展来锁定模块内部，听起来缺乏一定的灵活性。但同时也带来了减少用例、简化实现、增强可维护性、提升可用性等优势。<br>在实践中，这意味着更倾向于对外暴露函数而不是类，避免向外部世界泄露任何内部的细节。</p><h5 id="简单性和实用主义"><a href="#简单性和实用主义" class="headerlink" title="简单性和实用主义"></a>简单性和实用主义</h5><p><strong>Keep It Simple, Stupid (KISS)</strong><br>设计简单的，而不是“完美”的、功能完备的软件，在实践中往往是更优的选择：</p><ul><li>更少的时间和资源去实现</li><li>更快地完成交付</li><li>更容易适应不断变化和增加的需求</li><li>更容易理解和维护</li></ul><p>JavaScript 是一种非常“现实”的语言。在实践中，经常见到使用更简单的类、函数和闭包替换复杂的层级结构的类。<br>纯粹的 OO 设计常常致力于使用数学模型完整地复制现实世界，并没有考虑到现实本身的“不完美”和复杂性。事实上，我们的软件一直都是对现实世界的接近，如果能够放弃创建“完美”软件的执念，尝试构造一个有着合理复杂度、能够快速工作的成品，有可能会获取到更大的成功。</p><h4 id="二、Node-js-核心原理"><a href="#二、Node-js-核心原理" class="headerlink" title="二、Node.js 核心原理"></a>二、Node.js 核心原理</h4><h5 id="I-O-很慢"><a href="#I-O-很慢" class="headerlink" title="I/O 很慢"></a>I/O 很慢</h5><p>在计算机的世界里，I/O 算得上基础操作里最慢的一种了。比如访问 RAM 的速度处于纳秒（10^-9）量级，而访问磁盘或者网络数据的速度则处于毫秒（10^-3）量级。I/O 操作通常并不消耗多少 CPU 资源，但它实际上在请求发出和操作完成之间增添了很大的延迟。<br>此外，我们还必须考虑人为因素。很多场景下应用的输入依赖于具体的个人，比如点击鼠标等。从而导致现实里的 I/O 速度，有可能比纯技术层面的磁盘和网络读写要慢得多。</p><h5 id="阻塞式-I-O"><a href="#阻塞式-I-O" class="headerlink" title="阻塞式 I/O"></a>阻塞式 I/O</h5><p>在传统的阻塞式 I/O 编程中，I/O 请求关联的函数调用会阻塞线程的执行，直到 I/O 操作完成。这会导致一定程度的延迟，有可能是毫秒级别，比如 I/O 操作涉及到磁盘读写；也有可能长达几分钟甚至更久，比如等待用户提供某些输入。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// blocks the thread until the data is available</span></span><br><span class="line">data = socket.read()</span><br><span class="line"><span class="comment">// data is available</span></span><br><span class="line">print(data)</span><br></pre></td></tr></table></figure><p>很明显，由阻塞式 I/O 实现的 Web 服务无法在同一个线程中同时处理多个连接请求，因为 socket 上的每个 I/O 操作都会阻塞任何其他连接的访问。解决此问题的传统方法就是借助多线程，每个独立的线程分别处理并发连接中的一个请求。<br>一个线程被 I/O 操作阻塞，并不会影响其他的线程继续提供服务。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-f4675436ce4d0fd4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using multiple threads to process multiple connections"></p><p>多线程的缺点在于，从资源消耗的角度看，线程并不是一个低廉的选择。他会消耗内存，引发上下文切换等。一个长时间运行的只处理一个网络请求的线程，实际上有可能大部分时间并没有在工作，这意味着对内存和 CPU 资源的浪费。</p><h5 id="非阻塞式-I-O"><a href="#非阻塞式-I-O" class="headerlink" title="非阻塞式 I/O"></a>非阻塞式 I/O</h5><p>除了阻塞式 I/O 外，现代的操作系统还支持另一种访问资源的机制，称为<strong>非阻塞式 I/O</strong>。在这种模式下，系统调用会立即返回，无需等待读写操作彻底完成。若返回时还没有获取到任何结果，则返回一个预定义的对象，该对象表明此时没有任何数据可以获取到。<br>处理非阻塞式 I/O 的最基本的模式就是，通过循环主动轮询资源池中的资源，直到某个对象返回了实际的数据。这种方式称为 <strong>busy-waiting</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">resources = [socketA, socketB, fileA]</span><br><span class="line"><span class="keyword">while</span> (!resources.isEmpty()) &#123;</span><br><span class="line">  <span class="keyword">for</span> (resource <span class="keyword">of</span> resources) &#123;</span><br><span class="line">    <span class="comment">// try to read</span></span><br><span class="line">    data = resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === NO_DATA_AVAILABLE) &#123;</span><br><span class="line">      <span class="comment">// there is no data to read at the moment</span></span><br><span class="line">      <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the list</span></span><br><span class="line">      resources.remove(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//some data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述简单的机制，不同的资源即能够在同一个线程中被处理。但仍然不够高效。实际上，CPU 的大部分时钟都被循环用来查询还没有准备好的资源，轮询算法通常意味着 CPU 资源的大量浪费。</p><h5 id="解多路复用"><a href="#解多路复用" class="headerlink" title="解多路复用"></a>解多路复用</h5><p>Busy-waiting 并不是处理非阻塞资源的理想技术，好在现代的大部分操作系统还提供了一种高效的原生机制，专门用来处理并发的非阻塞需求。该机制称为 <strong>synchronous event demultiplexer</strong> 或 <strong>event notification interface</strong>。<br><strong>multiplexing</strong> 是指将多路信号合并到一条通信链路中进行传输；<strong>demultiplexing</strong> 则是指相反的操作，将合并到一条链路中的数据重新还原成原本的多路信号。</p><p>synchronous event demultiplexer 会同时监听多个资源，当其中任何一个资源对应的读写操作完成时，就会返回一个或一系列新的事件。它的优势在于 <strong>synchronous</strong>，即它是<strong>同步</strong>的，当没有任何新的事件需要处理时，它会一直处于阻塞状态。<br>因而我们可以在同一个线程中处理多个 I/O 操作，同时不至于像 busy-waiting 那样持续轮询消耗资源。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1a479833a864587d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Using a single thread to process multiple connections"></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">watchedList.add(socketA, FOR_READ)</span><br><span class="line">watchedList.add(fileB, FOR_READ)</span><br><span class="line"><span class="keyword">while</span> (events = demultiplexer.watch(watchedList)) &#123;</span><br><span class="line">  <span class="comment">// event loop</span></span><br><span class="line">  <span class="keyword">for</span> (event <span class="keyword">of</span> events) &#123;</span><br><span class="line">    <span class="comment">// This read will never block and will always return data</span></span><br><span class="line">    data = event.resource.read()</span><br><span class="line">    <span class="keyword">if</span> (data === RESOURCE_CLOSED) &#123;</span><br><span class="line">      <span class="comment">// the resource was closed, remove it from the watched list</span></span><br><span class="line">      demultiplexer.unwatch(event.resource)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// some actual data was received, process it</span></span><br><span class="line">      consumeData(data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 <code>demultiplexer.watch()</code> 方法是同步的，当它监听的资源没有任何一个准备好时，它会一直处于阻塞状态。直到有任意资源准备好后，才会返回一系列新的事件。这个时间点返回的事件及其关联的资源由于是已经“准备好”的，可以被直接读取而不会阻塞。</p><h5 id="Reactor-pattern"><a href="#Reactor-pattern" class="headerlink" title="Reactor pattern"></a>Reactor pattern</h5><p>Reactor 模式背后的主要理念，就是给每一个 I/O 操作绑定一个 handler。在 Node.js 中可以使用回调函数来表示 handler。当某个事件被 event loop 生产和处理完之后，对应的 handler 就会立即被触发。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-1c7eb9186ecf94f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="The reactor pattern"></p><ul><li>应用首先向 <strong>Event Demultiplexer</strong> 提交一个请求，由此生成一个新的 I/O 操作。与此同时应用会为该请求绑定一个 handler，当 I/O 操作结束时自动被调用。向 Event Demultiplexer 提交请求的操作是非阻塞的，该操作提交后程序控制权会立即返还给应用</li><li>当一系列 I/O 操作完成后，Event Demultiplexer 会向 <strong>Event Queue</strong> 中推入对应的事件</li><li><strong>Event Loop</strong> 会不断遍历 Event Queue 中的事件，调用每一个事件对应的 handler</li><li>handler 代码实际上是应用本身的一部分，它在执行完毕后又会把控制权给到 Event Loop。在 handler 执行的过程中，应用仍然可以向 Event Demultiplexer 提交新的异步操作请求</li></ul><p>简单来说，所谓的异步行为，就是应用先在某个时间点表达出想要访问某个资源的兴趣（这个操作是非阻塞的），并给这个资源定义一个 handler。在另一个时间节点当资源能够被访问之后，绑定的 handler 自动被调用，处理对应的资源。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;一、Node-js-哲学&quot;&gt;&lt;a href=&quot;#一、Node-js-哲学&quot; class=&quot;headerlink&quot; title=&quot;一、Node.js 哲学&quot;&gt;&lt;/a&gt;一、Node.js 哲学&lt;/h4&gt;&lt;p&gt;每种编程语言平台都有其特定的“哲学”，即一系列被社区普遍接受
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="Functional" scheme="https://rollingstarky.github.io/tags/Functional/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Concurrency" scheme="https://rollingstarky.github.io/tags/Concurrency/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Event" scheme="https://rollingstarky.github.io/tags/Event/"/>
    
      <category term="KISS" scheme="https://rollingstarky.github.io/tags/KISS/"/>
    
      <category term="DRY" scheme="https://rollingstarky.github.io/tags/DRY/"/>
    
      <category term="Reactor" scheme="https://rollingstarky.github.io/tags/Reactor/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— State 模式</title>
    <link href="https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-state-pattern/"/>
    <id>https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-state-pattern/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-07-18T11:55:27.292Z</updated>
    
    <content type="html"><![CDATA[<p><strong>State</strong> 模式是一种特殊形式的 <strong>Strategy</strong> 模式：Context 选择的具体策略根据不同的 <em>state</em> 发生变化。<br>对于 Strategy 模式，可以基于不同的变量比如传入的参数来决定选择具体哪个策略，一旦选择确定后，直到 context 剩余的整个生命周期结束，该策略都保持不变。相反在 State 模式中，策略（或者在这里的语境下，叫做<strong>状态</strong>）在 context 的生命周期里是动态变化的，从而允许对象的行为可以根据内部状态的变化自适应地更改。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-6df095b24f7fe88a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="State pattern"></p><p>举例来说，我们需要创建一个宾馆预定系统，由一个 <strong>Reservation</strong> 类对预定房间的行为进行建模。</p><p>考虑如下一系列事件：</p><ul><li>当 reservation 对象初次创建后，其处于<strong>未确认</strong>状态。用户可以通过一个 <code>confirm()</code> 方法对此次预定进行确认。但不能通过 <code>cancel()</code> 方法取消预订，因为此次预定还并没有被确认。可以使用 <code>delete()</code> 方法删除这条记录</li><li>一旦该 reservation 被确认，订单处于<strong>已确认</strong>状态。<code>confirm()</code> 方法将不能再次被调用（不能重复确认）；但该 reservation 支持通过 <code>cancel()</code> 方法进行取消，同时该记录无法被删除（已经有人确认预定）</li><li>在 reservation 日期的前一天，订单处于<strong>已生效</strong>状态。上述所有 3 个方法都不再支持，用户只能办理入住</li></ul><p><img src="https://upload-images.jianshu.io/upload_images/6875152-4cc6dc24c762ec3e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="State pattern"></p><p>参考上图，可以实现 3 种 不同的策略，他们都实现了 <code>confirm()</code>、<code>cancel()</code>、<code>delete()</code> 这几个方法。每种策略的具体逻辑由不同的状态决定。<strong>Reservation</strong> 对象只需要在每次状态切换时，激活对应的策略。</p><h4 id="实例：failsafe-socket"><a href="#实例：failsafe-socket" class="headerlink" title="实例：failsafe socket"></a>实例：failsafe socket</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> state &amp;&amp; <span class="built_in">cd</span> state</span><br><span class="line">npm install json-over-tcp-<span class="number">2</span></span><br></pre></td></tr></table></figure><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"json-over-tcp-2"</span>: <span class="string">"^0.3.5"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>failsafeSocket.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;OfflineState&#125; <span class="keyword">from</span> <span class="string">'./offlineState.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;OnlineState&#125; <span class="keyword">from</span> <span class="string">'./onlineState.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">FailsafeSocket</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(options) &#123;</span><br><span class="line">    <span class="keyword">this</span>.options = options</span><br><span class="line">    <span class="keyword">this</span>.queue = []</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.socket = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">this</span>.states = &#123;</span><br><span class="line">      offline: <span class="keyword">new</span> OfflineState(<span class="keyword">this</span>),</span><br><span class="line">      online: <span class="keyword">new</span> OnlineState(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.changeState(<span class="string">'offline'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeState(state) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Activating state: <span class="subst">$&#123;state&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.currentState = <span class="keyword">this</span>.states[state]</span><br><span class="line">    <span class="keyword">this</span>.currentState.activate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.currentState.send(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述 <code>FailsafeSocket</code> 类主要由以下几个组件构成：</p><ul><li>构造函数 <code>constructor</code> 会初始化一个 <code>queue</code> 队列来存储 socket 离线时发送的数据，还创建了 <code>offline</code> 和 <code>online</code> 两种不同的状态，分别对应离线时和在线时 socket 的不同行为</li><li><code>changeState()</code> 方法负责不同状态的切换。它会更新当前状态 <code>currentState</code> 并调用该状态的 <code>activate()</code> 方法</li><li><code>send()</code> 方法包含 <code>FailsafeSocket</code> 类的主要功能，它会基于在线或离线状态触发不同的行为。这里它将具体的操作指派给了当前激活的状态对象去实现</li></ul><p><code>offlineState.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonOverTcp <span class="keyword">from</span> <span class="string">'json-over-tcp-2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">OfflineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="keyword">const</span> retry = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.activate(), <span class="number">1000</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Trying to connect...'</span>)</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket = jsonOverTcp.connect(</span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.options,</span><br><span class="line">      () =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Connection established'</span>)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.socket.removeListener(<span class="string">'error'</span>, retry)</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'online'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, retry)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述模块负责定义 socket 处于离线状态时的行为。</p><ul><li><code>send()</code> 方法只负责将接受到的数据存储到队列中，因为此时是离线状态，队列中的数据会在 socket 在线时取出并发送</li><li><code>activate()</code> 方法会尝试建立连接，连接失败则隔一秒重试。成功建立连接后，<code>failsafeSocket</code> 的状态变为在线状态，触发在线状态的 <code>activate()</code> 方法</li></ul><p><code>onlineState.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">OnlineState</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(failsafeSocket) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket = failsafeSocket</span><br><span class="line">    <span class="keyword">this</span>.hasDisconnected = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  send(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.queue.push(data)</span><br><span class="line">    <span class="keyword">this</span>._safeWrite(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _safeWrite(data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.write(data, (err) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>.hasDisconnected &amp;&amp; !err) &#123;</span><br><span class="line">        <span class="keyword">this</span>.failsafeSocket.queue.pop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  activate() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasDisconnected = <span class="literal">false</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> data <span class="keyword">of</span> <span class="keyword">this</span>.failsafeSocket.queue) &#123;</span><br><span class="line">      <span class="keyword">this</span>._safeWrite(data)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.failsafeSocket.socket.once(<span class="string">'error'</span>, () =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.hasDisconnected = <span class="literal">true</span></span><br><span class="line">      <span class="keyword">this</span>.failsafeSocket.changeState(<span class="string">'offline'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>OnlineState</code> 模块实现了当 socket 处于在线状态时的行为。</p><ul><li><code>send()</code> 方法会将数据放入队列，并立即尝试将其写入到 socket，因为此时是在线状态。若该数据成功写入，则将其从队列中移除</li><li><code>activate()</code> 方法会在连接成功建立时触发，会尝试发送在 socket 离线时排队的所有数据并监听任意错误事件。若有错误发生，转换到离线状态，触发离线状态的 <code>activate</code> 方法，继续尝试建立连接</li></ul><p><code>server.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> jsonOverTcp <span class="keyword">from</span> <span class="string">'json-over-tcp-2'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = jsonOverTcp.createServer(&#123;<span class="attr">port</span>: <span class="number">5000</span>&#125;)</span><br><span class="line">server.on(<span class="string">'connection'</span>, socket =&gt; &#123;</span><br><span class="line">  socket.on(<span class="string">'data'</span>, data =&gt; &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Client data'</span>, data)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.listen(<span class="number">5000</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'Server started'</span>))</span><br></pre></td></tr></table></figure></p><p><code>client.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;FailsafeSocket&#125; <span class="keyword">from</span> <span class="string">'./failsafeSocket.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> failsafeSocket = <span class="keyword">new</span> FailsafeSocket(&#123;<span class="attr">port</span>: <span class="number">5000</span>&#125;)</span><br><span class="line">setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  failsafeSocket.send(process.memoryUsage())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;State&lt;/strong&gt; 模式是一种特殊形式的 &lt;strong&gt;Strategy&lt;/strong&gt; 模式：Context 选择的具体策略根据不同的 &lt;em&gt;state&lt;/em&gt; 发生变化。&lt;br&gt;对于 Strategy 模式，可以基于不同的变量比如传入的
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="Javascript" scheme="https://rollingstarky.github.io/tags/Javascript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Template 模式</title>
    <link href="https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/"/>
    <id>https://rollingstarky.github.io/2022/07/18/node-js-design-patterns-template-pattern/</id>
    <published>2022-07-17T16:00:00.000Z</published>
    <updated>2022-07-18T11:52:30.745Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Template</strong> 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。<br>之后由虚拟基类的子类来实现上述组件中缺失的未定义部分，这部分之前未定义的方法称为 <strong>template methods</strong>。<br>此模式的目的在于，定义一系列属于“同一家族”的类，能够囊括某个组件的所有变体。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-766fa71787b062ad.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UML of Template pattern"></p><p>Template 和 Strategy 模式的目的是非常相似的，它们之间的区别主要在于结构和实现。<br>两者都允许我们在共享组件中通用部分的同时，修改组件中变化的部分，以此形成不同的变体。不同的地方在于，Strategy 是在运行时<strong>动态</strong>实现的，而 Template 则在子类定义的时刻就已经被确定了。</p><h4 id="配置管理模板"><a href="#配置管理模板" class="headerlink" title="配置管理模板"></a>配置管理模板</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> template &amp;&amp; <span class="built_in">cd</span> template</span><br><span class="line">npm install ini</span><br><span class="line">npm install objec-<span class="built_in">path</span></span><br></pre></td></tr></table></figure><p><code>package.json</code>：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>configTemplate.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fsPromises&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> objectPath <span class="keyword">from</span> <span class="string">'object-path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  <span class="keyword">async</span> load(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>._deserialize(</span><br><span class="line">      <span class="keyword">await</span> fsPromises.readFile(file, <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> save(file) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;file&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> fsPromises.writeFile(file, <span class="keyword">this</span>._serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(path) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, path)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(path, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, path, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'_serialize() must be implemented'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _deserialize() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`_deserialize() must be implemented`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中 <code>configTemplate</code> 虚拟基类实现了配置管理逻辑中的通用部分，即加载和保存文件、获取和设置属性。同时不对序列化和反序列化部分的逻辑进行定义，从而可以通过再创建不同的 Config 子类（即后面的 <code>jsonConfig</code> 和 <code>iniConfig</code>）来实现具体的序列化逻辑，进而支持特定的配置文件格式。</p><p><code>jsonConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>iniConfig.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ConfigTemplate&#125; <span class="keyword">from</span> <span class="string">'./configTemplate.js'</span></span><br><span class="line"><span class="keyword">import</span> ini <span class="keyword">from</span> <span class="string">'ini'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">IniConfig</span> <span class="keyword">extends</span> <span class="title">ConfigTemplate</span> </span>&#123;</span><br><span class="line">  _deserialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.parse(data)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _serialize(data) &#123;</span><br><span class="line">    <span class="keyword">return</span> ini.stringify(data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;JsonConfig&#125; <span class="keyword">from</span> <span class="string">'./jsonConfig.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;IniConfig&#125; <span class="keyword">from</span> <span class="string">'./iniConfig.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> jsonConfig = <span class="keyword">new</span> JsonConfig()</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.load(<span class="string">'samples/conf.json'</span>)</span><br><span class="line">  jsonConfig.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.save(<span class="string">'samples/conf_mod.json'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> iniConifg = <span class="keyword">new</span> IniConfig()</span><br><span class="line">  <span class="keyword">await</span> iniConifg.load(<span class="string">'samples/conf.ini'</span>)</span><br><span class="line">  iniConifg.set(<span class="string">'nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> iniConifg.save(<span class="string">'samples/conf_mod.ini'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Template&lt;/strong&gt; 模式与 Strategy 模式有很多相似之处。Template 模式首先会定义一个虚拟基类，描述某个组件的骨架（即通用的部分），同时令骨架中存在的某些步骤处于未定义状态。&lt;br&gt;之后由虚拟基类的子类来实现上述组件中缺失的未
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Javascript" scheme="https://rollingstarky.github.io/tags/Javascript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Template" scheme="https://rollingstarky.github.io/tags/Template/"/>
    
      <category term="Inheritance" scheme="https://rollingstarky.github.io/tags/Inheritance/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Strategy 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/26/node-js-design-patterns-strategy-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/26/node-js-design-patterns-strategy-pattern/</id>
    <published>2022-05-25T16:00:00.000Z</published>
    <updated>2022-05-25T17:08:18.915Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Strategy</strong> 模式的主体是一个 <strong>context</strong> 对象，再把逻辑中有变化的部分抽取到独立的可相互替换的 <strong>strategy</strong> 对象中，从而使 context 支持不同的策略。即 context 实现通用的逻辑，strategy 实现可替换的部分。context 与 不同的 strategy 相组合即产生了多种不同的实现。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-a70dbd6e691fcf91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Strategy"></p><p>就像雨天穿胶鞋，打篮球穿运动鞋，短跑比赛穿跑鞋。这些不同的鞋子对应的就是一系列策略，它们是同一类对象的不同变种，彼此之间可以相互替换。<br>面对不同的使用场景，选择对应的策略即可，这带来了更多的灵活性。首先鞋子和人不能是绑定的，这样的话，换鞋子就需要同时换掉整个人了；其次也没有任何一双鞋可以同时满足所有的使用场景。让鞋子作为可替换的插件无疑是最直观和方便的。<br>总的来说，策略代表了一个对象中可替换的部分。不同的策略应对同一个问题的不同变种。静态与动态分离。</p><p>比如需要实现一个 <code>Order</code> 对象，代表在线商城中的订单。该对象有一个 <code>pay()</code> 方法，负责支付行为，将用户的钱转移到商户手中。为了能够支持多种不同的支付方式，可以有以下两种选项：</p><ul><li>在 <code>pay()</code> 方法中使用 <code>if...else</code>，根据不同的支付方式，完成对应的支付动作</li><li>将支付的具体逻辑移交给独立的 strategy 对象，用户选择支付方式后，将对应的 strategy 注入到 <code>Order</code> 中</li></ul><p>对于第一种方案，当 Order 对象需要支持更多的支付方式时，就必须要修改 Order 本身的代码。这会使代码变得非常复杂，难以维护。<br>当使用第二种 Strategy 模式时，理论上可以支持无限多的支付方式。Order 只负责维护用户、商品条目、价格等信息，具体的支付逻辑则由另一个 Strategy 对象来实现。Order 本身不会由于支付方式的增加而发生任何变更。</p><h4 id="实例：支持-JSON、INI-等多种格式的-config-对象"><a href="#实例：支持-JSON、INI-等多种格式的-config-对象" class="headerlink" title="实例：支持 JSON、INI 等多种格式的 config 对象"></a>实例：支持 JSON、INI 等多种格式的 config 对象</h4><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> strategy &amp;&amp; <span class="built_in">cd</span> strategy</span><br><span class="line">npm install ini</span><br><span class="line">npm install object-<span class="built_in">path</span></span><br></pre></td></tr></table></figure><p><code>package.json</code><br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"ini"</span>: <span class="string">"^3.0.0"</span>,</span><br><span class="line">    <span class="attr">"object-path"</span>: <span class="string">"^0.11.8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>config.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promises <span class="keyword">as</span> fs&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> objectPath <span class="keyword">from</span> <span class="string">'object-path'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(formatStrategy) &#123;</span><br><span class="line">    <span class="keyword">this</span>.data = &#123;&#125;</span><br><span class="line">    <span class="keyword">this</span>.formatStrategy = formatStrategy</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  get(configPath) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.get(<span class="keyword">this</span>.data, configPath)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  set(configPath, value) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectPath.set(<span class="keyword">this</span>.data, configPath, value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> load(filePath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Deserializing from <span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">this</span>.data = <span class="keyword">this</span>.formatStrategy.deserialize(</span><br><span class="line">      <span class="keyword">await</span> fs.readFile(filePath, <span class="string">'utf-8'</span>)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span> save(filePath) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Serializing to <span class="subst">$&#123;filePath&#125;</span>`</span>)</span><br><span class="line">    <span class="keyword">await</span> fs.writeFile(filePath,</span><br><span class="line">      <span class="keyword">this</span>.formatStrategy.serialize(<span class="keyword">this</span>.data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中构造函数 <code>constructor</code> 接收一个具体的策略对象 <code>formStrategy</code> 作为参数，之后的 <code>load</code> 和 <code>save</code> 方法又使用这个 <code>formStrategy</code> 去执行与格式相关的序列化和反序列化操作。不同的 <code>formStrategy</code> 有着不同的实现，从而 <code>Config</code> 类可以凭借 <code>construcotr</code> 接收的不同参数，与不同的策略整合，灵活地应对不同的需求场景。</p><p><code>strategy.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ini <span class="keyword">from</span> <span class="string">'ini'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> iniStrategy = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> ini.stringify(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> jsonStrategy = &#123;</span><br><span class="line">  deserialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.parse(data),</span><br><span class="line">  serialize: <span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">JSON</span>.stringify(data, <span class="literal">null</span>, <span class="string">' '</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此处的代码实现了两种不同的策略：<code>iniStrategy</code> 和 <code>jsonStrategy</code>，分别针对不同的文件格式。它们有着一致的接口，符合策略之间可以相互替换的原则，从而都可以被前面 <code>Config</code> 类的 <code>load</code> 和 <code>save</code> 方法调用。</p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Config&#125; <span class="keyword">from</span> <span class="string">'./config.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;jsonStrategy, iniStrategy&#125; <span class="keyword">from</span> <span class="string">'./strategy.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> iniConfig = <span class="keyword">new</span> Config(iniStrategy)</span><br><span class="line">  <span class="keyword">await</span> iniConfig.load(<span class="string">'samples/conf.ini'</span>)</span><br><span class="line">  iniConfig.set(<span class="string">'book.nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> iniConfig.save(<span class="string">'samples/conf_mod.ini'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> jsonConfig = <span class="keyword">new</span> Config(jsonStrategy)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.load(<span class="string">'samples/conf.json'</span>)</span><br><span class="line">  jsonConfig.set(<span class="string">'book.nodejs'</span>, <span class="string">'design patterns'</span>)</span><br><span class="line">  <span class="keyword">await</span> jsonConfig.save(<span class="string">'samples/conf_mod.json'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;Strategy&lt;/strong&gt; 模式的主体是一个 &lt;strong&gt;context&lt;/strong&gt; 对象，再把逻辑中有变化的部分抽取到独立的可相互替换的 &lt;strong&gt;strategy&lt;/strong&gt; 对象中，从而使 context 支持不同的策略。
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Proxy 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/13/node-js-design-patterns-proxy-pattern/</id>
    <published>2022-05-12T16:00:00.000Z</published>
    <updated>2022-05-12T16:14:08.283Z</updated>
    
    <content type="html"><![CDATA[<p><strong>代理（proxy）</strong> 可以理解为一种对象，其能够控制客户端对另一个对象（<strong>subject</strong>）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。<br>proxy 会拦截所有或者部分本应该直接交给 subject 执行的操作，通过额外的预处理或后处理增强其行为，再转发给 subject。<br><img src="https://upload-images.jianshu.io/upload_images/6875152-361cc860946b4838.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Proxy pattern schematic"></p><p>Proxy 的主要应用场景：</p><ul><li>Data validation：proxy 对输入数据进行验证，再转发给 subject</li><li>Security：proxy 检查客户端是否有权限执行请求的操作，若检查通过则将请求转发给 subject</li><li>Caching：proxy 负责维护一份内部缓存，只有当请求的数据不在缓存中时，才将该请求转发给 subject 处理</li><li>Lazy initialization：若创建某个对象代价很高，proxy 可以延迟该创建操作直到必要的时候</li><li>Logging：proxy 拦截函数和对应的参数，在函数执行的同时记录日志信息</li><li>Remote objects：proxy 可以接收一个远程对象并令其表现为本地对象</li></ul><h4 id="示例代码：StackCalculator"><a href="#示例代码：StackCalculator" class="headerlink" title="示例代码：StackCalculator"></a>示例代码：StackCalculator</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack.push(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack.pop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.stack[<span class="keyword">this</span>.stack.length - <span class="number">1</span>]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">this</span>.stack = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> dividend = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = dividend / divisor</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">const</span> multiplicand = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> multiplier = <span class="keyword">this</span>.getValue()</span><br><span class="line">    <span class="keyword">const</span> result = multiplier * multiplicand</span><br><span class="line">    <span class="keyword">this</span>.putValue(result)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br></pre></td></tr></table></figure><p>现代的计算器基本上都遵循类似的逻辑，即上一个式子的计算结果可以作为下一次计算的输入。<br>在 JavaScript 中，当用户尝试除以 0 时，并不会报错而是返回 <code>Infinity</code>。现在我们尝试借助 Proxy 模式来增强 StackCalculator 除以 0 时的行为。</p><h4 id="Object-composition"><a href="#Object-composition" class="headerlink" title="Object composition"></a>Object composition</h4><p><strong>组合（Composition）</strong>表示一个对象通过引用另一个对象，来扩展或者使用后者的功能。<br>借助组合可以实现 Proxy 模式。创建一个新的对象，令其有着和 subject 完全一致的接口，同时内部还保存着一个对 subject 的引用。参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SafeCalculator</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(calculator) &#123;</span><br><span class="line">    <span class="keyword">this</span>.calculator = calculator</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  divide() &#123;</span><br><span class="line">    <span class="keyword">const</span> divisor = <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.divide()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  putValue(value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.putValue(value)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  peekValue() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.peekValue()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  clear() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.clear()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  multiply() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.calculator.multiply()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> SafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">3</span>)</span><br><span class="line">calculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.multiply())  <span class="comment">// 3 * 2 = 6</span></span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.multiply())  <span class="comment">// 6 * 2 = 12</span></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// 12 / 0 = Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在这次的实现中，proxy 拦截了感兴趣的方法（<code>divide()</code>），为其实现了新的行为（除以 0），而其他的操作（如 <code>putValue()</code>、<code>getValue()</code>、<code>peekValue()</code>、<code>clear()</code> 和 <code>multiply()</code>）则是简单地分派给 subject 去做。<br>计算器的状态（栈中存放的值）仍由 <code>calculator</code> 实例在维护，<code>SafeCalculator</code> 只是调用 <code>calculator</code> 的方法来读取或者修改这些状态。</p><p>上面的实现方式，需要我们显式地将很多方法指派给 subject。即需要写出很多如下形式的代码片段：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">getValue() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.calculator.getValue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这在很大程度上增加了代码的冗余度。</p><h4 id="Object-augmentation"><a href="#Object-augmentation" class="headerlink" title="Object augmentation"></a>Object augmentation</h4><p><strong>对象增强（Object augmentation）</strong>又叫做<strong>猴子补丁（monkey patching）</strong>，能够只代理某个对象的部分方法，并且可能是所有方案中最简单、最常见的一种。<br>它可以将 subject 的某个方法直接替换为 proxy 版本的实现，即直接修改 subject 对象本身。</p><p>参考如下代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patchToSafeCalculator</span>(<span class="params">calculator</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> divideOrig = calculator.divide</span><br><span class="line">  calculator.divide = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// additional validation logic</span></span><br><span class="line">    <span class="keyword">const</span> divisor = calculator.peekValue()</span><br><span class="line">    <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">    <span class="keyword">return</span> divideOrig.apply(calculator)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> calculator</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> patchToSafeCalculator(calculator)</span><br><span class="line"></span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// console.log(calculator.divide())  // Error, not Infinity</span></span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>当只需要代理某一个或几个方法的时候，上述方案会非常方便。用户不需要再手动重新实现一遍 <code>putValue()</code> 等方法。<br>不幸的是，简单化也带来了一定的代价，像上面那样直接修改 subject 对象是一种危险的行为。当该 subject 对象被其他部分的代码共享时，修改行为必须尽一切可能避免，从而不至于引发意想不到的 side effect。<br>尝试将代码中的 <code>// console.log(calculator.divide())</code> 取消注释，会发现 <code>calculator</code> 并没有像之前那样输出 <code>Infinity</code>，而是跟 <code>safeCalculator</code> 一样报出错误。即原来的 <code>calculator</code> 对象已经被猴子补丁所改变。</p><h4 id="内置的-Proxy-对象"><a href="#内置的-Proxy-对象" class="headerlink" title="内置的 Proxy 对象"></a>内置的 Proxy 对象</h4><p>ES2015 引入了一种原生的创建 proxy 对象的方式。其语法如下：<br><code>const proxy = new Proxy(target, handler)</code></p><p>其中 <code>target</code> 代表被 proxy 代理的对象（即 subject），<code>handler</code> 对象则用来定义 proxy 的具体行为。它包含一系列可选的预定义方法（如 <code>get</code>、<code>set</code>、<code>apply</code> 等），叫做 <strong>trap methods</strong>，在 subject 上执行对应的操作时会自动触发这些方法。</p><p>示例代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackCalculator</span> </span>&#123;</span><br><span class="line">  <span class="comment">// see above</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> safeCalculatorHandler = &#123;</span><br><span class="line">  get: <span class="function">(<span class="params">target, property</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (property === <span class="string">'divide'</span>) &#123;</span><br><span class="line">      <span class="comment">// proxied method</span></span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="comment">// additional validation logic</span></span><br><span class="line">        <span class="keyword">const</span> divisor = target.peekValue()</span><br><span class="line">        <span class="keyword">if</span> (divisor === <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'Division by 0'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// if valid, delegates to the subject</span></span><br><span class="line">        <span class="keyword">return</span> target.divide()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// delegated methods and properties</span></span><br><span class="line">    <span class="keyword">return</span> target[property]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> calculator = <span class="keyword">new</span> StackCalculator()</span><br><span class="line"><span class="keyword">const</span> safeCalculator = <span class="keyword">new</span> <span class="built_in">Proxy</span>(</span><br><span class="line">  calculator,</span><br><span class="line">  safeCalculatorHandler</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">calculator.putValue(<span class="number">4</span>)</span><br><span class="line">calculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(calculator.divide())  <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line">safeCalculator.clear()</span><br><span class="line">safeCalculator.putValue(<span class="number">4</span>)</span><br><span class="line">safeCalculator.putValue(<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(safeCalculator.divide())  <span class="comment">// 4 / 0 -&gt; Error</span></span><br></pre></td></tr></table></figure></p><p>在上面的代码中，通过 <code>get</code> trap method 捕获对于原本的 <code>calculator</code> 对象的属性和方法的访问，当访问的方法是 <code>divide()</code> 时，proxy 就会返回一个添加了额外验证逻辑的新函数。<br>之后又简单地使用 <code>target[property]</code> 返回了所有未修改过的属性和方法。</p><p>总的来说，Proxy 对象为我们提供了一个非常简单的方法，只代理 subject 的一部分功能，且不需要显式地将未代理的方法移交给 subject。同时也不会对原本的 subject 做出任何改动。</p><h5 id="几种-proxy-实现机制的比较"><a href="#几种-proxy-实现机制的比较" class="headerlink" title="几种 proxy 实现机制的比较"></a>几种 proxy 实现机制的比较</h5><ul><li>Composition：最直观和安全，subject 不会被修改。但需要手动将未代理的方法指派给 subject。冗余代码</li><li>Object augmentation：会直接修改原本的 subject 对象，不够安全。不需要手动处理未代理的方法</li><li>Proxy 对象：提供了更高级的访问控制。支持更多类型的属性访问，比如可以拦截 subject 对自身属性的删除等操作。不会修改 subject 本身，只需要使用一句代码处理未代理的方法</li></ul><h4 id="实例：logging-Writable-stream"><a href="#实例：logging-Writable-stream" class="headerlink" title="实例：logging Writable stream"></a>实例：logging Writable stream</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir logwritting &amp;&amp; cd logwritting</span><br></pre></td></tr></table></figure><p>package.json：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>logging-writable.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createLoggingWritable</span>(<span class="params">writable</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Proxy</span>(writable, &#123;</span><br><span class="line">    get(target, propKey) &#123;</span><br><span class="line">      <span class="keyword">if</span> (propKey === <span class="string">'write'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">const</span> [chunk] = args</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'Writing'</span>, chunk)</span><br><span class="line">          <span class="keyword">return</span> writable.write(...args)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> target[propKey]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>index.js：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createWriteStream&#125; <span class="keyword">from</span> <span class="string">'fs'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createLoggingWritable&#125; <span class="keyword">from</span> <span class="string">'./logging-writable.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> writable = createWriteStream(<span class="string">'test.txt'</span>)</span><br><span class="line"><span class="keyword">const</span> writableProxy = createLoggingWritable(writable)</span><br><span class="line"></span><br><span class="line">writableProxy.write(<span class="string">'First chunk'</span>)</span><br><span class="line">writableProxy.write(<span class="string">'Second chunk'</span>)</span><br><span class="line">writable.write(<span class="string">'This is not logged'</span>)</span><br><span class="line">writableProxy.end()</span><br><span class="line"><span class="comment">// =&gt; Writing First chunk</span></span><br><span class="line"><span class="comment">// =&gt; Writing Second chunk</span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;代理（proxy）&lt;/strong&gt; 可以理解为一种对象，其能够控制客户端对另一个对象（&lt;strong&gt;subject&lt;/strong&gt;）的访问。代理（proxy）和目标对象（subject）拥有完全相同的接口，可以自由地进行替换。&lt;br&gt;proxy 会拦截
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Proxy" scheme="https://rollingstarky.github.io/tags/Proxy/"/>
    
      <category term="Composition" scheme="https://rollingstarky.github.io/tags/Composition/"/>
    
      <category term="Monkey Patching" scheme="https://rollingstarky.github.io/tags/Monkey-Patching/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 设计模式笔记 —— Health Probe</title>
    <link href="https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/"/>
    <id>https://rollingstarky.github.io/2022/05/10/kubernetes-patterns-reading-notes-health-probe/</id>
    <published>2022-05-09T16:00:00.000Z</published>
    <updated>2022-05-10T13:32:21.728Z</updated>
    
    <content type="html"><![CDATA[<p><em>Health Probe</em> 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度<strong>可观测</strong>的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经准备好接收请求。<br>这些观测结果会影响 Pod 的生命周期管理，以及网络流量被路由到应用的具体路径。</p><p>Kubernetes 会定期检测容器中进程的状态，如果有错误发生，就立即重启该容器。然而在实践中，通过检查进程状态来确定应用是否健康，并不总是有效。<br>很多情况下应用提供的服务中断了，但进程仍旧在运行。比如 Java 应用有可能抛出 <code>OutOfMemoryError</code> 同时 JVM 进程仍在运行。此外，应用还有可能因为无限循环、死锁或者缓存异常等原因冻结。<br>因此 Kubernetes 需要一种可靠的方式来检查应用的健康状态，不关注应用的内部工作流程，而是通过某些指标，衡量应用能否对外提供服务。</p><p>软件行业已经接受了这样一个事实，即写出完全没有 bug 的软件是不现实的。因此当面对 failures 时，可以把关注点从避免 bug 转移到如何快速检测到失效并自动恢复。<br>但错误检测并不是一个简单的对所有应用通用的任务，存在很多不同的对于错误的定义，并且不同类型的错误也需要不同的应对方式。</p><h4 id="Process-Health-Checks"><a href="#Process-Health-Checks" class="headerlink" title="Process Health Checks"></a>Process Health Checks</h4><p><em>process health check</em> 是最简单的一种 health check 方式，由 Kubelet 持续对容器进程进行检测。若容器进程没有处于运行状态，即对其进行重启。<br>如果应用本身能够检测到任意类型的错误并自行终止，凭借 process health check 就足够完成健康检查任务。</p><h4 id="Liveness-Probes"><a href="#Liveness-Probes" class="headerlink" title="Liveness Probes"></a>Liveness Probes</h4><p>假如应用会进入某种死锁状态，进程并未停止运行，因而从 process health check 的角度看应用仍然是健康的。Kubernetes 可以通过 <em>liveness probes</em> 来检测此类错误。<br>能够从应用外部执行健康检测，而不是仅仅依靠应用本身，这一点是非常重要的。因为有些错误有可能会阻止应用本身的 watchdog 对外报告异常。<br>liveness probes 看上去和 process health check 非常相似，它们都会在检测到异常时重启容器。但前者提供了更多的灵活性：</p><ul><li>HTTP probe：向容器的 IP 地址发起 HTTP GET 请求，期待获取一个成功的 HTTP 响应码（200 - 399）</li><li>TCP Socket probe：测试是否能完成完整的 TCP 连接</li><li>Exec probe：在容器内部执行任意的命令，期待获取一个成功的退出码（0）</li></ul><p>基于 HTTP 的 liveness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-liveness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    env:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">DELAY_STARTUP</span></span><br><span class="line"><span class="attr">      value:</span> <span class="string">"20"</span></span><br><span class="line"><span class="attr">    ports:</span></span><br><span class="line"><span class="attr">    - containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">    protocol:</span> <span class="string">TCP</span></span><br><span class="line"><span class="attr">    livenessProbe:</span></span><br><span class="line"><span class="attr">      httpGet:</span></span><br><span class="line"><span class="attr">        path:</span> <span class="string">/actuator/health</span></span><br><span class="line"><span class="attr">        port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">      initialDelaySeconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure></p><p>其中 <code>httpGet</code> 中的 <code>path</code> 项用于配置 HTTP probe 执行健康检测时请求的端点；<code>initialDelaySeconds</code> 用于配置执行第一次检测前等待的时间，以等待应用启动后完成 warm up。</p><p>需要注意的是，未通过 liveness probe 检查的后果就是容器被重启，若容器重启对于解决问题没有任何效果，则 liveness probe 本身也不会再有任何其他作用。</p><h4 id="Readiness-Probes"><a href="#Readiness-Probes" class="headerlink" title="Readiness Probes"></a>Readiness Probes</h4><p>Liveness 检查通过杀掉不健康的容器并将它们替换为新的容器实例，来确保应用处于健康状态。但有些时候容器遇到问题，重启它们并不会令其恢复健康。最常见的情况就是容器正处于启动过程中，还没有准备好处理任何请求。或者有可能容器负载过高导致延迟极度增长。</p><p>在上述场景下，Kubernetes 提供了 <em>readiness probe</em> 特性。Readiness 检查和 Liveness 检查提供的检测方法是一样的（都是 HTTP、TCP 和 Exec），只有触发的操作不同。<br>失败的 Readiness 检查会将容器从 Service 端点移除，确保其不再对外提供任何服务。它关注的重点在于容器是否已经准备好，有些容器在启动时需要一定的 warm up 时间才能处理请求。<br>Readiness probe 在容器启动后依然会定期运行，从而将不能对外提供服务的容器屏蔽掉，保证未准备好的容器不会接收到外部的请求。</p><p>即 Liveness probe 触发的操作是重启容器，目的是不健康的容器尽可能恢复服务；Readiness probe 触发的操作是将容器从 Service 移除，目的是确保不健康的容器不会对外提供服务，用户的请求只会转发到健康的容器。<br>当然在容器重启时，Kubernetes 也会尽力确保该容器不会再收到用户请求，不管 Readiness probe 是否通过。</p><p>Readiness probe 示例：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">pod-with-readiness-check</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  containers:</span></span><br><span class="line"><span class="attr">  - image:</span> <span class="string">k8spatterns/random-generator:1.0</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">random-generator</span></span><br><span class="line"><span class="attr">    readinessProbe:</span></span><br><span class="line"><span class="attr">      exec:</span></span><br><span class="line"><span class="attr">        command:</span> <span class="string">[</span> <span class="string">"stat"</span><span class="string">,</span> <span class="string">"/var/run/random-generator-ready"</span> <span class="string">]</span></span><br></pre></td></tr></table></figure></p><p>Process health check 和 liveness probe 的目的都是通过重启容器来使应用能从错误中自动恢复。Readiness probe 则力求为处于恢复中的容器争取足够的时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>容器技术为打包和运行应用实现了一系列统一的接口，从而可以将应用作为<strong>黑盒（black box）</strong>看待。<br>然而任何致力于成为云原生应用的容器，必须为运行时环境提供一系列必要的 API，对容器的健康状态进行统一的观测，并执行对应的操作。这是容器能统一地实现自动化升级和生命周期管理的基础需求，从而提高系统的稳定性和用户体验。<br>这意味着容器化应用必须为多种不同的健康检测（liveness 和 readiness）提供需要的 API。<br>甚至更优异的应用还必须为管理平台提供其他手段，以方便更好地观测容器化应用的状态，比如与 Prometheus 进行整合。将应用视为一种黑盒，同时实现必须的 API 接口，方便平台对其进行监控和管理。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://developers.redhat.com/books/kubernetes-patterns" target="_blank" rel="noopener">Kubernetes Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;em&gt;Health Probe&lt;/em&gt; 模式主要关注 Kubernetes 如何获取某个应用的健康状态。为了实现完全自动化，一个云原生应用必须是高度&lt;strong&gt;可观测&lt;/strong&gt;的，从而 Kubernetes 能够推断应用的状态，检测应用是否已经启动，是否已经
      
    
    </summary>
    
      <category term="Linux" scheme="https://rollingstarky.github.io/categories/Linux/"/>
    
    
      <category term="Linux" scheme="https://rollingstarky.github.io/tags/Linux/"/>
    
      <category term="Automation" scheme="https://rollingstarky.github.io/tags/Automation/"/>
    
      <category term="Docker" scheme="https://rollingstarky.github.io/tags/Docker/"/>
    
      <category term="Container" scheme="https://rollingstarky.github.io/tags/Container/"/>
    
      <category term="Kubernetes" scheme="https://rollingstarky.github.io/tags/Kubernetes/"/>
    
      <category term="Service" scheme="https://rollingstarky.github.io/tags/Service/"/>
    
      <category term="Recovery" scheme="https://rollingstarky.github.io/tags/Recovery/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— 单例模式</title>
    <link href="https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/09/node-js-design-patterns-singleton-pattern/</id>
    <published>2022-05-08T16:00:00.000Z</published>
    <updated>2022-05-09T14:18:38.395Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Singleton"><a href="#Singleton" class="headerlink" title="Singleton"></a>Singleton</h4><p>单例（<strong>Singleton</strong>）模式是面向对象编程中最常见的设计模式之一，Node.js 已经有了很简单的实现。<br>使用单例模式的目的在于确保某个类只有一个实例存在，并对该实例的访问进行统一的控制。其主要运用场景如下：</p><ul><li>共享有状态的信息</li><li>优化资源消耗</li><li>同步对某个资源的访问</li></ul><p>比如，一个标准的 Database 类会提供对数据库的访问：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 'Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Database</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(dbName, connectionDetails) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在上述类的标准实现中，通常需要维护一个数据库连接池，毕竟为每一次数据库请求都分别创建一个新的 Database 实例显得不太现实。此外，Database 实例可能会保存部分有状态的数据，比如 pending 的事务列表。<br>因此，一般只在应用开始运行时初始化一个 Database 实例，此后其作为一个唯一的共享实例被所有其他组件使用。</p><p>Node.js 的新用户可能会思考该如何从逻辑层面实现单例模式，事实上远比想象中更简单。<br><strong>将某个实例从模块中导入，即可实现单例模式的所有需求。</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file 'dbInstance.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Database&#125; <span class="keyword">from</span> <span class="string">'./Database.js'</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> dbInstance = <span class="keyword">new</span> Database(<span class="string">'my-app-db'</span>, &#123;</span><br><span class="line">  url: <span class="string">'localhost:5432'</span>,</span><br><span class="line">  username: <span class="string">'user'</span>,</span><br><span class="line">  password: <span class="string">'password'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>只需要简单地导出 Database 类的一个新实例（<code>dbInstance</code>），在当前的整个包中就可以认为只存在这一个 <code>dbInstance</code> 对象（单例），这得益于 Node.js 的模块系统。Node.js 会对模块进行缓存，保证不会在每次导入时都再执行一遍代码。</p><p>再通过如下一行代码即可简单地获取上面创建的共享的 <code>dbInstance</code> 实例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; dbInstance &#125; <span class="keyword">from</span> <span class="string">'./dbInstance.js'</span></span><br></pre></td></tr></table></figure></p><h4 id="例外情况"><a href="#例外情况" class="headerlink" title="例外情况"></a>例外情况</h4><p>Node.js 中缓存的模块以完整路径作为对其进行查找的 key，所以前面实现的 Singleton 只在当前的包中生效。每个包都有可能包含其私有的依赖，放置在它自己的 <code>node_modules</code> 路径下。因而就可能导致同一个模块存在多个实例，前面实现的 Singleton 不能再保证唯一性。</p><p>例如，前面的 <code>Database.js</code> 和 <code>dbInstance.js</code> 同属于 <code>mydb</code> 包，其 <code>package.json</code> 内容如下：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"mydb"</span>,</span><br><span class="line">  <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"main"</span>: <span class="string">"dbInstance.js"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>又假设有两个包（<code>package-a</code> 和 <code>package-b</code>）各自都拥有包含如下内容的 <code>index.js</code> 文件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dbInstance&#125; <span class="keyword">from</span> <span class="string">'mydb'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">getDbInstance</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> dbInstance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>package-a</code> 和 <code>package-b</code> 都依赖包 <code>mydb</code>，但 <code>package-a</code> 依赖版本 1.0.0，<code>package-b</code> 依赖版本 2.0.0。结果就会出现如下结构的依赖关系：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app/</span><br><span class="line">`-- node_modules</span><br><span class="line">    |-- package-a</span><br><span class="line">    |  `-- node_modules</span><br><span class="line">    |      `-- mydb</span><br><span class="line">    `-- package-b</span><br><span class="line">        `-- node_modules</span><br><span class="line">            `-- mydb</span><br></pre></td></tr></table></figure></p><p>当 <code>package-a</code> 和 <code>package-b</code> 依赖两个不兼容版本的 <code>mydb</code> 模块时，包管理器不会将 <code>mydb</code> 放置在 <code>node_modules</code> 的根路径下，而是在 <code>package-a</code> 和 <code>package-b</code> 下面各自放一个私有的 <code>mydb</code> 副本，从而解决版本冲突。</p><p>此时假如 <code>app/</code> 路径下有一个如下内容的 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromA&#125; <span class="keyword">from</span> <span class="string">'package-a'</span></span><br><span class="line"><span class="keyword">import</span> &#123;getDbInstance <span class="keyword">as</span> getDbFromB&#125; <span class="keyword">from</span> <span class="string">'package-b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> isSame = getDbFromA() === getDbFromB()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is the db instance in package-a the same '</span> +</span><br><span class="line">  <span class="string">`as package-b? <span class="subst">$&#123;isSame ? <span class="string">'YES'</span> : <span class="string">'NO'</span>&#125;</span>`</span>)</span><br></pre></td></tr></table></figure></p><p><code>getDbFromA()</code> 和 <code>getDbFromB()</code> 并不会获得同一个 <code>dbInstance</code> 实例，打破了 Singleton 模式的假设。</p><p>当然了，大多数情况下我们并不需要一个 <em>pure</em> Singleton。事实上，通常也只会在应用的 main 包中创建和导入 Singleton。</p><h4 id="Singleton-dependencies"><a href="#Singleton-dependencies" class="headerlink" title="Singleton dependencies"></a>Singleton dependencies</h4><p>最简单地将两个模块组合在一起的方式，就是直接利用 Node.js 的模块系统。如前面所说，这样组合起来的有状态的依赖关系其实就是单例模式。</p><p>实现下面一个博客系统：<br><code>mkdir blog &amp;&amp; cd blog</code><br><code>npm install sqlite3</code></p><p><code>blog/package.json</code>:<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"type"</span>: <span class="string">"module"</span>,</span><br><span class="line">  <span class="attr">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"sqlite3"</span>: <span class="string">"^5.0.8"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> db = <span class="keyword">new</span> sqlite3.Database(</span><br><span class="line">  join(__dirname, <span class="string">'data.sqlite'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p><code>blog/blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"><span class="keyword">import</span> &#123;db&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dbRun = promisify(db.run.bind(db))</span><br><span class="line"><span class="keyword">const</span> dbAll = promisify(db.all.bind(db))</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>blog/index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p><code>db.js</code> 创建了一个 <code>db</code> 数据库实例并导出，<code>blog.js</code> 从 <code>db.js</code> 中导入 <code>db</code> 实例并直接在代码中使用。形成了一种简单直观的 <code>blog.js</code> 依赖于 <code>db.js</code> 模块的关系。同时整个项目中的数据库连接都由唯一的 <code>db</code> 单例进行控制。</p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">No posts available.</span><br></pre></td></tr></table></figure></p><p>可以运行下面的命令插入测试数据：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-posts.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> posts = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'my-first-post'</span>,</span><br><span class="line">    title: <span class="string">'My first post'</span>,</span><br><span class="line">    content: <span class="string">'Hello World!\nThis is my first post'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-03'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'iterator-patterns'</span>,</span><br><span class="line">    title: <span class="string">'Node.js iterator patterns'</span>,</span><br><span class="line">    content: <span class="string">'Let\'s talk about some iterator patterns in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-06'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="string">'dependency-injection'</span>,</span><br><span class="line">    title: <span class="string">'Dependency injection in Node.js'</span>,</span><br><span class="line">    content: <span class="string">'Today we will discuss about dependency injection in Node.js\n\n...'</span>,</span><br><span class="line">    created_at: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2020-02-29'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog()</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> <span class="built_in">Promise</span>.all(</span><br><span class="line">    posts.map(</span><br><span class="line">      (post) =&gt; blog.createPost(</span><br><span class="line">        post.id,</span><br><span class="line">        post.title,</span><br><span class="line">        post.content,</span><br><span class="line">        post.created_at</span><br><span class="line">      )</span><br><span class="line">    )</span><br><span class="line">  )</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'All posts imported'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ node <span class="keyword">import</span>-posts.js</span><br><span class="line">All posts imported</span><br><span class="line">$ node index.js</span><br><span class="line">Dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line">-------------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-29</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Today we will discuss about dependency injection <span class="keyword">in</span> Node.js</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">Node.js iterator patterns</span><br><span class="line">-------------------------</span><br><span class="line">Published on <span class="number">2020</span><span class="number">-02</span><span class="number">-06</span>T00:<span class="number">00</span>:<span class="number">00.000</span>Z</span><br><span class="line">Let<span class="string">'s talk about some iterator patterns in Node.js</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">My first post</span></span><br><span class="line"><span class="string">-------------</span></span><br><span class="line"><span class="string">Published on 2020-02-03T00:00:00.000Z</span></span><br><span class="line"><span class="string">Hello World!</span></span><br><span class="line"><span class="string">This is my first post</span></span><br></pre></td></tr></table></figure><p>就如上面的代码所示，借助 Singleton 模式，将 <code>db</code> 实例自由地在文件之间传递，可以实现一个很简单的命令行博客管理系统。这也是大多数情况下我们管理有状态的依赖的方式。<br>使用 Singleton 诚然是最简单、即时，可读性最好的方案。但是，假如我们需要在测试过程中 mock 数据库，或者需要终端用户能够自主选择另一个数据库后端，而不是默认提供的 SQLite。<br>对于以上需求，Singleton 反而成为了一个设计更好结构的阻碍。可以在 <code>db.js</code> 中引入 <code>if</code> 语句根据某些条件来选择不同的实现，显然这种方式并不是很美观。</p><h4 id="Dependency-Injection"><a href="#Dependency-Injection" class="headerlink" title="Dependency Injection"></a>Dependency Injection</h4><p>Node.js 的模块系统以及 Singleton 模式可以作为一个很好的管理和组合应用组件的工具，它们非常简单，容易上手。但另一方面，它们也可能会使各组件之间的<strong>耦合</strong>程度加深。<br>在前面的例子中，<code>blog.js</code> 和 <code>db.js</code> 模块是耦合度很高的，<code>blog.js</code> 没有了 <code>db.js</code> 就无法工作，当然也无法使用另一个不同的数据库模块。<br>可以借助 <strong>Dependency Injection</strong> 来弱化模块之间的耦合度。</p><p><strong>依赖注入</strong>表示将某个组件的依赖模块由外部实体（injector）作为<strong>输入</strong>提供。<br>DI 的主要优势在于能够降低耦合度，尤其当模块依赖于有状态的实例（比如数据库连接）时。<strong>每个依赖项并不是硬编码进主体代码，而是由外部传入，意味着这些依赖项可以被替换成任意相互兼容的实例</strong>。使得主体代码本身可以以最小的改动在不同的背景下重用。</p><p><img src="https://upload-images.jianshu.io/upload_images/6875152-187f28cb137f94fe.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Dependency injection schematic"></p><p>修改 <code>blog.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;promisify&#125; <span class="keyword">from</span> <span class="string">'util'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(db) &#123;</span><br><span class="line">    <span class="keyword">this</span>.db = db</span><br><span class="line">    <span class="keyword">this</span>.dbRun = promisify(db.run.bind(db))</span><br><span class="line">    <span class="keyword">this</span>.dbAll = promisify(db.all.bind(db))</span><br><span class="line">  &#125;</span><br><span class="line">  initialize() &#123;</span><br><span class="line">    <span class="keyword">const</span> initQuery = <span class="string">`CREATE TABLE IF NOT EXISTS posts (</span></span><br><span class="line"><span class="string">      id TEXT PRIMARY KEY,</span></span><br><span class="line"><span class="string">      title TEXT NOT NULL,</span></span><br><span class="line"><span class="string">      content TEXT,</span></span><br><span class="line"><span class="string">      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP</span></span><br><span class="line"><span class="string">    );`</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(initQuery)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  createPost(id, title, content, createdAt) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbRun(<span class="string">'INSERT INTO posts VALUES (?, ?, ?, ?)'</span>,</span><br><span class="line">      id, title, content, createdAt)</span><br><span class="line">  &#125;</span><br><span class="line">  getAllPosts() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.dbAll(<span class="string">'SELECT * FROM posts ORDER BY created_at DESC'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最主要的改动在于为 <code>Blog</code> 类添加了 <code>constructor (db)</code> 构造方法，该方法的参数 <code>db</code> 即为 Dependency，Blog 的依赖项，需要在运行时由 Blog 的客户端提供。</p><p>修改 <code>db.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sqlite3 <span class="keyword">from</span> <span class="string">'sqlite3'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createDb</span>(<span class="params">dbFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> sqlite3.Database(dbFile)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>此版本的 <code>db</code> 模块提供了一个 <code>createDB()</code> 工厂函数，可以在运行时返回一个新的数据库实例。</p><p>修改 <code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;dirname, join&#125; <span class="keyword">from</span> <span class="string">'path'</span></span><br><span class="line"><span class="keyword">import</span> &#123;fileURLToPath&#125; <span class="keyword">from</span> <span class="string">'url'</span></span><br><span class="line"><span class="keyword">import</span> &#123;Blog&#125; <span class="keyword">from</span> <span class="string">'./blog.js'</span></span><br><span class="line"><span class="keyword">import</span> &#123;createDb&#125; <span class="keyword">from</span> <span class="string">'./db.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> __dirname = dirname(fileURLToPath(<span class="keyword">import</span>.meta.url))</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> db = createDb(join(__dirname, <span class="string">'data.sqlite'</span>))</span><br><span class="line">  <span class="keyword">const</span> blog = <span class="keyword">new</span> Blog(db)</span><br><span class="line">  <span class="keyword">await</span> blog.initialize()</span><br><span class="line">  <span class="keyword">const</span> posts = <span class="keyword">await</span> blog.getAllPosts()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (posts.length === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'No posts available.'</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> post <span class="keyword">of</span> posts) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(post.title)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'-'</span>.repeat(post.title.length))</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`Published on <span class="subst">$&#123;<span class="keyword">new</span> <span class="built_in">Date</span>(post.created_at).toISOString()&#125;</span>`</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(post.content)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main().catch(<span class="built_in">console</span>.error)</span><br></pre></td></tr></table></figure></p><p>使用 <code>createDB()</code> 工厂函数创建数据库实例 <code>db</code>，然后在初始化 Blog 实例时，将 <code>db</code> 作为 Blog 的依赖进行注入。<br>从而 <code>blog.js</code> 与具体的数据库实现进行了分离。</p><p>依赖注入可以提供松耦合和代码重用等优势，但也存在一定的代价。比如无法在编码时解析依赖项，使得理解模块之间的逻辑关系变得更加困难，尤其当应用很大很复杂的时候。<br>此外，我们还必须确保数据库实例（依赖）在 Blog 实例之前创建，从而迫使我们手动构建整个应用的依赖图，以保证顺序正确。</p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Singleton&quot;&gt;&lt;a href=&quot;#Singleton&quot; class=&quot;headerlink&quot; title=&quot;Singleton&quot;&gt;&lt;/a&gt;Singleton&lt;/h4&gt;&lt;p&gt;单例（&lt;strong&gt;Singleton&lt;/strong&gt;）模式是面向对象编程中最常
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
      <category term="Singleton" scheme="https://rollingstarky.github.io/tags/Singleton/"/>
    
      <category term="Dependency Injection" scheme="https://rollingstarky.github.io/tags/Dependency-Injection/"/>
    
      <category term="Decoupling" scheme="https://rollingstarky.github.io/tags/Decoupling/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 设计模式笔记 —— Builder 模式</title>
    <link href="https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/"/>
    <id>https://rollingstarky.github.io/2022/05/05/node-js-design-patterns-builder-pattern/</id>
    <published>2022-05-04T16:00:00.000Z</published>
    <updated>2022-05-05T14:46:01.904Z</updated>
    
    <content type="html"><![CDATA[<p>Builder 是一种<strong>创建型</strong>设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。<br>最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。</p><p>比如下面的一个 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(hasMotor, motorCount, motorBrand, motorModel,</span><br><span class="line">    hasSails, sailsCount, sailsMaterial, sailsColor,</span><br><span class="line">    hullColor, hasCabin) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>调用上述 <code>Boat</code> 类的构造方法会导致出现非常难以阅读的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(<span class="literal">true</span>, <span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>, <span class="literal">true</span>, <span class="number">1</span>,</span><br><span class="line">  <span class="string">'fabric'</span>, <span class="string">'white'</span>, <span class="string">'blue'</span>, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></p><p>想要提升上述构造函数的设计，首先可以将所有的参数整合到一个单一的对象中，如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">  hasMotor: <span class="literal">true</span>,</span><br><span class="line">  motorCount: <span class="number">2</span>,</span><br><span class="line">  motorBrand: <span class="string">'Best Motor Co. '</span>,</span><br><span class="line">  motorModel: <span class="string">'OM123'</span>,</span><br><span class="line">  hasSails: <span class="literal">true</span>,</span><br><span class="line">  sailsCount: <span class="number">1</span>,</span><br><span class="line">  sailsMaterial: <span class="string">'fabric'</span>,</span><br><span class="line">  sailsColor: <span class="string">'white'</span>,</span><br><span class="line">  hullColor: <span class="string">'blue'</span>,</span><br><span class="line">  hasCabin: <span class="literal">false</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>新版本的构造函数跟原来相比提升了不少，比如用户可以清晰地看到每个传入的参数所代表的具体含义。<br>但是，将所有参数都放入同一个对象后再传入构造函数的方式，也有其自身的缺点。比如要想知道每个参数的具体含义，还是需要查看类的说明文档甚至类的代码。此外，没有任何强制性的协议来引导用户创建一致的对象，假如我们指定 <code>hasMotor: true</code>，意味着我们同时还需要再指定 <code>motorCount</code>、<code>motorBrand</code> 和 <code>motorModel</code> 参数的值。但我们无从获取此类信息（除非查看源代码）。</p><p>Builder 模式就非常适合解决上述问题。帮助用户创建一个平滑、易读、自说明的生成对象的接口，同时为创建具有一致性的对象提供指导信息。</p><p>使用 Builder 模式的 <code>Boat</code> 类：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(allParameters) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BoatBuilder</span> </span>&#123;</span><br><span class="line">  withMotors(count, brand, model) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasMotor = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.motorCount = count</span><br><span class="line">    <span class="keyword">this</span>.motorBrand = brand</span><br><span class="line">    <span class="keyword">this</span>.motorModel = model</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withSails(count, material, color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasSails = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">this</span>.sailsCount = count</span><br><span class="line">    <span class="keyword">this</span>.sailsMaterial = material</span><br><span class="line">    <span class="keyword">this</span>.sailsColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  hullColor(color) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hullColor = color</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  withCabin() &#123;</span><br><span class="line">    <span class="keyword">this</span>.hasCabin = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Boat(&#123;</span><br><span class="line">      hasMotor: <span class="keyword">this</span>.hasMotor,</span><br><span class="line">      motorCount: <span class="keyword">this</span>.motorCount,</span><br><span class="line">      motorBrand: <span class="keyword">this</span>.motorBrand,</span><br><span class="line">      motorModel: <span class="keyword">this</span>.motorModel,</span><br><span class="line">      hasSails: <span class="keyword">this</span>.hasSails,</span><br><span class="line">      sailsCount: <span class="keyword">this</span>.sailsCount,</span><br><span class="line">      sailsMaterial: <span class="keyword">this</span>.sailsMaterial,</span><br><span class="line">      sailsColor: <span class="keyword">this</span>.sailsColor,</span><br><span class="line">      hullColor: <span class="keyword">this</span>.hullColor,</span><br><span class="line">      hasCabin: <span class="keyword">this</span>.hasCabin</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myBoat = <span class="keyword">new</span> BoatBuilder()</span><br><span class="line">  .withMotors(<span class="number">2</span>, <span class="string">'Best Motor Co. '</span>, <span class="string">'OM123'</span>)</span><br><span class="line">  .withSails(<span class="number">1</span>, <span class="string">'fabric'</span>, <span class="string">'white'</span>)</span><br><span class="line">  .withCabin()</span><br><span class="line">  .hullColor(<span class="string">'blue'</span>)</span><br><span class="line">  .build()</span><br></pre></td></tr></table></figure></p><p><code>BoatBuilder</code> 类的作用就是收集 <code>Boat</code> 类需要的所有参数，再通过一系列 helper 方法传递给 <code>Boat</code>。</p><p>Builder 模式的基本规则：</p><ul><li>将主要对象的复杂构建过程拆分为几个更为易读的、更容易管理的步骤</li><li>尝试创建 builder 方法，向需要创建的对象一组一组地传递相关联的参数</li><li>必要的情况下，在通过 builder 方法将参数传递给需要创建的对象前，尽可能地先对参数做一些处理</li></ul><h4 id="实例：URL-builder"><a href="#实例：URL-builder" class="headerlink" title="实例：URL builder"></a>实例：URL builder</h4><p>创建并进入 <code>url_builder</code> 文件夹，编辑如下内容的 <code>package.json</code> 文件：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">        <span class="attr">"type"</span>: <span class="string">"module"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>url.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Url</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(protocol, username, password, hostname,</span><br><span class="line">    port, pathname, search, hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.validate()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  validate() &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.protocol || !<span class="keyword">this</span>.hostname) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Must specify at least a '</span> + <span class="string">'protocol and a hostname'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">let</span> url = <span class="string">''</span></span><br><span class="line">    url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.protocol&#125;</span>://`</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.username &amp;&amp; <span class="keyword">this</span>.password) &#123;</span><br><span class="line">      url += <span class="string">`<span class="subst">$&#123;<span class="keyword">this</span>.username&#125;</span>:<span class="subst">$&#123;<span class="keyword">this</span>.password&#125;</span>@`</span></span><br><span class="line">    &#125;</span><br><span class="line">    url += <span class="keyword">this</span>.hostname</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.port) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.port</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.pathname) &#123;</span><br><span class="line">      url += <span class="keyword">this</span>.pathname</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.search) &#123;</span><br><span class="line">      url += <span class="string">`?<span class="subst">$&#123;<span class="keyword">this</span>.search&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.hash) &#123;</span><br><span class="line">      url += <span class="string">`#<span class="subst">$&#123;<span class="keyword">this</span>.hash&#125;</span>`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>urlBuilder.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Url &#125; <span class="keyword">from</span> <span class="string">'./url.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlBuilder</span> </span>&#123;</span><br><span class="line">  setProtocol(protocol) &#123;</span><br><span class="line">    <span class="keyword">this</span>.protocol = protocol</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setAuthentication(username, password) &#123;</span><br><span class="line">    <span class="keyword">this</span>.username = username</span><br><span class="line">    <span class="keyword">this</span>.password = password</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHostname(hostname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hostname = hostname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPort(port) &#123;</span><br><span class="line">    <span class="keyword">this</span>.port = port</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setPathname(pathname) &#123;</span><br><span class="line">    <span class="keyword">this</span>.pathname = pathname</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setSearch(search) &#123;</span><br><span class="line">    <span class="keyword">this</span>.search = search</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  setHash(hash) &#123;</span><br><span class="line">    <span class="keyword">this</span>.hash = hash</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  build() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Url(<span class="keyword">this</span>.protocol, <span class="keyword">this</span>.username, <span class="keyword">this</span>.password,</span><br><span class="line">      <span class="keyword">this</span>.hostname, <span class="keyword">this</span>.port, <span class="keyword">this</span>.pathname, <span class="keyword">this</span>.search, <span class="keyword">this</span>.hash)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>index.js</code>：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;UrlBuilder&#125; <span class="keyword">from</span> <span class="string">'./urlBuilder.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="keyword">new</span> UrlBuilder()</span><br><span class="line">  .setProtocol(<span class="string">'https'</span>)</span><br><span class="line">  .setAuthentication(<span class="string">'user'</span>, <span class="string">'pass'</span>)</span><br><span class="line">  .setHostname(<span class="string">'example.com'</span>)</span><br><span class="line">  .build()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(url.toString())</span><br></pre></td></tr></table></figure></p><p>运行效果：<br><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line"><span class="function">https://<span class="title">user:pass</span>@<span class="title">example.com</span></span></span><br></pre></td></tr></table></figure></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><p><a href="https://www.amazon.com/Node-js-Design-Patterns-production-grade-applications/dp/1839214112" target="_blank" rel="noopener">Node.js Design Patterns: Design and implement production-grade Node.js applications using proven patterns and techniques, 3rd Edition</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Builder 是一种&lt;strong&gt;创建型&lt;/strong&gt;设计模式，可以通过提供简单平滑的接口来简化复杂对象的创建，允许我们一步一步的构建新对象。&lt;br&gt;最明显的需要使用 Builder 模式的时候，就是当某个类的构造函数包含了太多的参数。&lt;/p&gt;
&lt;p&gt;比如下面的一个
      
    
    </summary>
    
      <category term="Program" scheme="https://rollingstarky.github.io/categories/Program/"/>
    
    
      <category term="Program" scheme="https://rollingstarky.github.io/tags/Program/"/>
    
      <category term="OOP" scheme="https://rollingstarky.github.io/tags/OOP/"/>
    
      <category term="Class" scheme="https://rollingstarky.github.io/tags/Class/"/>
    
      <category term="Design" scheme="https://rollingstarky.github.io/tags/Design/"/>
    
      <category term="Pattern" scheme="https://rollingstarky.github.io/tags/Pattern/"/>
    
      <category term="JavaScript" scheme="https://rollingstarky.github.io/tags/JavaScript/"/>
    
      <category term="Node.js" scheme="https://rollingstarky.github.io/tags/Node-js/"/>
    
  </entry>
  
</feed>
